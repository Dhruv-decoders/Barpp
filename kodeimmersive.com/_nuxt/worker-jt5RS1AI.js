(function() {
    "use strict";
    /**
     * @license
     * Copyright 2010-2025 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const Ku = "177",
        Pp = "attached",
        fx = "detached",
        Ir = "",
        Yt = "srgb",
        yn = "srgb-linear",
        $l = "linear",
        Rt = "srgb",
        Fp = "300 es";
    let aa = class {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
        }
        hasEventListener(e, t) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
        }
        removeEventListener(e, t) {
            const n = this._listeners;
            if (n === void 0) return;
            const i = n[e];
            if (i !== void 0) {
                const s = i.indexOf(t);
                s !== -1 && i.splice(s, 1)
            }
        }
        dispatchEvent(e) {
            const t = this._listeners;
            if (t === void 0) return;
            const n = t[e.type];
            if (n !== void 0) {
                e.target = this;
                const i = n.slice(0);
                for (let s = 0, a = i.length; s < a; s++) i[s].call(this, e);
                e.target = null
            }
        }
    };
    const Sn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    let Lp = 1234567;
    const So = Math.PI / 180,
        oa = 180 / Math.PI;

    function Ei() {
        const r = Math.random() * 4294967295 | 0,
            e = Math.random() * 4294967295 | 0,
            t = Math.random() * 4294967295 | 0,
            n = Math.random() * 4294967295 | 0;
        return (Sn[r & 255] + Sn[r >> 8 & 255] + Sn[r >> 16 & 255] + Sn[r >> 24 & 255] + "-" + Sn[e & 255] + Sn[e >> 8 & 255] + "-" + Sn[e >> 16 & 15 | 64] + Sn[e >> 24 & 255] + "-" + Sn[t & 63 | 128] + Sn[t >> 8 & 255] + "-" + Sn[t >> 16 & 255] + Sn[t >> 24 & 255] + Sn[n & 255] + Sn[n >> 8 & 255] + Sn[n >> 16 & 255] + Sn[n >> 24 & 255]).toLowerCase()
    }

    function dt(r, e, t) {
        return Math.max(e, Math.min(t, r))
    }

    function $u(r, e) {
        return (r % e + e) % e
    }

    function hx(r, e, t, n, i) {
        return n + (r - e) * (i - n) / (t - e)
    }

    function dx(r, e, t) {
        return r !== e ? (t - r) / (e - r) : 0
    }

    function Mo(r, e, t) {
        return (1 - t) * r + t * e
    }

    function px(r, e, t, n) {
        return Mo(r, e, 1 - Math.exp(-t * n))
    }

    function mx(r, e = 1) {
        return e - Math.abs($u(r, e * 2) - e)
    }

    function gx(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r))
    }

    function _x(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10))
    }

    function bx(r, e) {
        return r + Math.floor(Math.random() * (e - r + 1))
    }

    function xx(r, e) {
        return r + Math.random() * (e - r)
    }

    function vx(r) {
        return r * (.5 - Math.random())
    }

    function yx(r) {
        r !== void 0 && (Lp = r);
        let e = Lp += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
    }

    function Sx(r) {
        return r * So
    }

    function Mx(r) {
        return r * oa
    }

    function Tx(r) {
        return (r & r - 1) === 0 && r !== 0
    }

    function Ex(r) {
        return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
    }

    function Dx(r) {
        return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
    }

    function Ax(r, e, t, n, i) {
        const s = Math.cos,
            a = Math.sin,
            o = s(t / 2),
            l = a(t / 2),
            c = s((e + n) / 2),
            f = a((e + n) / 2),
            h = s((e - n) / 2),
            d = a((e - n) / 2),
            u = s((n - e) / 2),
            _ = a((n - e) / 2);
        switch (i) {
            case "XYX":
                r.set(o * f, l * h, l * d, o * c);
                break;
            case "YZY":
                r.set(l * d, o * f, l * h, o * c);
                break;
            case "ZXZ":
                r.set(l * h, l * d, o * f, o * c);
                break;
            case "XZX":
                r.set(o * f, l * _, l * u, o * c);
                break;
            case "YXY":
                r.set(l * u, o * f, l * _, o * c);
                break;
            case "ZYZ":
                r.set(l * _, l * u, o * f, o * c);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
        }
    }

    function Di(r, e) {
        switch (e.constructor) {
            case Float32Array:
                return r;
            case Uint32Array:
                return r / 4294967295;
            case Uint16Array:
                return r / 65535;
            case Uint8Array:
                return r / 255;
            case Int32Array:
                return Math.max(r / 2147483647, -1);
            case Int16Array:
                return Math.max(r / 32767, -1);
            case Int8Array:
                return Math.max(r / 127, -1);
            default:
                throw new Error("Invalid component type.")
        }
    }

    function At(r, e) {
        switch (e.constructor) {
            case Float32Array:
                return r;
            case Uint32Array:
                return Math.round(r * 4294967295);
            case Uint16Array:
                return Math.round(r * 65535);
            case Uint8Array:
                return Math.round(r * 255);
            case Int32Array:
                return Math.round(r * 2147483647);
            case Int16Array:
                return Math.round(r * 32767);
            case Int8Array:
                return Math.round(r * 127);
            default:
                throw new Error("Invalid component type.")
        }
    }
    const wx = {
        DEG2RAD: So,
        RAD2DEG: oa,
        generateUUID: Ei,
        clamp: dt,
        euclideanModulo: $u,
        mapLinear: hx,
        inverseLerp: dx,
        lerp: Mo,
        damp: px,
        pingpong: mx,
        smoothstep: gx,
        smootherstep: _x,
        randInt: bx,
        randFloat: xx,
        randFloatSpread: vx,
        seededRandom: yx,
        degToRad: Sx,
        radToDeg: Mx,
        isPowerOfTwo: Tx,
        ceilPowerOfTwo: Ex,
        floorPowerOfTwo: Dx,
        setQuaternionFromProperEuler: Ax,
        normalize: At,
        denormalize: Di
    };
    class pt {
        constructor(e = 0, t = 0) {
            pt.prototype.isVector2 = !0, this.x = e, this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e, this.y = t, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }
        clamp(e, t) {
            return this.x = dt(this.x, e.x, t.x), this.y = dt(this.y, e.y, t.y), this
        }
        clampScalar(e, t) {
            return this.x = dt(this.x, e, t), this.y = dt(this.y, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(dt(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(dt(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this
        }
        rotateAround(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                s = this.x - e.x,
                a = this.y - e.y;
            return this.x = s * n - a * i + e.x, this.y = s * i + a * n + e.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class Nr {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
        }
        static slerpFlat(e, t, n, i, s, a, o) {
            let l = n[i + 0],
                c = n[i + 1],
                f = n[i + 2],
                h = n[i + 3];
            const d = s[a + 0],
                u = s[a + 1],
                _ = s[a + 2],
                m = s[a + 3];
            if (o === 0) {
                e[t + 0] = l, e[t + 1] = c, e[t + 2] = f, e[t + 3] = h;
                return
            }
            if (o === 1) {
                e[t + 0] = d, e[t + 1] = u, e[t + 2] = _, e[t + 3] = m;
                return
            }
            if (h !== m || l !== d || c !== u || f !== _) {
                let g = 1 - o;
                const p = l * d + c * u + f * _ + h * m,
                    v = p >= 0 ? 1 : -1,
                    x = 1 - p * p;
                if (x > Number.EPSILON) {
                    const M = Math.sqrt(x),
                        D = Math.atan2(M, p * v);
                    g = Math.sin(g * D) / M, o = Math.sin(o * D) / M
                }
                const b = o * v;
                if (l = l * g + d * b, c = c * g + u * b, f = f * g + _ * b, h = h * g + m * b, g === 1 - o) {
                    const M = 1 / Math.sqrt(l * l + c * c + f * f + h * h);
                    l *= M, c *= M, f *= M, h *= M
                }
            }
            e[t] = l, e[t + 1] = c, e[t + 2] = f, e[t + 3] = h
        }
        static multiplyQuaternionsFlat(e, t, n, i, s, a) {
            const o = n[i],
                l = n[i + 1],
                c = n[i + 2],
                f = n[i + 3],
                h = s[a],
                d = s[a + 1],
                u = s[a + 2],
                _ = s[a + 3];
            return e[t] = o * _ + f * h + l * u - c * d, e[t + 1] = l * _ + f * d + c * h - o * u, e[t + 2] = c * _ + f * u + o * d - l * h, e[t + 3] = f * _ - o * h - l * d - c * u, e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e, this._onChangeCallback()
        }
        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        }
        setFromEuler(e, t = !0) {
            const n = e._x,
                i = e._y,
                s = e._z,
                a = e._order,
                o = Math.cos,
                l = Math.sin,
                c = o(n / 2),
                f = o(i / 2),
                h = o(s / 2),
                d = l(n / 2),
                u = l(i / 2),
                _ = l(s / 2);
            switch (a) {
                case "XYZ":
                    this._x = d * f * h + c * u * _, this._y = c * u * h - d * f * _, this._z = c * f * _ + d * u * h, this._w = c * f * h - d * u * _;
                    break;
                case "YXZ":
                    this._x = d * f * h + c * u * _, this._y = c * u * h - d * f * _, this._z = c * f * _ - d * u * h, this._w = c * f * h + d * u * _;
                    break;
                case "ZXY":
                    this._x = d * f * h - c * u * _, this._y = c * u * h + d * f * _, this._z = c * f * _ + d * u * h, this._w = c * f * h - d * u * _;
                    break;
                case "ZYX":
                    this._x = d * f * h - c * u * _, this._y = c * u * h + d * f * _, this._z = c * f * _ - d * u * h, this._w = c * f * h + d * u * _;
                    break;
                case "YZX":
                    this._x = d * f * h + c * u * _, this._y = c * u * h + d * f * _, this._z = c * f * _ - d * u * h, this._w = c * f * h - d * u * _;
                    break;
                case "XZY":
                    this._x = d * f * h - c * u * _, this._y = c * u * h - d * f * _, this._z = c * f * _ + d * u * h, this._w = c * f * h + d * u * _;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return t === !0 && this._onChangeCallback(), this
        }
        setFromAxisAngle(e, t) {
            const n = t / 2,
                i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(e) {
            const t = e.elements,
                n = t[0],
                i = t[4],
                s = t[8],
                a = t[1],
                o = t[5],
                l = t[9],
                c = t[2],
                f = t[6],
                h = t[10],
                d = n + o + h;
            if (d > 0) {
                const u = .5 / Math.sqrt(d + 1);
                this._w = .25 / u, this._x = (f - l) * u, this._y = (s - c) * u, this._z = (a - i) * u
            } else if (n > o && n > h) {
                const u = 2 * Math.sqrt(1 + n - o - h);
                this._w = (f - l) / u, this._x = .25 * u, this._y = (i + a) / u, this._z = (s + c) / u
            } else if (o > h) {
                const u = 2 * Math.sqrt(1 + o - n - h);
                this._w = (s - c) / u, this._x = (i + a) / u, this._y = .25 * u, this._z = (l + f) / u
            } else {
                const u = 2 * Math.sqrt(1 + h - n - o);
                this._w = (a - i) / u, this._x = (s + c) / u, this._y = (l + f) / u, this._z = .25 * u
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(dt(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (n === 0) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            const n = e._x,
                i = e._y,
                s = e._z,
                a = e._w,
                o = t._x,
                l = t._y,
                c = t._z,
                f = t._w;
            return this._x = n * f + a * o + i * c - s * l, this._y = i * f + a * l + s * o - n * c, this._z = s * f + a * c + n * l - i * o, this._w = a * f - n * o - i * l - s * c, this._onChangeCallback(), this
        }
        slerp(e, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(e);
            const n = this._x,
                i = this._y,
                s = this._z,
                a = this._w;
            let o = a * e._w + n * e._x + i * e._y + s * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = s, this;
            const l = 1 - o * o;
            if (l <= Number.EPSILON) {
                const u = 1 - t;
                return this._w = u * a + t * this._w, this._x = u * n + t * this._x, this._y = u * i + t * this._y, this._z = u * s + t * this._z, this.normalize(), this
            }
            const c = Math.sqrt(l),
                f = Math.atan2(c, o),
                h = Math.sin((1 - t) * f) / c,
                d = Math.sin(t * f) / c;
            return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n)
        }
        random() {
            const e = 2 * Math.PI * Math.random(),
                t = 2 * Math.PI * Math.random(),
                n = Math.random(),
                i = Math.sqrt(1 - n),
                s = Math.sqrt(n);
            return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    }
    class Y {
        constructor(e = 0, t = 0, n = 0) {
            Y.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }
        applyEuler(e) {
            return this.applyQuaternion(Ip.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(Ip.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements;
            return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements,
                a = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
            return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * a, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * a, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * a, this
        }
        applyQuaternion(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.x,
                a = e.y,
                o = e.z,
                l = e.w,
                c = 2 * (a * i - o * n),
                f = 2 * (o * t - s * i),
                h = 2 * (s * n - a * t);
            return this.x = t + l * c + a * h - o * f, this.y = n + l * f + o * c - s * h, this.z = i + l * h + s * f - a * c, this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements;
            return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize()
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }
        clamp(e, t) {
            return this.x = dt(this.x, e.x, t.x), this.y = dt(this.y, e.y, t.y), this.z = dt(this.z, e.z, t.z), this
        }
        clampScalar(e, t) {
            return this.x = dt(this.x, e, t), this.y = dt(this.y, e, t), this.z = dt(this.z, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(dt(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
        }
        cross(e) {
            return this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            const n = e.x,
                i = e.y,
                s = e.z,
                a = t.x,
                o = t.y,
                l = t.z;
            return this.x = i * l - s * o, this.y = s * a - n * l, this.z = n * o - i * a, this
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (t === 0) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return Ju.copy(this).projectOnVector(e), this.sub(Ju)
        }
        reflect(e) {
            return this.sub(Ju.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(dt(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y,
                i = this.z - e.z;
            return t * t + n * n + i * i
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3)
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2,
                t = Math.random() * 2 - 1,
                n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    const Ju = new Y,
        Ip = new Nr;
    class ot {
        constructor(e, t, n, i, s, a, o, l, c) {
            ot.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, a, o, l, c)
        }
        set(e, t, n, i, s, a, o, l, c) {
            const f = this.elements;
            return f[0] = e, f[1] = i, f[2] = o, f[3] = t, f[4] = s, f[5] = l, f[6] = n, f[7] = a, f[8] = c, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                s = this.elements,
                a = n[0],
                o = n[3],
                l = n[6],
                c = n[1],
                f = n[4],
                h = n[7],
                d = n[2],
                u = n[5],
                _ = n[8],
                m = i[0],
                g = i[3],
                p = i[6],
                v = i[1],
                x = i[4],
                b = i[7],
                M = i[2],
                D = i[5],
                T = i[8];
            return s[0] = a * m + o * v + l * M, s[3] = a * g + o * x + l * D, s[6] = a * p + o * b + l * T, s[1] = c * m + f * v + h * M, s[4] = c * g + f * x + h * D, s[7] = c * p + f * b + h * T, s[2] = d * m + u * v + _ * M, s[5] = d * g + u * x + _ * D, s[8] = d * p + u * b + _ * T, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                l = e[6],
                c = e[7],
                f = e[8];
            return t * a * f - t * o * c - n * s * f + n * o * l + i * s * c - i * a * l
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                l = e[6],
                c = e[7],
                f = e[8],
                h = f * a - o * c,
                d = o * l - f * s,
                u = c * s - a * l,
                _ = t * h + n * d + i * u;
            if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / _;
            return e[0] = h * m, e[1] = (i * c - f * n) * m, e[2] = (o * n - i * a) * m, e[3] = d * m, e[4] = (f * t - i * l) * m, e[5] = (i * s - o * t) * m, e[6] = u * m, e[7] = (n * l - c * t) * m, e[8] = (a * t - n * s) * m, this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }
        setUvTransform(e, t, n, i, s, a, o) {
            const l = Math.cos(s),
                c = Math.sin(s);
            return this.set(n * l, n * c, -n * (l * a + c * o) + a + e, -i * c, i * l, -i * (-c * a + l * o) + o + t, 0, 0, 1), this
        }
        scale(e, t) {
            return this.premultiply(Zu.makeScale(e, t)), this
        }
        rotate(e) {
            return this.premultiply(Zu.makeRotation(-e)), this
        }
        translate(e, t) {
            return this.premultiply(Zu.makeTranslation(e, t)), this
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
        }
        makeRotation(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let i = 0; i < 9; i++)
                if (t[i] !== n[i]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
        clone() {
            return new this.constructor().fromArray(this.elements)
        }
    }
    const Zu = new ot;

    function Np(r) {
        for (let e = r.length - 1; e >= 0; --e)
            if (r[e] >= 65535) return !0;
        return !1
    }

    function To(r) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", r)
    }

    function Cx() {
        const r = To("canvas");
        return r.style.display = "block", r
    }
    const Op = {};

    function la(r) {
        r in Op || (Op[r] = !0, console.warn(r))
    }

    function Rx(r, e, t) {
        return new Promise(function(n, i) {
            function s() {
                switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                    case r.WAIT_FAILED:
                        i();
                        break;
                    case r.TIMEOUT_EXPIRED:
                        setTimeout(s, t);
                        break;
                    default:
                        n()
                }
            }
            setTimeout(s, t)
        })
    }

    function Px(r) {
        const e = r.elements;
        e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15]
    }

    function Fx(r) {
        const e = r.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1)
    }
    const Up = new ot().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
        Bp = new ot().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);

    function Lx() {
        const r = {
                enabled: !0,
                workingColorSpace: yn,
                spaces: {},
                convert: function(i, s, a) {
                    return this.enabled === !1 || s === a || !s || !a || (this.spaces[s].transfer === Rt && (i.r = lr(i.r), i.g = lr(i.g), i.b = lr(i.b)), this.spaces[s].primaries !== this.spaces[a].primaries && (i.applyMatrix3(this.spaces[s].toXYZ), i.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === Rt && (i.r = ca(i.r), i.g = ca(i.g), i.b = ca(i.b))), i
                },
                workingToColorSpace: function(i, s) {
                    return this.convert(i, this.workingColorSpace, s)
                },
                colorSpaceToWorking: function(i, s) {
                    return this.convert(i, s, this.workingColorSpace)
                },
                getPrimaries: function(i) {
                    return this.spaces[i].primaries
                },
                getTransfer: function(i) {
                    return i === Ir ? $l : this.spaces[i].transfer
                },
                getLuminanceCoefficients: function(i, s = this.workingColorSpace) {
                    return i.fromArray(this.spaces[s].luminanceCoefficients)
                },
                define: function(i) {
                    Object.assign(this.spaces, i)
                },
                _getMatrix: function(i, s, a) {
                    return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ)
                },
                _getDrawingBufferColorSpace: function(i) {
                    return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace
                },
                _getUnpackColorSpace: function(i = this.workingColorSpace) {
                    return this.spaces[i].workingColorSpaceConfig.unpackColorSpace
                },
                fromWorkingColorSpace: function(i, s) {
                    return la("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), r.workingToColorSpace(i, s)
                },
                toWorkingColorSpace: function(i, s) {
                    return la("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), r.colorSpaceToWorking(i, s)
                }
            },
            e = [.64, .33, .3, .6, .15, .06],
            t = [.2126, .7152, .0722],
            n = [.3127, .329];
        return r.define({
            [yn]: {
                primaries: e,
                whitePoint: n,
                transfer: $l,
                toXYZ: Up,
                fromXYZ: Bp,
                luminanceCoefficients: t,
                workingColorSpaceConfig: {
                    unpackColorSpace: Yt
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Yt
                }
            },
            [Yt]: {
                primaries: e,
                whitePoint: n,
                transfer: Rt,
                toXYZ: Up,
                fromXYZ: Bp,
                luminanceCoefficients: t,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Yt
                }
            }
        }), r
    }
    const xt = Lx();

    function lr(r) {
        return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
    }

    function ca(r) {
        return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
    }
    let ua;
    class Ix {
        static getDataURL(e, t = "image/png") {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
            let n;
            if (e instanceof HTMLCanvasElement) n = e;
            else {
                ua === void 0 && (ua = To("canvas")), ua.width = e.width, ua.height = e.height;
                const i = ua.getContext("2d");
                e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = ua
            }
            return n.toDataURL(t)
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                const t = To("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const i = n.getImageData(0, 0, e.width, e.height),
                    s = i.data;
                for (let a = 0; a < s.length; a++) s[a] = lr(s[a] / 255) * 255;
                return n.putImageData(i, 0, 0), t
            } else if (e.data) {
                const t = e.data.slice(0);
                for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(lr(t[n] / 255) * 255) : t[n] = lr(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                }
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
        }
    }
    let Nx = 0;
    class Qu {
        constructor(e = null) {
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: Nx++
            }), this.uuid = Ei(), this.data = e, this.dataReady = !0, this.version = 0
        }
        getSize(e) {
            const t = this.data;
            return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
            const n = {
                    uuid: this.uuid,
                    url: ""
                },
                i = this.data;
            if (i !== null) {
                let s;
                if (Array.isArray(i)) {
                    s = [];
                    for (let a = 0, o = i.length; a < o; a++) i[a].isDataTexture ? s.push(ef(i[a].image)) : s.push(ef(i[a]))
                } else s = ef(i);
                n.url = s
            }
            return t || (e.images[this.uuid] = n), n
        }
    }

    function ef(r) {
        return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Ix.getDataURL(r) : r.data ? {
            data: Array.from(r.data),
            width: r.width,
            height: r.height,
            type: r.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    let Ox = 0;
    const tf = new Y;
    class tn extends aa {
        constructor(e = tn.DEFAULT_IMAGE, t = tn.DEFAULT_MAPPING, n = 1001, i = 1001, s = 1006, a = 1008, o = 1023, l = 1009, c = tn.DEFAULT_ANISOTROPY, f = Ir) {
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: Ox++
            }), this.uuid = Ei(), this.name = "", this.source = new Qu(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new pt(0, 0), this.repeat = new pt(1, 1), this.center = new pt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ot, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = f, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0
        }
        get width() {
            return this.source.getSize(tf).x
        }
        get height() {
            return this.source.getSize(tf).y
        }
        get depth() {
            return this.source.getSize(tf).z
        }
        get image() {
            return this.source.data
        }
        set image(e = null) {
            this.source.data = e
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
        }
        setValues(e) {
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
                    continue
                }
                i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (this.mapping !== 300) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case 1e3:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case 1001:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case 1e3:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case 1001:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
        set needsUpdate(e) {
            e === !0 && (this.version++, this.source.needsUpdate = !0)
        }
        set needsPMREMUpdate(e) {
            e === !0 && this.pmremVersion++
        }
    }
    tn.DEFAULT_IMAGE = null, tn.DEFAULT_MAPPING = 300, tn.DEFAULT_ANISOTROPY = 1;
    class Tt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            Tt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setW(e) {
            return this.w = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = this.w,
                a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * s, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * s, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * s, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * s, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, s;
            const l = e.elements,
                c = l[0],
                f = l[4],
                h = l[8],
                d = l[1],
                u = l[5],
                _ = l[9],
                m = l[2],
                g = l[6],
                p = l[10];
            if (Math.abs(f - d) < .01 && Math.abs(h - m) < .01 && Math.abs(_ - g) < .01) {
                if (Math.abs(f + d) < .1 && Math.abs(h + m) < .1 && Math.abs(_ + g) < .1 && Math.abs(c + u + p - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const x = (c + 1) / 2,
                    b = (u + 1) / 2,
                    M = (p + 1) / 2,
                    D = (f + d) / 4,
                    T = (h + m) / 4,
                    w = (_ + g) / 4;
                return x > b && x > M ? x < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(x), i = D / n, s = T / n) : b > M ? b < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(b), n = D / i, s = w / i) : M < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(M), n = T / s, i = w / s), this.set(n, i, s, t), this
            }
            let v = Math.sqrt((g - _) * (g - _) + (h - m) * (h - m) + (d - f) * (d - f));
            return Math.abs(v) < .001 && (v = 1), this.x = (g - _) / v, this.y = (h - m) / v, this.z = (d - f) / v, this.w = Math.acos((c + u + p - 1) / 2), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }
        clamp(e, t) {
            return this.x = dt(this.x, e.x, t.x), this.y = dt(this.y, e.y, t.y), this.z = dt(this.z, e.z, t.z), this.w = dt(this.w, e.w, t.w), this
        }
        clampScalar(e, t) {
            return this.x = dt(this.x, e, t), this.y = dt(this.y, e, t), this.z = dt(this.z, e, t), this.w = dt(this.w, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(dt(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }
    class Ux extends aa {
        constructor(e = 1, t = 1, n = {}) {
            super(), n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: 1006,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
                depth: 1,
                multiview: !1
            }, n), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = n.depth, this.scissor = new Tt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Tt(0, 0, e, t);
            const i = {
                    width: e,
                    height: t,
                    depth: n.depth
                },
                s = new tn(i);
            this.textures = [];
            const a = n.count;
            for (let o = 0; o < a; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            this._setTextureOptions(n), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples, this.multiview = n.multiview
        }
        _setTextureOptions(e = {}) {
            const t = {
                minFilter: 1006,
                generateMipmaps: !1,
                flipY: !1,
                internalFormat: null
            };
            e.mapping !== void 0 && (t.mapping = e.mapping), e.wrapS !== void 0 && (t.wrapS = e.wrapS), e.wrapT !== void 0 && (t.wrapT = e.wrapT), e.wrapR !== void 0 && (t.wrapR = e.wrapR), e.magFilter !== void 0 && (t.magFilter = e.magFilter), e.minFilter !== void 0 && (t.minFilter = e.minFilter), e.format !== void 0 && (t.format = e.format), e.type !== void 0 && (t.type = e.type), e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace), e.flipY !== void 0 && (t.flipY = e.flipY), e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
            for (let n = 0; n < this.textures.length; n++) this.textures[n].setValues(t)
        }
        get texture() {
            return this.textures[0]
        }
        set texture(e) {
            this.textures[0] = e
        }
        set depthTexture(e) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e
        }
        get depthTexture() {
            return this._depthTexture
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for (let i = 0, s = this.textures.length; i < s; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                this.dispose()
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for (let t = 0, n = e.textures.length; t < n; t++) {
                this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                const i = Object.assign({}, e.textures[t].image);
                this.textures[t].source = new Qu(i)
            }
            return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    class bs extends Ux {
        constructor(e = 1, t = 1, n = {}) {
            super(e, t, n), this.isWebGLRenderTarget = !0
        }
    }
    class kp extends tn {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e)
        }
        clearLayerUpdates() {
            this.layerUpdates.clear()
        }
    }
    class Bx extends tn {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.isData3DTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    class cr {
        constructor(e = new Y(1 / 0, 1 / 0, 1 / 0), t = new Y(-1 / 0, -1 / 0, -1 / 0)) {
            this.isBox3 = !0, this.min = e, this.max = t
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }
        setFromArray(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Ai.fromArray(e, t));
            return this
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(Ai.fromBufferAttribute(e, t));
            return this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = Ai.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (n !== void 0) {
                const s = n.getAttribute("position");
                if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                    for (let a = 0, o = s.count; a < o; a++) e.isMesh === !0 ? e.getVertexPosition(a, Ai) : Ai.fromBufferAttribute(s, a), Ai.applyMatrix4(e.matrixWorld), this.expandByPoint(Ai);
                else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Jl.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Jl.copy(n.boundingBox)), Jl.applyMatrix4(e.matrixWorld), this.union(Jl)
            }
            const i = e.children;
            for (let s = 0, a = i.length; s < a; s++) this.expandByObject(i[s], t);
            return this
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, Ai), Ai.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Eo), Zl.subVectors(this.max, Eo), fa.subVectors(e.a, Eo), ha.subVectors(e.b, Eo), da.subVectors(e.c, Eo), Or.subVectors(ha, fa), Ur.subVectors(da, ha), xs.subVectors(fa, da);
            let t = [0, -Or.z, Or.y, 0, -Ur.z, Ur.y, 0, -xs.z, xs.y, Or.z, 0, -Or.x, Ur.z, 0, -Ur.x, xs.z, 0, -xs.x, -Or.y, Or.x, 0, -Ur.y, Ur.x, 0, -xs.y, xs.x, 0];
            return !nf(t, fa, ha, da, Zl) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !nf(t, fa, ha, da, Zl)) ? !1 : (Ql.crossVectors(Or, Ur), t = [Ql.x, Ql.y, Ql.z], nf(t, fa, ha, da, Zl))
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return this.clampPoint(e, Ai).distanceTo(e)
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ai).length() * .5), e
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (ur[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ur[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ur[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ur[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ur[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ur[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ur[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ur[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ur), this)
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
        toJSON() {
            return {
                min: this.min.toArray(),
                max: this.max.toArray()
            }
        }
        fromJSON(e) {
            return this.min.fromArray(e.min), this.max.fromArray(e.max), this
        }
    }
    const ur = [new Y, new Y, new Y, new Y, new Y, new Y, new Y, new Y],
        Ai = new Y,
        Jl = new cr,
        fa = new Y,
        ha = new Y,
        da = new Y,
        Or = new Y,
        Ur = new Y,
        xs = new Y,
        Eo = new Y,
        Zl = new Y,
        Ql = new Y,
        vs = new Y;

    function nf(r, e, t, n, i) {
        for (let s = 0, a = r.length - 3; s <= a; s += 3) {
            vs.fromArray(r, s);
            const o = i.x * Math.abs(vs.x) + i.y * Math.abs(vs.y) + i.z * Math.abs(vs.z),
                l = e.dot(vs),
                c = t.dot(vs),
                f = n.dot(vs);
            if (Math.max(-Math.max(l, c, f), Math.min(l, c, f)) > o) return !1
        }
        return !0
    }
    const kx = new cr,
        Do = new Y,
        rf = new Y;
    class Xi {
        constructor(e = new Y, t = -1) {
            this.isSphere = !0, this.center = e, this.radius = t
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this
        }
        setFromPoints(e, t) {
            const n = this.center;
            t !== void 0 ? n.copy(t) : kx.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let s = 0, a = e.length; s < a; s++) i = Math.max(i, n.distanceToSquared(e[s]));
            return this.radius = Math.sqrt(i), this
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }
        translate(e) {
            return this.center.add(e), this
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            Do.subVectors(e, this.center);
            const t = Do.lengthSq();
            if (t > this.radius * this.radius) {
                const n = Math.sqrt(t),
                    i = (n - this.radius) * .5;
                this.center.addScaledVector(Do, i / n), this.radius += i
            }
            return this
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (rf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Do.copy(e.center).add(rf)), this.expandByPoint(Do.copy(e.center).sub(rf))), this)
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return new this.constructor().copy(this)
        }
        toJSON() {
            return {
                radius: this.radius,
                center: this.center.toArray()
            }
        }
        fromJSON(e) {
            return this.radius = e.radius, this.center.fromArray(e.center), this
        }
    }
    const fr = new Y,
        sf = new Y,
        ec = new Y,
        Br = new Y,
        af = new Y,
        tc = new Y,
        of = new Y;
    class Ao {
        constructor(e = new Y, t = new Y(0, 0, -1)) {
            this.origin = e, this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }
        recast(e) {
            return this.origin.copy(this.at(e, fr)), this
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            const t = fr.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (fr.copy(this.origin).addScaledVector(this.direction, t), fr.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, i) {
            sf.copy(e).add(t).multiplyScalar(.5), ec.copy(t).sub(e).normalize(), Br.copy(this.origin).sub(sf);
            const s = e.distanceTo(t) * .5,
                a = -this.direction.dot(ec),
                o = Br.dot(this.direction),
                l = -Br.dot(ec),
                c = Br.lengthSq(),
                f = Math.abs(1 - a * a);
            let h, d, u, _;
            if (f > 0)
                if (h = a * l - o, d = a * o - l, _ = s * f, h >= 0)
                    if (d >= -_)
                        if (d <= _) {
                            const m = 1 / f;
                            h *= m, d *= m, u = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + c
                        } else d = s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * l) + c;
            else d = -s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * l) + c;
            else d <= -_ ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), u = -h * h + d * (d + 2 * l) + c) : d <= _ ? (h = 0, d = Math.min(Math.max(-s, -l), s), u = d * (d + 2 * l) + c) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), u = -h * h + d * (d + 2 * l) + c);
            else d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * l) + c;
            return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(sf).addScaledVector(ec, d), u
        }
        intersectSphere(e, t) {
            fr.subVectors(e.center, this.origin);
            const n = fr.dot(this.direction),
                i = fr.dot(fr) - n * n,
                s = e.radius * e.radius;
            if (i > s) return null;
            const a = Math.sqrt(s - i),
                o = n - a,
                l = n + a;
            return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t)
        }
        intersectsSphere(e) {
            return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, i, s, a, o, l;
            const c = 1 / this.direction.x,
                f = 1 / this.direction.y,
                h = 1 / this.direction.z,
                d = this.origin;
            return c >= 0 ? (n = (e.min.x - d.x) * c, i = (e.max.x - d.x) * c) : (n = (e.max.x - d.x) * c, i = (e.min.x - d.x) * c), f >= 0 ? (s = (e.min.y - d.y) * f, a = (e.max.y - d.y) * f) : (s = (e.max.y - d.y) * f, a = (e.min.y - d.y) * f), n > a || s > i || ((s > n || isNaN(n)) && (n = s), (a < i || isNaN(i)) && (i = a), h >= 0 ? (o = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (o = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), n > l || o > i) || ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t)
        }
        intersectsBox(e) {
            return this.intersectBox(e, fr) !== null
        }
        intersectTriangle(e, t, n, i, s) {
            af.subVectors(t, e), tc.subVectors(n, e), of .crossVectors(af, tc);
            let a = this.direction.dot( of ),
                o;
            if (a > 0) {
                if (i) return null;
                o = 1
            } else if (a < 0) o = -1, a = -a;
            else return null;
            Br.subVectors(this.origin, e);
            const l = o * this.direction.dot(tc.crossVectors(Br, tc));
            if (l < 0) return null;
            const c = o * this.direction.dot(af.cross(Br));
            if (c < 0 || l + c > a) return null;
            const f = -o * Br.dot( of );
            return f < 0 ? null : this.at(f / a, s)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    class st {
        constructor(e, t, n, i, s, a, o, l, c, f, h, d, u, _, m, g) {
            st.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, a, o, l, c, f, h, d, u, _, m, g)
        }
        set(e, t, n, i, s, a, o, l, c, f, h, d, u, _, m, g) {
            const p = this.elements;
            return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = s, p[5] = a, p[9] = o, p[13] = l, p[2] = c, p[6] = f, p[10] = h, p[14] = d, p[3] = u, p[7] = _, p[11] = m, p[15] = g, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return new st().fromArray(this.elements)
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        }
        copyPosition(e) {
            const t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(e) {
            const t = this.elements,
                n = e.elements,
                i = 1 / pa.setFromMatrixColumn(e, 0).length(),
                s = 1 / pa.setFromMatrixColumn(e, 1).length(),
                a = 1 / pa.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromEuler(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z,
                a = Math.cos(n),
                o = Math.sin(n),
                l = Math.cos(i),
                c = Math.sin(i),
                f = Math.cos(s),
                h = Math.sin(s);
            if (e.order === "XYZ") {
                const d = a * f,
                    u = a * h,
                    _ = o * f,
                    m = o * h;
                t[0] = l * f, t[4] = -l * h, t[8] = c, t[1] = u + _ * c, t[5] = d - m * c, t[9] = -o * l, t[2] = m - d * c, t[6] = _ + u * c, t[10] = a * l
            } else if (e.order === "YXZ") {
                const d = l * f,
                    u = l * h,
                    _ = c * f,
                    m = c * h;
                t[0] = d + m * o, t[4] = _ * o - u, t[8] = a * c, t[1] = a * h, t[5] = a * f, t[9] = -o, t[2] = u * o - _, t[6] = m + d * o, t[10] = a * l
            } else if (e.order === "ZXY") {
                const d = l * f,
                    u = l * h,
                    _ = c * f,
                    m = c * h;
                t[0] = d - m * o, t[4] = -a * h, t[8] = _ + u * o, t[1] = u + _ * o, t[5] = a * f, t[9] = m - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l
            } else if (e.order === "ZYX") {
                const d = a * f,
                    u = a * h,
                    _ = o * f,
                    m = o * h;
                t[0] = l * f, t[4] = _ * c - u, t[8] = d * c + m, t[1] = l * h, t[5] = m * c + d, t[9] = u * c - _, t[2] = -c, t[6] = o * l, t[10] = a * l
            } else if (e.order === "YZX") {
                const d = a * l,
                    u = a * c,
                    _ = o * l,
                    m = o * c;
                t[0] = l * f, t[4] = m - d * h, t[8] = _ * h + u, t[1] = h, t[5] = a * f, t[9] = -o * f, t[2] = -c * f, t[6] = u * h + _, t[10] = d - m * h
            } else if (e.order === "XZY") {
                const d = a * l,
                    u = a * c,
                    _ = o * l,
                    m = o * c;
                t[0] = l * f, t[4] = -h, t[8] = c * f, t[1] = d * h + m, t[5] = a * f, t[9] = u * h - _, t[2] = _ * h - u, t[6] = o * f, t[10] = m * h + d
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(zx, e, Gx)
        }
        lookAt(e, t, n) {
            const i = this.elements;
            return Zn.subVectors(e, t), Zn.lengthSq() === 0 && (Zn.z = 1), Zn.normalize(), kr.crossVectors(n, Zn), kr.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zn.x += 1e-4 : Zn.z += 1e-4, Zn.normalize(), kr.crossVectors(n, Zn)), kr.normalize(), nc.crossVectors(Zn, kr), i[0] = kr.x, i[4] = nc.x, i[8] = Zn.x, i[1] = kr.y, i[5] = nc.y, i[9] = Zn.y, i[2] = kr.z, i[6] = nc.z, i[10] = Zn.z, this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                s = this.elements,
                a = n[0],
                o = n[4],
                l = n[8],
                c = n[12],
                f = n[1],
                h = n[5],
                d = n[9],
                u = n[13],
                _ = n[2],
                m = n[6],
                g = n[10],
                p = n[14],
                v = n[3],
                x = n[7],
                b = n[11],
                M = n[15],
                D = i[0],
                T = i[4],
                w = i[8],
                S = i[12],
                y = i[1],
                C = i[5],
                O = i[9],
                N = i[13],
                V = i[2],
                G = i[6],
                B = i[10],
                j = i[14],
                H = i[3],
                k = i[7],
                F = i[11],
                se = i[15];
            return s[0] = a * D + o * y + l * V + c * H, s[4] = a * T + o * C + l * G + c * k, s[8] = a * w + o * O + l * B + c * F, s[12] = a * S + o * N + l * j + c * se, s[1] = f * D + h * y + d * V + u * H, s[5] = f * T + h * C + d * G + u * k, s[9] = f * w + h * O + d * B + u * F, s[13] = f * S + h * N + d * j + u * se, s[2] = _ * D + m * y + g * V + p * H, s[6] = _ * T + m * C + g * G + p * k, s[10] = _ * w + m * O + g * B + p * F, s[14] = _ * S + m * N + g * j + p * se, s[3] = v * D + x * y + b * V + M * H, s[7] = v * T + x * C + b * G + M * k, s[11] = v * w + x * O + b * B + M * F, s[15] = v * S + x * N + b * j + M * se, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[4],
                i = e[8],
                s = e[12],
                a = e[1],
                o = e[5],
                l = e[9],
                c = e[13],
                f = e[2],
                h = e[6],
                d = e[10],
                u = e[14],
                _ = e[3],
                m = e[7],
                g = e[11],
                p = e[15];
            return _ * (+s * l * h - i * c * h - s * o * d + n * c * d + i * o * u - n * l * u) + m * (+t * l * u - t * c * d + s * a * d - i * a * u + i * c * f - s * l * f) + g * (+t * c * h - t * o * u - s * a * h + n * a * u + s * o * f - n * c * f) + p * (-i * o * f - t * l * h + t * o * d + i * a * h - n * a * d + n * l * f)
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        }
        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                l = e[6],
                c = e[7],
                f = e[8],
                h = e[9],
                d = e[10],
                u = e[11],
                _ = e[12],
                m = e[13],
                g = e[14],
                p = e[15],
                v = h * g * c - m * d * c + m * l * u - o * g * u - h * l * p + o * d * p,
                x = _ * d * c - f * g * c - _ * l * u + a * g * u + f * l * p - a * d * p,
                b = f * m * c - _ * h * c + _ * o * u - a * m * u - f * o * p + a * h * p,
                M = _ * h * l - f * m * l - _ * o * d + a * m * d + f * o * g - a * h * g,
                D = t * v + n * x + i * b + s * M;
            if (D === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const T = 1 / D;
            return e[0] = v * T, e[1] = (m * d * s - h * g * s - m * i * u + n * g * u + h * i * p - n * d * p) * T, e[2] = (o * g * s - m * l * s + m * i * c - n * g * c - o * i * p + n * l * p) * T, e[3] = (h * l * s - o * d * s - h * i * c + n * d * c + o * i * u - n * l * u) * T, e[4] = x * T, e[5] = (f * g * s - _ * d * s + _ * i * u - t * g * u - f * i * p + t * d * p) * T, e[6] = (_ * l * s - a * g * s - _ * i * c + t * g * c + a * i * p - t * l * p) * T, e[7] = (a * d * s - f * l * s + f * i * c - t * d * c - a * i * u + t * l * u) * T, e[8] = b * T, e[9] = (_ * h * s - f * m * s - _ * n * u + t * m * u + f * n * p - t * h * p) * T, e[10] = (a * m * s - _ * o * s + _ * n * c - t * m * c - a * n * p + t * o * p) * T, e[11] = (f * o * s - a * h * s - f * n * c + t * h * c + a * n * u - t * o * u) * T, e[12] = M * T, e[13] = (f * m * i - _ * h * i + _ * n * d - t * m * d - f * n * g + t * h * g) * T, e[14] = (_ * o * i - a * m * i - _ * n * l + t * m * l + a * n * g - t * o * g) * T, e[15] = (a * h * i - f * o * i + f * n * l - t * h * l - a * n * d + t * o * d) * T, this
        }
        scale(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this
        }
        getMaxScaleOnAxis() {
            const e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        }
        makeRotationY(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                s = 1 - n,
                a = e.x,
                o = e.y,
                l = e.z,
                c = s * a,
                f = s * o;
            return this.set(c * a + n, c * o - i * l, c * l + i * o, 0, c * o + i * l, f * o + n, f * l - i * a, 0, c * l - i * o, f * l + i * a, s * l * l + n, 0, 0, 0, 0, 1), this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(e, t, n, i, s, a) {
            return this.set(1, n, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(e, t, n) {
            const i = this.elements,
                s = t._x,
                a = t._y,
                o = t._z,
                l = t._w,
                c = s + s,
                f = a + a,
                h = o + o,
                d = s * c,
                u = s * f,
                _ = s * h,
                m = a * f,
                g = a * h,
                p = o * h,
                v = l * c,
                x = l * f,
                b = l * h,
                M = n.x,
                D = n.y,
                T = n.z;
            return i[0] = (1 - (m + p)) * M, i[1] = (u + b) * M, i[2] = (_ - x) * M, i[3] = 0, i[4] = (u - b) * D, i[5] = (1 - (d + p)) * D, i[6] = (g + v) * D, i[7] = 0, i[8] = (_ + x) * T, i[9] = (g - v) * T, i[10] = (1 - (d + m)) * T, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
        }
        decompose(e, t, n) {
            const i = this.elements;
            let s = pa.set(i[0], i[1], i[2]).length();
            const a = pa.set(i[4], i[5], i[6]).length(),
                o = pa.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], wi.copy(this);
            const c = 1 / s,
                f = 1 / a,
                h = 1 / o;
            return wi.elements[0] *= c, wi.elements[1] *= c, wi.elements[2] *= c, wi.elements[4] *= f, wi.elements[5] *= f, wi.elements[6] *= f, wi.elements[8] *= h, wi.elements[9] *= h, wi.elements[10] *= h, t.setFromRotationMatrix(wi), n.x = s, n.y = a, n.z = o, this
        }
        makePerspective(e, t, n, i, s, a, o = 2e3) {
            const l = this.elements,
                c = 2 * s / (t - e),
                f = 2 * s / (n - i),
                h = (t + e) / (t - e),
                d = (n + i) / (n - i);
            let u, _;
            if (o === 2e3) u = -(a + s) / (a - s), _ = -2 * a * s / (a - s);
            else if (o === 2001) u = -a / (a - s), _ = -a * s / (a - s);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = f, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = u, l[14] = _, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
        }
        makeOrthographic(e, t, n, i, s, a, o = 2e3) {
            const l = this.elements,
                c = 1 / (t - e),
                f = 1 / (n - i),
                h = 1 / (a - s),
                d = (t + e) * c,
                u = (n + i) * f;
            let _, m;
            if (o === 2e3) _ = (a + s) * h, m = -2 * h;
            else if (o === 2001) _ = s * h, m = -1 * h;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * f, l[9] = 0, l[13] = -u, l[2] = 0, l[6] = 0, l[10] = m, l[14] = -_, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let i = 0; i < 16; i++)
                if (t[i] !== n[i]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }
    const pa = new Y,
        wi = new st,
        zx = new Y(0, 0, 0),
        Gx = new Y(1, 1, 1),
        kr = new Y,
        nc = new Y,
        Zn = new Y,
        zp = new st,
        Gp = new Nr;
    class ji {
        constructor(e = 0, t = 0, n = 0, i = ji.DEFAULT_ORDER) {
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._onChangeCallback()
        }
        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements,
                s = i[0],
                a = i[4],
                o = i[8],
                l = i[1],
                c = i[5],
                f = i[9],
                h = i[2],
                d = i[6],
                u = i[10];
            switch (t) {
                case "XYZ":
                    this._y = Math.asin(dt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-f, u), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, c), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-dt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(o, u), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(dt(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                    break;
                case "ZYX":
                    this._y = Math.asin(-dt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
                    break;
                case "YZX":
                    this._z = Math.asin(dt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-f, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, u));
                    break;
                case "XZY":
                    this._z = Math.asin(-dt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-f, u), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t, n === !0 && this._onChangeCallback(), this
        }
        setFromQuaternion(e, t, n) {
            return zp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zp, t, n)
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t)
        }
        reorder(e) {
            return Gp.setFromEuler(this), this.setFromQuaternion(Gp, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order
        }
    }
    ji.DEFAULT_ORDER = "XYZ";
    class lf {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return (this.mask & e.mask) !== 0
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0
        }
    }
    let Hx = 0;
    const Hp = new Y,
        ma = new Nr,
        hr = new st,
        ic = new Y,
        wo = new Y,
        Vx = new Y,
        Wx = new Nr,
        Vp = new Y(1, 0, 0),
        Wp = new Y(0, 1, 0),
        Xp = new Y(0, 0, 1),
        jp = {
            type: "added"
        },
        Xx = {
            type: "removed"
        },
        ga = {
            type: "childadded",
            child: null
        },
        cf = {
            type: "childremoved",
            child: null
        };
    class zt extends aa {
        constructor() {
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: Hx++
            }), this.uuid = Ei(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = zt.DEFAULT_UP.clone();
            const e = new Y,
                t = new ji,
                n = new Nr,
                i = new Y(1, 1, 1);

            function s() {
                n.setFromEuler(t, !1)
            }

            function a() {
                t.setFromQuaternion(n, void 0, !1)
            }
            t._onChange(s), n._onChange(a), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new st
                },
                normalMatrix: {
                    value: new ot
                }
            }), this.matrix = new st, this.matrixWorld = new st, this.matrixAutoUpdate = zt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new lf, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }
        rotateOnAxis(e, t) {
            return ma.setFromAxisAngle(e, t), this.quaternion.multiply(ma), this
        }
        rotateOnWorldAxis(e, t) {
            return ma.setFromAxisAngle(e, t), this.quaternion.premultiply(ma), this
        }
        rotateX(e) {
            return this.rotateOnAxis(Vp, e)
        }
        rotateY(e) {
            return this.rotateOnAxis(Wp, e)
        }
        rotateZ(e) {
            return this.rotateOnAxis(Xp, e)
        }
        translateOnAxis(e, t) {
            return Hp.copy(e).applyQuaternion(this.quaternion), this.position.add(Hp.multiplyScalar(t)), this
        }
        translateX(e) {
            return this.translateOnAxis(Vp, e)
        }
        translateY(e) {
            return this.translateOnAxis(Wp, e)
        }
        translateZ(e) {
            return this.translateOnAxis(Xp, e)
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(hr.copy(this.matrixWorld).invert())
        }
        lookAt(e, t, n) {
            e.isVector3 ? ic.copy(e) : ic.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), wo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? hr.lookAt(wo, ic, this.up) : hr.lookAt(ic, wo, this.up), this.quaternion.setFromRotationMatrix(hr), i && (hr.extractRotation(i.matrixWorld), ma.setFromRotationMatrix(hr), this.quaternion.premultiply(ma.invert()))
        }
        add(e) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(jp), ga.child = e, this.dispatchEvent(ga), ga.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
                return this
            }
            const t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Xx), cf.child = e, this.dispatchEvent(cf), cf.child = null), this
        }
        removeFromParent() {
            const e = this.parent;
            return e !== null && e.remove(this), this
        }
        clear() {
            return this.remove(...this.children)
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), hr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), hr.multiply(e.parent.matrixWorld)), e.applyMatrix4(hr), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(jp), ga.child = e, this.dispatchEvent(ga), ga.child = null, this
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const a = this.children[n].getObjectByProperty(e, t);
                if (a !== void 0) return a
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const i = this.children;
            for (let s = 0, a = i.length; s < a; s++) i[s].getObjectsByProperty(e, t, n);
            return n
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wo, e, Vx), e
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wo, Wx, e), e
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
        }
        traverseAncestors(e) {
            const t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
                const i = this.children;
                for (let s = 0, a = i.length; s < a; s++) i[s].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string",
                n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.7,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};
            i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map(o => ({ ...o,
                boundingBox: o.boundingBox ? o.boundingBox.toJSON() : void 0,
                boundingSphere: o.boundingSphere ? o.boundingSphere.toJSON() : void 0
            })), i.instanceInfo = this._instanceInfo.map(o => ({ ...o
            })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(e), i.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));

            function s(o, l) {
                return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid
            }
            if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = s(e.geometries, this.geometry);
                const o = this.geometry.parameters;
                if (o !== void 0 && o.shapes !== void 0) {
                    const l = o.shapes;
                    if (Array.isArray(l))
                        for (let c = 0, f = l.length; c < f; c++) {
                            const h = l[c];
                            s(e.shapes, h)
                        } else s(e.shapes, l)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
                if (Array.isArray(this.material)) {
                    const o = [];
                    for (let l = 0, c = this.material.length; l < c; l++) o.push(s(e.materials, this.material[l]));
                    i.material = o
                } else i.material = s(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let o = 0; o < this.animations.length; o++) {
                    const l = this.animations[o];
                    i.animations.push(s(e.animations, l))
                }
            }
            if (t) {
                const o = a(e.geometries),
                    l = a(e.materials),
                    c = a(e.textures),
                    f = a(e.images),
                    h = a(e.shapes),
                    d = a(e.skeletons),
                    u = a(e.animations),
                    _ = a(e.nodes);
                o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), f.length > 0 && (n.images = f), h.length > 0 && (n.shapes = h), d.length > 0 && (n.skeletons = d), u.length > 0 && (n.animations = u), _.length > 0 && (n.nodes = _)
            }
            return n.object = i, n;

            function a(o) {
                const l = [];
                for (const c in o) {
                    const f = o[c];
                    delete f.metadata, l.push(f)
                }
                return l
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e)
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                for (let n = 0; n < e.children.length; n++) {
                    const i = e.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }
    zt.DEFAULT_UP = new Y(0, 1, 0), zt.DEFAULT_MATRIX_AUTO_UPDATE = !0, zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const Ci = new Y,
        dr = new Y,
        uf = new Y,
        pr = new Y,
        _a = new Y,
        ba = new Y,
        qp = new Y,
        ff = new Y,
        hf = new Y,
        df = new Y,
        pf = new Tt,
        mf = new Tt,
        gf = new Tt;
    class Ri {
        constructor(e = new Y, t = new Y, n = new Y) {
            this.a = e, this.b = t, this.c = n
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), Ci.subVectors(e, t), i.cross(Ci);
            const s = i.lengthSq();
            return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, i, s) {
            Ci.subVectors(i, t), dr.subVectors(n, t), uf.subVectors(e, t);
            const a = Ci.dot(Ci),
                o = Ci.dot(dr),
                l = Ci.dot(uf),
                c = dr.dot(dr),
                f = dr.dot(uf),
                h = a * c - o * o;
            if (h === 0) return s.set(0, 0, 0), null;
            const d = 1 / h,
                u = (c * l - o * f) * d,
                _ = (a * f - o * l) * d;
            return s.set(1 - u - _, _, u)
        }
        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, pr) === null ? !1 : pr.x >= 0 && pr.y >= 0 && pr.x + pr.y <= 1
        }
        static getInterpolation(e, t, n, i, s, a, o, l) {
            return this.getBarycoord(e, t, n, i, pr) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, pr.x), l.addScaledVector(a, pr.y), l.addScaledVector(o, pr.z), l)
        }
        static getInterpolatedAttribute(e, t, n, i, s, a) {
            return pf.setScalar(0), mf.setScalar(0), gf.setScalar(0), pf.fromBufferAttribute(e, t), mf.fromBufferAttribute(e, n), gf.fromBufferAttribute(e, i), a.setScalar(0), a.addScaledVector(pf, s.x), a.addScaledVector(mf, s.y), a.addScaledVector(gf, s.z), a
        }
        static isFrontFacing(e, t, n, i) {
            return Ci.subVectors(n, t), dr.subVectors(e, t), Ci.cross(dr).dot(i) < 0
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        }
        getArea() {
            return Ci.subVectors(this.c, this.b), dr.subVectors(this.a, this.b), Ci.cross(dr).length() * .5
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return Ri.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return Ri.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getInterpolation(e, t, n, i, s) {
            return Ri.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
        }
        containsPoint(e) {
            return Ri.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return Ri.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            const n = this.a,
                i = this.b,
                s = this.c;
            let a, o;
            _a.subVectors(i, n), ba.subVectors(s, n), ff.subVectors(e, n);
            const l = _a.dot(ff),
                c = ba.dot(ff);
            if (l <= 0 && c <= 0) return t.copy(n);
            hf.subVectors(e, i);
            const f = _a.dot(hf),
                h = ba.dot(hf);
            if (f >= 0 && h <= f) return t.copy(i);
            const d = l * h - f * c;
            if (d <= 0 && l >= 0 && f <= 0) return a = l / (l - f), t.copy(n).addScaledVector(_a, a);
            df.subVectors(e, s);
            const u = _a.dot(df),
                _ = ba.dot(df);
            if (_ >= 0 && u <= _) return t.copy(s);
            const m = u * c - l * _;
            if (m <= 0 && c >= 0 && _ <= 0) return o = c / (c - _), t.copy(n).addScaledVector(ba, o);
            const g = f * _ - u * h;
            if (g <= 0 && h - f >= 0 && u - _ >= 0) return qp.subVectors(s, i), o = (h - f) / (h - f + (u - _)), t.copy(i).addScaledVector(qp, o);
            const p = 1 / (g + m + d);
            return a = m * p, o = d * p, t.copy(n).addScaledVector(_a, a).addScaledVector(ba, o)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
    const Yp = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        zr = {
            h: 0,
            s: 0,
            l: 0
        },
        rc = {
            h: 0,
            s: 0,
            l: 0
        };

    function _f(r, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
    }
    class it {
        constructor(e, t, n) {
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
        }
        set(e, t, n) {
            if (t === void 0 && n === void 0) {
                const i = e;
                i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
            } else this.setRGB(e, t, n);
            return this
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }
        setHex(e, t = Yt) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, xt.colorSpaceToWorking(this, t), this
        }
        setRGB(e, t, n, i = xt.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, xt.colorSpaceToWorking(this, i), this
        }
        setHSL(e, t, n, i = xt.workingColorSpace) {
            if (e = $u(e, 1), t = dt(t, 0, 1), n = dt(n, 0, 1), t === 0) this.r = this.g = this.b = n;
            else {
                const s = n <= .5 ? n * (1 + t) : n + t - n * t,
                    a = 2 * n - s;
                this.r = _f(a, s, e + 1 / 3), this.g = _f(a, s, e), this.b = _f(a, s, e - 1 / 3)
            }
            return xt.colorSpaceToWorking(this, i), this
        }
        setStyle(e, t = Yt) {
            function n(s) {
                s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let s;
                const a = i[1],
                    o = i[2];
                switch (a) {
                    case "rgb":
                    case "rgba":
                        if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                        if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const s = i[1],
                    a = s.length;
                if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
                if (a === 6) return this.setHex(parseInt(s, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e)
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this
        }
        setColorName(e, t = Yt) {
            const n = Yp[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }
        copySRGBToLinear(e) {
            return this.r = lr(e.r), this.g = lr(e.g), this.b = lr(e.b), this
        }
        copyLinearToSRGB(e) {
            return this.r = ca(e.r), this.g = ca(e.g), this.b = ca(e.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex(e = Yt) {
            return xt.workingToColorSpace(Mn.copy(this), e), Math.round(dt(Mn.r * 255, 0, 255)) * 65536 + Math.round(dt(Mn.g * 255, 0, 255)) * 256 + Math.round(dt(Mn.b * 255, 0, 255))
        }
        getHexString(e = Yt) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
        getHSL(e, t = xt.workingColorSpace) {
            xt.workingToColorSpace(Mn.copy(this), t);
            const n = Mn.r,
                i = Mn.g,
                s = Mn.b,
                a = Math.max(n, i, s),
                o = Math.min(n, i, s);
            let l, c;
            const f = (o + a) / 2;
            if (o === a) l = 0, c = 0;
            else {
                const h = a - o;
                switch (c = f <= .5 ? h / (a + o) : h / (2 - a - o), a) {
                    case n:
                        l = (i - s) / h + (i < s ? 6 : 0);
                        break;
                    case i:
                        l = (s - n) / h + 2;
                        break;
                    case s:
                        l = (n - i) / h + 4;
                        break
                }
                l /= 6
            }
            return e.h = l, e.s = c, e.l = f, e
        }
        getRGB(e, t = xt.workingColorSpace) {
            return xt.workingToColorSpace(Mn.copy(this), t), e.r = Mn.r, e.g = Mn.g, e.b = Mn.b, e
        }
        getStyle(e = Yt) {
            xt.workingToColorSpace(Mn.copy(this), e);
            const t = Mn.r,
                n = Mn.g,
                i = Mn.b;
            return e !== Yt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`
        }
        offsetHSL(e, t, n) {
            return this.getHSL(zr), this.setHSL(zr.h + e, zr.s + t, zr.l + n)
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }
        lerpHSL(e, t) {
            this.getHSL(zr), e.getHSL(rc);
            const n = Mo(zr.h, rc.h, t),
                i = Mo(zr.s, rc.s, t),
                s = Mo(zr.l, rc.l, t);
            return this.setHSL(n, i, s), this
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this
        }
        applyMatrix3(e) {
            const t = this.r,
                n = this.g,
                i = this.b,
                s = e.elements;
            return this.r = s[0] * t + s[3] * n + s[6] * i, this.g = s[1] * t + s[4] * n + s[7] * i, this.b = s[2] * t + s[5] * n + s[8] * i, this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
        }
        toJSON() {
            return this.getHex()
        }*[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b
        }
    }
    const Mn = new it;
    it.NAMES = Yp;
    let jx = 0;
    class fi extends aa {
        constructor() {
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: jx++
            }), this.uuid = Ei(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new it(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(e) {
            if (e !== void 0)
                for (const t in e) {
                    const n = e[t];
                    if (n === void 0) {
                        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                        continue
                    }
                    const i = this[t];
                    if (i === void 0) {
                        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                        continue
                    }
                    i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== 0 && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== 204 && (n.blendSrc = this.blendSrc), this.blendDst !== 205 && (n.blendDst = this.blendDst), this.blendEquation !== 100 && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== 3 && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== 519 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== 7680 && (n.stencilFail = this.stencilFail), this.stencilZFail !== 7680 && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== 7680 && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

            function i(s) {
                const a = [];
                for (const o in s) {
                    const l = s[o];
                    delete l.metadata, a.push(l)
                }
                return a
            }
            if (t) {
                const s = i(e.textures),
                    a = i(e.images);
                s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a)
            }
            return n
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (t !== null) {
                const i = t.length;
                n = new Array(i);
                for (let s = 0; s !== i; ++s) n[s] = t[s].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
    }
    class Gr extends fi {
        constructor(e) {
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new it(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ji, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
        }
    }
    const Jt = new Y,
        sc = new pt;
    let qx = 0;
    class _n {
        constructor(e, t, n = !1) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: qx++
            }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = 35044, this.updateRanges = [], this.gpuType = 1015, this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        copyArray(e) {
            return this.array.set(e), this
        }
        applyMatrix3(e) {
            if (this.itemSize === 2)
                for (let t = 0, n = this.count; t < n; t++) sc.fromBufferAttribute(this, t), sc.applyMatrix3(e), this.setXY(t, sc.x, sc.y);
            else if (this.itemSize === 3)
                for (let t = 0, n = this.count; t < n; t++) Jt.fromBufferAttribute(this, t), Jt.applyMatrix3(e), this.setXYZ(t, Jt.x, Jt.y, Jt.z);
            return this
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++) Jt.fromBufferAttribute(this, t), Jt.applyMatrix4(e), this.setXYZ(t, Jt.x, Jt.y, Jt.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Jt.fromBufferAttribute(this, t), Jt.applyNormalMatrix(e), this.setXYZ(t, Jt.x, Jt.y, Jt.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Jt.fromBufferAttribute(this, t), Jt.transformDirection(e), this.setXYZ(t, Jt.x, Jt.y, Jt.z);
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = Di(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + t] = n, this
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = Di(t, this.array)), t
        }
        setX(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize] = t, this
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = Di(t, this.array)), t
        }
        setY(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 1] = t, this
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = Di(t, this.array)), t
        }
        setZ(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 2] = t, this
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = Di(t, this.array)), t
        }
        setW(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 3] = t, this
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, s) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array), s = At(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name), this.usage !== 35044 && (e.usage = this.usage), e
        }
    }
    class Kp extends _n {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }
    class $p extends _n {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }
    class mr extends _n {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }
    let Yx = 0;
    const hi = new st,
        bf = new zt,
        xa = new Y,
        Qn = new cr,
        Co = new cr,
        hn = new Y;
    class Pi extends aa {
        constructor() {
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: Yx++
            }), this.uuid = Ei(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new(Np(e) ? $p : Kp)(e, 1) : this.index = e, this
        }
        setIndirect(e) {
            return this.indirect = e, this
        }
        getIndirect() {
            return this.indirect
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const s = new ot().getNormalMatrix(e);
                n.applyNormalMatrix(s), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
        }
        applyQuaternion(e) {
            return hi.makeRotationFromQuaternion(e), this.applyMatrix4(hi), this
        }
        rotateX(e) {
            return hi.makeRotationX(e), this.applyMatrix4(hi), this
        }
        rotateY(e) {
            return hi.makeRotationY(e), this.applyMatrix4(hi), this
        }
        rotateZ(e) {
            return hi.makeRotationZ(e), this.applyMatrix4(hi), this
        }
        translate(e, t, n) {
            return hi.makeTranslation(e, t, n), this.applyMatrix4(hi), this
        }
        scale(e, t, n) {
            return hi.makeScale(e, t, n), this.applyMatrix4(hi), this
        }
        lookAt(e) {
            return bf.lookAt(e), bf.updateMatrix(), this.applyMatrix4(bf.matrix), this
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(xa).negate(), this.translate(xa.x, xa.y, xa.z), this
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (t === void 0) {
                const n = [];
                for (let i = 0, s = e.length; i < s; i++) {
                    const a = e[i];
                    n.push(a.x, a.y, a.z || 0)
                }
                this.setAttribute("position", new mr(n, 3))
            } else {
                const n = Math.min(e.length, t.count);
                for (let i = 0; i < n; i++) {
                    const s = e[i];
                    t.setXYZ(i, s.x, s.y, s.z || 0)
                }
                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0
            }
            return this
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new cr);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Y(-1 / 0, -1 / 0, -1 / 0), new Y(1 / 0, 1 / 0, 1 / 0));
                return
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (let n = 0, i = t.length; n < i; n++) {
                        const s = t[n];
                        Qn.setFromBufferAttribute(s), this.morphTargetsRelative ? (hn.addVectors(this.boundingBox.min, Qn.min), this.boundingBox.expandByPoint(hn), hn.addVectors(this.boundingBox.max, Qn.max), this.boundingBox.expandByPoint(hn)) : (this.boundingBox.expandByPoint(Qn.min), this.boundingBox.expandByPoint(Qn.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Xi);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Y, 1 / 0);
                return
            }
            if (e) {
                const n = this.boundingSphere.center;
                if (Qn.setFromBufferAttribute(e), t)
                    for (let s = 0, a = t.length; s < a; s++) {
                        const o = t[s];
                        Co.setFromBufferAttribute(o), this.morphTargetsRelative ? (hn.addVectors(Qn.min, Co.min), Qn.expandByPoint(hn), hn.addVectors(Qn.max, Co.max), Qn.expandByPoint(hn)) : (Qn.expandByPoint(Co.min), Qn.expandByPoint(Co.max))
                    }
                Qn.getCenter(n);
                let i = 0;
                for (let s = 0, a = e.count; s < a; s++) hn.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(hn));
                if (t)
                    for (let s = 0, a = t.length; s < a; s++) {
                        const o = t[s],
                            l = this.morphTargetsRelative;
                        for (let c = 0, f = o.count; c < f; c++) hn.fromBufferAttribute(o, c), l && (xa.fromBufferAttribute(e, c), hn.add(xa)), i = Math.max(i, n.distanceToSquared(hn))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            const e = this.index,
                t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return
            }
            const n = t.position,
                i = t.normal,
                s = t.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new _n(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"),
                o = [],
                l = [];
            for (let w = 0; w < n.count; w++) o[w] = new Y, l[w] = new Y;
            const c = new Y,
                f = new Y,
                h = new Y,
                d = new pt,
                u = new pt,
                _ = new pt,
                m = new Y,
                g = new Y;

            function p(w, S, y) {
                c.fromBufferAttribute(n, w), f.fromBufferAttribute(n, S), h.fromBufferAttribute(n, y), d.fromBufferAttribute(s, w), u.fromBufferAttribute(s, S), _.fromBufferAttribute(s, y), f.sub(c), h.sub(c), u.sub(d), _.sub(d);
                const C = 1 / (u.x * _.y - _.x * u.y);
                isFinite(C) && (m.copy(f).multiplyScalar(_.y).addScaledVector(h, -u.y).multiplyScalar(C), g.copy(h).multiplyScalar(u.x).addScaledVector(f, -_.x).multiplyScalar(C), o[w].add(m), o[S].add(m), o[y].add(m), l[w].add(g), l[S].add(g), l[y].add(g))
            }
            let v = this.groups;
            v.length === 0 && (v = [{
                start: 0,
                count: e.count
            }]);
            for (let w = 0, S = v.length; w < S; ++w) {
                const y = v[w],
                    C = y.start,
                    O = y.count;
                for (let N = C, V = C + O; N < V; N += 3) p(e.getX(N + 0), e.getX(N + 1), e.getX(N + 2))
            }
            const x = new Y,
                b = new Y,
                M = new Y,
                D = new Y;

            function T(w) {
                M.fromBufferAttribute(i, w), D.copy(M);
                const S = o[w];
                x.copy(S), x.sub(M.multiplyScalar(M.dot(S))).normalize(), b.crossVectors(D, S);
                const C = b.dot(l[w]) < 0 ? -1 : 1;
                a.setXYZW(w, x.x, x.y, x.z, C)
            }
            for (let w = 0, S = v.length; w < S; ++w) {
                const y = v[w],
                    C = y.start,
                    O = y.count;
                for (let N = C, V = C + O; N < V; N += 3) T(e.getX(N + 0)), T(e.getX(N + 1)), T(e.getX(N + 2))
            }
        }
        computeVertexNormals() {
            const e = this.index,
                t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new _n(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                else
                    for (let d = 0, u = n.count; d < u; d++) n.setXYZ(d, 0, 0, 0);
                const i = new Y,
                    s = new Y,
                    a = new Y,
                    o = new Y,
                    l = new Y,
                    c = new Y,
                    f = new Y,
                    h = new Y;
                if (e)
                    for (let d = 0, u = e.count; d < u; d += 3) {
                        const _ = e.getX(d + 0),
                            m = e.getX(d + 1),
                            g = e.getX(d + 2);
                        i.fromBufferAttribute(t, _), s.fromBufferAttribute(t, m), a.fromBufferAttribute(t, g), f.subVectors(a, s), h.subVectors(i, s), f.cross(h), o.fromBufferAttribute(n, _), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, g), o.add(f), l.add(f), c.add(f), n.setXYZ(_, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(g, c.x, c.y, c.z)
                    } else
                        for (let d = 0, u = t.count; d < u; d += 3) i.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), f.subVectors(a, s), h.subVectors(i, s), f.cross(h), n.setXYZ(d + 0, f.x, f.y, f.z), n.setXYZ(d + 1, f.x, f.y, f.z), n.setXYZ(d + 2, f.x, f.y, f.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++) hn.fromBufferAttribute(e, t), hn.normalize(), e.setXYZ(t, hn.x, hn.y, hn.z)
        }
        toNonIndexed() {
            function e(o, l) {
                const c = o.array,
                    f = o.itemSize,
                    h = o.normalized,
                    d = new c.constructor(l.length * f);
                let u = 0,
                    _ = 0;
                for (let m = 0, g = l.length; m < g; m++) {
                    o.isInterleavedBufferAttribute ? u = l[m] * o.data.stride + o.offset : u = l[m] * f;
                    for (let p = 0; p < f; p++) d[_++] = c[u++]
                }
                return new _n(d, f, h)
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new Pi,
                n = this.index.array,
                i = this.attributes;
            for (const o in i) {
                const l = i[o],
                    c = e(l, n);
                t.setAttribute(o, c)
            }
            const s = this.morphAttributes;
            for (const o in s) {
                const l = [],
                    c = s[o];
                for (let f = 0, h = c.length; f < h; f++) {
                    const d = c[f],
                        u = e(d, n);
                    l.push(u)
                }
                t.morphAttributes[o] = l
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for (let o = 0, l = a.length; o < l; o++) {
                const c = a[o];
                t.addGroup(c.start, c.count, c.materialIndex)
            }
            return t
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                const l = this.parameters;
                for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
                return e
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for (const l in n) {
                const c = n[l];
                e.data.attributes[l] = c.toJSON(e.data)
            }
            const i = {};
            let s = !1;
            for (const l in this.morphAttributes) {
                const c = this.morphAttributes[l],
                    f = [];
                for (let h = 0, d = c.length; h < d; h++) {
                    const u = c[h];
                    f.push(u.toJSON(e.data))
                }
                f.length > 0 && (i[l] = f, s = !0)
            }
            s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return o !== null && (e.data.boundingSphere = o.toJSON()), e
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            n !== null && this.setIndex(n.clone());
            const i = e.attributes;
            for (const c in i) {
                const f = i[c];
                this.setAttribute(c, f.clone(t))
            }
            const s = e.morphAttributes;
            for (const c in s) {
                const f = [],
                    h = s[c];
                for (let d = 0, u = h.length; d < u; d++) f.push(h[d].clone(t));
                this.morphAttributes[c] = f
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for (let c = 0, f = a.length; c < f; c++) {
                const h = a[c];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            const o = e.boundingBox;
            o !== null && (this.boundingBox = o.clone());
            const l = e.boundingSphere;
            return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    const Jp = new st,
        ys = new Ao,
        ac = new Xi,
        Zp = new Y,
        oc = new Y,
        lc = new Y,
        cc = new Y,
        xf = new Y,
        uc = new Y,
        Qp = new Y,
        fc = new Y;
    class ei extends zt {
        constructor(e = new Pi, t = new Gr) {
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry,
                i = n.attributes.position,
                s = n.morphAttributes.position,
                a = n.morphTargetsRelative;
            t.fromBufferAttribute(i, e);
            const o = this.morphTargetInfluences;
            if (s && o) {
                uc.set(0, 0, 0);
                for (let l = 0, c = s.length; l < c; l++) {
                    const f = o[l],
                        h = s[l];
                    f !== 0 && (xf.fromBufferAttribute(h, e), a ? uc.addScaledVector(xf, f) : uc.addScaledVector(xf.sub(t), f))
                }
                t.add(uc)
            }
            return t
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.material,
                s = this.matrixWorld;
            i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), ac.copy(n.boundingSphere), ac.applyMatrix4(s), ys.copy(e.ray).recast(e.near), !(ac.containsPoint(ys.origin) === !1 && (ys.intersectSphere(ac, Zp) === null || ys.origin.distanceToSquared(Zp) > (e.far - e.near) ** 2)) && (Jp.copy(s).invert(), ys.copy(e.ray).applyMatrix4(Jp), !(n.boundingBox !== null && ys.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, ys)))
        }
        _computeIntersections(e, t, n) {
            let i;
            const s = this.geometry,
                a = this.material,
                o = s.index,
                l = s.attributes.position,
                c = s.attributes.uv,
                f = s.attributes.uv1,
                h = s.attributes.normal,
                d = s.groups,
                u = s.drawRange;
            if (o !== null)
                if (Array.isArray(a))
                    for (let _ = 0, m = d.length; _ < m; _++) {
                        const g = d[_],
                            p = a[g.materialIndex],
                            v = Math.max(g.start, u.start),
                            x = Math.min(o.count, Math.min(g.start + g.count, u.start + u.count));
                        for (let b = v, M = x; b < M; b += 3) {
                            const D = o.getX(b),
                                T = o.getX(b + 1),
                                w = o.getX(b + 2);
                            i = hc(this, p, e, n, c, f, h, D, T, w), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = g.materialIndex, t.push(i))
                        }
                    } else {
                        const _ = Math.max(0, u.start),
                            m = Math.min(o.count, u.start + u.count);
                        for (let g = _, p = m; g < p; g += 3) {
                            const v = o.getX(g),
                                x = o.getX(g + 1),
                                b = o.getX(g + 2);
                            i = hc(this, a, e, n, c, f, h, v, x, b), i && (i.faceIndex = Math.floor(g / 3), t.push(i))
                        }
                    } else if (l !== void 0)
                        if (Array.isArray(a))
                            for (let _ = 0, m = d.length; _ < m; _++) {
                                const g = d[_],
                                    p = a[g.materialIndex],
                                    v = Math.max(g.start, u.start),
                                    x = Math.min(l.count, Math.min(g.start + g.count, u.start + u.count));
                                for (let b = v, M = x; b < M; b += 3) {
                                    const D = b,
                                        T = b + 1,
                                        w = b + 2;
                                    i = hc(this, p, e, n, c, f, h, D, T, w), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = g.materialIndex, t.push(i))
                                }
                            } else {
                                const _ = Math.max(0, u.start),
                                    m = Math.min(l.count, u.start + u.count);
                                for (let g = _, p = m; g < p; g += 3) {
                                    const v = g,
                                        x = g + 1,
                                        b = g + 2;
                                    i = hc(this, a, e, n, c, f, h, v, x, b), i && (i.faceIndex = Math.floor(g / 3), t.push(i))
                                }
                            }
        }
    }

    function Kx(r, e, t, n, i, s, a, o) {
        let l;
        if (e.side === 1 ? l = n.intersectTriangle(a, s, i, !0, o) : l = n.intersectTriangle(i, s, a, e.side === 0, o), l === null) return null;
        fc.copy(o), fc.applyMatrix4(r.matrixWorld);
        const c = t.ray.origin.distanceTo(fc);
        return c < t.near || c > t.far ? null : {
            distance: c,
            point: fc.clone(),
            object: r
        }
    }

    function hc(r, e, t, n, i, s, a, o, l, c) {
        r.getVertexPosition(o, oc), r.getVertexPosition(l, lc), r.getVertexPosition(c, cc);
        const f = Kx(r, e, t, n, oc, lc, cc, Qp);
        if (f) {
            const h = new Y;
            Ri.getBarycoord(Qp, oc, lc, cc, h), i && (f.uv = Ri.getInterpolatedAttribute(i, o, l, c, h, new pt)), s && (f.uv1 = Ri.getInterpolatedAttribute(s, o, l, c, h, new pt)), a && (f.normal = Ri.getInterpolatedAttribute(a, o, l, c, h, new Y), f.normal.dot(n.direction) > 0 && f.normal.multiplyScalar(-1));
            const d = {
                a: o,
                b: l,
                c,
                normal: new Y,
                materialIndex: 0
            };
            Ri.getNormal(oc, lc, cc, d.normal), f.face = d, f.barycoord = h
        }
        return f
    }
    class Ro extends Pi {
        constructor(e = 1, t = 1, n = 1, i = 1, s = 1, a = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: s,
                depthSegments: a
            };
            const o = this;
            i = Math.floor(i), s = Math.floor(s), a = Math.floor(a);
            const l = [],
                c = [],
                f = [],
                h = [];
            let d = 0,
                u = 0;
            _("z", "y", "x", -1, -1, n, t, e, a, s, 0), _("z", "y", "x", 1, -1, n, t, -e, a, s, 1), _("x", "z", "y", 1, 1, e, n, t, i, a, 2), _("x", "z", "y", 1, -1, e, n, -t, i, a, 3), _("x", "y", "z", 1, -1, e, t, n, i, s, 4), _("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(l), this.setAttribute("position", new mr(c, 3)), this.setAttribute("normal", new mr(f, 3)), this.setAttribute("uv", new mr(h, 2));

            function _(m, g, p, v, x, b, M, D, T, w, S) {
                const y = b / T,
                    C = M / w,
                    O = b / 2,
                    N = M / 2,
                    V = D / 2,
                    G = T + 1,
                    B = w + 1;
                let j = 0,
                    H = 0;
                const k = new Y;
                for (let F = 0; F < B; F++) {
                    const se = F * C - N;
                    for (let de = 0; de < G; de++) {
                        const ke = de * y - O;
                        k[m] = ke * v, k[g] = se * x, k[p] = V, c.push(k.x, k.y, k.z), k[m] = 0, k[g] = 0, k[p] = D > 0 ? 1 : -1, f.push(k.x, k.y, k.z), h.push(de / T), h.push(1 - F / w), j += 1
                    }
                }
                for (let F = 0; F < w; F++)
                    for (let se = 0; se < T; se++) {
                        const de = d + se + G * F,
                            ke = d + se + G * (F + 1),
                            q = d + (se + 1) + G * (F + 1),
                            ee = d + (se + 1) + G * F;
                        l.push(de, ke, ee), l.push(ke, q, ee), H += 6
                    }
                o.addGroup(u, H, S), u += H, d += j
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new Ro(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
        }
    }

    function va(r) {
        const e = {};
        for (const t in r) {
            e[t] = {};
            for (const n in r[t]) {
                const i = r[t][n];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
            }
        }
        return e
    }

    function Pn(r) {
        const e = {};
        for (let t = 0; t < r.length; t++) {
            const n = va(r[t]);
            for (const i in n) e[i] = n[i]
        }
        return e
    }

    function $x(r) {
        const e = [];
        for (let t = 0; t < r.length; t++) e.push(r[t].clone());
        return e
    }

    function em(r) {
        const e = r.getRenderTarget();
        return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : xt.workingColorSpace
    }
    const Jx = {
        clone: va,
        merge: Pn
    };
    var Zx = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        Qx = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class Hr extends fi {
        constructor(e) {
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Zx, this.fragmentShader = Qx, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = va(e.uniforms), this.uniformsGroups = $x(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for (const i in this.uniforms) {
                const a = this.uniforms[i].value;
                a && a.isTexture ? t.uniforms[i] = {
                    type: "t",
                    value: a.toJSON(e).uuid
                } : a && a.isColor ? t.uniforms[i] = {
                    type: "c",
                    value: a.getHex()
                } : a && a.isVector2 ? t.uniforms[i] = {
                    type: "v2",
                    value: a.toArray()
                } : a && a.isVector3 ? t.uniforms[i] = {
                    type: "v3",
                    value: a.toArray()
                } : a && a.isVector4 ? t.uniforms[i] = {
                    type: "v4",
                    value: a.toArray()
                } : a && a.isMatrix3 ? t.uniforms[i] = {
                    type: "m3",
                    value: a.toArray()
                } : a && a.isMatrix4 ? t.uniforms[i] = {
                    type: "m4",
                    value: a.toArray()
                } : t.uniforms[i] = {
                    value: a
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t
        }
    }
    class tm extends zt {
        constructor() {
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new st, this.projectionMatrix = new st, this.projectionMatrixInverse = new st, this.coordinateSystem = 2e3
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate()
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    const Vr = new Y,
        nm = new pt,
        im = new pt;
    class Fn extends tm {
        constructor(e = 50, t = 1, n = .1, i = 2e3) {
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = oa * 2 * Math.atan(t), this.updateProjectionMatrix()
        }
        getFocalLength() {
            const e = Math.tan(So * .5 * this.fov);
            return .5 * this.getFilmHeight() / e
        }
        getEffectiveFOV() {
            return oa * 2 * Math.atan(Math.tan(So * .5 * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        getViewBounds(e, t, n) {
            Vr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Vr.x, Vr.y).multiplyScalar(-e / Vr.z), Vr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Vr.x, Vr.y).multiplyScalar(-e / Vr.z)
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, nm, im), t.subVectors(im, nm)
        }
        setViewOffset(e, t, n, i, s, a) {
            this.aspect = e / t, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(So * .5 * this.fov) / this.zoom,
                n = 2 * t,
                i = this.aspect * n,
                s = -.5 * i;
            const a = this.view;
            if (this.view !== null && this.view.enabled) {
                const l = a.fullWidth,
                    c = a.fullHeight;
                s += a.offsetX * i / l, t -= a.offsetY * n / c, i *= a.width / l, n *= a.height / c
            }
            const o = this.filmOffset;
            o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }
    const ya = -90,
        Sa = 1;
    class ev extends zt {
        constructor(e, t, n) {
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const i = new Fn(ya, Sa, e, t);
            i.layers = this.layers, this.add(i);
            const s = new Fn(ya, Sa, e, t);
            s.layers = this.layers, this.add(s);
            const a = new Fn(ya, Sa, e, t);
            a.layers = this.layers, this.add(a);
            const o = new Fn(ya, Sa, e, t);
            o.layers = this.layers, this.add(o);
            const l = new Fn(ya, Sa, e, t);
            l.layers = this.layers, this.add(l);
            const c = new Fn(ya, Sa, e, t);
            c.layers = this.layers, this.add(c)
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem,
                t = this.children.concat(),
                [n, i, s, a, o, l] = t;
            for (const c of t) this.remove(c);
            if (e === 2e3) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
            else if (e === 2001) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            for (const c of t) this.add(c), c.updateMatrixWorld()
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            const {
                renderTarget: n,
                activeMipmapLevel: i
            } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [s, a, o, l, c, f] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), _ = e.xr.enabled;
            e.xr.enabled = !1;
            const m = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, s), e.setRenderTarget(n, 1, i), e.render(t, a), e.setRenderTarget(n, 2, i), e.render(t, o), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = m, e.setRenderTarget(n, 5, i), e.render(t, f), e.setRenderTarget(h, d, u), e.xr.enabled = _, n.texture.needsPMREMUpdate = !0
        }
    }
    class rm extends tn {
        constructor(e = [], t = 301, n, i, s, a, o, l, c, f) {
            super(e, t, n, i, s, a, o, l, c, f), this.isCubeTexture = !0, this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
    class tv extends bs {
        constructor(e = 1, t = {}) {
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                    width: e,
                    height: e,
                    depth: 1
                },
                i = [n, n, n, n, n, n];
            this.texture = new rm(i), this._setTextureOptions(t), this.texture.isRenderTargetTexture = !0
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                    fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                },
                i = new Ro(5, 5, 5),
                s = new Hr({
                    name: "CubemapFromEquirect",
                    uniforms: va(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
            s.uniforms.tEquirect.value = t;
            const a = new ei(i, s),
                o = t.minFilter;
            return t.minFilter === 1008 && (t.minFilter = 1006), new ev(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this
        }
        clear(e, t = !0, n = !0, i = !0) {
            const s = e.getRenderTarget();
            for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
            e.setRenderTarget(s)
        }
    }
    class Wr extends zt {
        constructor() {
            super(), this.isGroup = !0, this.type = "Group"
        }
    }
    const nv = {
        type: "move"
    };
    class vf {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new Wr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new Wr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Y, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Y), this._targetRay
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new Wr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Y, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Y), this._grip
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t)
                    for (const n of e.hand.values()) this._getHandJoint(t, n)
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
        }
        update(e, t, n) {
            let i = null,
                s = null,
                a = null;
            const o = this._targetRay,
                l = this._grip,
                c = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (c && e.hand) {
                    a = !0;
                    for (const m of e.hand.values()) {
                        const g = t.getJointPose(m, n),
                            p = this._getHandJoint(c, m);
                        g !== null && (p.matrix.fromArray(g.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = g.radius), p.visible = g !== null
                    }
                    const f = c.joints["index-finger-tip"],
                        h = c.joints["thumb-tip"],
                        d = f.position.distanceTo(h.position),
                        u = .02,
                        _ = .005;
                    c.inputState.pinching && d > u + _ ? (c.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !c.inputState.pinching && d <= u - _ && (c.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
                o !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(nv)))
            }
            return o !== null && (o.visible = i !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                const n = new Wr;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
            }
            return e.joints[t.jointName]
        }
    }
    class iv extends zt {
        constructor() {
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new ji, this.environmentIntensity = 1, this.environmentRotation = new ji, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
        }
    }
    class rv {
        constructor(e, t) {
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = 35044, this.updateRanges = [], this.version = 0, this.uuid = Ei()
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        clone(e) {
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ei()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        toJSON(e) {
            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ei()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    const Ln = new Y;
    class yf {
        constructor(e, t, n, i = !1) {
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++) Ln.fromBufferAttribute(this, t), Ln.applyMatrix4(e), this.setXYZ(t, Ln.x, Ln.y, Ln.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Ln.fromBufferAttribute(this, t), Ln.applyNormalMatrix(e), this.setXYZ(t, Ln.x, Ln.y, Ln.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Ln.fromBufferAttribute(this, t), Ln.transformDirection(e), this.setXYZ(t, Ln.x, Ln.y, Ln.z);
            return this
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = Di(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
        }
        setX(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
        }
        setY(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }
        setZ(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }
        setW(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = Di(t, this.array)), t
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = Di(t, this.array)), t
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = Di(t, this.array)), t
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = Di(t, this.array)), t
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, s) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array), s = At(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this
        }
        clone(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let n = 0; n < this.count; n++) {
                    const i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
                }
                return new _n(new this.array.constructor(t), this.itemSize, this.normalized)
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new yf(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }
        toJSON(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let n = 0; n < this.count; n++) {
                    const i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    const sm = new Y,
        am = new Tt,
        om = new Tt,
        sv = new Y,
        lm = new st,
        dc = new Y,
        Sf = new Xi,
        cm = new st,
        Mf = new Ao;
    class av extends ei {
        constructor(e, t) {
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Pp, this.bindMatrix = new st, this.bindMatrixInverse = new st, this.boundingBox = null, this.boundingSphere = null
        }
        computeBoundingBox() {
            const e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new cr), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++) this.getVertexPosition(n, dc), this.boundingBox.expandByPoint(dc)
        }
        computeBoundingSphere() {
            const e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new Xi), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++) this.getVertexPosition(n, dc), this.boundingSphere.expandByPoint(dc)
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        raycast(e, t) {
            const n = this.material,
                i = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Sf.copy(this.boundingSphere), Sf.applyMatrix4(i), e.ray.intersectsSphere(Sf) !== !1 && (cm.copy(i).invert(), Mf.copy(e.ray).applyMatrix4(cm), !(this.boundingBox !== null && Mf.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Mf)))
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
        }
        bind(e, t) {
            this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            const e = new Tt,
                t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                e.fromBufferAttribute(t, n);
                const s = 1 / e.manhattanLength();
                s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === Pp ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === fx ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton,
                i = this.geometry;
            am.fromBufferAttribute(i.attributes.skinIndex, e), om.fromBufferAttribute(i.attributes.skinWeight, e), sm.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for (let s = 0; s < 4; s++) {
                const a = om.getComponent(s);
                if (a !== 0) {
                    const o = am.getComponent(s);
                    lm.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(sv.copy(sm).applyMatrix4(lm), a)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }
    class um extends zt {
        constructor() {
            super(), this.isBone = !0, this.type = "Bone"
        }
    }
    class fm extends tn {
        constructor(e = null, t = 1, n = 1, i, s, a, o, l, c = 1003, f = 1003, h, d) {
            super(null, a, o, l, c, f, i, s, h, d), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    const hm = new st,
        ov = new st;
    class Tf {
        constructor(e = [], t = []) {
            this.uuid = Ei(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
        }
        init() {
            const e = this.bones,
                t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new st)
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = new st;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
            }
        }
        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
            }
        }
        update() {
            const e = this.bones,
                t = this.boneInverses,
                n = this.boneMatrices,
                i = this.boneTexture;
            for (let s = 0, a = e.length; s < a; s++) {
                const o = e[s] ? e[s].matrixWorld : ov;
                hm.multiplyMatrices(o, t[s]), hm.toArray(n, s * 16)
            }
            i !== null && (i.needsUpdate = !0)
        }
        clone() {
            return new Tf(this.bones, this.boneInverses)
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new fm(t, e, e, 1023, 1015);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
        }
        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                const i = this.bones[t];
                if (i.name === e) return i
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                const s = e.bones[n];
                let a = t[s];
                a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new um), this.bones.push(a), this.boneInverses.push(new st().fromArray(e.boneInverses[n]))
            }
            return this.init(), this
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones,
                n = this.boneInverses;
            for (let i = 0, s = t.length; i < s; i++) {
                const a = t[i];
                e.bones.push(a.uuid);
                const o = n[i];
                e.boneInverses.push(o.toArray())
            }
            return e
        }
    }
    class Ef extends _n {
        constructor(e, t, n, i = 1) {
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }
    const Ma = new st,
        dm = new st,
        pc = [],
        pm = new cr,
        lv = new st,
        Po = new ei,
        Fo = new Xi;
    class cv extends ei {
        constructor(e, t, n) {
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Ef(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for (let i = 0; i < n; i++) this.setMatrixAt(i, lv)
        }
        computeBoundingBox() {
            const e = this.geometry,
                t = this.count;
            this.boundingBox === null && (this.boundingBox = new cr), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, Ma), pm.copy(e.boundingBox).applyMatrix4(Ma), this.boundingBox.union(pm)
        }
        computeBoundingSphere() {
            const e = this.geometry,
                t = this.count;
            this.boundingSphere === null && (this.boundingSphere = new Xi), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, Ma), Fo.copy(e.boundingSphere).applyMatrix4(Ma), this.boundingSphere.union(Fo)
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3)
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16)
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = this.morphTexture.source.data.data,
                s = n.length + 1,
                a = e * s + 1;
            for (let o = 0; o < n.length; o++) n[o] = i[a + o]
        }
        raycast(e, t) {
            const n = this.matrixWorld,
                i = this.count;
            if (Po.geometry = this.geometry, Po.material = this.material, Po.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Fo.copy(this.boundingSphere), Fo.applyMatrix4(n), e.ray.intersectsSphere(Fo) !== !1))
                for (let s = 0; s < i; s++) {
                    this.getMatrixAt(s, Ma), dm.multiplyMatrices(n, Ma), Po.matrixWorld = dm, Po.raycast(e, pc);
                    for (let a = 0, o = pc.length; a < o; a++) {
                        const l = pc[a];
                        l.instanceId = s, l.object = this, t.push(l)
                    }
                    pc.length = 0
                }
        }
        setColorAt(e, t) {
            this.instanceColor === null && (this.instanceColor = new Ef(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3)
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16)
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new fm(new Float32Array(i * this.count), i, this.count, 1028, 1015));
            const s = this.morphTexture.source.data.data;
            let a = 0;
            for (let c = 0; c < n.length; c++) a += n[c];
            const o = this.geometry.morphTargetsRelative ? 1 : 1 - a,
                l = i * e;
            s[l] = o, s.set(n, l + 1)
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null)
        }
    }
    const Df = new Y,
        uv = new Y,
        fv = new ot;
    class Ss {
        constructor(e = new Y(1, 0, 0), t = 0) {
            this.isPlane = !0, this.normal = e, this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }
        setFromCoplanarPoints(e, t, n) {
            const i = Df.subVectors(n, t).cross(uv.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
        }
        intersectLine(e, t) {
            const n = e.delta(Df),
                i = this.normal.dot(n);
            if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            const s = -(e.start.dot(this.normal) + this.constant) / i;
            return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            const n = t || fv.getNormalMatrix(e),
                i = this.coplanarPoint(Df).applyMatrix4(e),
                s = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(s), this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    const Ms = new Xi,
        mc = new Y;
    class Af {
        constructor(e = new Ss, t = new Ss, n = new Ss, i = new Ss, s = new Ss, a = new Ss) {
            this.planes = [e, t, n, i, s, a]
        }
        set(e, t, n, i, s, a) {
            const o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(s), o[5].copy(a), this
        }
        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e, t = 2e3) {
            const n = this.planes,
                i = e.elements,
                s = i[0],
                a = i[1],
                o = i[2],
                l = i[3],
                c = i[4],
                f = i[5],
                h = i[6],
                d = i[7],
                u = i[8],
                _ = i[9],
                m = i[10],
                g = i[11],
                p = i[12],
                v = i[13],
                x = i[14],
                b = i[15];
            if (n[0].setComponents(l - s, d - c, g - u, b - p).normalize(), n[1].setComponents(l + s, d + c, g + u, b + p).normalize(), n[2].setComponents(l + a, d + f, g + _, b + v).normalize(), n[3].setComponents(l - a, d - f, g - _, b - v).normalize(), n[4].setComponents(l - o, d - h, g - m, b - x).normalize(), t === 2e3) n[5].setComponents(l + o, d + h, g + m, b + x).normalize();
            else if (t === 2001) n[5].setComponents(o, h, m, x).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            return this
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ms.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(), Ms.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
            }
            return this.intersectsSphere(Ms)
        }
        intersectsSprite(e) {
            return Ms.center.set(0, 0, 0), Ms.radius = .7071067811865476, Ms.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ms)
        }
        intersectsSphere(e) {
            const t = this.planes,
                n = e.center,
                i = -e.radius;
            for (let s = 0; s < 6; s++)
                if (t[s].distanceToPoint(n) < i) return !1;
            return !0
        }
        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = t[n];
                if (mc.x = i.normal.x > 0 ? e.max.x : e.min.x, mc.y = i.normal.y > 0 ? e.max.y : e.min.y, mc.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(mc) < 0) return !1
            }
            return !0
        }
        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    class mm extends fi {
        constructor(e) {
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new it(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
        }
    }
    const gc = new Y,
        _c = new Y,
        gm = new st,
        Lo = new Ao,
        bc = new Xi,
        wf = new Y,
        _m = new Y;
    class Cf extends zt {
        constructor(e = new Pi, t = new mm) {
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position,
                    n = [0];
                for (let i = 1, s = t.count; i < s; i++) gc.fromBufferAttribute(t, i - 1), _c.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += gc.distanceTo(_c);
                e.setAttribute("lineDistance", new mr(n, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Line.threshold,
                a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), bc.copy(n.boundingSphere), bc.applyMatrix4(i), bc.radius += s, e.ray.intersectsSphere(bc) === !1) return;
            gm.copy(i).invert(), Lo.copy(e.ray).applyMatrix4(gm);
            const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                l = o * o,
                c = this.isLineSegments ? 2 : 1,
                f = n.index,
                d = n.attributes.position;
            if (f !== null) {
                const u = Math.max(0, a.start),
                    _ = Math.min(f.count, a.start + a.count);
                for (let m = u, g = _ - 1; m < g; m += c) {
                    const p = f.getX(m),
                        v = f.getX(m + 1),
                        x = xc(this, e, Lo, l, p, v, m);
                    x && t.push(x)
                }
                if (this.isLineLoop) {
                    const m = f.getX(_ - 1),
                        g = f.getX(u),
                        p = xc(this, e, Lo, l, m, g, _ - 1);
                    p && t.push(p)
                }
            } else {
                const u = Math.max(0, a.start),
                    _ = Math.min(d.count, a.start + a.count);
                for (let m = u, g = _ - 1; m < g; m += c) {
                    const p = xc(this, e, Lo, l, m, m + 1, m);
                    p && t.push(p)
                }
                if (this.isLineLoop) {
                    const m = xc(this, e, Lo, l, _ - 1, u, _ - 1);
                    m && t.push(m)
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
    }

    function xc(r, e, t, n, i, s, a) {
        const o = r.geometry.attributes.position;
        if (gc.fromBufferAttribute(o, i), _c.fromBufferAttribute(o, s), t.distanceSqToSegment(gc, _c, wf, _m) > n) return;
        wf.applyMatrix4(r.matrixWorld);
        const c = e.ray.origin.distanceTo(wf);
        if (!(c < e.near || c > e.far)) return {
            distance: c,
            point: _m.clone().applyMatrix4(r.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: r
        }
    }
    const bm = new Y,
        xm = new Y;
    class hv extends Cf {
        constructor(e, t) {
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position,
                    n = [];
                for (let i = 0, s = t.count; i < s; i += 2) bm.fromBufferAttribute(t, i), xm.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + bm.distanceTo(xm);
                e.setAttribute("lineDistance", new mr(n, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
    }
    class dv extends Cf {
        constructor(e, t) {
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
        }
    }
    class vm extends fi {
        constructor(e) {
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new it(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
        }
    }
    const ym = new st,
        Rf = new Ao,
        vc = new Xi,
        yc = new Y;
    class pv extends zt {
        constructor(e = new Pi, t = new vm) {
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Points.threshold,
                a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), vc.copy(n.boundingSphere), vc.applyMatrix4(i), vc.radius += s, e.ray.intersectsSphere(vc) === !1) return;
            ym.copy(i).invert(), Rf.copy(e.ray).applyMatrix4(ym);
            const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                l = o * o,
                c = n.index,
                h = n.attributes.position;
            if (c !== null) {
                const d = Math.max(0, a.start),
                    u = Math.min(c.count, a.start + a.count);
                for (let _ = d, m = u; _ < m; _++) {
                    const g = c.getX(_);
                    yc.fromBufferAttribute(h, g), Sm(yc, g, l, i, e, t, this)
                }
            } else {
                const d = Math.max(0, a.start),
                    u = Math.min(h.count, a.start + a.count);
                for (let _ = d, m = u; _ < m; _++) yc.fromBufferAttribute(h, _), Sm(yc, _, l, i, e, t, this)
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
    }

    function Sm(r, e, t, n, i, s, a) {
        const o = Rf.distanceSqToPoint(r);
        if (o < t) {
            const l = new Y;
            Rf.closestPointToPoint(r, l), l.applyMatrix4(n);
            const c = i.ray.origin.distanceTo(l);
            if (c < i.near || c > i.far) return;
            s.push({
                distance: c,
                distanceToRay: Math.sqrt(o),
                point: l,
                index: e,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: a
            })
        }
    }
    class Mm extends tn {
        constructor(e, t, n = 1014, i, s, a, o = 1003, l = 1003, c, f = 1026, h = 1) {
            if (f !== 1026 && f !== 1027) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            const d = {
                width: e,
                height: t,
                depth: h
            };
            super(d, i, s, a, o, l, f, n, c), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
        }
        copy(e) {
            return super.copy(e), this.source = new Qu(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
        }
    }
    class Sc extends Pi {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const s = e / 2,
                a = t / 2,
                o = Math.floor(n),
                l = Math.floor(i),
                c = o + 1,
                f = l + 1,
                h = e / o,
                d = t / l,
                u = [],
                _ = [],
                m = [],
                g = [];
            for (let p = 0; p < f; p++) {
                const v = p * d - a;
                for (let x = 0; x < c; x++) {
                    const b = x * h - s;
                    _.push(b, -v, 0), m.push(0, 0, 1), g.push(x / o), g.push(1 - p / l)
                }
            }
            for (let p = 0; p < l; p++)
                for (let v = 0; v < o; v++) {
                    const x = v + c * p,
                        b = v + c * (p + 1),
                        M = v + 1 + c * (p + 1),
                        D = v + 1 + c * p;
                    u.push(x, b, D), u.push(b, M, D)
                }
            this.setIndex(u), this.setAttribute("position", new mr(_, 3)), this.setAttribute("normal", new mr(m, 3)), this.setAttribute("uv", new mr(g, 2))
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new Sc(e.width, e.height, e.widthSegments, e.heightSegments)
        }
    }
    class Pf extends fi {
        constructor(e) {
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new it(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new it(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ji, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
        }
    }
    class qi extends Pf {
        constructor(e) {
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return dt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t)
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new it(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new it(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new it(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
        }
        get anisotropy() {
            return this._anisotropy
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
        }
        get clearcoat() {
            return this._clearcoat
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
        }
        get iridescence() {
            return this._iridescence
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
        }
        get dispersion() {
            return this._dispersion
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
        }
        get sheen() {
            return this._sheen
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
        }
        get transmission() {
            return this._transmission
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
        }
    }
    class mv extends fi {
        constructor(e) {
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }
    }
    class gv extends fi {
        constructor(e) {
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        }
    }
    class _v extends fi {
        constructor(e) {
            super(), this.isMeshMatcapMaterial = !0, this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new it(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                MATCAP: ""
            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
        }
    }

    function Mc(r, e) {
        return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
    }

    function bv(r) {
        return ArrayBuffer.isView(r) && !(r instanceof DataView)
    }

    function xv(r) {
        function e(i, s) {
            return r[i] - r[s]
        }
        const t = r.length,
            n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = i;
        return n.sort(e), n
    }

    function Tm(r, e, t) {
        const n = r.length,
            i = new r.constructor(n);
        for (let s = 0, a = 0; a !== n; ++s) {
            const o = t[s] * e;
            for (let l = 0; l !== e; ++l) i[a++] = r[o + l]
        }
        return i
    }

    function Em(r, e, t, n) {
        let i = 1,
            s = r[0];
        for (; s !== void 0 && s[n] === void 0;) s = r[i++];
        if (s === void 0) return;
        let a = s[n];
        if (a !== void 0)
            if (Array.isArray(a))
                do a = s[n], a !== void 0 && (e.push(s.time), t.push(...a)), s = r[i++]; while (s !== void 0);
            else if (a.toArray !== void 0)
            do a = s[n], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = r[i++]; while (s !== void 0);
        else
            do a = s[n], a !== void 0 && (e.push(s.time), t.push(a)), s = r[i++]; while (s !== void 0)
    }
    class Io {
        constructor(e, t, n, i) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex,
                i = t[n],
                s = t[n - 1];
            n: {
                e: {
                    let a;t: {
                        i: if (!(e < i)) {
                            for (let o = n + 2;;) {
                                if (i === void 0) {
                                    if (e < s) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                }
                                if (n === o) break;
                                if (s = i, i = t[++n], e < i) break e
                            }
                            a = t.length;
                            break t
                        }if (!(e >= s)) {
                            const o = t[1];
                            e < o && (n = 2, s = o);
                            for (let l = n - 2;;) {
                                if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === l) break;
                                if (i = s, s = t[--n - 1], e >= s) break e
                            }
                            a = n, n = 0;
                            break t
                        }
                        break n
                    }
                    for (; n < a;) {
                        const o = n + a >>> 1;
                        e < t[o] ? a = o : n = o + 1
                    }
                    if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, s, i)
            }
            return this.interpolate_(n, s, e, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                s = e * i;
            for (let a = 0; a !== i; ++a) t[a] = n[s + a];
            return t
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
    class vv extends Io {
        constructor(e, t, n, i) {
            super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: 2400,
                endingEnd: 2400
            }
        }
        intervalChanged_(e, t, n) {
            const i = this.parameterPositions;
            let s = e - 2,
                a = e + 1,
                o = i[s],
                l = i[a];
            if (o === void 0) switch (this.getSettings_().endingStart) {
                case 2401:
                    s = e, o = 2 * t - n;
                    break;
                case 2402:
                    s = i.length - 2, o = t + i[s] - i[s + 1];
                    break;
                default:
                    s = e, o = n
            }
            if (l === void 0) switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e, l = 2 * n - t;
                    break;
                case 2402:
                    a = 1, l = n + i[1] - i[0];
                    break;
                default:
                    a = e - 1, l = t
            }
            const c = (n - t) * .5,
                f = this.valueSize;
            this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = s * f, this._offsetNext = a * f
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                l = e * o,
                c = l - o,
                f = this._offsetPrev,
                h = this._offsetNext,
                d = this._weightPrev,
                u = this._weightNext,
                _ = (n - t) / (i - t),
                m = _ * _,
                g = m * _,
                p = -d * g + 2 * d * m - d * _,
                v = (1 + d) * g + (-1.5 - 2 * d) * m + (-.5 + d) * _ + 1,
                x = (-1 - u) * g + (1.5 + u) * m + .5 * _,
                b = u * g - u * m;
            for (let M = 0; M !== o; ++M) s[M] = p * a[f + M] + v * a[c + M] + x * a[l + M] + b * a[h + M];
            return s
        }
    }
    class yv extends Io {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                l = e * o,
                c = l - o,
                f = (n - t) / (i - t),
                h = 1 - f;
            for (let d = 0; d !== o; ++d) s[d] = a[c + d] * h + a[l + d] * f;
            return s
        }
    }
    class Sv extends Io {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1)
        }
    }
    class Fi {
        constructor(e, t, n, i) {
            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = Mc(t, this.TimeBufferType), this.values = Mc(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: Mc(e.times, Array),
                    values: Mc(e.values, Array)
                };
                const i = e.getInterpolation();
                i !== e.DefaultInterpolation && (n.interpolation = i)
            }
            return n.type = e.ValueTypeName, n
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new Sv(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodLinear(e) {
            return new yv(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodSmooth(e) {
            return new vv(this.times, this.values, this.getValueSize(), e)
        }
        setInterpolation(e) {
            let t;
            switch (e) {
                case 2300:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth;
                    break
            }
            if (t === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0)
                    if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                    else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this
            }
            return this.createInterpolant = t, this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(e) {
            if (e !== 0) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
            }
            return this
        }
        scale(e) {
            if (e !== 1) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
            }
            return this
        }
        trim(e, t) {
            const n = this.times,
                i = n.length;
            let s = 0,
                a = i - 1;
            for (; s !== i && n[s] < e;) ++s;
            for (; a !== -1 && n[a] > t;) --a;
            if (++a, s !== 0 || a !== i) {
                s >= a && (a = Math.max(a, 1), s = a - 1);
                const o = this.getValueSize();
                this.times = n.slice(s, a), this.values = this.values.slice(s * o, a * o)
            }
            return this
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times,
                i = this.values,
                s = n.length;
            s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let a = null;
            for (let o = 0; o !== s; o++) {
                const l = n[o];
                if (typeof l == "number" && isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
                    break
                }
                if (a !== null && a > l) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
                    break
                }
                a = l
            }
            if (i !== void 0 && bv(i))
                for (let o = 0, l = i.length; o !== l; ++o) {
                    const c = i[o];
                    if (isNaN(c)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
                        break
                    }
                }
            return e
        }
        optimize() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = this.getValueSize(),
                i = this.getInterpolation() === 2302,
                s = e.length - 1;
            let a = 1;
            for (let o = 1; o < s; ++o) {
                let l = !1;
                const c = e[o],
                    f = e[o + 1];
                if (c !== f && (o !== 1 || c !== e[0]))
                    if (i) l = !0;
                    else {
                        const h = o * n,
                            d = h - n,
                            u = h + n;
                        for (let _ = 0; _ !== n; ++_) {
                            const m = t[h + _];
                            if (m !== t[d + _] || m !== t[u + _]) {
                                l = !0;
                                break
                            }
                        }
                    }
                if (l) {
                    if (o !== a) {
                        e[a] = e[o];
                        const h = o * n,
                            d = a * n;
                        for (let u = 0; u !== n; ++u) t[d + u] = t[h + u]
                    }++a
                }
            }
            if (s > 0) {
                e[a] = e[s];
                for (let o = s * n, l = a * n, c = 0; c !== n; ++c) t[l + c] = t[o + c];
                ++a
            }
            return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this
        }
        clone() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = this.constructor,
                i = new n(this.name, e, t);
            return i.createInterpolant = this.createInterpolant, i
        }
    }
    Fi.prototype.ValueTypeName = "", Fi.prototype.TimeBufferType = Float32Array, Fi.prototype.ValueBufferType = Float32Array, Fi.prototype.DefaultInterpolation = 2301;
    class Ta extends Fi {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    Ta.prototype.ValueTypeName = "bool", Ta.prototype.ValueBufferType = Array, Ta.prototype.DefaultInterpolation = 2300, Ta.prototype.InterpolantFactoryMethodLinear = void 0, Ta.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Dm extends Fi {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    Dm.prototype.ValueTypeName = "color";
    class Ea extends Fi {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    Ea.prototype.ValueTypeName = "number";
    class Mv extends Io {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                l = (n - t) / (i - t);
            let c = e * o;
            for (let f = c + o; c !== f; c += 4) Nr.slerpFlat(s, 0, a, c - o, a, c, l);
            return s
        }
    }
    class Da extends Fi {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        InterpolantFactoryMethodLinear(e) {
            return new Mv(this.times, this.values, this.getValueSize(), e)
        }
    }
    Da.prototype.ValueTypeName = "quaternion", Da.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Aa extends Fi {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    Aa.prototype.ValueTypeName = "string", Aa.prototype.ValueBufferType = Array, Aa.prototype.DefaultInterpolation = 2300, Aa.prototype.InterpolantFactoryMethodLinear = void 0, Aa.prototype.InterpolantFactoryMethodSmooth = void 0;
    class wa extends Fi {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    wa.prototype.ValueTypeName = "vector";
    class Tv {
        constructor(e = "", t = -1, n = [], i = 2500) {
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Ei(), this.duration < 0 && this.resetDuration()
        }
        static parse(e) {
            const t = [],
                n = e.tracks,
                i = 1 / (e.fps || 1);
            for (let a = 0, o = n.length; a !== o; ++a) t.push(Dv(n[a]).scale(i));
            const s = new this(e.name, e.duration, t, e.blendMode);
            return s.uuid = e.uuid, s
        }
        static toJSON(e) {
            const t = [],
                n = e.tracks,
                i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
            for (let s = 0, a = n.length; s !== a; ++s) t.push(Fi.toJSON(n[s]));
            return i
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
            const s = t.length,
                a = [];
            for (let o = 0; o < s; o++) {
                let l = [],
                    c = [];
                l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
                const f = xv(l);
                l = Tm(l, 1, f), c = Tm(c, 1, f), !i && l[0] === 0 && (l.push(s), c.push(c[0])), a.push(new Ea(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n))
            }
            return new this(e, -1, a)
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const i = e;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (let i = 0; i < n.length; i++)
                if (n[i].name === t) return n[i];
            return null
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const i = {},
                s = /^([\w-]*?)([\d]+)$/;
            for (let o = 0, l = e.length; o < l; o++) {
                const c = e[o],
                    f = c.name.match(s);
                if (f && f.length > 1) {
                    const h = f[1];
                    let d = i[h];
                    d || (i[h] = d = []), d.push(c)
                }
            }
            const a = [];
            for (const o in i) a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
            return a
        }
        static parseAnimation(e, t) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(h, d, u, _, m) {
                    if (u.length !== 0) {
                        const g = [],
                            p = [];
                        Em(u, g, p, _), g.length !== 0 && m.push(new h(d, g, p))
                    }
                },
                i = [],
                s = e.name || "default",
                a = e.fps || 30,
                o = e.blendMode;
            let l = e.length || -1;
            const c = e.hierarchy || [];
            for (let h = 0; h < c.length; h++) {
                const d = c[h].keys;
                if (!(!d || d.length === 0))
                    if (d[0].morphTargets) {
                        const u = {};
                        let _;
                        for (_ = 0; _ < d.length; _++)
                            if (d[_].morphTargets)
                                for (let m = 0; m < d[_].morphTargets.length; m++) u[d[_].morphTargets[m]] = -1;
                        for (const m in u) {
                            const g = [],
                                p = [];
                            for (let v = 0; v !== d[_].morphTargets.length; ++v) {
                                const x = d[_];
                                g.push(x.time), p.push(x.morphTarget === m ? 1 : 0)
                            }
                            i.push(new Ea(".morphTargetInfluence[" + m + "]", g, p))
                        }
                        l = u.length * a
                    } else {
                        const u = ".bones[" + t[h].name + "]";
                        n(wa, u + ".position", d, "pos", i), n(Da, u + ".quaternion", d, "rot", i), n(wa, u + ".scale", d, "scl", i)
                    }
            }
            return i.length === 0 ? null : new this(s, l, i, o)
        }
        resetDuration() {
            const e = this.tracks;
            let t = 0;
            for (let n = 0, i = e.length; n !== i; ++n) {
                const s = this.tracks[n];
                t = Math.max(t, s.times[s.times.length - 1])
            }
            return this.duration = t, this
        }
        trim() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        }
        validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        }
        optimize() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
        clone() {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }

    function Ev(r) {
        switch (r.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ea;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return wa;
            case "color":
                return Dm;
            case "quaternion":
                return Da;
            case "bool":
            case "boolean":
                return Ta;
            case "string":
                return Aa
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
    }

    function Dv(r) {
        if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = Ev(r.type);
        if (r.times === void 0) {
            const t = [],
                n = [];
            Em(r.keys, t, n, "value"), r.times = t, r.values = n
        }
        return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation)
    }
    const Xr = {
        enabled: !1,
        files: {},
        add: function(r, e) {
            this.enabled !== !1 && (this.files[r] = e)
        },
        get: function(r) {
            if (this.enabled !== !1) return this.files[r]
        },
        remove: function(r) {
            delete this.files[r]
        },
        clear: function() {
            this.files = {}
        }
    };
    class Am {
        constructor(e, t, n) {
            const i = this;
            let s = !1,
                a = 0,
                o = 0,
                l;
            const c = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(f) {
                o++, s === !1 && i.onStart !== void 0 && i.onStart(f, a, o), s = !0
            }, this.itemEnd = function(f) {
                a++, i.onProgress !== void 0 && i.onProgress(f, a, o), a === o && (s = !1, i.onLoad !== void 0 && i.onLoad())
            }, this.itemError = function(f) {
                i.onError !== void 0 && i.onError(f)
            }, this.resolveURL = function(f) {
                return l ? l(f) : f
            }, this.setURLModifier = function(f) {
                return l = f, this
            }, this.addHandler = function(f, h) {
                return c.push(f, h), this
            }, this.removeHandler = function(f) {
                const h = c.indexOf(f);
                return h !== -1 && c.splice(h, 2), this
            }, this.getHandler = function(f) {
                for (let h = 0, d = c.length; h < d; h += 2) {
                    const u = c[h],
                        _ = c[h + 1];
                    if (u.global && (u.lastIndex = 0), u.test(f)) return _
                }
                return null
            }
        }
    }
    const Av = new Am;
    class Ts {
        constructor(e) {
            this.manager = e !== void 0 ? e : Av, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise(function(i, s) {
                n.load(e, i, t, s)
            })
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this
        }
        setPath(e) {
            return this.path = e, this
        }
        setResourcePath(e) {
            return this.resourcePath = e, this
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this
        }
    }
    Ts.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const gr = {};
    class wv extends Error {
        constructor(e, t) {
            super(e), this.response = t
        }
    }
    class Tc extends Ts {
        constructor(e) {
            super(e), this.mimeType = "", this.responseType = ""
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = Xr.get(e);
            if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
                t && t(s), this.manager.itemEnd(e)
            }, 0), s;
            if (gr[e] !== void 0) {
                gr[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                return
            }
            gr[e] = [], gr[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            const a = new Request(e, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                }),
                o = this.mimeType,
                l = this.responseType;
            fetch(a).then(c => {
                if (c.status === 200 || c.status === 0) {
                    if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                    const f = gr[e],
                        h = c.body.getReader(),
                        d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
                        u = d ? parseInt(d) : 0,
                        _ = u !== 0;
                    let m = 0;
                    const g = new ReadableStream({
                        start(p) {
                            v();

                            function v() {
                                h.read().then(({
                                    done: x,
                                    value: b
                                }) => {
                                    if (x) p.close();
                                    else {
                                        m += b.byteLength;
                                        const M = new ProgressEvent("progress", {
                                            lengthComputable: _,
                                            loaded: m,
                                            total: u
                                        });
                                        for (let D = 0, T = f.length; D < T; D++) {
                                            const w = f[D];
                                            w.onProgress && w.onProgress(M)
                                        }
                                        p.enqueue(b), v()
                                    }
                                }, x => {
                                    p.error(x)
                                })
                            }
                        }
                    });
                    return new Response(g)
                } else throw new wv(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
            }).then(c => {
                switch (l) {
                    case "arraybuffer":
                        return c.arrayBuffer();
                    case "blob":
                        return c.blob();
                    case "document":
                        return c.text().then(f => new DOMParser().parseFromString(f, o));
                    case "json":
                        return c.json();
                    default:
                        if (o === "") return c.text(); {
                            const h = /charset="?([^;"\s]*)"?/i.exec(o),
                                d = h && h[1] ? h[1].toLowerCase() : void 0,
                                u = new TextDecoder(d);
                            return c.arrayBuffer().then(_ => u.decode(_))
                        }
                }
            }).then(c => {
                Xr.add(e, c);
                const f = gr[e];
                delete gr[e];
                for (let h = 0, d = f.length; h < d; h++) {
                    const u = f[h];
                    u.onLoad && u.onLoad(c)
                }
            }).catch(c => {
                const f = gr[e];
                if (f === void 0) throw this.manager.itemError(e), c;
                delete gr[e];
                for (let h = 0, d = f.length; h < d; h++) {
                    const u = f[h];
                    u.onError && u.onError(c)
                }
                this.manager.itemError(e)
            }).finally(() => {
                this.manager.itemEnd(e)
            }), this.manager.itemStart(e)
        }
        setResponseType(e) {
            return this.responseType = e, this
        }
        setMimeType(e) {
            return this.mimeType = e, this
        }
    }
    class Cv extends Ts {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = this,
                a = Xr.get(e);
            if (a !== void 0) return s.manager.itemStart(e), setTimeout(function() {
                t && t(a), s.manager.itemEnd(e)
            }, 0), a;
            const o = To("img");

            function l() {
                f(), Xr.add(e, this), t && t(this), s.manager.itemEnd(e)
            }

            function c(h) {
                f(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e)
            }

            function f() {
                o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1)
            }
            return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o
        }
    }
    let wm = class extends Ts {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const s = new tn,
                a = new Cv(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
                s.image = o, s.needsUpdate = !0, t !== void 0 && t(s)
            }, n, i), s
        }
    };
    class Ff extends zt {
        constructor(e, t = 1) {
            super(), this.isLight = !0, this.type = "Light", this.color = new it(e), this.intensity = t
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t
        }
    }
    const Lf = new st,
        Cm = new Y,
        Rm = new Y;
    class If {
        constructor(e) {
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new pt(512, 512), this.mapType = 1009, this.map = null, this.mapPass = null, this.matrix = new st, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Af, this._frameExtents = new pt(1, 1), this._viewportCount = 1, this._viewports = [new Tt(0, 0, 1, 1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            const t = this.camera,
                n = this.matrix;
            Cm.setFromMatrixPosition(e.matrixWorld), t.position.copy(Cm), Rm.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Rm), t.updateMatrixWorld(), Lf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Lf), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Lf)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        toJSON() {
            const e = {};
            return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }
    class Rv extends If {
        constructor() {
            super(new Fn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1
        }
        updateMatrices(e) {
            const t = this.camera,
                n = oa * 2 * e.angle * this.focus,
                i = this.mapSize.width / this.mapSize.height * this.aspect,
                s = e.distance || t.far;
            (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this
        }
    }
    class Pv extends Ff {
        constructor(e, t, n = 0, i = Math.PI / 3, s = 0, a = 2) {
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(zt.DEFAULT_UP), this.updateMatrix(), this.target = new zt, this.distance = n, this.angle = i, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new Rv
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(e) {
            this.intensity = e / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    const Pm = new st,
        No = new Y,
        Nf = new Y;
    class Fv extends If {
        constructor() {
            super(new Fn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new pt(4, 2), this._viewportCount = 6, this._viewports = [new Tt(2, 1, 1, 1), new Tt(0, 1, 1, 1), new Tt(3, 1, 1, 1), new Tt(1, 1, 1, 1), new Tt(3, 0, 1, 1), new Tt(1, 0, 1, 1)], this._cubeDirections = [new Y(1, 0, 0), new Y(-1, 0, 0), new Y(0, 0, 1), new Y(0, 0, -1), new Y(0, 1, 0), new Y(0, -1, 0)], this._cubeUps = [new Y(0, 1, 0), new Y(0, 1, 0), new Y(0, 1, 0), new Y(0, 1, 0), new Y(0, 0, 1), new Y(0, 0, -1)]
        }
        updateMatrices(e, t = 0) {
            const n = this.camera,
                i = this.matrix,
                s = e.distance || n.far;
            s !== n.far && (n.far = s, n.updateProjectionMatrix()), No.setFromMatrixPosition(e.matrixWorld), n.position.copy(No), Nf.copy(n.position), Nf.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Nf), n.updateMatrixWorld(), i.makeTranslation(-No.x, -No.y, -No.z), Pm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Pm)
        }
    }
    class Lv extends Ff {
        constructor(e, t, n = 0, i = 2) {
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Fv
        }
        get power() {
            return this.intensity * 4 * Math.PI
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }
    class Of extends tm {
        constructor(e = -1, t = 1, n = 1, i = -1, s = .1, a = 2e3) {
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = a, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
        }
        setViewOffset(e, t, n, i, s, a) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let s = n - e,
                a = n + e,
                o = i + t,
                l = i - t;
            if (this.view !== null && this.view.enabled) {
                const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                s += c * this.view.offsetX, a = s + c * this.view.width, o -= f * this.view.offsetY, l = o - f * this.view.height
            }
            this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
        }
    }
    class Iv extends If {
        constructor() {
            super(new Of(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
        }
    }
    class Nv extends Ff {
        constructor(e, t) {
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(zt.DEFAULT_UP), this.updateMatrix(), this.target = new zt, this.shadow = new Iv
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    class Oo {
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1)
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }
    const Uf = new WeakMap;
    class Ov extends Ts {
        constructor(e) {
            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(e) {
            return this.options = e, this
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = this,
                a = Xr.get(e);
            if (a !== void 0) {
                if (s.manager.itemStart(e), a.then) {
                    a.then(c => {
                        if (Uf.has(a) === !0) i && i(Uf.get(a)), s.manager.itemError(e), s.manager.itemEnd(e);
                        else return t && t(c), s.manager.itemEnd(e), c
                    });
                    return
                }
                return setTimeout(function() {
                    t && t(a), s.manager.itemEnd(e)
                }, 0), a
            }
            const o = {};
            o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
            const l = fetch(e, o).then(function(c) {
                return c.blob()
            }).then(function(c) {
                return createImageBitmap(c, Object.assign(s.options, {
                    colorSpaceConversion: "none"
                }))
            }).then(function(c) {
                return Xr.add(e, c), t && t(c), s.manager.itemEnd(e), c
            }).catch(function(c) {
                i && i(c), Uf.set(l, c), Xr.remove(e), s.manager.itemError(e), s.manager.itemEnd(e)
            });
            Xr.add(e, l), s.manager.itemStart(e)
        }
    }
    class Uv extends Fn {
        constructor(e = []) {
            super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e
        }
    }
    const Bf = "\\[\\]\\.:\\/",
        Bv = new RegExp("[" + Bf + "]", "g"),
        kf = "[^" + Bf + "]",
        kv = "[^" + Bf.replace("\\.", "") + "]",
        zv = /((?:WC+[\/:])*)/.source.replace("WC", kf),
        Gv = /(WCOD+)?/.source.replace("WCOD", kv),
        Hv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kf),
        Vv = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kf),
        Wv = new RegExp("^" + zv + Gv + Hv + Vv + "$"),
        Xv = ["material", "materials", "bones", "map"];
    class jv {
        constructor(e, t, n) {
            const i = n || wt.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            i !== void 0 && i.getValue(e, t)
        }
        setValue(e, t) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t)
        }
        bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        }
        unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }
    class wt {
        constructor(e, t, n) {
            this.path = t, this.parsedPath = n || wt.parseTrackName(t), this.node = wt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new wt.Composite(e, t, n) : new wt(e, t, n)
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(Bv, "")
        }
        static parseTrackName(e) {
            const t = Wv.exec(e);
            if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (i !== void 0 && i !== -1) {
                const s = n.nodeName.substring(i + 1);
                Xv.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n
            }
            if (e.children) {
                const n = function(s) {
                        for (let a = 0; a < s.length; a++) {
                            const o = s[a];
                            if (o.name === t || o.uuid === t) return o;
                            const l = n(o.children);
                            if (l) return l
                        }
                        return null
                    },
                    i = n(e.children);
                if (i) return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i]
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++]
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t)
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t)
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath,
                n = t.objectName,
                i = t.propertyName;
            let s = t.propertyIndex;
            if (e || (e = wt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return
            }
            if (n) {
                let c = t.objectIndex;
                switch (n) {
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return
                        }
                        e = e.skeleton.bones;
                        for (let f = 0; f < e.length; f++)
                            if (e[f].name === c) {
                                c = f;
                                break
                            }
                        break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return
                        }
                        e = e[n]
                }
                if (c !== void 0) {
                    if (e[c] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return
                    }
                    e = e[c]
                }
            }
            const a = e[i];
            if (a === void 0) {
                const c = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
                return
            }
            let o = this.Versioning.None;
            this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let l = this.BindingType.Direct;
            if (s !== void 0) {
                if (i === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return
                    }
                    e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
                }
                l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s
            } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o]
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }
    wt.Composite = jv, wt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, wt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, wt.prototype.GetterByBindingType = [wt.prototype._getValue_direct, wt.prototype._getValue_array, wt.prototype._getValue_arrayElement, wt.prototype._getValue_toArray], wt.prototype.SetterByBindingTypeAndVersioning = [
        [wt.prototype._setValue_direct, wt.prototype._setValue_direct_setNeedsUpdate, wt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [wt.prototype._setValue_array, wt.prototype._setValue_array_setNeedsUpdate, wt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [wt.prototype._setValue_arrayElement, wt.prototype._setValue_arrayElement_setNeedsUpdate, wt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
        [wt.prototype._setValue_fromArray, wt.prototype._setValue_fromArray_setNeedsUpdate, wt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ];
    const Fm = new st;
    class qv {
        constructor(e, t, n = 0, i = 1 / 0) {
            this.ray = new Ao(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new lf, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(e, t) {
            this.ray.set(e, t)
        }
        setFromCamera(e, t) {
            t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        }
        setFromXRController(e) {
            return Fm.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Fm), this
        }
        intersectObject(e, t = !0, n = []) {
            return zf(e, this, n, t), n.sort(Lm), n
        }
        intersectObjects(e, t = !0, n = []) {
            for (let i = 0, s = e.length; i < s; i++) zf(e[i], this, n, t);
            return n.sort(Lm), n
        }
    }

    function Lm(r, e) {
        return r.distance - e.distance
    }

    function zf(r, e, t, n) {
        let i = !0;
        if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
            const s = r.children;
            for (let a = 0, o = s.length; a < o; a++) zf(s[a], e, t, !0)
        }
    }

    function Im(r, e, t, n) {
        const i = Yv(n);
        switch (t) {
            case 1021:
                return r * e;
            case 1028:
                return r * e / i.components * i.byteLength;
            case 1029:
                return r * e / i.components * i.byteLength;
            case 1030:
                return r * e * 2 / i.components * i.byteLength;
            case 1031:
                return r * e * 2 / i.components * i.byteLength;
            case 1022:
                return r * e * 3 / i.components * i.byteLength;
            case 1023:
                return r * e * 4 / i.components * i.byteLength;
            case 1033:
                return r * e * 4 / i.components * i.byteLength;
            case 33776:
            case 33777:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case 33778:
            case 33779:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 35841:
            case 35843:
                return Math.max(r, 16) * Math.max(e, 8) / 4;
            case 35840:
            case 35842:
                return Math.max(r, 8) * Math.max(e, 8) / 2;
            case 36196:
            case 37492:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case 37496:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 37808:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 37809:
                return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
            case 37810:
                return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
            case 37811:
                return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
            case 37812:
                return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
            case 37813:
                return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
            case 37814:
                return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
            case 37815:
                return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
            case 37816:
                return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
            case 37817:
                return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
            case 37818:
                return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
            case 37819:
                return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
            case 37820:
                return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
            case 37821:
                return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
            case 36492:
            case 36494:
            case 36495:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
            case 36283:
            case 36284:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
            case 36285:
            case 36286:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`)
    }

    function Yv(r) {
        switch (r) {
            case 1009:
            case 1010:
                return {
                    byteLength: 1,
                    components: 1
                };
            case 1012:
            case 1011:
            case 1016:
                return {
                    byteLength: 2,
                    components: 1
                };
            case 1017:
            case 1018:
                return {
                    byteLength: 2,
                    components: 4
                };
            case 1014:
            case 1013:
            case 1015:
                return {
                    byteLength: 4,
                    components: 1
                };
            case 35902:
                return {
                    byteLength: 4,
                    components: 3
                }
        }
        throw new Error(`Unknown texture type ${r}.`)
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: Ku
        }
    })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ku);
    /**
     * @license
     * Copyright 2010-2025 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    function Nm() {
        let r = null,
            e = !1,
            t = null,
            n = null;

        function i(s, a) {
            t(s, a), n = r.requestAnimationFrame(i)
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0)
            },
            stop: function() {
                r.cancelAnimationFrame(n), e = !1
            },
            setAnimationLoop: function(s) {
                t = s
            },
            setContext: function(s) {
                r = s
            }
        }
    }

    function Kv(r) {
        const e = new WeakMap;

        function t(o, l) {
            const c = o.array,
                f = o.usage,
                h = c.byteLength,
                d = r.createBuffer();
            r.bindBuffer(l, d), r.bufferData(l, c, f), o.onUploadCallback();
            let u;
            if (c instanceof Float32Array) u = r.FLOAT;
            else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? u = r.HALF_FLOAT : u = r.UNSIGNED_SHORT;
            else if (c instanceof Int16Array) u = r.SHORT;
            else if (c instanceof Uint32Array) u = r.UNSIGNED_INT;
            else if (c instanceof Int32Array) u = r.INT;
            else if (c instanceof Int8Array) u = r.BYTE;
            else if (c instanceof Uint8Array) u = r.UNSIGNED_BYTE;
            else if (c instanceof Uint8ClampedArray) u = r.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
            return {
                buffer: d,
                type: u,
                bytesPerElement: c.BYTES_PER_ELEMENT,
                version: o.version,
                size: h
            }
        }

        function n(o, l, c) {
            const f = l.array,
                h = l.updateRanges;
            if (r.bindBuffer(c, o), h.length === 0) r.bufferSubData(c, 0, f);
            else {
                h.sort((u, _) => u.start - _.start);
                let d = 0;
                for (let u = 1; u < h.length; u++) {
                    const _ = h[d],
                        m = h[u];
                    m.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, m.start + m.count - _.start) : (++d, h[d] = m)
                }
                h.length = d + 1;
                for (let u = 0, _ = h.length; u < _; u++) {
                    const m = h[u];
                    r.bufferSubData(c, m.start * f.BYTES_PER_ELEMENT, f, m.start, m.count)
                }
                l.clearUpdateRanges()
            }
            l.onUploadCallback()
        }

        function i(o) {
            return o.isInterleavedBufferAttribute && (o = o.data), e.get(o)
        }

        function s(o) {
            o.isInterleavedBufferAttribute && (o = o.data);
            const l = e.get(o);
            l && (r.deleteBuffer(l.buffer), e.delete(o))
        }

        function a(o, l) {
            if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
                const f = e.get(o);
                (!f || f.version < o.version) && e.set(o, {
                    buffer: o.buffer,
                    type: o.type,
                    bytesPerElement: o.elementSize,
                    version: o.version
                });
                return
            }
            const c = e.get(o);
            if (c === void 0) e.set(o, t(o, l));
            else if (c.version < o.version) {
                if (c.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(c.buffer, o, l), c.version = o.version
            }
        }
        return {
            get: i,
            remove: s,
            update: a
        }
    }
    var $v = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
        Jv = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
        Zv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
        Qv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        ey = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
        ty = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        ny = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        iy = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        ry = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
        sy = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
        ay = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
        oy = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        ly = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
        cy = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
        uy = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        fy = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
        hy = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        dy = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        py = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        my = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        gy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        _y = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
        by = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
        xy = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
        vy = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        yy = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Sy = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        My = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
        Ty = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Ey = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        Dy = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        Ay = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        wy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Cy = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        Ry = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        Py = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Fy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        Ly = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        Iy = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        Ny = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        Oy = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        Uy = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
        By = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        ky = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
        zy = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
        Gy = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        Hy = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
        Vy = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        Wy = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
        Xy = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        jy = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
        qy = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
        Yy = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        Ky = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        $y = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        Jy = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
        Zy = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        Qy = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        eS = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        tS = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
        nS = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        iS = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        rS = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        sS = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        aS = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        oS = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        lS = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
        cS = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        uS = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        fS = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
        hS = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        dS = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
        pS = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        mS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        gS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        _S = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        bS = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
        xS = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
        vS = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
        yS = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
        SS = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
        MS = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        TS = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
        ES = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        DS = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        AS = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        wS = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        CS = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        RS = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        PS = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
        FS = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        LS = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
        IS = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        NS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        OS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
        US = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        BS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        kS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        zS = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        GS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        HS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        VS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
        WS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
        XS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        jS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        qS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
        YS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const at = {
            alphahash_fragment: $v,
            alphahash_pars_fragment: Jv,
            alphamap_fragment: Zv,
            alphamap_pars_fragment: Qv,
            alphatest_fragment: ey,
            alphatest_pars_fragment: ty,
            aomap_fragment: ny,
            aomap_pars_fragment: iy,
            batching_pars_vertex: ry,
            batching_vertex: sy,
            begin_vertex: ay,
            beginnormal_vertex: oy,
            bsdfs: ly,
            iridescence_fragment: cy,
            bumpmap_pars_fragment: uy,
            clipping_planes_fragment: fy,
            clipping_planes_pars_fragment: hy,
            clipping_planes_pars_vertex: dy,
            clipping_planes_vertex: py,
            color_fragment: my,
            color_pars_fragment: gy,
            color_pars_vertex: _y,
            color_vertex: by,
            common: xy,
            cube_uv_reflection_fragment: vy,
            defaultnormal_vertex: yy,
            displacementmap_pars_vertex: Sy,
            displacementmap_vertex: My,
            emissivemap_fragment: Ty,
            emissivemap_pars_fragment: Ey,
            colorspace_fragment: Dy,
            colorspace_pars_fragment: Ay,
            envmap_fragment: wy,
            envmap_common_pars_fragment: Cy,
            envmap_pars_fragment: Ry,
            envmap_pars_vertex: Py,
            envmap_physical_pars_fragment: Hy,
            envmap_vertex: Fy,
            fog_vertex: Ly,
            fog_pars_vertex: Iy,
            fog_fragment: Ny,
            fog_pars_fragment: Oy,
            gradientmap_pars_fragment: Uy,
            lightmap_pars_fragment: By,
            lights_lambert_fragment: ky,
            lights_lambert_pars_fragment: zy,
            lights_pars_begin: Gy,
            lights_toon_fragment: Vy,
            lights_toon_pars_fragment: Wy,
            lights_phong_fragment: Xy,
            lights_phong_pars_fragment: jy,
            lights_physical_fragment: qy,
            lights_physical_pars_fragment: Yy,
            lights_fragment_begin: Ky,
            lights_fragment_maps: $y,
            lights_fragment_end: Jy,
            logdepthbuf_fragment: Zy,
            logdepthbuf_pars_fragment: Qy,
            logdepthbuf_pars_vertex: eS,
            logdepthbuf_vertex: tS,
            map_fragment: nS,
            map_pars_fragment: iS,
            map_particle_fragment: rS,
            map_particle_pars_fragment: sS,
            metalnessmap_fragment: aS,
            metalnessmap_pars_fragment: oS,
            morphinstance_vertex: lS,
            morphcolor_vertex: cS,
            morphnormal_vertex: uS,
            morphtarget_pars_vertex: fS,
            morphtarget_vertex: hS,
            normal_fragment_begin: dS,
            normal_fragment_maps: pS,
            normal_pars_fragment: mS,
            normal_pars_vertex: gS,
            normal_vertex: _S,
            normalmap_pars_fragment: bS,
            clearcoat_normal_fragment_begin: xS,
            clearcoat_normal_fragment_maps: vS,
            clearcoat_pars_fragment: yS,
            iridescence_pars_fragment: SS,
            opaque_fragment: MS,
            packing: TS,
            premultiplied_alpha_fragment: ES,
            project_vertex: DS,
            dithering_fragment: AS,
            dithering_pars_fragment: wS,
            roughnessmap_fragment: CS,
            roughnessmap_pars_fragment: RS,
            shadowmap_pars_fragment: PS,
            shadowmap_pars_vertex: FS,
            shadowmap_vertex: LS,
            shadowmask_pars_fragment: IS,
            skinbase_vertex: NS,
            skinning_pars_vertex: OS,
            skinning_vertex: US,
            skinnormal_vertex: BS,
            specularmap_fragment: kS,
            specularmap_pars_fragment: zS,
            tonemapping_fragment: GS,
            tonemapping_pars_fragment: HS,
            transmission_fragment: VS,
            transmission_pars_fragment: WS,
            uv_pars_fragment: XS,
            uv_pars_vertex: jS,
            uv_vertex: qS,
            worldpos_vertex: YS,
            background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
            background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
            depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
            distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
            distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
            equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
            equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
            meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
            meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
            meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
            meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
            meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
            points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
            sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
        },
        Re = {
            common: {
                diffuse: {
                    value: new it(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new ot
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ot
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new ot
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new ot
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new ot
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new ot
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new ot
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new ot
                },
                normalScale: {
                    value: new pt(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new ot
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new ot
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new ot
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new ot
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new it(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new it(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ot
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new ot
                }
            },
            sprite: {
                diffuse: {
                    value: new it(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new pt(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new ot
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ot
                },
                alphaTest: {
                    value: 0
                }
            }
        },
        Yi = {
            basic: {
                uniforms: Pn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]),
                vertexShader: at.meshbasic_vert,
                fragmentShader: at.meshbasic_frag
            },
            lambert: {
                uniforms: Pn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new it(0)
                    }
                }]),
                vertexShader: at.meshlambert_vert,
                fragmentShader: at.meshlambert_frag
            },
            phong: {
                uniforms: Pn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new it(0)
                    },
                    specular: {
                        value: new it(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: at.meshphong_vert,
                fragmentShader: at.meshphong_frag
            },
            standard: {
                uniforms: Pn([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new it(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: at.meshphysical_vert,
                fragmentShader: at.meshphysical_frag
            },
            toon: {
                uniforms: Pn([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new it(0)
                    }
                }]),
                vertexShader: at.meshtoon_vert,
                fragmentShader: at.meshtoon_frag
            },
            matcap: {
                uniforms: Pn([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: at.meshmatcap_vert,
                fragmentShader: at.meshmatcap_frag
            },
            points: {
                uniforms: Pn([Re.points, Re.fog]),
                vertexShader: at.points_vert,
                fragmentShader: at.points_frag
            },
            dashed: {
                uniforms: Pn([Re.common, Re.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: at.linedashed_vert,
                fragmentShader: at.linedashed_frag
            },
            depth: {
                uniforms: Pn([Re.common, Re.displacementmap]),
                vertexShader: at.depth_vert,
                fragmentShader: at.depth_frag
            },
            normal: {
                uniforms: Pn([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: at.meshnormal_vert,
                fragmentShader: at.meshnormal_frag
            },
            sprite: {
                uniforms: Pn([Re.sprite, Re.fog]),
                vertexShader: at.sprite_vert,
                fragmentShader: at.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new ot
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: at.background_vert,
                fragmentShader: at.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new ot
                    }
                },
                vertexShader: at.backgroundCube_vert,
                fragmentShader: at.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: at.cube_vert,
                fragmentShader: at.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: at.equirect_vert,
                fragmentShader: at.equirect_frag
            },
            distanceRGBA: {
                uniforms: Pn([Re.common, Re.displacementmap, {
                    referencePosition: {
                        value: new Y
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: at.distanceRGBA_vert,
                fragmentShader: at.distanceRGBA_frag
            },
            shadow: {
                uniforms: Pn([Re.lights, Re.fog, {
                    color: {
                        value: new it(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: at.shadow_vert,
                fragmentShader: at.shadow_frag
            }
        };
    Yi.physical = {
        uniforms: Pn([Yi.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatMapTransform: {
                value: new ot
            },
            clearcoatNormalMap: {
                value: null
            },
            clearcoatNormalMapTransform: {
                value: new ot
            },
            clearcoatNormalScale: {
                value: new pt(1, 1)
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatRoughnessMapTransform: {
                value: new ot
            },
            dispersion: {
                value: 0
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceMapTransform: {
                value: new ot
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            iridescenceThicknessMapTransform: {
                value: new ot
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new it(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenColorMapTransform: {
                value: new ot
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            sheenRoughnessMapTransform: {
                value: new ot
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionMapTransform: {
                value: new ot
            },
            transmissionSamplerSize: {
                value: new pt
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            thicknessMapTransform: {
                value: new ot
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new it(0)
            },
            specularColor: {
                value: new it(1, 1, 1)
            },
            specularColorMap: {
                value: null
            },
            specularColorMapTransform: {
                value: new ot
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularIntensityMapTransform: {
                value: new ot
            },
            anisotropyVector: {
                value: new pt
            },
            anisotropyMap: {
                value: null
            },
            anisotropyMapTransform: {
                value: new ot
            }
        }]),
        vertexShader: at.meshphysical_vert,
        fragmentShader: at.meshphysical_frag
    };
    const Ec = {
            r: 0,
            b: 0,
            g: 0
        },
        Es = new ji,
        KS = new st;

    function $S(r, e, t, n, i, s, a) {
        const o = new it(0);
        let l = s === !0 ? 0 : 1,
            c, f, h = null,
            d = 0,
            u = null;

        function _(x) {
            let b = x.isScene === !0 ? x.background : null;
            return b && b.isTexture && (b = (x.backgroundBlurriness > 0 ? t : e).get(b)), b
        }

        function m(x) {
            let b = !1;
            const M = _(x);
            M === null ? p(o, l) : M && M.isColor && (p(M, 1), b = !0);
            const D = r.xr.getEnvironmentBlendMode();
            D === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : D === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (r.autoClear || b) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
        }

        function g(x, b) {
            const M = _(b);
            M && (M.isCubeTexture || M.mapping === 306) ? (f === void 0 && (f = new ei(new Ro(1, 1, 1), new Hr({
                name: "BackgroundCubeMaterial",
                uniforms: va(Yi.backgroundCube.uniforms),
                vertexShader: Yi.backgroundCube.vertexShader,
                fragmentShader: Yi.backgroundCube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(D, T, w) {
                this.matrixWorld.copyPosition(w.matrixWorld)
            }, Object.defineProperty(f.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }), i.update(f)), Es.copy(b.backgroundRotation), Es.x *= -1, Es.y *= -1, Es.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (Es.y *= -1, Es.z *= -1), f.material.uniforms.envMap.value = M, f.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(KS.makeRotationFromEuler(Es)), f.material.toneMapped = xt.getTransfer(M.colorSpace) !== Rt, (h !== M || d !== M.version || u !== r.toneMapping) && (f.material.needsUpdate = !0, h = M, d = M.version, u = r.toneMapping), f.layers.enableAll(), x.unshift(f, f.geometry, f.material, 0, 0, null)) : M && M.isTexture && (c === void 0 && (c = new ei(new Sc(2, 2), new Hr({
                name: "BackgroundMaterial",
                uniforms: va(Yi.background.uniforms),
                vertexShader: Yi.background.vertexShader,
                fragmentShader: Yi.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }), i.update(c)), c.material.uniforms.t2D.value = M, c.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, c.material.toneMapped = xt.getTransfer(M.colorSpace) !== Rt, M.matrixAutoUpdate === !0 && M.updateMatrix(), c.material.uniforms.uvTransform.value.copy(M.matrix), (h !== M || d !== M.version || u !== r.toneMapping) && (c.material.needsUpdate = !0, h = M, d = M.version, u = r.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null))
        }

        function p(x, b) {
            x.getRGB(Ec, em(r)), n.buffers.color.setClear(Ec.r, Ec.g, Ec.b, b, a)
        }

        function v() {
            f !== void 0 && (f.geometry.dispose(), f.material.dispose(), f = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0)
        }
        return {
            getClearColor: function() {
                return o
            },
            setClearColor: function(x, b = 1) {
                o.set(x), l = b, p(o, l)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(x) {
                l = x, p(o, l)
            },
            render: m,
            addToRenderList: g,
            dispose: v
        }
    }

    function JS(r, e) {
        const t = r.getParameter(r.MAX_VERTEX_ATTRIBS),
            n = {},
            i = d(null);
        let s = i,
            a = !1;

        function o(y, C, O, N, V) {
            let G = !1;
            const B = h(N, O, C);
            s !== B && (s = B, c(s.object)), G = u(y, N, O, V), G && _(y, N, O, V), V !== null && e.update(V, r.ELEMENT_ARRAY_BUFFER), (G || a) && (a = !1, b(y, C, O, N), V !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(V).buffer))
        }

        function l() {
            return r.createVertexArray()
        }

        function c(y) {
            return r.bindVertexArray(y)
        }

        function f(y) {
            return r.deleteVertexArray(y)
        }

        function h(y, C, O) {
            const N = O.wireframe === !0;
            let V = n[y.id];
            V === void 0 && (V = {}, n[y.id] = V);
            let G = V[C.id];
            G === void 0 && (G = {}, V[C.id] = G);
            let B = G[N];
            return B === void 0 && (B = d(l()), G[N] = B), B
        }

        function d(y) {
            const C = [],
                O = [],
                N = [];
            for (let V = 0; V < t; V++) C[V] = 0, O[V] = 0, N[V] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: C,
                enabledAttributes: O,
                attributeDivisors: N,
                object: y,
                attributes: {},
                index: null
            }
        }

        function u(y, C, O, N) {
            const V = s.attributes,
                G = C.attributes;
            let B = 0;
            const j = O.getAttributes();
            for (const H in j)
                if (j[H].location >= 0) {
                    const F = V[H];
                    let se = G[H];
                    if (se === void 0 && (H === "instanceMatrix" && y.instanceMatrix && (se = y.instanceMatrix), H === "instanceColor" && y.instanceColor && (se = y.instanceColor)), F === void 0 || F.attribute !== se || se && F.data !== se.data) return !0;
                    B++
                }
            return s.attributesNum !== B || s.index !== N
        }

        function _(y, C, O, N) {
            const V = {},
                G = C.attributes;
            let B = 0;
            const j = O.getAttributes();
            for (const H in j)
                if (j[H].location >= 0) {
                    let F = G[H];
                    F === void 0 && (H === "instanceMatrix" && y.instanceMatrix && (F = y.instanceMatrix), H === "instanceColor" && y.instanceColor && (F = y.instanceColor));
                    const se = {};
                    se.attribute = F, F && F.data && (se.data = F.data), V[H] = se, B++
                }
            s.attributes = V, s.attributesNum = B, s.index = N
        }

        function m() {
            const y = s.newAttributes;
            for (let C = 0, O = y.length; C < O; C++) y[C] = 0
        }

        function g(y) {
            p(y, 0)
        }

        function p(y, C) {
            const O = s.newAttributes,
                N = s.enabledAttributes,
                V = s.attributeDivisors;
            O[y] = 1, N[y] === 0 && (r.enableVertexAttribArray(y), N[y] = 1), V[y] !== C && (r.vertexAttribDivisor(y, C), V[y] = C)
        }

        function v() {
            const y = s.newAttributes,
                C = s.enabledAttributes;
            for (let O = 0, N = C.length; O < N; O++) C[O] !== y[O] && (r.disableVertexAttribArray(O), C[O] = 0)
        }

        function x(y, C, O, N, V, G, B) {
            B === !0 ? r.vertexAttribIPointer(y, C, O, V, G) : r.vertexAttribPointer(y, C, O, N, V, G)
        }

        function b(y, C, O, N) {
            m();
            const V = N.attributes,
                G = O.getAttributes(),
                B = C.defaultAttributeValues;
            for (const j in G) {
                const H = G[j];
                if (H.location >= 0) {
                    let k = V[j];
                    if (k === void 0 && (j === "instanceMatrix" && y.instanceMatrix && (k = y.instanceMatrix), j === "instanceColor" && y.instanceColor && (k = y.instanceColor)), k !== void 0) {
                        const F = k.normalized,
                            se = k.itemSize,
                            de = e.get(k);
                        if (de === void 0) continue;
                        const ke = de.buffer,
                            q = de.type,
                            ee = de.bytesPerElement,
                            he = q === r.INT || q === r.UNSIGNED_INT || k.gpuType === 1013;
                        if (k.isInterleavedBufferAttribute) {
                            const fe = k.data,
                                be = fe.stride,
                                Ye = k.offset;
                            if (fe.isInstancedInterleavedBuffer) {
                                for (let Pe = 0; Pe < H.locationSize; Pe++) p(H.location + Pe, fe.meshPerAttribute);
                                y.isInstancedMesh !== !0 && N._maxInstanceCount === void 0 && (N._maxInstanceCount = fe.meshPerAttribute * fe.count)
                            } else
                                for (let Pe = 0; Pe < H.locationSize; Pe++) g(H.location + Pe);
                            r.bindBuffer(r.ARRAY_BUFFER, ke);
                            for (let Pe = 0; Pe < H.locationSize; Pe++) x(H.location + Pe, se / H.locationSize, q, F, be * ee, (Ye + se / H.locationSize * Pe) * ee, he)
                        } else {
                            if (k.isInstancedBufferAttribute) {
                                for (let fe = 0; fe < H.locationSize; fe++) p(H.location + fe, k.meshPerAttribute);
                                y.isInstancedMesh !== !0 && N._maxInstanceCount === void 0 && (N._maxInstanceCount = k.meshPerAttribute * k.count)
                            } else
                                for (let fe = 0; fe < H.locationSize; fe++) g(H.location + fe);
                            r.bindBuffer(r.ARRAY_BUFFER, ke);
                            for (let fe = 0; fe < H.locationSize; fe++) x(H.location + fe, se / H.locationSize, q, F, se * ee, se / H.locationSize * fe * ee, he)
                        }
                    } else if (B !== void 0) {
                        const F = B[j];
                        if (F !== void 0) switch (F.length) {
                            case 2:
                                r.vertexAttrib2fv(H.location, F);
                                break;
                            case 3:
                                r.vertexAttrib3fv(H.location, F);
                                break;
                            case 4:
                                r.vertexAttrib4fv(H.location, F);
                                break;
                            default:
                                r.vertexAttrib1fv(H.location, F)
                        }
                    }
                }
            }
            v()
        }

        function M() {
            w();
            for (const y in n) {
                const C = n[y];
                for (const O in C) {
                    const N = C[O];
                    for (const V in N) f(N[V].object), delete N[V];
                    delete C[O]
                }
                delete n[y]
            }
        }

        function D(y) {
            if (n[y.id] === void 0) return;
            const C = n[y.id];
            for (const O in C) {
                const N = C[O];
                for (const V in N) f(N[V].object), delete N[V];
                delete C[O]
            }
            delete n[y.id]
        }

        function T(y) {
            for (const C in n) {
                const O = n[C];
                if (O[y.id] === void 0) continue;
                const N = O[y.id];
                for (const V in N) f(N[V].object), delete N[V];
                delete O[y.id]
            }
        }

        function w() {
            S(), a = !0, s !== i && (s = i, c(s.object))
        }

        function S() {
            i.geometry = null, i.program = null, i.wireframe = !1
        }
        return {
            setup: o,
            reset: w,
            resetDefaultState: S,
            dispose: M,
            releaseStatesOfGeometry: D,
            releaseStatesOfProgram: T,
            initAttributes: m,
            enableAttribute: g,
            disableUnusedAttributes: v
        }
    }

    function ZS(r, e, t) {
        let n;

        function i(c) {
            n = c
        }

        function s(c, f) {
            r.drawArrays(n, c, f), t.update(f, n, 1)
        }

        function a(c, f, h) {
            h !== 0 && (r.drawArraysInstanced(n, c, f, h), t.update(f, n, h))
        }

        function o(c, f, h) {
            if (h === 0) return;
            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, f, 0, h);
            let u = 0;
            for (let _ = 0; _ < h; _++) u += f[_];
            t.update(u, n, 1)
        }

        function l(c, f, h, d) {
            if (h === 0) return;
            const u = e.get("WEBGL_multi_draw");
            if (u === null)
                for (let _ = 0; _ < c.length; _++) a(c[_], f[_], d[_]);
            else {
                u.multiDrawArraysInstancedWEBGL(n, c, 0, f, 0, d, 0, h);
                let _ = 0;
                for (let m = 0; m < h; m++) _ += f[m] * d[m];
                t.update(_, n, 1)
            }
        }
        this.setMode = i, this.render = s, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l
    }

    function QS(r, e, t, n) {
        let i;

        function s() {
            if (i !== void 0) return i;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                const T = e.get("EXT_texture_filter_anisotropic");
                i = r.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else i = 0;
            return i
        }

        function a(T) {
            return !(T !== 1023 && n.convert(T) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
        }

        function o(T) {
            const w = T === 1016 && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(T !== 1009 && n.convert(T) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && T !== 1015 && !w)
        }

        function l(T) {
            if (T === "highp") {
                if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
                T = "mediump"
            }
            return T === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        let c = t.precision !== void 0 ? t.precision : "highp";
        const f = l(c);
        f !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", f, "instead."), c = f);
        const h = t.logarithmicDepthBuffer === !0,
            d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
            u = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
            _ = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            m = r.getParameter(r.MAX_TEXTURE_SIZE),
            g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = r.getParameter(r.MAX_VERTEX_ATTRIBS),
            v = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
            x = r.getParameter(r.MAX_VARYING_VECTORS),
            b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
            M = _ > 0,
            D = r.getParameter(r.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: s,
            getMaxPrecision: l,
            textureFormatReadable: a,
            textureTypeReadable: o,
            precision: c,
            logarithmicDepthBuffer: h,
            reverseDepthBuffer: d,
            maxTextures: u,
            maxVertexTextures: _,
            maxTextureSize: m,
            maxCubemapSize: g,
            maxAttributes: p,
            maxVertexUniforms: v,
            maxVaryings: x,
            maxFragmentUniforms: b,
            vertexTextures: M,
            maxSamples: D
        }
    }

    function eM(r) {
        const e = this;
        let t = null,
            n = 0,
            i = !1,
            s = !1;
        const a = new Ss,
            o = new ot,
            l = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d) {
            const u = h.length !== 0 || d || n !== 0 || i;
            return i = d, n = h.length, u
        }, this.beginShadows = function() {
            s = !0, f(null)
        }, this.endShadows = function() {
            s = !1
        }, this.setGlobalState = function(h, d) {
            t = f(h, d, 0)
        }, this.setState = function(h, d, u) {
            const _ = h.clippingPlanes,
                m = h.clipIntersection,
                g = h.clipShadows,
                p = r.get(h);
            if (!i || _ === null || _.length === 0 || s && !g) s ? f(null) : c();
            else {
                const v = s ? 0 : n,
                    x = v * 4;
                let b = p.clippingState || null;
                l.value = b, b = f(_, d, x, u);
                for (let M = 0; M !== x; ++M) b[M] = t[M];
                p.clippingState = b, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += v
            }
        };

        function c() {
            l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
        }

        function f(h, d, u, _) {
            const m = h !== null ? h.length : 0;
            let g = null;
            if (m !== 0) {
                if (g = l.value, _ !== !0 || g === null) {
                    const p = u + m * 4,
                        v = d.matrixWorldInverse;
                    o.getNormalMatrix(v), (g === null || g.length < p) && (g = new Float32Array(p));
                    for (let x = 0, b = u; x !== m; ++x, b += 4) a.copy(h[x]).applyMatrix4(v, o), a.normal.toArray(g, b), g[b + 3] = a.constant
                }
                l.value = g, l.needsUpdate = !0
            }
            return e.numPlanes = m, e.numIntersection = 0, g
        }
    }

    function tM(r) {
        let e = new WeakMap;

        function t(a, o) {
            return o === 303 ? a.mapping = 301 : o === 304 && (a.mapping = 302), a
        }

        function n(a) {
            if (a && a.isTexture) {
                const o = a.mapping;
                if (o === 303 || o === 304)
                    if (e.has(a)) {
                        const l = e.get(a).texture;
                        return t(l, a.mapping)
                    } else {
                        const l = a.image;
                        if (l && l.height > 0) {
                            const c = new tv(l.height);
                            return c.fromEquirectangularTexture(r, a), e.set(a, c), a.addEventListener("dispose", i), t(c.texture, a.mapping)
                        } else return null
                    }
            }
            return a
        }

        function i(a) {
            const o = a.target;
            o.removeEventListener("dispose", i);
            const l = e.get(o);
            l !== void 0 && (e.delete(o), l.dispose())
        }

        function s() {
            e = new WeakMap
        }
        return {
            get: n,
            dispose: s
        }
    }
    const Ca = 4,
        Om = [.125, .215, .35, .446, .526, .582],
        Ds = 20,
        Gf = new Of,
        Um = new it;
    let Hf = null,
        Vf = 0,
        Wf = 0,
        Xf = !1;
    const As = (1 + Math.sqrt(5)) / 2,
        Ra = 1 / As,
        Bm = [new Y(-As, Ra, 0), new Y(As, Ra, 0), new Y(-Ra, 0, As), new Y(Ra, 0, As), new Y(0, As, -Ra), new Y(0, As, Ra), new Y(-1, 1, -1), new Y(1, 1, -1), new Y(-1, 1, 1), new Y(1, 1, 1)],
        nM = new Y;
    class km {
        constructor(e) {
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
        }
        fromScene(e, t = 0, n = .1, i = 100, s = {}) {
            const {
                size: a = 256,
                position: o = nM
            } = s;
            Hf = this._renderer.getRenderTarget(), Vf = this._renderer.getActiveCubeFace(), Wf = this._renderer.getActiveMipmapLevel(), Xf = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
            const l = this._allocateTargets();
            return l.depthBuffer = !0, this._sceneToCubeUV(e, n, i, l, o), t > 0 && this._blur(l, 0, 0, t), this._applyPMREM(l), this._cleanup(l), l
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t)
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t)
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = Hm(), this._compileMaterial(this._cubemapMaterial))
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = Gm(), this._compileMaterial(this._equirectMaterial))
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(Hf, Vf, Wf), this._renderer.xr.enabled = Xf, e.scissorTest = !1, Dc(e, 0, 0, e.width, e.height)
        }
        _fromTexture(e, t) {
            e.mapping === 301 || e.mapping === 302 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Hf = this._renderer.getRenderTarget(), Vf = this._renderer.getActiveCubeFace(), Wf = this._renderer.getActiveMipmapLevel(), Xf = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112),
                t = 4 * this._cubeSize,
                n = {
                    magFilter: 1006,
                    minFilter: 1006,
                    generateMipmaps: !1,
                    type: 1016,
                    format: 1023,
                    colorSpace: yn,
                    depthBuffer: !1
                },
                i = zm(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = zm(e, t, n);
                const {
                    _lodMax: s
                } = this;
                ({
                    sizeLods: this._sizeLods,
                    lodPlanes: this._lodPlanes,
                    sigmas: this._sigmas
                } = iM(s)), this._blurMaterial = rM(s, e, t)
            }
            return i
        }
        _compileMaterial(e) {
            const t = new ei(this._lodPlanes[0], e);
            this._renderer.compile(t, Gf)
        }
        _sceneToCubeUV(e, t, n, i, s) {
            const l = new Fn(90, 1, t, n),
                c = [1, -1, 1, 1, 1, 1],
                f = [1, 1, 1, -1, -1, -1],
                h = this._renderer,
                d = h.autoClear,
                u = h.toneMapping;
            h.getClearColor(Um), h.toneMapping = 0, h.autoClear = !1;
            const _ = new Gr({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                m = new ei(new Ro, _);
            let g = !1;
            const p = e.background;
            p ? p.isColor && (_.color.copy(p), e.background = null, g = !0) : (_.color.copy(Um), g = !0);
            for (let v = 0; v < 6; v++) {
                const x = v % 3;
                x === 0 ? (l.up.set(0, c[v], 0), l.position.set(s.x, s.y, s.z), l.lookAt(s.x + f[v], s.y, s.z)) : x === 1 ? (l.up.set(0, 0, c[v]), l.position.set(s.x, s.y, s.z), l.lookAt(s.x, s.y + f[v], s.z)) : (l.up.set(0, c[v], 0), l.position.set(s.x, s.y, s.z), l.lookAt(s.x, s.y, s.z + f[v]));
                const b = this._cubeSize;
                Dc(i, x * b, v > 2 ? b : 0, b, b), h.setRenderTarget(i), g && h.render(m, l), h.render(e, l)
            }
            m.geometry.dispose(), m.material.dispose(), h.toneMapping = u, h.autoClear = d, e.background = p
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer,
                i = e.mapping === 301 || e.mapping === 302;
            i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Hm()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Gm());
            const s = i ? this._cubemapMaterial : this._equirectMaterial,
                a = new ei(this._lodPlanes[0], s),
                o = s.uniforms;
            o.envMap.value = e;
            const l = this._cubeSize;
            Dc(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Gf)
        }
        _applyPMREM(e) {
            const t = this._renderer,
                n = t.autoClear;
            t.autoClear = !1;
            const i = this._lodPlanes.length;
            for (let s = 1; s < i; s++) {
                const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                    o = Bm[(i - s - 1) % Bm.length];
                this._blur(e, s - 1, s, a, o)
            }
            t.autoClear = n
        }
        _blur(e, t, n, i, s) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, i, "latitudinal", s), this._halfBlur(a, e, n, n, i, "longitudinal", s)
        }
        _halfBlur(e, t, n, i, s, a, o) {
            const l = this._renderer,
                c = this._blurMaterial;
            a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const f = 3,
                h = new ei(this._lodPlanes[i], c),
                d = c.uniforms,
                u = this._sizeLods[n] - 1,
                _ = isFinite(s) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Ds - 1),
                m = s / _,
                g = isFinite(s) ? 1 + Math.floor(f * m) : Ds;
            g > Ds && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Ds}`);
            const p = [];
            let v = 0;
            for (let T = 0; T < Ds; ++T) {
                const w = T / m,
                    S = Math.exp(-w * w / 2);
                p.push(S), T === 0 ? v += S : T < g && (v += 2 * S)
            }
            for (let T = 0; T < p.length; T++) p[T] = p[T] / v;
            d.envMap.value = e.texture, d.samples.value = g, d.weights.value = p, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
            const {
                _lodMax: x
            } = this;
            d.dTheta.value = _, d.mipInt.value = x - n;
            const b = this._sizeLods[i],
                M = 3 * b * (i > x - Ca ? i - x + Ca : 0),
                D = 4 * (this._cubeSize - b);
            Dc(t, M, D, 3 * b, 2 * b), l.setRenderTarget(t), l.render(h, Gf)
        }
    }

    function iM(r) {
        const e = [],
            t = [],
            n = [];
        let i = r;
        const s = r - Ca + 1 + Om.length;
        for (let a = 0; a < s; a++) {
            const o = Math.pow(2, i);
            t.push(o);
            let l = 1 / o;
            a > r - Ca ? l = Om[a - r + Ca - 1] : a === 0 && (l = 0), n.push(l);
            const c = 1 / (o - 2),
                f = -c,
                h = 1 + c,
                d = [f, f, h, f, h, h, f, f, h, h, f, h],
                u = 6,
                _ = 6,
                m = 3,
                g = 2,
                p = 1,
                v = new Float32Array(m * _ * u),
                x = new Float32Array(g * _ * u),
                b = new Float32Array(p * _ * u);
            for (let D = 0; D < u; D++) {
                const T = D % 3 * 2 / 3 - 1,
                    w = D > 2 ? 0 : -1,
                    S = [T, w, 0, T + 2 / 3, w, 0, T + 2 / 3, w + 1, 0, T, w, 0, T + 2 / 3, w + 1, 0, T, w + 1, 0];
                v.set(S, m * _ * D), x.set(d, g * _ * D);
                const y = [D, D, D, D, D, D];
                b.set(y, p * _ * D)
            }
            const M = new Pi;
            M.setAttribute("position", new _n(v, m)), M.setAttribute("uv", new _n(x, g)), M.setAttribute("faceIndex", new _n(b, p)), e.push(M), i > Ca && i--
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        }
    }

    function zm(r, e, t) {
        const n = new bs(r, e, t);
        return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
    }

    function Dc(r, e, t, n, i) {
        r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i)
    }

    function rM(r, e, t) {
        const n = new Float32Array(Ds),
            i = new Y(0, 1, 0);
        return new Hr({
            name: "SphericalGaussianBlur",
            defines: {
                n: Ds,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${r}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: i
                }
            },
            vertexShader: jf(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function Gm() {
        return new Hr({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: jf(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function Hm() {
        return new Hr({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: jf(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function jf() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    }

    function sM(r) {
        let e = new WeakMap,
            t = null;

        function n(o) {
            if (o && o.isTexture) {
                const l = o.mapping,
                    c = l === 303 || l === 304,
                    f = l === 301 || l === 302;
                if (c || f) {
                    let h = e.get(o);
                    const d = h !== void 0 ? h.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new km(r)), h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), h.texture;
                    if (h !== void 0) return h.texture; {
                        const u = o.image;
                        return c && u && u.height > 0 || f && u && i(u) ? (t === null && (t = new km(r)), h = c ? t.fromEquirectangular(o) : t.fromCubemap(o), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), o.addEventListener("dispose", s), h.texture) : null
                    }
                }
            }
            return o
        }

        function i(o) {
            let l = 0;
            const c = 6;
            for (let f = 0; f < c; f++) o[f] !== void 0 && l++;
            return l === c
        }

        function s(o) {
            const l = o.target;
            l.removeEventListener("dispose", s);
            const c = e.get(l);
            c !== void 0 && (e.delete(l), c.dispose())
        }

        function a() {
            e = new WeakMap, t !== null && (t.dispose(), t = null)
        }
        return {
            get: n,
            dispose: a
        }
    }

    function aM(r) {
        const e = {};

        function t(n) {
            if (e[n] !== void 0) return e[n];
            let i;
            switch (n) {
                case "WEBGL_depth_texture":
                    i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = r.getExtension(n)
            }
            return e[n] = i, i
        }
        return {
            has: function(n) {
                return t(n) !== null
            },
            init: function() {
                t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent")
            },
            get: function(n) {
                const i = t(n);
                return i === null && la("THREE.WebGLRenderer: " + n + " extension not supported."), i
            }
        }
    }

    function oM(r, e, t, n) {
        const i = {},
            s = new WeakMap;

        function a(h) {
            const d = h.target;
            d.index !== null && e.remove(d.index);
            for (const _ in d.attributes) e.remove(d.attributes[_]);
            d.removeEventListener("dispose", a), delete i[d.id];
            const u = s.get(d);
            u && (e.remove(u), s.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--
        }

        function o(h, d) {
            return i[d.id] === !0 || (d.addEventListener("dispose", a), i[d.id] = !0, t.memory.geometries++), d
        }

        function l(h) {
            const d = h.attributes;
            for (const u in d) e.update(d[u], r.ARRAY_BUFFER)
        }

        function c(h) {
            const d = [],
                u = h.index,
                _ = h.attributes.position;
            let m = 0;
            if (u !== null) {
                const v = u.array;
                m = u.version;
                for (let x = 0, b = v.length; x < b; x += 3) {
                    const M = v[x + 0],
                        D = v[x + 1],
                        T = v[x + 2];
                    d.push(M, D, D, T, T, M)
                }
            } else if (_ !== void 0) {
                const v = _.array;
                m = _.version;
                for (let x = 0, b = v.length / 3 - 1; x < b; x += 3) {
                    const M = x + 0,
                        D = x + 1,
                        T = x + 2;
                    d.push(M, D, D, T, T, M)
                }
            } else return;
            const g = new(Np(d) ? $p : Kp)(d, 1);
            g.version = m;
            const p = s.get(h);
            p && e.remove(p), s.set(h, g)
        }

        function f(h) {
            const d = s.get(h);
            if (d) {
                const u = h.index;
                u !== null && d.version < u.version && c(h)
            } else c(h);
            return s.get(h)
        }
        return {
            get: o,
            update: l,
            getWireframeAttribute: f
        }
    }

    function lM(r, e, t) {
        let n;

        function i(d) {
            n = d
        }
        let s, a;

        function o(d) {
            s = d.type, a = d.bytesPerElement
        }

        function l(d, u) {
            r.drawElements(n, u, s, d * a), t.update(u, n, 1)
        }

        function c(d, u, _) {
            _ !== 0 && (r.drawElementsInstanced(n, u, s, d * a, _), t.update(u, n, _))
        }

        function f(d, u, _) {
            if (_ === 0) return;
            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, u, 0, s, d, 0, _);
            let g = 0;
            for (let p = 0; p < _; p++) g += u[p];
            t.update(g, n, 1)
        }

        function h(d, u, _, m) {
            if (_ === 0) return;
            const g = e.get("WEBGL_multi_draw");
            if (g === null)
                for (let p = 0; p < d.length; p++) c(d[p] / a, u[p], m[p]);
            else {
                g.multiDrawElementsInstancedWEBGL(n, u, 0, s, d, 0, m, 0, _);
                let p = 0;
                for (let v = 0; v < _; v++) p += u[v] * m[v];
                t.update(p, n, 1)
            }
        }
        this.setMode = i, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = f, this.renderMultiDrawInstances = h
    }

    function cM(r) {
        const e = {
                geometries: 0,
                textures: 0
            },
            t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };

        function n(s, a, o) {
            switch (t.calls++, a) {
                case r.TRIANGLES:
                    t.triangles += o * (s / 3);
                    break;
                case r.LINES:
                    t.lines += o * (s / 2);
                    break;
                case r.LINE_STRIP:
                    t.lines += o * (s - 1);
                    break;
                case r.LINE_LOOP:
                    t.lines += o * s;
                    break;
                case r.POINTS:
                    t.points += o * s;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", a);
                    break
            }
        }

        function i() {
            t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: i,
            update: n
        }
    }

    function uM(r, e, t) {
        const n = new WeakMap,
            i = new Tt;

        function s(a, o, l) {
            const c = a.morphTargetInfluences,
                f = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
                h = f !== void 0 ? f.length : 0;
            let d = n.get(o);
            if (d === void 0 || d.count !== h) {
                let S = function() {
                    T.dispose(), n.delete(o), o.removeEventListener("dispose", S)
                };
                d !== void 0 && d.texture.dispose();
                const u = o.morphAttributes.position !== void 0,
                    _ = o.morphAttributes.normal !== void 0,
                    m = o.morphAttributes.color !== void 0,
                    g = o.morphAttributes.position || [],
                    p = o.morphAttributes.normal || [],
                    v = o.morphAttributes.color || [];
                let x = 0;
                u === !0 && (x = 1), _ === !0 && (x = 2), m === !0 && (x = 3);
                let b = o.attributes.position.count * x,
                    M = 1;
                b > e.maxTextureSize && (M = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
                const D = new Float32Array(b * M * 4 * h),
                    T = new kp(D, b, M, h);
                T.type = 1015, T.needsUpdate = !0;
                const w = x * 4;
                for (let y = 0; y < h; y++) {
                    const C = g[y],
                        O = p[y],
                        N = v[y],
                        V = b * M * 4 * y;
                    for (let G = 0; G < C.count; G++) {
                        const B = G * w;
                        u === !0 && (i.fromBufferAttribute(C, G), D[V + B + 0] = i.x, D[V + B + 1] = i.y, D[V + B + 2] = i.z, D[V + B + 3] = 0), _ === !0 && (i.fromBufferAttribute(O, G), D[V + B + 4] = i.x, D[V + B + 5] = i.y, D[V + B + 6] = i.z, D[V + B + 7] = 0), m === !0 && (i.fromBufferAttribute(N, G), D[V + B + 8] = i.x, D[V + B + 9] = i.y, D[V + B + 10] = i.z, D[V + B + 11] = N.itemSize === 4 ? i.w : 1)
                    }
                }
                d = {
                    count: h,
                    texture: T,
                    size: new pt(b, M)
                }, n.set(o, d), o.addEventListener("dispose", S)
            }
            if (a.isInstancedMesh === !0 && a.morphTexture !== null) l.getUniforms().setValue(r, "morphTexture", a.morphTexture, t);
            else {
                let u = 0;
                for (let m = 0; m < c.length; m++) u += c[m];
                const _ = o.morphTargetsRelative ? 1 : 1 - u;
                l.getUniforms().setValue(r, "morphTargetBaseInfluence", _), l.getUniforms().setValue(r, "morphTargetInfluences", c)
            }
            l.getUniforms().setValue(r, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(r, "morphTargetsTextureSize", d.size)
        }
        return {
            update: s
        }
    }

    function fM(r, e, t, n) {
        let i = new WeakMap;

        function s(l) {
            const c = n.render.frame,
                f = l.geometry,
                h = e.get(l, f);
            if (i.get(h) !== c && (e.update(h), i.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), i.get(l) !== c && (t.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
                const d = l.skeleton;
                i.get(d) !== c && (d.update(), i.set(d, c))
            }
            return h
        }

        function a() {
            i = new WeakMap
        }

        function o(l) {
            const c = l.target;
            c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
        }
        return {
            update: s,
            dispose: a
        }
    }
    const Vm = new tn,
        Wm = new Mm(1, 1),
        Xm = new kp,
        jm = new Bx,
        qm = new rm,
        Ym = [],
        Km = [],
        $m = new Float32Array(16),
        Jm = new Float32Array(9),
        Zm = new Float32Array(4);

    function Pa(r, e, t) {
        const n = r[0];
        if (n <= 0 || n > 0) return r;
        const i = e * t;
        let s = Ym[i];
        if (s === void 0 && (s = new Float32Array(i), Ym[i] = s), e !== 0) {
            n.toArray(s, 0);
            for (let a = 1, o = 0; a !== e; ++a) o += t, r[a].toArray(s, o)
        }
        return s
    }

    function nn(r, e) {
        if (r.length !== e.length) return !1;
        for (let t = 0, n = r.length; t < n; t++)
            if (r[t] !== e[t]) return !1;
        return !0
    }

    function rn(r, e) {
        for (let t = 0, n = e.length; t < n; t++) r[t] = e[t]
    }

    function Ac(r, e) {
        let t = Km[e];
        t === void 0 && (t = new Int32Array(e), Km[e] = t);
        for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
        return t
    }

    function hM(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e)
    }

    function dM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (nn(t, e)) return;
            r.uniform2fv(this.addr, e), rn(t, e)
        }
    }

    function pM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
            if (nn(t, e)) return;
            r.uniform3fv(this.addr, e), rn(t, e)
        }
    }

    function mM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (nn(t, e)) return;
            r.uniform4fv(this.addr, e), rn(t, e)
        }
    }

    function gM(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (nn(t, e)) return;
            r.uniformMatrix2fv(this.addr, !1, e), rn(t, e)
        } else {
            if (nn(t, n)) return;
            Zm.set(n), r.uniformMatrix2fv(this.addr, !1, Zm), rn(t, n)
        }
    }

    function _M(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (nn(t, e)) return;
            r.uniformMatrix3fv(this.addr, !1, e), rn(t, e)
        } else {
            if (nn(t, n)) return;
            Jm.set(n), r.uniformMatrix3fv(this.addr, !1, Jm), rn(t, n)
        }
    }

    function bM(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (nn(t, e)) return;
            r.uniformMatrix4fv(this.addr, !1, e), rn(t, e)
        } else {
            if (nn(t, n)) return;
            $m.set(n), r.uniformMatrix4fv(this.addr, !1, $m), rn(t, n)
        }
    }

    function xM(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e)
    }

    function vM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (nn(t, e)) return;
            r.uniform2iv(this.addr, e), rn(t, e)
        }
    }

    function yM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (nn(t, e)) return;
            r.uniform3iv(this.addr, e), rn(t, e)
        }
    }

    function SM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (nn(t, e)) return;
            r.uniform4iv(this.addr, e), rn(t, e)
        }
    }

    function MM(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e)
    }

    function TM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (nn(t, e)) return;
            r.uniform2uiv(this.addr, e), rn(t, e)
        }
    }

    function EM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (nn(t, e)) return;
            r.uniform3uiv(this.addr, e), rn(t, e)
        }
    }

    function DM(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (nn(t, e)) return;
            r.uniform4uiv(this.addr, e), rn(t, e)
        }
    }

    function AM(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
        let s;
        this.type === r.SAMPLER_2D_SHADOW ? (Wm.compareFunction = 515, s = Wm) : s = Vm, t.setTexture2D(e || s, i)
    }

    function wM(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || jm, i)
    }

    function CM(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || qm, i)
    }

    function RM(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || Xm, i)
    }

    function PM(r) {
        switch (r) {
            case 5126:
                return hM;
            case 35664:
                return dM;
            case 35665:
                return pM;
            case 35666:
                return mM;
            case 35674:
                return gM;
            case 35675:
                return _M;
            case 35676:
                return bM;
            case 5124:
            case 35670:
                return xM;
            case 35667:
            case 35671:
                return vM;
            case 35668:
            case 35672:
                return yM;
            case 35669:
            case 35673:
                return SM;
            case 5125:
                return MM;
            case 36294:
                return TM;
            case 36295:
                return EM;
            case 36296:
                return DM;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return AM;
            case 35679:
            case 36299:
            case 36307:
                return wM;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return CM;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return RM
        }
    }

    function FM(r, e) {
        r.uniform1fv(this.addr, e)
    }

    function LM(r, e) {
        const t = Pa(e, this.size, 2);
        r.uniform2fv(this.addr, t)
    }

    function IM(r, e) {
        const t = Pa(e, this.size, 3);
        r.uniform3fv(this.addr, t)
    }

    function NM(r, e) {
        const t = Pa(e, this.size, 4);
        r.uniform4fv(this.addr, t)
    }

    function OM(r, e) {
        const t = Pa(e, this.size, 4);
        r.uniformMatrix2fv(this.addr, !1, t)
    }

    function UM(r, e) {
        const t = Pa(e, this.size, 9);
        r.uniformMatrix3fv(this.addr, !1, t)
    }

    function BM(r, e) {
        const t = Pa(e, this.size, 16);
        r.uniformMatrix4fv(this.addr, !1, t)
    }

    function kM(r, e) {
        r.uniform1iv(this.addr, e)
    }

    function zM(r, e) {
        r.uniform2iv(this.addr, e)
    }

    function GM(r, e) {
        r.uniform3iv(this.addr, e)
    }

    function HM(r, e) {
        r.uniform4iv(this.addr, e)
    }

    function VM(r, e) {
        r.uniform1uiv(this.addr, e)
    }

    function WM(r, e) {
        r.uniform2uiv(this.addr, e)
    }

    function XM(r, e) {
        r.uniform3uiv(this.addr, e)
    }

    function jM(r, e) {
        r.uniform4uiv(this.addr, e)
    }

    function qM(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Ac(t, i);
        nn(n, s) || (r.uniform1iv(this.addr, s), rn(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || Vm, s[a])
    }

    function YM(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Ac(t, i);
        nn(n, s) || (r.uniform1iv(this.addr, s), rn(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || jm, s[a])
    }

    function KM(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Ac(t, i);
        nn(n, s) || (r.uniform1iv(this.addr, s), rn(n, s));
        for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || qm, s[a])
    }

    function $M(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Ac(t, i);
        nn(n, s) || (r.uniform1iv(this.addr, s), rn(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || Xm, s[a])
    }

    function JM(r) {
        switch (r) {
            case 5126:
                return FM;
            case 35664:
                return LM;
            case 35665:
                return IM;
            case 35666:
                return NM;
            case 35674:
                return OM;
            case 35675:
                return UM;
            case 35676:
                return BM;
            case 5124:
            case 35670:
                return kM;
            case 35667:
            case 35671:
                return zM;
            case 35668:
            case 35672:
                return GM;
            case 35669:
            case 35673:
                return HM;
            case 5125:
                return VM;
            case 36294:
                return WM;
            case 36295:
                return XM;
            case 36296:
                return jM;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return qM;
            case 35679:
            case 36299:
            case 36307:
                return YM;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return KM;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return $M
        }
    }
    class ZM {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = PM(t.type)
        }
    }
    class QM {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = JM(t.type)
        }
    }
    class eT {
        constructor(e) {
            this.id = e, this.seq = [], this.map = {}
        }
        setValue(e, t, n) {
            const i = this.seq;
            for (let s = 0, a = i.length; s !== a; ++s) {
                const o = i[s];
                o.setValue(e, t[o.id], n)
            }
        }
    }
    const qf = /(\w+)(\])?(\[|\.)?/g;

    function Qm(r, e) {
        r.seq.push(e), r.map[e.id] = e
    }

    function tT(r, e, t) {
        const n = r.name,
            i = n.length;
        for (qf.lastIndex = 0;;) {
            const s = qf.exec(n),
                a = qf.lastIndex;
            let o = s[1];
            const l = s[2] === "]",
                c = s[3];
            if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === i) {
                Qm(t, c === void 0 ? new ZM(o, r, e) : new QM(o, r, e));
                break
            } else {
                let h = t.map[o];
                h === void 0 && (h = new eT(o), Qm(t, h)), t = h
            }
        }
    }
    class wc {
        constructor(e, t) {
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
                const s = e.getActiveUniform(t, i),
                    a = e.getUniformLocation(t, s.name);
                tT(s, a, this)
            }
        }
        setValue(e, t, n, i) {
            const s = this.map[t];
            s !== void 0 && s.setValue(e, n, i)
        }
        setOptional(e, t, n) {
            const i = t[n];
            i !== void 0 && this.setValue(e, n, i)
        }
        static upload(e, t, n, i) {
            for (let s = 0, a = t.length; s !== a; ++s) {
                const o = t[s],
                    l = n[o.id];
                l.needsUpdate !== !1 && o.setValue(e, l.value, i)
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for (let i = 0, s = e.length; i !== s; ++i) {
                const a = e[i];
                a.id in t && n.push(a)
            }
            return n
        }
    }

    function eg(r, e, t) {
        const n = r.createShader(e);
        return r.shaderSource(n, t), r.compileShader(n), n
    }
    const nT = 37297;
    let iT = 0;

    function rT(r, e) {
        const t = r.split(`
`),
            n = [],
            i = Math.max(e - 6, 0),
            s = Math.min(e + 6, t.length);
        for (let a = i; a < s; a++) {
            const o = a + 1;
            n.push(`${o===e?">":" "} ${o}: ${t[a]}`)
        }
        return n.join(`
`)
    }
    const tg = new ot;

    function sT(r) {
        xt._getMatrix(tg, xt.workingColorSpace, r);
        const e = `mat3( ${tg.elements.map(t=>t.toFixed(4))} )`;
        switch (xt.getTransfer(r)) {
            case $l:
                return [e, "LinearTransferOETF"];
            case Rt:
                return [e, "sRGBTransferOETF"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"]
        }
    }

    function ng(r, e, t) {
        const n = r.getShaderParameter(e, r.COMPILE_STATUS),
            i = r.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(i);
        if (s) {
            const a = parseInt(s[1]);
            return t.toUpperCase() + `

` + i + `

` + rT(r.getShaderSource(e), a)
        } else return i
    }

    function aT(r, e) {
        const t = sT(e);
        return [`vec4 ${r}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
    }

    function oT(r, e) {
        let t;
        switch (e) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Cineon";
                break;
            case 4:
                t = "ACESFilmic";
                break;
            case 6:
                t = "AgX";
                break;
            case 7:
                t = "Neutral";
                break;
            case 5:
                t = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
        }
        return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }
    const Cc = new Y;

    function lT() {
        xt.getLuminanceCoefficients(Cc);
        const r = Cc.x.toFixed(4),
            e = Cc.y.toFixed(4),
            t = Cc.z.toFixed(4);
        return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
    }

    function cT(r) {
        return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Uo).join(`
`)
    }

    function uT(r) {
        const e = [];
        for (const t in r) {
            const n = r[t];
            n !== !1 && e.push("#define " + t + " " + n)
        }
        return e.join(`
`)
    }

    function fT(r, e) {
        const t = {},
            n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < n; i++) {
            const s = r.getActiveAttrib(e, i),
                a = s.name;
            let o = 1;
            s.type === r.FLOAT_MAT2 && (o = 2), s.type === r.FLOAT_MAT3 && (o = 3), s.type === r.FLOAT_MAT4 && (o = 4), t[a] = {
                type: s.type,
                location: r.getAttribLocation(e, a),
                locationSize: o
            }
        }
        return t
    }

    function Uo(r) {
        return r !== ""
    }

    function ig(r, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function rg(r, e) {
        return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const hT = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Yf(r) {
        return r.replace(hT, pT)
    }
    const dT = new Map;

    function pT(r, e) {
        let t = at[e];
        if (t === void 0) {
            const n = dT.get(e);
            if (n !== void 0) t = at[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
            else throw new Error("Can not resolve #include <" + e + ">")
        }
        return Yf(t)
    }
    const mT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function sg(r) {
        return r.replace(mT, gT)
    }

    function gT(r, e, t, n) {
        let i = "";
        for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
        return i
    }

    function ag(r) {
        let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
        return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
    }

    function _T(r) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return r.shadowMapType === 1 ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === 2 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === 3 && (e = "SHADOWMAP_TYPE_VSM"), e
    }

    function bT(r) {
        let e = "ENVMAP_TYPE_CUBE";
        if (r.envMap) switch (r.envMapMode) {
            case 301:
            case 302:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
                e = "ENVMAP_TYPE_CUBE_UV";
                break
        }
        return e
    }

    function xT(r) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (r.envMap) switch (r.envMapMode) {
            case 302:
                e = "ENVMAP_MODE_REFRACTION";
                break
        }
        return e
    }

    function vT(r) {
        let e = "ENVMAP_BLENDING_NONE";
        if (r.envMap) switch (r.combine) {
            case 0:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                e = "ENVMAP_BLENDING_ADD";
                break
        }
        return e
    }

    function yT(r) {
        const e = r.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2,
            n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
            texelHeight: n,
            maxMip: t
        }
    }

    function ST(r, e, t, n) {
        const i = r.getContext(),
            s = t.defines;
        let a = t.vertexShader,
            o = t.fragmentShader;
        const l = _T(t),
            c = bT(t),
            f = xT(t),
            h = vT(t),
            d = yT(t),
            u = cT(t),
            _ = uT(s),
            m = i.createProgram();
        let g, p, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Uo).join(`
`), g.length > 0 && (g += `
`), p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Uo).join(`
`), p.length > 0 && (p += `
`)) : (g = [ag(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Uo).join(`
`), p = [ag(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== 0 ? "#define TONE_MAPPING" : "", t.toneMapping !== 0 ? at.tonemapping_pars_fragment : "", t.toneMapping !== 0 ? oT("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", at.colorspace_pars_fragment, aT("linearToOutputTexel", t.outputColorSpace), lT(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Uo).join(`
`)), a = Yf(a), a = ig(a, t), a = rg(a, t), o = Yf(o), o = ig(o, t), o = rg(o, t), a = sg(a), o = sg(o), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, g = [u, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g, p = ["#define varying in", t.glslVersion === Fp ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Fp ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
        const x = v + g + a,
            b = v + p + o,
            M = eg(i, i.VERTEX_SHADER, x),
            D = eg(i, i.FRAGMENT_SHADER, b);
        i.attachShader(m, M), i.attachShader(m, D), t.index0AttributeName !== void 0 ? i.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m);

        function T(C) {
            if (r.debug.checkShaderErrors) {
                const O = i.getProgramInfoLog(m).trim(),
                    N = i.getShaderInfoLog(M).trim(),
                    V = i.getShaderInfoLog(D).trim();
                let G = !0,
                    B = !0;
                if (i.getProgramParameter(m, i.LINK_STATUS) === !1)
                    if (G = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, m, M, D);
                    else {
                        const j = ng(i, M, "vertex"),
                            H = ng(i, D, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + `

Material Name: ` + C.name + `
Material Type: ` + C.type + `

Program Info Log: ` + O + `
` + j + `
` + H)
                    }
                else O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (N === "" || V === "") && (B = !1);
                B && (C.diagnostics = {
                    runnable: G,
                    programLog: O,
                    vertexShader: {
                        log: N,
                        prefix: g
                    },
                    fragmentShader: {
                        log: V,
                        prefix: p
                    }
                })
            }
            i.deleteShader(M), i.deleteShader(D), w = new wc(i, m), S = fT(i, m)
        }
        let w;
        this.getUniforms = function() {
            return w === void 0 && T(this), w
        };
        let S;
        this.getAttributes = function() {
            return S === void 0 && T(this), S
        };
        let y = t.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return y === !1 && (y = i.getProgramParameter(m, nT)), y
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = iT++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = M, this.fragmentShader = D, this
    }
    let MT = 0;
    class TT {
        constructor() {
            this.shaderCache = new Map, this.materialCache = new Map
        }
        update(e) {
            const t = e.vertexShader,
                n = e.fragmentShader,
                i = this._getShaderStage(t),
                s = this._getShaderStage(n),
                a = this._getShaderCacheForMaterial(e);
            return a.has(i) === !1 && (a.add(i), i.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e), this
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear()
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return n === void 0 && (n = new Set, t.set(e, n)), n
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return n === void 0 && (n = new ET(e), t.set(e, n)), n
        }
    }
    class ET {
        constructor(e) {
            this.id = MT++, this.code = e, this.usedTimes = 0
        }
    }

    function DT(r, e, t, n, i, s, a) {
        const o = new lf,
            l = new TT,
            c = new Set,
            f = [],
            h = i.logarithmicDepthBuffer,
            d = i.vertexTextures;
        let u = i.precision;
        const _ = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };

        function m(S) {
            return c.add(S), S === 0 ? "uv" : `uv${S}`
        }

        function g(S, y, C, O, N) {
            const V = O.fog,
                G = N.geometry,
                B = S.isMeshStandardMaterial ? O.environment : null,
                j = (S.isMeshStandardMaterial ? t : e).get(S.envMap || B),
                H = j && j.mapping === 306 ? j.image.height : null,
                k = _[S.type];
            S.precision !== null && (u = i.getMaxPrecision(S.precision), u !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", u, "instead."));
            const F = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color,
                se = F !== void 0 ? F.length : 0;
            let de = 0;
            G.morphAttributes.position !== void 0 && (de = 1), G.morphAttributes.normal !== void 0 && (de = 2), G.morphAttributes.color !== void 0 && (de = 3);
            let ke, q, ee, he;
            if (k) {
                const U = Yi[k];
                ke = U.vertexShader, q = U.fragmentShader
            } else ke = S.vertexShader, q = S.fragmentShader, l.update(S), ee = l.getVertexShaderID(S), he = l.getFragmentShaderID(S);
            const fe = r.getRenderTarget(),
                be = r.state.buffers.depth.getReversed(),
                Ye = N.isInstancedMesh === !0,
                Pe = N.isBatchedMesh === !0,
                Xe = !!S.map,
                tt = !!S.matcap,
                xe = !!j,
                R = !!S.aoMap,
                Ge = !!S.lightMap,
                $e = !!S.bumpMap,
                X = !!S.normalMap,
                ve = !!S.displacementMap,
                Qe = !!S.emissiveMap,
                Ie = !!S.metalnessMap,
                ge = !!S.roughnessMap,
                rt = S.anisotropy > 0,
                P = S.clearcoat > 0,
                E = S.dispersion > 0,
                K = S.iridescence > 0,
                ne = S.sheen > 0,
                ie = S.transmission > 0,
                te = rt && !!S.anisotropyMap,
                Fe = P && !!S.clearcoatMap,
                ye = P && !!S.clearcoatNormalMap,
                Oe = P && !!S.clearcoatRoughnessMap,
                De = K && !!S.iridescenceMap,
                pe = K && !!S.iridescenceThicknessMap,
                Ae = ne && !!S.sheenColorMap,
                Ve = ne && !!S.sheenRoughnessMap,
                He = !!S.specularMap,
                Se = !!S.specularColorMap,
                je = !!S.specularIntensityMap,
                I = ie && !!S.transmissionMap,
                Me = ie && !!S.thicknessMap,
                oe = !!S.gradientMap,
                Ee = !!S.alphaMap,
                me = S.alphaTest > 0,
                le = !!S.alphaHash,
                ae = !!S.extensions;
            let L = 0;
            S.toneMapped && (fe === null || fe.isXRRenderTarget === !0) && (L = r.toneMapping);
            const re = {
                shaderID: k,
                shaderType: S.type,
                shaderName: S.name,
                vertexShader: ke,
                fragmentShader: q,
                defines: S.defines,
                customVertexShaderID: ee,
                customFragmentShaderID: he,
                isRawShaderMaterial: S.isRawShaderMaterial === !0,
                glslVersion: S.glslVersion,
                precision: u,
                batching: Pe,
                batchingColor: Pe && N._colorsTexture !== null,
                instancing: Ye,
                instancingColor: Ye && N.instanceColor !== null,
                instancingMorph: Ye && N.morphTexture !== null,
                supportsVertexTextures: d,
                outputColorSpace: fe === null ? r.outputColorSpace : fe.isXRRenderTarget === !0 ? fe.texture.colorSpace : yn,
                alphaToCoverage: !!S.alphaToCoverage,
                map: Xe,
                matcap: tt,
                envMap: xe,
                envMapMode: xe && j.mapping,
                envMapCubeUVHeight: H,
                aoMap: R,
                lightMap: Ge,
                bumpMap: $e,
                normalMap: X,
                displacementMap: d && ve,
                emissiveMap: Qe,
                normalMapObjectSpace: X && S.normalMapType === 1,
                normalMapTangentSpace: X && S.normalMapType === 0,
                metalnessMap: Ie,
                roughnessMap: ge,
                anisotropy: rt,
                anisotropyMap: te,
                clearcoat: P,
                clearcoatMap: Fe,
                clearcoatNormalMap: ye,
                clearcoatRoughnessMap: Oe,
                dispersion: E,
                iridescence: K,
                iridescenceMap: De,
                iridescenceThicknessMap: pe,
                sheen: ne,
                sheenColorMap: Ae,
                sheenRoughnessMap: Ve,
                specularMap: He,
                specularColorMap: Se,
                specularIntensityMap: je,
                transmission: ie,
                transmissionMap: I,
                thicknessMap: Me,
                gradientMap: oe,
                opaque: S.transparent === !1 && S.blending === 1 && S.alphaToCoverage === !1,
                alphaMap: Ee,
                alphaTest: me,
                alphaHash: le,
                combine: S.combine,
                mapUv: Xe && m(S.map.channel),
                aoMapUv: R && m(S.aoMap.channel),
                lightMapUv: Ge && m(S.lightMap.channel),
                bumpMapUv: $e && m(S.bumpMap.channel),
                normalMapUv: X && m(S.normalMap.channel),
                displacementMapUv: ve && m(S.displacementMap.channel),
                emissiveMapUv: Qe && m(S.emissiveMap.channel),
                metalnessMapUv: Ie && m(S.metalnessMap.channel),
                roughnessMapUv: ge && m(S.roughnessMap.channel),
                anisotropyMapUv: te && m(S.anisotropyMap.channel),
                clearcoatMapUv: Fe && m(S.clearcoatMap.channel),
                clearcoatNormalMapUv: ye && m(S.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: Oe && m(S.clearcoatRoughnessMap.channel),
                iridescenceMapUv: De && m(S.iridescenceMap.channel),
                iridescenceThicknessMapUv: pe && m(S.iridescenceThicknessMap.channel),
                sheenColorMapUv: Ae && m(S.sheenColorMap.channel),
                sheenRoughnessMapUv: Ve && m(S.sheenRoughnessMap.channel),
                specularMapUv: He && m(S.specularMap.channel),
                specularColorMapUv: Se && m(S.specularColorMap.channel),
                specularIntensityMapUv: je && m(S.specularIntensityMap.channel),
                transmissionMapUv: I && m(S.transmissionMap.channel),
                thicknessMapUv: Me && m(S.thicknessMap.channel),
                alphaMapUv: Ee && m(S.alphaMap.channel),
                vertexTangents: !!G.attributes.tangent && (X || rt),
                vertexColors: S.vertexColors,
                vertexAlphas: S.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
                pointsUvs: N.isPoints === !0 && !!G.attributes.uv && (Xe || Ee),
                fog: !!V,
                useFog: S.fog === !0,
                fogExp2: !!V && V.isFogExp2,
                flatShading: S.flatShading === !0,
                sizeAttenuation: S.sizeAttenuation === !0,
                logarithmicDepthBuffer: h,
                reverseDepthBuffer: be,
                skinning: N.isSkinnedMesh === !0,
                morphTargets: G.morphAttributes.position !== void 0,
                morphNormals: G.morphAttributes.normal !== void 0,
                morphColors: G.morphAttributes.color !== void 0,
                morphTargetsCount: se,
                morphTextureStride: de,
                numDirLights: y.directional.length,
                numPointLights: y.point.length,
                numSpotLights: y.spot.length,
                numSpotLightMaps: y.spotLightMap.length,
                numRectAreaLights: y.rectArea.length,
                numHemiLights: y.hemi.length,
                numDirLightShadows: y.directionalShadowMap.length,
                numPointLightShadows: y.pointShadowMap.length,
                numSpotLightShadows: y.spotShadowMap.length,
                numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
                numLightProbes: y.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: S.dithering,
                shadowMapEnabled: r.shadowMap.enabled && C.length > 0,
                shadowMapType: r.shadowMap.type,
                toneMapping: L,
                decodeVideoTexture: Xe && S.map.isVideoTexture === !0 && xt.getTransfer(S.map.colorSpace) === Rt,
                decodeVideoTextureEmissive: Qe && S.emissiveMap.isVideoTexture === !0 && xt.getTransfer(S.emissiveMap.colorSpace) === Rt,
                premultipliedAlpha: S.premultipliedAlpha,
                doubleSided: S.side === 2,
                flipSided: S.side === 1,
                useDepthPacking: S.depthPacking >= 0,
                depthPacking: S.depthPacking || 0,
                index0AttributeName: S.index0AttributeName,
                extensionClipCullDistance: ae && S.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ae && S.extensions.multiDraw === !0 || Pe) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: S.customProgramCacheKey()
            };
            return re.vertexUv1s = c.has(1), re.vertexUv2s = c.has(2), re.vertexUv3s = c.has(3), c.clear(), re
        }

        function p(S) {
            const y = [];
            if (S.shaderID ? y.push(S.shaderID) : (y.push(S.customVertexShaderID), y.push(S.customFragmentShaderID)), S.defines !== void 0)
                for (const C in S.defines) y.push(C), y.push(S.defines[C]);
            return S.isRawShaderMaterial === !1 && (v(y, S), x(y, S), y.push(r.outputColorSpace)), y.push(S.customProgramCacheKey), y.join()
        }

        function v(S, y) {
            S.push(y.precision), S.push(y.outputColorSpace), S.push(y.envMapMode), S.push(y.envMapCubeUVHeight), S.push(y.mapUv), S.push(y.alphaMapUv), S.push(y.lightMapUv), S.push(y.aoMapUv), S.push(y.bumpMapUv), S.push(y.normalMapUv), S.push(y.displacementMapUv), S.push(y.emissiveMapUv), S.push(y.metalnessMapUv), S.push(y.roughnessMapUv), S.push(y.anisotropyMapUv), S.push(y.clearcoatMapUv), S.push(y.clearcoatNormalMapUv), S.push(y.clearcoatRoughnessMapUv), S.push(y.iridescenceMapUv), S.push(y.iridescenceThicknessMapUv), S.push(y.sheenColorMapUv), S.push(y.sheenRoughnessMapUv), S.push(y.specularMapUv), S.push(y.specularColorMapUv), S.push(y.specularIntensityMapUv), S.push(y.transmissionMapUv), S.push(y.thicknessMapUv), S.push(y.combine), S.push(y.fogExp2), S.push(y.sizeAttenuation), S.push(y.morphTargetsCount), S.push(y.morphAttributeCount), S.push(y.numDirLights), S.push(y.numPointLights), S.push(y.numSpotLights), S.push(y.numSpotLightMaps), S.push(y.numHemiLights), S.push(y.numRectAreaLights), S.push(y.numDirLightShadows), S.push(y.numPointLightShadows), S.push(y.numSpotLightShadows), S.push(y.numSpotLightShadowsWithMaps), S.push(y.numLightProbes), S.push(y.shadowMapType), S.push(y.toneMapping), S.push(y.numClippingPlanes), S.push(y.numClipIntersection), S.push(y.depthPacking)
        }

        function x(S, y) {
            o.disableAll(), y.supportsVertexTextures && o.enable(0), y.instancing && o.enable(1), y.instancingColor && o.enable(2), y.instancingMorph && o.enable(3), y.matcap && o.enable(4), y.envMap && o.enable(5), y.normalMapObjectSpace && o.enable(6), y.normalMapTangentSpace && o.enable(7), y.clearcoat && o.enable(8), y.iridescence && o.enable(9), y.alphaTest && o.enable(10), y.vertexColors && o.enable(11), y.vertexAlphas && o.enable(12), y.vertexUv1s && o.enable(13), y.vertexUv2s && o.enable(14), y.vertexUv3s && o.enable(15), y.vertexTangents && o.enable(16), y.anisotropy && o.enable(17), y.alphaHash && o.enable(18), y.batching && o.enable(19), y.dispersion && o.enable(20), y.batchingColor && o.enable(21), S.push(o.mask), o.disableAll(), y.fog && o.enable(0), y.useFog && o.enable(1), y.flatShading && o.enable(2), y.logarithmicDepthBuffer && o.enable(3), y.reverseDepthBuffer && o.enable(4), y.skinning && o.enable(5), y.morphTargets && o.enable(6), y.morphNormals && o.enable(7), y.morphColors && o.enable(8), y.premultipliedAlpha && o.enable(9), y.shadowMapEnabled && o.enable(10), y.doubleSided && o.enable(11), y.flipSided && o.enable(12), y.useDepthPacking && o.enable(13), y.dithering && o.enable(14), y.transmission && o.enable(15), y.sheen && o.enable(16), y.opaque && o.enable(17), y.pointsUvs && o.enable(18), y.decodeVideoTexture && o.enable(19), y.decodeVideoTextureEmissive && o.enable(20), y.alphaToCoverage && o.enable(21), S.push(o.mask)
        }

        function b(S) {
            const y = _[S.type];
            let C;
            if (y) {
                const O = Yi[y];
                C = Jx.clone(O.uniforms)
            } else C = S.uniforms;
            return C
        }

        function M(S, y) {
            let C;
            for (let O = 0, N = f.length; O < N; O++) {
                const V = f[O];
                if (V.cacheKey === y) {
                    C = V, ++C.usedTimes;
                    break
                }
            }
            return C === void 0 && (C = new ST(r, y, S, s), f.push(C)), C
        }

        function D(S) {
            if (--S.usedTimes === 0) {
                const y = f.indexOf(S);
                f[y] = f[f.length - 1], f.pop(), S.destroy()
            }
        }

        function T(S) {
            l.remove(S)
        }

        function w() {
            l.dispose()
        }
        return {
            getParameters: g,
            getProgramCacheKey: p,
            getUniforms: b,
            acquireProgram: M,
            releaseProgram: D,
            releaseShaderCache: T,
            programs: f,
            dispose: w
        }
    }

    function AT() {
        let r = new WeakMap;

        function e(a) {
            return r.has(a)
        }

        function t(a) {
            let o = r.get(a);
            return o === void 0 && (o = {}, r.set(a, o)), o
        }

        function n(a) {
            r.delete(a)
        }

        function i(a, o, l) {
            r.get(a)[o] = l
        }

        function s() {
            r = new WeakMap
        }
        return {
            has: e,
            get: t,
            remove: n,
            update: i,
            dispose: s
        }
    }

    function wT(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
    }

    function og(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
    }

    function lg() {
        const r = [];
        let e = 0;
        const t = [],
            n = [],
            i = [];

        function s() {
            e = 0, t.length = 0, n.length = 0, i.length = 0
        }

        function a(h, d, u, _, m, g) {
            let p = r[e];
            return p === void 0 ? (p = {
                id: h.id,
                object: h,
                geometry: d,
                material: u,
                groupOrder: _,
                renderOrder: h.renderOrder,
                z: m,
                group: g
            }, r[e] = p) : (p.id = h.id, p.object = h, p.geometry = d, p.material = u, p.groupOrder = _, p.renderOrder = h.renderOrder, p.z = m, p.group = g), e++, p
        }

        function o(h, d, u, _, m, g) {
            const p = a(h, d, u, _, m, g);
            u.transmission > 0 ? n.push(p) : u.transparent === !0 ? i.push(p) : t.push(p)
        }

        function l(h, d, u, _, m, g) {
            const p = a(h, d, u, _, m, g);
            u.transmission > 0 ? n.unshift(p) : u.transparent === !0 ? i.unshift(p) : t.unshift(p)
        }

        function c(h, d) {
            t.length > 1 && t.sort(h || wT), n.length > 1 && n.sort(d || og), i.length > 1 && i.sort(d || og)
        }

        function f() {
            for (let h = e, d = r.length; h < d; h++) {
                const u = r[h];
                if (u.id === null) break;
                u.id = null, u.object = null, u.geometry = null, u.material = null, u.group = null
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: i,
            init: s,
            push: o,
            unshift: l,
            finish: f,
            sort: c
        }
    }

    function CT() {
        let r = new WeakMap;

        function e(n, i) {
            const s = r.get(n);
            let a;
            return s === void 0 ? (a = new lg, r.set(n, [a])) : i >= s.length ? (a = new lg, s.push(a)) : a = s[i], a
        }

        function t() {
            r = new WeakMap
        }
        return {
            get: e,
            dispose: t
        }
    }

    function RT() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            direction: new Y,
                            color: new it
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new Y,
                            direction: new Y,
                            color: new it,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new Y,
                            color: new it,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new Y,
                            skyColor: new it,
                            groundColor: new it
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new it,
                            position: new Y,
                            halfWidth: new Y,
                            halfHeight: new Y
                        };
                        break
                }
                return r[e.id] = t, t
            }
        }
    }

    function PT() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new pt
                        };
                        break;
                    case "SpotLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new pt
                        };
                        break;
                    case "PointLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new pt,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break
                }
                return r[e.id] = t, t
            }
        }
    }
    let FT = 0;

    function LT(r, e) {
        return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
    }

    function IT(r) {
        const e = new RT,
            t = PT(),
            n = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
        for (let c = 0; c < 9; c++) n.probe.push(new Y);
        const i = new Y,
            s = new st,
            a = new st;

        function o(c) {
            let f = 0,
                h = 0,
                d = 0;
            for (let S = 0; S < 9; S++) n.probe[S].set(0, 0, 0);
            let u = 0,
                _ = 0,
                m = 0,
                g = 0,
                p = 0,
                v = 0,
                x = 0,
                b = 0,
                M = 0,
                D = 0,
                T = 0;
            c.sort(LT);
            for (let S = 0, y = c.length; S < y; S++) {
                const C = c[S],
                    O = C.color,
                    N = C.intensity,
                    V = C.distance,
                    G = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
                if (C.isAmbientLight) f += O.r * N, h += O.g * N, d += O.b * N;
                else if (C.isLightProbe) {
                    for (let B = 0; B < 9; B++) n.probe[B].addScaledVector(C.sh.coefficients[B], N);
                    T++
                } else if (C.isDirectionalLight) {
                    const B = e.get(C);
                    if (B.color.copy(C.color).multiplyScalar(C.intensity), C.castShadow) {
                        const j = C.shadow,
                            H = t.get(C);
                        H.shadowIntensity = j.intensity, H.shadowBias = j.bias, H.shadowNormalBias = j.normalBias, H.shadowRadius = j.radius, H.shadowMapSize = j.mapSize, n.directionalShadow[u] = H, n.directionalShadowMap[u] = G, n.directionalShadowMatrix[u] = C.shadow.matrix, v++
                    }
                    n.directional[u] = B, u++
                } else if (C.isSpotLight) {
                    const B = e.get(C);
                    B.position.setFromMatrixPosition(C.matrixWorld), B.color.copy(O).multiplyScalar(N), B.distance = V, B.coneCos = Math.cos(C.angle), B.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), B.decay = C.decay, n.spot[m] = B;
                    const j = C.shadow;
                    if (C.map && (n.spotLightMap[M] = C.map, M++, j.updateMatrices(C), C.castShadow && D++), n.spotLightMatrix[m] = j.matrix, C.castShadow) {
                        const H = t.get(C);
                        H.shadowIntensity = j.intensity, H.shadowBias = j.bias, H.shadowNormalBias = j.normalBias, H.shadowRadius = j.radius, H.shadowMapSize = j.mapSize, n.spotShadow[m] = H, n.spotShadowMap[m] = G, b++
                    }
                    m++
                } else if (C.isRectAreaLight) {
                    const B = e.get(C);
                    B.color.copy(O).multiplyScalar(N), B.halfWidth.set(C.width * .5, 0, 0), B.halfHeight.set(0, C.height * .5, 0), n.rectArea[g] = B, g++
                } else if (C.isPointLight) {
                    const B = e.get(C);
                    if (B.color.copy(C.color).multiplyScalar(C.intensity), B.distance = C.distance, B.decay = C.decay, C.castShadow) {
                        const j = C.shadow,
                            H = t.get(C);
                        H.shadowIntensity = j.intensity, H.shadowBias = j.bias, H.shadowNormalBias = j.normalBias, H.shadowRadius = j.radius, H.shadowMapSize = j.mapSize, H.shadowCameraNear = j.camera.near, H.shadowCameraFar = j.camera.far, n.pointShadow[_] = H, n.pointShadowMap[_] = G, n.pointShadowMatrix[_] = C.shadow.matrix, x++
                    }
                    n.point[_] = B, _++
                } else if (C.isHemisphereLight) {
                    const B = e.get(C);
                    B.skyColor.copy(C.color).multiplyScalar(N), B.groundColor.copy(C.groundColor).multiplyScalar(N), n.hemi[p] = B, p++
                }
            }
            g > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Re.LTC_FLOAT_1, n.rectAreaLTC2 = Re.LTC_FLOAT_2) : (n.rectAreaLTC1 = Re.LTC_HALF_1, n.rectAreaLTC2 = Re.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = h, n.ambient[2] = d;
            const w = n.hash;
            (w.directionalLength !== u || w.pointLength !== _ || w.spotLength !== m || w.rectAreaLength !== g || w.hemiLength !== p || w.numDirectionalShadows !== v || w.numPointShadows !== x || w.numSpotShadows !== b || w.numSpotMaps !== M || w.numLightProbes !== T) && (n.directional.length = u, n.spot.length = m, n.rectArea.length = g, n.point.length = _, n.hemi.length = p, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + M - D, n.spotLightMap.length = M, n.numSpotLightShadowsWithMaps = D, n.numLightProbes = T, w.directionalLength = u, w.pointLength = _, w.spotLength = m, w.rectAreaLength = g, w.hemiLength = p, w.numDirectionalShadows = v, w.numPointShadows = x, w.numSpotShadows = b, w.numSpotMaps = M, w.numLightProbes = T, n.version = FT++)
        }

        function l(c, f) {
            let h = 0,
                d = 0,
                u = 0,
                _ = 0,
                m = 0;
            const g = f.matrixWorldInverse;
            for (let p = 0, v = c.length; p < v; p++) {
                const x = c[p];
                if (x.isDirectionalLight) {
                    const b = n.directional[h];
                    b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(g), h++
                } else if (x.isSpotLight) {
                    const b = n.spot[u];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(g), u++
                } else if (x.isRectAreaLight) {
                    const b = n.rectArea[_];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), a.identity(), s.copy(x.matrixWorld), s.premultiply(g), a.extractRotation(s), b.halfWidth.set(x.width * .5, 0, 0), b.halfHeight.set(0, x.height * .5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), _++
                } else if (x.isPointLight) {
                    const b = n.point[d];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), d++
                } else if (x.isHemisphereLight) {
                    const b = n.hemi[m];
                    b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(g), m++
                }
            }
        }
        return {
            setup: o,
            setupView: l,
            state: n
        }
    }

    function cg(r) {
        const e = new IT(r),
            t = [],
            n = [];

        function i(f) {
            c.camera = f, t.length = 0, n.length = 0
        }

        function s(f) {
            t.push(f)
        }

        function a(f) {
            n.push(f)
        }

        function o() {
            e.setup(t)
        }

        function l(f) {
            e.setupView(t, f)
        }
        const c = {
            lightsArray: t,
            shadowsArray: n,
            camera: null,
            lights: e,
            transmissionRenderTarget: {}
        };
        return {
            init: i,
            state: c,
            setupLights: o,
            setupLightsView: l,
            pushLight: s,
            pushShadow: a
        }
    }

    function NT(r) {
        let e = new WeakMap;

        function t(i, s = 0) {
            const a = e.get(i);
            let o;
            return a === void 0 ? (o = new cg(r), e.set(i, [o])) : s >= a.length ? (o = new cg(r), a.push(o)) : o = a[s], o
        }

        function n() {
            e = new WeakMap
        }
        return {
            get: t,
            dispose: n
        }
    }
    const OT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        UT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

    function BT(r, e, t) {
        let n = new Af;
        const i = new pt,
            s = new pt,
            a = new Tt,
            o = new mv({
                depthPacking: 3201
            }),
            l = new gv,
            c = {},
            f = t.maxTextureSize,
            h = {
                0: 1,
                1: 0,
                2: 2
            },
            d = new Hr({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new pt
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: OT,
                fragmentShader: UT
            }),
            u = d.clone();
        u.defines.HORIZONTAL_PASS = 1;
        const _ = new Pi;
        _.setAttribute("position", new _n(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const m = new ei(_, d),
            g = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
        let p = this.type;
        this.render = function(D, T, w) {
            if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || D.length === 0) return;
            const S = r.getRenderTarget(),
                y = r.getActiveCubeFace(),
                C = r.getActiveMipmapLevel(),
                O = r.state;
            O.setBlending(0), O.buffers.color.setClear(1, 1, 1, 1), O.buffers.depth.setTest(!0), O.setScissorTest(!1);
            const N = p !== 3 && this.type === 3,
                V = p === 3 && this.type !== 3;
            for (let G = 0, B = D.length; G < B; G++) {
                const j = D[G],
                    H = j.shadow;
                if (H === void 0) {
                    console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
                    continue
                }
                if (H.autoUpdate === !1 && H.needsUpdate === !1) continue;
                i.copy(H.mapSize);
                const k = H.getFrameExtents();
                if (i.multiply(k), s.copy(H.mapSize), (i.x > f || i.y > f) && (i.x > f && (s.x = Math.floor(f / k.x), i.x = s.x * k.x, H.mapSize.x = s.x), i.y > f && (s.y = Math.floor(f / k.y), i.y = s.y * k.y, H.mapSize.y = s.y)), H.map === null || N === !0 || V === !0) {
                    const se = this.type !== 3 ? {
                        minFilter: 1003,
                        magFilter: 1003
                    } : {};
                    H.map !== null && H.map.dispose(), H.map = new bs(i.x, i.y, se), H.map.texture.name = j.name + ".shadowMap", H.camera.updateProjectionMatrix()
                }
                r.setRenderTarget(H.map), r.clear();
                const F = H.getViewportCount();
                for (let se = 0; se < F; se++) {
                    const de = H.getViewport(se);
                    a.set(s.x * de.x, s.y * de.y, s.x * de.z, s.y * de.w), O.viewport(a), H.updateMatrices(j, se), n = H.getFrustum(), b(T, w, H.camera, j, this.type)
                }
                H.isPointLightShadow !== !0 && this.type === 3 && v(H, w), H.needsUpdate = !1
            }
            p = this.type, g.needsUpdate = !1, r.setRenderTarget(S, y, C)
        };

        function v(D, T) {
            const w = e.update(m);
            d.defines.VSM_SAMPLES !== D.blurSamples && (d.defines.VSM_SAMPLES = D.blurSamples, u.defines.VSM_SAMPLES = D.blurSamples, d.needsUpdate = !0, u.needsUpdate = !0), D.mapPass === null && (D.mapPass = new bs(i.x, i.y)), d.uniforms.shadow_pass.value = D.map.texture, d.uniforms.resolution.value = D.mapSize, d.uniforms.radius.value = D.radius, r.setRenderTarget(D.mapPass), r.clear(), r.renderBufferDirect(T, null, w, d, m, null), u.uniforms.shadow_pass.value = D.mapPass.texture, u.uniforms.resolution.value = D.mapSize, u.uniforms.radius.value = D.radius, r.setRenderTarget(D.map), r.clear(), r.renderBufferDirect(T, null, w, u, m, null)
        }

        function x(D, T, w, S) {
            let y = null;
            const C = w.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
            if (C !== void 0) y = C;
            else if (y = w.isPointLight === !0 ? l : o, r.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0 || T.alphaToCoverage === !0) {
                const O = y.uuid,
                    N = T.uuid;
                let V = c[O];
                V === void 0 && (V = {}, c[O] = V);
                let G = V[N];
                G === void 0 && (G = y.clone(), V[N] = G, T.addEventListener("dispose", M)), y = G
            }
            if (y.visible = T.visible, y.wireframe = T.wireframe, S === 3 ? y.side = T.shadowSide !== null ? T.shadowSide : T.side : y.side = T.shadowSide !== null ? T.shadowSide : h[T.side], y.alphaMap = T.alphaMap, y.alphaTest = T.alphaToCoverage === !0 ? .5 : T.alphaTest, y.map = T.map, y.clipShadows = T.clipShadows, y.clippingPlanes = T.clippingPlanes, y.clipIntersection = T.clipIntersection, y.displacementMap = T.displacementMap, y.displacementScale = T.displacementScale, y.displacementBias = T.displacementBias, y.wireframeLinewidth = T.wireframeLinewidth, y.linewidth = T.linewidth, w.isPointLight === !0 && y.isMeshDistanceMaterial === !0) {
                const O = r.properties.get(y);
                O.light = w
            }
            return y
        }

        function b(D, T, w, S, y) {
            if (D.visible === !1) return;
            if (D.layers.test(T.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && y === 3) && (!D.frustumCulled || n.intersectsObject(D))) {
                D.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, D.matrixWorld);
                const N = e.update(D),
                    V = D.material;
                if (Array.isArray(V)) {
                    const G = N.groups;
                    for (let B = 0, j = G.length; B < j; B++) {
                        const H = G[B],
                            k = V[H.materialIndex];
                        if (k && k.visible) {
                            const F = x(D, k, S, y);
                            D.onBeforeShadow(r, D, T, w, N, F, H), r.renderBufferDirect(w, null, N, F, D, H), D.onAfterShadow(r, D, T, w, N, F, H)
                        }
                    }
                } else if (V.visible) {
                    const G = x(D, V, S, y);
                    D.onBeforeShadow(r, D, T, w, N, G, null), r.renderBufferDirect(w, null, N, G, D, null), D.onAfterShadow(r, D, T, w, N, G, null)
                }
            }
            const O = D.children;
            for (let N = 0, V = O.length; N < V; N++) b(O[N], T, w, S, y)
        }

        function M(D) {
            D.target.removeEventListener("dispose", M);
            for (const w in c) {
                const S = c[w],
                    y = D.target.uuid;
                y in S && (S[y].dispose(), delete S[y])
            }
        }
    }
    const kT = {
        0: 1,
        2: 6,
        4: 7,
        3: 5,
        1: 0,
        6: 2,
        7: 4,
        5: 3
    };

    function zT(r, e) {
        function t() {
            let I = !1;
            const Me = new Tt;
            let oe = null;
            const Ee = new Tt(0, 0, 0, 0);
            return {
                setMask: function(me) {
                    oe !== me && !I && (r.colorMask(me, me, me, me), oe = me)
                },
                setLocked: function(me) {
                    I = me
                },
                setClear: function(me, le, ae, L, re) {
                    re === !0 && (me *= L, le *= L, ae *= L), Me.set(me, le, ae, L), Ee.equals(Me) === !1 && (r.clearColor(me, le, ae, L), Ee.copy(Me))
                },
                reset: function() {
                    I = !1, oe = null, Ee.set(-1, 0, 0, 0)
                }
            }
        }

        function n() {
            let I = !1,
                Me = !1,
                oe = null,
                Ee = null,
                me = null;
            return {
                setReversed: function(le) {
                    if (Me !== le) {
                        const ae = e.get("EXT_clip_control");
                        le ? ae.clipControlEXT(ae.LOWER_LEFT_EXT, ae.ZERO_TO_ONE_EXT) : ae.clipControlEXT(ae.LOWER_LEFT_EXT, ae.NEGATIVE_ONE_TO_ONE_EXT), Me = le;
                        const L = me;
                        me = null, this.setClear(L)
                    }
                },
                getReversed: function() {
                    return Me
                },
                setTest: function(le) {
                    le ? fe(r.DEPTH_TEST) : be(r.DEPTH_TEST)
                },
                setMask: function(le) {
                    oe !== le && !I && (r.depthMask(le), oe = le)
                },
                setFunc: function(le) {
                    if (Me && (le = kT[le]), Ee !== le) {
                        switch (le) {
                            case 0:
                                r.depthFunc(r.NEVER);
                                break;
                            case 1:
                                r.depthFunc(r.ALWAYS);
                                break;
                            case 2:
                                r.depthFunc(r.LESS);
                                break;
                            case 3:
                                r.depthFunc(r.LEQUAL);
                                break;
                            case 4:
                                r.depthFunc(r.EQUAL);
                                break;
                            case 5:
                                r.depthFunc(r.GEQUAL);
                                break;
                            case 6:
                                r.depthFunc(r.GREATER);
                                break;
                            case 7:
                                r.depthFunc(r.NOTEQUAL);
                                break;
                            default:
                                r.depthFunc(r.LEQUAL)
                        }
                        Ee = le
                    }
                },
                setLocked: function(le) {
                    I = le
                },
                setClear: function(le) {
                    me !== le && (Me && (le = 1 - le), r.clearDepth(le), me = le)
                },
                reset: function() {
                    I = !1, oe = null, Ee = null, me = null, Me = !1
                }
            }
        }

        function i() {
            let I = !1,
                Me = null,
                oe = null,
                Ee = null,
                me = null,
                le = null,
                ae = null,
                L = null,
                re = null;
            return {
                setTest: function(U) {
                    I || (U ? fe(r.STENCIL_TEST) : be(r.STENCIL_TEST))
                },
                setMask: function(U) {
                    Me !== U && !I && (r.stencilMask(U), Me = U)
                },
                setFunc: function(U, J, ce) {
                    (oe !== U || Ee !== J || me !== ce) && (r.stencilFunc(U, J, ce), oe = U, Ee = J, me = ce)
                },
                setOp: function(U, J, ce) {
                    (le !== U || ae !== J || L !== ce) && (r.stencilOp(U, J, ce), le = U, ae = J, L = ce)
                },
                setLocked: function(U) {
                    I = U
                },
                setClear: function(U) {
                    re !== U && (r.clearStencil(U), re = U)
                },
                reset: function() {
                    I = !1, Me = null, oe = null, Ee = null, me = null, le = null, ae = null, L = null, re = null
                }
            }
        }
        const s = new t,
            a = new n,
            o = new i,
            l = new WeakMap,
            c = new WeakMap;
        let f = {},
            h = {},
            d = new WeakMap,
            u = [],
            _ = null,
            m = !1,
            g = null,
            p = null,
            v = null,
            x = null,
            b = null,
            M = null,
            D = null,
            T = new it(0, 0, 0),
            w = 0,
            S = !1,
            y = null,
            C = null,
            O = null,
            N = null,
            V = null;
        const G = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let B = !1,
            j = 0;
        const H = r.getParameter(r.VERSION);
        H.indexOf("WebGL") !== -1 ? (j = parseFloat(/^WebGL (\d)/.exec(H)[1]), B = j >= 1) : H.indexOf("OpenGL ES") !== -1 && (j = parseFloat(/^OpenGL ES (\d)/.exec(H)[1]), B = j >= 2);
        let k = null,
            F = {};
        const se = r.getParameter(r.SCISSOR_BOX),
            de = r.getParameter(r.VIEWPORT),
            ke = new Tt().fromArray(se),
            q = new Tt().fromArray(de);

        function ee(I, Me, oe, Ee) {
            const me = new Uint8Array(4),
                le = r.createTexture();
            r.bindTexture(I, le), r.texParameteri(I, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(I, r.TEXTURE_MAG_FILTER, r.NEAREST);
            for (let ae = 0; ae < oe; ae++) I === r.TEXTURE_3D || I === r.TEXTURE_2D_ARRAY ? r.texImage3D(Me, 0, r.RGBA, 1, 1, Ee, 0, r.RGBA, r.UNSIGNED_BYTE, me) : r.texImage2D(Me + ae, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, me);
            return le
        }
        const he = {};
        he[r.TEXTURE_2D] = ee(r.TEXTURE_2D, r.TEXTURE_2D, 1), he[r.TEXTURE_CUBE_MAP] = ee(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), he[r.TEXTURE_2D_ARRAY] = ee(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), he[r.TEXTURE_3D] = ee(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), fe(r.DEPTH_TEST), a.setFunc(3), $e(!1), X(1), fe(r.CULL_FACE), R(0);

        function fe(I) {
            f[I] !== !0 && (r.enable(I), f[I] = !0)
        }

        function be(I) {
            f[I] !== !1 && (r.disable(I), f[I] = !1)
        }

        function Ye(I, Me) {
            return h[I] !== Me ? (r.bindFramebuffer(I, Me), h[I] = Me, I === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = Me), I === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = Me), !0) : !1
        }

        function Pe(I, Me) {
            let oe = u,
                Ee = !1;
            if (I) {
                oe = d.get(Me), oe === void 0 && (oe = [], d.set(Me, oe));
                const me = I.textures;
                if (oe.length !== me.length || oe[0] !== r.COLOR_ATTACHMENT0) {
                    for (let le = 0, ae = me.length; le < ae; le++) oe[le] = r.COLOR_ATTACHMENT0 + le;
                    oe.length = me.length, Ee = !0
                }
            } else oe[0] !== r.BACK && (oe[0] = r.BACK, Ee = !0);
            Ee && r.drawBuffers(oe)
        }

        function Xe(I) {
            return _ !== I ? (r.useProgram(I), _ = I, !0) : !1
        }
        const tt = {
            100: r.FUNC_ADD,
            101: r.FUNC_SUBTRACT,
            102: r.FUNC_REVERSE_SUBTRACT
        };
        tt[103] = r.MIN, tt[104] = r.MAX;
        const xe = {
            200: r.ZERO,
            201: r.ONE,
            202: r.SRC_COLOR,
            204: r.SRC_ALPHA,
            210: r.SRC_ALPHA_SATURATE,
            208: r.DST_COLOR,
            206: r.DST_ALPHA,
            203: r.ONE_MINUS_SRC_COLOR,
            205: r.ONE_MINUS_SRC_ALPHA,
            209: r.ONE_MINUS_DST_COLOR,
            207: r.ONE_MINUS_DST_ALPHA,
            211: r.CONSTANT_COLOR,
            212: r.ONE_MINUS_CONSTANT_COLOR,
            213: r.CONSTANT_ALPHA,
            214: r.ONE_MINUS_CONSTANT_ALPHA
        };

        function R(I, Me, oe, Ee, me, le, ae, L, re, U) {
            if (I === 0) {
                m === !0 && (be(r.BLEND), m = !1);
                return
            }
            if (m === !1 && (fe(r.BLEND), m = !0), I !== 5) {
                if (I !== g || U !== S) {
                    if ((p !== 100 || b !== 100) && (r.blendEquation(r.FUNC_ADD), p = 100, b = 100), U) switch (I) {
                        case 1:
                            r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            r.blendFunc(r.ONE, r.ONE);
                            break;
                        case 3:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case 4:
                            r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", I);
                            break
                    } else switch (I) {
                        case 1:
                            r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            r.blendFunc(r.SRC_ALPHA, r.ONE);
                            break;
                        case 3:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case 4:
                            r.blendFunc(r.ZERO, r.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", I);
                            break
                    }
                    v = null, x = null, M = null, D = null, T.set(0, 0, 0), w = 0, g = I, S = U
                }
                return
            }
            me = me || Me, le = le || oe, ae = ae || Ee, (Me !== p || me !== b) && (r.blendEquationSeparate(tt[Me], tt[me]), p = Me, b = me), (oe !== v || Ee !== x || le !== M || ae !== D) && (r.blendFuncSeparate(xe[oe], xe[Ee], xe[le], xe[ae]), v = oe, x = Ee, M = le, D = ae), (L.equals(T) === !1 || re !== w) && (r.blendColor(L.r, L.g, L.b, re), T.copy(L), w = re), g = I, S = !1
        }

        function Ge(I, Me) {
            I.side === 2 ? be(r.CULL_FACE) : fe(r.CULL_FACE);
            let oe = I.side === 1;
            Me && (oe = !oe), $e(oe), I.blending === 1 && I.transparent === !1 ? R(0) : R(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.blendColor, I.blendAlpha, I.premultipliedAlpha), a.setFunc(I.depthFunc), a.setTest(I.depthTest), a.setMask(I.depthWrite), s.setMask(I.colorWrite);
            const Ee = I.stencilWrite;
            o.setTest(Ee), Ee && (o.setMask(I.stencilWriteMask), o.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask), o.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)), Qe(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits), I.alphaToCoverage === !0 ? fe(r.SAMPLE_ALPHA_TO_COVERAGE) : be(r.SAMPLE_ALPHA_TO_COVERAGE)
        }

        function $e(I) {
            y !== I && (I ? r.frontFace(r.CW) : r.frontFace(r.CCW), y = I)
        }

        function X(I) {
            I !== 0 ? (fe(r.CULL_FACE), I !== C && (I === 1 ? r.cullFace(r.BACK) : I === 2 ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : be(r.CULL_FACE), C = I
        }

        function ve(I) {
            I !== O && (B && r.lineWidth(I), O = I)
        }

        function Qe(I, Me, oe) {
            I ? (fe(r.POLYGON_OFFSET_FILL), (N !== Me || V !== oe) && (r.polygonOffset(Me, oe), N = Me, V = oe)) : be(r.POLYGON_OFFSET_FILL)
        }

        function Ie(I) {
            I ? fe(r.SCISSOR_TEST) : be(r.SCISSOR_TEST)
        }

        function ge(I) {
            I === void 0 && (I = r.TEXTURE0 + G - 1), k !== I && (r.activeTexture(I), k = I)
        }

        function rt(I, Me, oe) {
            oe === void 0 && (k === null ? oe = r.TEXTURE0 + G - 1 : oe = k);
            let Ee = F[oe];
            Ee === void 0 && (Ee = {
                type: void 0,
                texture: void 0
            }, F[oe] = Ee), (Ee.type !== I || Ee.texture !== Me) && (k !== oe && (r.activeTexture(oe), k = oe), r.bindTexture(I, Me || he[I]), Ee.type = I, Ee.texture = Me)
        }

        function P() {
            const I = F[k];
            I !== void 0 && I.type !== void 0 && (r.bindTexture(I.type, null), I.type = void 0, I.texture = void 0)
        }

        function E() {
            try {
                r.compressedTexImage2D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function K() {
            try {
                r.compressedTexImage3D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function ne() {
            try {
                r.texSubImage2D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function ie() {
            try {
                r.texSubImage3D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function te() {
            try {
                r.compressedTexSubImage2D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function Fe() {
            try {
                r.compressedTexSubImage3D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function ye() {
            try {
                r.texStorage2D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function Oe() {
            try {
                r.texStorage3D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function De() {
            try {
                r.texImage2D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function pe() {
            try {
                r.texImage3D(...arguments)
            } catch (I) {
                console.error("THREE.WebGLState:", I)
            }
        }

        function Ae(I) {
            ke.equals(I) === !1 && (r.scissor(I.x, I.y, I.z, I.w), ke.copy(I))
        }

        function Ve(I) {
            q.equals(I) === !1 && (r.viewport(I.x, I.y, I.z, I.w), q.copy(I))
        }

        function He(I, Me) {
            let oe = c.get(Me);
            oe === void 0 && (oe = new WeakMap, c.set(Me, oe));
            let Ee = oe.get(I);
            Ee === void 0 && (Ee = r.getUniformBlockIndex(Me, I.name), oe.set(I, Ee))
        }

        function Se(I, Me) {
            const Ee = c.get(Me).get(I);
            l.get(Me) !== Ee && (r.uniformBlockBinding(Me, Ee, I.__bindingPointIndex), l.set(Me, Ee))
        }

        function je() {
            r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), a.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), f = {}, k = null, F = {}, h = {}, d = new WeakMap, u = [], _ = null, m = !1, g = null, p = null, v = null, x = null, b = null, M = null, D = null, T = new it(0, 0, 0), w = 0, S = !1, y = null, C = null, O = null, N = null, V = null, ke.set(0, 0, r.canvas.width, r.canvas.height), q.set(0, 0, r.canvas.width, r.canvas.height), s.reset(), a.reset(), o.reset()
        }
        return {
            buffers: {
                color: s,
                depth: a,
                stencil: o
            },
            enable: fe,
            disable: be,
            bindFramebuffer: Ye,
            drawBuffers: Pe,
            useProgram: Xe,
            setBlending: R,
            setMaterial: Ge,
            setFlipSided: $e,
            setCullFace: X,
            setLineWidth: ve,
            setPolygonOffset: Qe,
            setScissorTest: Ie,
            activeTexture: ge,
            bindTexture: rt,
            unbindTexture: P,
            compressedTexImage2D: E,
            compressedTexImage3D: K,
            texImage2D: De,
            texImage3D: pe,
            updateUBOMapping: He,
            uniformBlockBinding: Se,
            texStorage2D: ye,
            texStorage3D: Oe,
            texSubImage2D: ne,
            texSubImage3D: ie,
            compressedTexSubImage2D: te,
            compressedTexSubImage3D: Fe,
            scissor: Ae,
            viewport: Ve,
            reset: je
        }
    }

    function GT(r, e, t, n, i, s, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
            l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
            c = new pt,
            f = new WeakMap;
        let h;
        const d = new WeakMap;
        let u = !1;
        try {
            u = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
        } catch {}

        function _(P, E) {
            return u ? new OffscreenCanvas(P, E) : To("canvas")
        }

        function m(P, E, K) {
            let ne = 1;
            const ie = rt(P);
            if ((ie.width > K || ie.height > K) && (ne = K / Math.max(ie.width, ie.height)), ne < 1)
                if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap || typeof VideoFrame < "u" && P instanceof VideoFrame) {
                    const te = Math.floor(ne * ie.width),
                        Fe = Math.floor(ne * ie.height);
                    h === void 0 && (h = _(te, Fe));
                    const ye = E ? _(te, Fe) : h;
                    return ye.width = te, ye.height = Fe, ye.getContext("2d").drawImage(P, 0, 0, te, Fe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + te + "x" + Fe + ")."), ye
                } else return "data" in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), P;
            return P
        }

        function g(P) {
            return P.generateMipmaps
        }

        function p(P) {
            r.generateMipmap(P)
        }

        function v(P) {
            return P.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : P.isWebGL3DRenderTarget ? r.TEXTURE_3D : P.isWebGLArrayRenderTarget || P.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D
        }

        function x(P, E, K, ne, ie = !1) {
            if (P !== null) {
                if (r[P] !== void 0) return r[P];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'")
            }
            let te = E;
            if (E === r.RED && (K === r.FLOAT && (te = r.R32F), K === r.HALF_FLOAT && (te = r.R16F), K === r.UNSIGNED_BYTE && (te = r.R8)), E === r.RED_INTEGER && (K === r.UNSIGNED_BYTE && (te = r.R8UI), K === r.UNSIGNED_SHORT && (te = r.R16UI), K === r.UNSIGNED_INT && (te = r.R32UI), K === r.BYTE && (te = r.R8I), K === r.SHORT && (te = r.R16I), K === r.INT && (te = r.R32I)), E === r.RG && (K === r.FLOAT && (te = r.RG32F), K === r.HALF_FLOAT && (te = r.RG16F), K === r.UNSIGNED_BYTE && (te = r.RG8)), E === r.RG_INTEGER && (K === r.UNSIGNED_BYTE && (te = r.RG8UI), K === r.UNSIGNED_SHORT && (te = r.RG16UI), K === r.UNSIGNED_INT && (te = r.RG32UI), K === r.BYTE && (te = r.RG8I), K === r.SHORT && (te = r.RG16I), K === r.INT && (te = r.RG32I)), E === r.RGB_INTEGER && (K === r.UNSIGNED_BYTE && (te = r.RGB8UI), K === r.UNSIGNED_SHORT && (te = r.RGB16UI), K === r.UNSIGNED_INT && (te = r.RGB32UI), K === r.BYTE && (te = r.RGB8I), K === r.SHORT && (te = r.RGB16I), K === r.INT && (te = r.RGB32I)), E === r.RGBA_INTEGER && (K === r.UNSIGNED_BYTE && (te = r.RGBA8UI), K === r.UNSIGNED_SHORT && (te = r.RGBA16UI), K === r.UNSIGNED_INT && (te = r.RGBA32UI), K === r.BYTE && (te = r.RGBA8I), K === r.SHORT && (te = r.RGBA16I), K === r.INT && (te = r.RGBA32I)), E === r.RGB && K === r.UNSIGNED_INT_5_9_9_9_REV && (te = r.RGB9_E5), E === r.RGBA) {
                const Fe = ie ? $l : xt.getTransfer(ne);
                K === r.FLOAT && (te = r.RGBA32F), K === r.HALF_FLOAT && (te = r.RGBA16F), K === r.UNSIGNED_BYTE && (te = Fe === Rt ? r.SRGB8_ALPHA8 : r.RGBA8), K === r.UNSIGNED_SHORT_4_4_4_4 && (te = r.RGBA4), K === r.UNSIGNED_SHORT_5_5_5_1 && (te = r.RGB5_A1)
            }
            return (te === r.R16F || te === r.R32F || te === r.RG16F || te === r.RG32F || te === r.RGBA16F || te === r.RGBA32F) && e.get("EXT_color_buffer_float"), te
        }

        function b(P, E) {
            let K;
            return P ? E === null || E === 1014 || E === 1020 ? K = r.DEPTH24_STENCIL8 : E === 1015 ? K = r.DEPTH32F_STENCIL8 : E === 1012 && (K = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : E === null || E === 1014 || E === 1020 ? K = r.DEPTH_COMPONENT24 : E === 1015 ? K = r.DEPTH_COMPONENT32F : E === 1012 && (K = r.DEPTH_COMPONENT16), K
        }

        function M(P, E) {
            return g(P) === !0 || P.isFramebufferTexture && P.minFilter !== 1003 && P.minFilter !== 1006 ? Math.log2(Math.max(E.width, E.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? E.mipmaps.length : 1
        }

        function D(P) {
            const E = P.target;
            E.removeEventListener("dispose", D), w(E), E.isVideoTexture && f.delete(E)
        }

        function T(P) {
            const E = P.target;
            E.removeEventListener("dispose", T), y(E)
        }

        function w(P) {
            const E = n.get(P);
            if (E.__webglInit === void 0) return;
            const K = P.source,
                ne = d.get(K);
            if (ne) {
                const ie = ne[E.__cacheKey];
                ie.usedTimes--, ie.usedTimes === 0 && S(P), Object.keys(ne).length === 0 && d.delete(K)
            }
            n.remove(P)
        }

        function S(P) {
            const E = n.get(P);
            r.deleteTexture(E.__webglTexture);
            const K = P.source,
                ne = d.get(K);
            delete ne[E.__cacheKey], a.memory.textures--
        }

        function y(P) {
            const E = n.get(P);
            if (P.depthTexture && (P.depthTexture.dispose(), n.remove(P.depthTexture)), P.isWebGLCubeRenderTarget)
                for (let ne = 0; ne < 6; ne++) {
                    if (Array.isArray(E.__webglFramebuffer[ne]))
                        for (let ie = 0; ie < E.__webglFramebuffer[ne].length; ie++) r.deleteFramebuffer(E.__webglFramebuffer[ne][ie]);
                    else r.deleteFramebuffer(E.__webglFramebuffer[ne]);
                    E.__webglDepthbuffer && r.deleteRenderbuffer(E.__webglDepthbuffer[ne])
                } else {
                    if (Array.isArray(E.__webglFramebuffer))
                        for (let ne = 0; ne < E.__webglFramebuffer.length; ne++) r.deleteFramebuffer(E.__webglFramebuffer[ne]);
                    else r.deleteFramebuffer(E.__webglFramebuffer);
                    if (E.__webglDepthbuffer && r.deleteRenderbuffer(E.__webglDepthbuffer), E.__webglMultisampledFramebuffer && r.deleteFramebuffer(E.__webglMultisampledFramebuffer), E.__webglColorRenderbuffer)
                        for (let ne = 0; ne < E.__webglColorRenderbuffer.length; ne++) E.__webglColorRenderbuffer[ne] && r.deleteRenderbuffer(E.__webglColorRenderbuffer[ne]);
                    E.__webglDepthRenderbuffer && r.deleteRenderbuffer(E.__webglDepthRenderbuffer)
                }
            const K = P.textures;
            for (let ne = 0, ie = K.length; ne < ie; ne++) {
                const te = n.get(K[ne]);
                te.__webglTexture && (r.deleteTexture(te.__webglTexture), a.memory.textures--), n.remove(K[ne])
            }
            n.remove(P)
        }
        let C = 0;

        function O() {
            C = 0
        }

        function N() {
            const P = C;
            return P >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + i.maxTextures), C += 1, P
        }

        function V(P) {
            const E = [];
            return E.push(P.wrapS), E.push(P.wrapT), E.push(P.wrapR || 0), E.push(P.magFilter), E.push(P.minFilter), E.push(P.anisotropy), E.push(P.internalFormat), E.push(P.format), E.push(P.type), E.push(P.generateMipmaps), E.push(P.premultiplyAlpha), E.push(P.flipY), E.push(P.unpackAlignment), E.push(P.colorSpace), E.join()
        }

        function G(P, E) {
            const K = n.get(P);
            if (P.isVideoTexture && Ie(P), P.isRenderTargetTexture === !1 && P.version > 0 && K.__version !== P.version) {
                const ne = P.image;
                if (ne === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (ne.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    he(K, P, E);
                    return
                }
            }
            t.bindTexture(r.TEXTURE_2D, K.__webglTexture, r.TEXTURE0 + E)
        }

        function B(P, E) {
            const K = n.get(P);
            if (P.version > 0 && K.__version !== P.version) {
                he(K, P, E);
                return
            }
            t.bindTexture(r.TEXTURE_2D_ARRAY, K.__webglTexture, r.TEXTURE0 + E)
        }

        function j(P, E) {
            const K = n.get(P);
            if (P.version > 0 && K.__version !== P.version) {
                he(K, P, E);
                return
            }
            t.bindTexture(r.TEXTURE_3D, K.__webglTexture, r.TEXTURE0 + E)
        }

        function H(P, E) {
            const K = n.get(P);
            if (P.version > 0 && K.__version !== P.version) {
                fe(K, P, E);
                return
            }
            t.bindTexture(r.TEXTURE_CUBE_MAP, K.__webglTexture, r.TEXTURE0 + E)
        }
        const k = {
                1e3: r.REPEAT,
                1001: r.CLAMP_TO_EDGE,
                1002: r.MIRRORED_REPEAT
            },
            F = {
                1003: r.NEAREST,
                1004: r.NEAREST_MIPMAP_NEAREST,
                1005: r.NEAREST_MIPMAP_LINEAR,
                1006: r.LINEAR,
                1007: r.LINEAR_MIPMAP_NEAREST,
                1008: r.LINEAR_MIPMAP_LINEAR
            },
            se = {
                512: r.NEVER,
                519: r.ALWAYS,
                513: r.LESS,
                515: r.LEQUAL,
                514: r.EQUAL,
                518: r.GEQUAL,
                516: r.GREATER,
                517: r.NOTEQUAL
            };

        function de(P, E) {
            if (E.type === 1015 && e.has("OES_texture_float_linear") === !1 && (E.magFilter === 1006 || E.magFilter === 1007 || E.magFilter === 1005 || E.magFilter === 1008 || E.minFilter === 1006 || E.minFilter === 1007 || E.minFilter === 1005 || E.minFilter === 1008) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(P, r.TEXTURE_WRAP_S, k[E.wrapS]), r.texParameteri(P, r.TEXTURE_WRAP_T, k[E.wrapT]), (P === r.TEXTURE_3D || P === r.TEXTURE_2D_ARRAY) && r.texParameteri(P, r.TEXTURE_WRAP_R, k[E.wrapR]), r.texParameteri(P, r.TEXTURE_MAG_FILTER, F[E.magFilter]), r.texParameteri(P, r.TEXTURE_MIN_FILTER, F[E.minFilter]), E.compareFunction && (r.texParameteri(P, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(P, r.TEXTURE_COMPARE_FUNC, se[E.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                if (E.magFilter === 1003 || E.minFilter !== 1005 && E.minFilter !== 1008 || E.type === 1015 && e.has("OES_texture_float_linear") === !1) return;
                if (E.anisotropy > 1 || n.get(E).__currentAnisotropy) {
                    const K = e.get("EXT_texture_filter_anisotropic");
                    r.texParameterf(P, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(E.anisotropy, i.getMaxAnisotropy())), n.get(E).__currentAnisotropy = E.anisotropy
                }
            }
        }

        function ke(P, E) {
            let K = !1;
            P.__webglInit === void 0 && (P.__webglInit = !0, E.addEventListener("dispose", D));
            const ne = E.source;
            let ie = d.get(ne);
            ie === void 0 && (ie = {}, d.set(ne, ie));
            const te = V(E);
            if (te !== P.__cacheKey) {
                ie[te] === void 0 && (ie[te] = {
                    texture: r.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, K = !0), ie[te].usedTimes++;
                const Fe = ie[P.__cacheKey];
                Fe !== void 0 && (ie[P.__cacheKey].usedTimes--, Fe.usedTimes === 0 && S(E)), P.__cacheKey = te, P.__webglTexture = ie[te].texture
            }
            return K
        }

        function q(P, E, K) {
            return Math.floor(Math.floor(P / K) / E)
        }

        function ee(P, E, K, ne) {
            const te = P.updateRanges;
            if (te.length === 0) t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, E.width, E.height, K, ne, E.data);
            else {
                te.sort((pe, Ae) => pe.start - Ae.start);
                let Fe = 0;
                for (let pe = 1; pe < te.length; pe++) {
                    const Ae = te[Fe],
                        Ve = te[pe],
                        He = Ae.start + Ae.count,
                        Se = q(Ve.start, E.width, 4),
                        je = q(Ae.start, E.width, 4);
                    Ve.start <= He + 1 && Se === je && q(Ve.start + Ve.count - 1, E.width, 4) === Se ? Ae.count = Math.max(Ae.count, Ve.start + Ve.count - Ae.start) : (++Fe, te[Fe] = Ve)
                }
                te.length = Fe + 1;
                const ye = r.getParameter(r.UNPACK_ROW_LENGTH),
                    Oe = r.getParameter(r.UNPACK_SKIP_PIXELS),
                    De = r.getParameter(r.UNPACK_SKIP_ROWS);
                r.pixelStorei(r.UNPACK_ROW_LENGTH, E.width);
                for (let pe = 0, Ae = te.length; pe < Ae; pe++) {
                    const Ve = te[pe],
                        He = Math.floor(Ve.start / 4),
                        Se = Math.ceil(Ve.count / 4),
                        je = He % E.width,
                        I = Math.floor(He / E.width),
                        Me = Se,
                        oe = 1;
                    r.pixelStorei(r.UNPACK_SKIP_PIXELS, je), r.pixelStorei(r.UNPACK_SKIP_ROWS, I), t.texSubImage2D(r.TEXTURE_2D, 0, je, I, Me, oe, K, ne, E.data)
                }
                P.clearUpdateRanges(), r.pixelStorei(r.UNPACK_ROW_LENGTH, ye), r.pixelStorei(r.UNPACK_SKIP_PIXELS, Oe), r.pixelStorei(r.UNPACK_SKIP_ROWS, De)
            }
        }

        function he(P, E, K) {
            let ne = r.TEXTURE_2D;
            (E.isDataArrayTexture || E.isCompressedArrayTexture) && (ne = r.TEXTURE_2D_ARRAY), E.isData3DTexture && (ne = r.TEXTURE_3D);
            const ie = ke(P, E),
                te = E.source;
            t.bindTexture(ne, P.__webglTexture, r.TEXTURE0 + K);
            const Fe = n.get(te);
            if (te.version !== Fe.__version || ie === !0) {
                t.activeTexture(r.TEXTURE0 + K);
                const ye = xt.getPrimaries(xt.workingColorSpace),
                    Oe = E.colorSpace === Ir ? null : xt.getPrimaries(E.colorSpace),
                    De = E.colorSpace === Ir || ye === Oe ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, De);
                let pe = m(E.image, !1, i.maxTextureSize);
                pe = ge(E, pe);
                const Ae = s.convert(E.format, E.colorSpace),
                    Ve = s.convert(E.type);
                let He = x(E.internalFormat, Ae, Ve, E.colorSpace, E.isVideoTexture);
                de(ne, E);
                let Se;
                const je = E.mipmaps,
                    I = E.isVideoTexture !== !0,
                    Me = Fe.__version === void 0 || ie === !0,
                    oe = te.dataReady,
                    Ee = M(E, pe);
                if (E.isDepthTexture) He = b(E.format === 1027, E.type), Me && (I ? t.texStorage2D(r.TEXTURE_2D, 1, He, pe.width, pe.height) : t.texImage2D(r.TEXTURE_2D, 0, He, pe.width, pe.height, 0, Ae, Ve, null));
                else if (E.isDataTexture)
                    if (je.length > 0) {
                        I && Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, je[0].width, je[0].height);
                        for (let me = 0, le = je.length; me < le; me++) Se = je[me], I ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Ve, Se.data) : t.texImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Ae, Ve, Se.data);
                        E.generateMipmaps = !1
                    } else I ? (Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, pe.width, pe.height), oe && ee(E, pe, Ae, Ve)) : t.texImage2D(r.TEXTURE_2D, 0, He, pe.width, pe.height, 0, Ae, Ve, pe.data);
                else if (E.isCompressedTexture)
                    if (E.isCompressedArrayTexture) {
                        I && Me && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ee, He, je[0].width, je[0].height, pe.depth);
                        for (let me = 0, le = je.length; me < le; me++)
                            if (Se = je[me], E.format !== 1023)
                                if (Ae !== null)
                                    if (I) {
                                        if (oe)
                                            if (E.layerUpdates.size > 0) {
                                                const ae = Im(Se.width, Se.height, E.format, E.type);
                                                for (const L of E.layerUpdates) {
                                                    const re = Se.data.subarray(L * ae / Se.data.BYTES_PER_ELEMENT, (L + 1) * ae / Se.data.BYTES_PER_ELEMENT);
                                                    t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, L, Se.width, Se.height, 1, Ae, re)
                                                }
                                                E.clearLayerUpdates()
                                            } else t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, 0, Se.width, Se.height, pe.depth, Ae, Se.data)
                                    } else t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, me, He, Se.width, Se.height, pe.depth, 0, Se.data, 0, 0);
                        else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else I ? oe && t.texSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, 0, Se.width, Se.height, pe.depth, Ae, Ve, Se.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, me, He, Se.width, Se.height, pe.depth, 0, Ae, Ve, Se.data)
                    } else {
                        I && Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, je[0].width, je[0].height);
                        for (let me = 0, le = je.length; me < le; me++) Se = je[me], E.format !== 1023 ? Ae !== null ? I ? oe && t.compressedTexSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Se.data) : t.compressedTexImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : I ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Ve, Se.data) : t.texImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Ae, Ve, Se.data)
                    }
                else if (E.isDataArrayTexture)
                    if (I) {
                        if (Me && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ee, He, pe.width, pe.height, pe.depth), oe)
                            if (E.layerUpdates.size > 0) {
                                const me = Im(pe.width, pe.height, E.format, E.type);
                                for (const le of E.layerUpdates) {
                                    const ae = pe.data.subarray(le * me / pe.data.BYTES_PER_ELEMENT, (le + 1) * me / pe.data.BYTES_PER_ELEMENT);
                                    t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, le, pe.width, pe.height, 1, Ae, Ve, ae)
                                }
                                E.clearLayerUpdates()
                            } else t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Ae, Ve, pe.data)
                    } else t.texImage3D(r.TEXTURE_2D_ARRAY, 0, He, pe.width, pe.height, pe.depth, 0, Ae, Ve, pe.data);
                else if (E.isData3DTexture) I ? (Me && t.texStorage3D(r.TEXTURE_3D, Ee, He, pe.width, pe.height, pe.depth), oe && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Ae, Ve, pe.data)) : t.texImage3D(r.TEXTURE_3D, 0, He, pe.width, pe.height, pe.depth, 0, Ae, Ve, pe.data);
                else if (E.isFramebufferTexture) {
                    if (Me)
                        if (I) t.texStorage2D(r.TEXTURE_2D, Ee, He, pe.width, pe.height);
                        else {
                            let me = pe.width,
                                le = pe.height;
                            for (let ae = 0; ae < Ee; ae++) t.texImage2D(r.TEXTURE_2D, ae, He, me, le, 0, Ae, Ve, null), me >>= 1, le >>= 1
                        }
                } else if (je.length > 0) {
                    if (I && Me) {
                        const me = rt(je[0]);
                        t.texStorage2D(r.TEXTURE_2D, Ee, He, me.width, me.height)
                    }
                    for (let me = 0, le = je.length; me < le; me++) Se = je[me], I ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Ae, Ve, Se) : t.texImage2D(r.TEXTURE_2D, me, He, Ae, Ve, Se);
                    E.generateMipmaps = !1
                } else if (I) {
                    if (Me) {
                        const me = rt(pe);
                        t.texStorage2D(r.TEXTURE_2D, Ee, He, me.width, me.height)
                    }
                    oe && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ae, Ve, pe)
                } else t.texImage2D(r.TEXTURE_2D, 0, He, Ae, Ve, pe);
                g(E) && p(ne), Fe.__version = te.version, E.onUpdate && E.onUpdate(E)
            }
            P.__version = E.version
        }

        function fe(P, E, K) {
            if (E.image.length !== 6) return;
            const ne = ke(P, E),
                ie = E.source;
            t.bindTexture(r.TEXTURE_CUBE_MAP, P.__webglTexture, r.TEXTURE0 + K);
            const te = n.get(ie);
            if (ie.version !== te.__version || ne === !0) {
                t.activeTexture(r.TEXTURE0 + K);
                const Fe = xt.getPrimaries(xt.workingColorSpace),
                    ye = E.colorSpace === Ir ? null : xt.getPrimaries(E.colorSpace),
                    Oe = E.colorSpace === Ir || Fe === ye ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Oe);
                const De = E.isCompressedTexture || E.image[0].isCompressedTexture,
                    pe = E.image[0] && E.image[0].isDataTexture,
                    Ae = [];
                for (let le = 0; le < 6; le++) !De && !pe ? Ae[le] = m(E.image[le], !0, i.maxCubemapSize) : Ae[le] = pe ? E.image[le].image : E.image[le], Ae[le] = ge(E, Ae[le]);
                const Ve = Ae[0],
                    He = s.convert(E.format, E.colorSpace),
                    Se = s.convert(E.type),
                    je = x(E.internalFormat, He, Se, E.colorSpace),
                    I = E.isVideoTexture !== !0,
                    Me = te.__version === void 0 || ne === !0,
                    oe = ie.dataReady;
                let Ee = M(E, Ve);
                de(r.TEXTURE_CUBE_MAP, E);
                let me;
                if (De) {
                    I && Me && t.texStorage2D(r.TEXTURE_CUBE_MAP, Ee, je, Ve.width, Ve.height);
                    for (let le = 0; le < 6; le++) {
                        me = Ae[le].mipmaps;
                        for (let ae = 0; ae < me.length; ae++) {
                            const L = me[ae];
                            E.format !== 1023 ? He !== null ? I ? oe && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae, 0, 0, L.width, L.height, He, L.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae, je, L.width, L.height, 0, L.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : I ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae, 0, 0, L.width, L.height, He, Se, L.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae, je, L.width, L.height, 0, He, Se, L.data)
                        }
                    }
                } else {
                    if (me = E.mipmaps, I && Me) {
                        me.length > 0 && Ee++;
                        const le = rt(Ae[0]);
                        t.texStorage2D(r.TEXTURE_CUBE_MAP, Ee, je, le.width, le.height)
                    }
                    for (let le = 0; le < 6; le++)
                        if (pe) {
                            I ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, 0, 0, Ae[le].width, Ae[le].height, He, Se, Ae[le].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, je, Ae[le].width, Ae[le].height, 0, He, Se, Ae[le].data);
                            for (let ae = 0; ae < me.length; ae++) {
                                const re = me[ae].image[le].image;
                                I ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae + 1, 0, 0, re.width, re.height, He, Se, re.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae + 1, je, re.width, re.height, 0, He, Se, re.data)
                            }
                        } else {
                            I ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, 0, 0, He, Se, Ae[le]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0, je, He, Se, Ae[le]);
                            for (let ae = 0; ae < me.length; ae++) {
                                const L = me[ae];
                                I ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae + 1, 0, 0, He, Se, L.image[le]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + le, ae + 1, je, He, Se, L.image[le])
                            }
                        }
                }
                g(E) && p(r.TEXTURE_CUBE_MAP), te.__version = ie.version, E.onUpdate && E.onUpdate(E)
            }
            P.__version = E.version
        }

        function be(P, E, K, ne, ie, te) {
            const Fe = s.convert(K.format, K.colorSpace),
                ye = s.convert(K.type),
                Oe = x(K.internalFormat, Fe, ye, K.colorSpace),
                De = n.get(E),
                pe = n.get(K);
            if (pe.__renderTarget = E, !De.__hasExternalTextures) {
                const Ae = Math.max(1, E.width >> te),
                    Ve = Math.max(1, E.height >> te);
                ie === r.TEXTURE_3D || ie === r.TEXTURE_2D_ARRAY ? t.texImage3D(ie, te, Oe, Ae, Ve, E.depth, 0, Fe, ye, null) : t.texImage2D(ie, te, Oe, Ae, Ve, 0, Fe, ye, null)
            }
            t.bindFramebuffer(r.FRAMEBUFFER, P), Qe(E) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ne, ie, pe.__webglTexture, 0, ve(E)) : (ie === r.TEXTURE_2D || ie >= r.TEXTURE_CUBE_MAP_POSITIVE_X && ie <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ne, ie, pe.__webglTexture, te), t.bindFramebuffer(r.FRAMEBUFFER, null)
        }

        function Ye(P, E, K) {
            if (r.bindRenderbuffer(r.RENDERBUFFER, P), E.depthBuffer) {
                const ne = E.depthTexture,
                    ie = ne && ne.isDepthTexture ? ne.type : null,
                    te = b(E.stencilBuffer, ie),
                    Fe = E.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                    ye = ve(E);
                Qe(E) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ye, te, E.width, E.height) : K ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ye, te, E.width, E.height) : r.renderbufferStorage(r.RENDERBUFFER, te, E.width, E.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Fe, r.RENDERBUFFER, P)
            } else {
                const ne = E.textures;
                for (let ie = 0; ie < ne.length; ie++) {
                    const te = ne[ie],
                        Fe = s.convert(te.format, te.colorSpace),
                        ye = s.convert(te.type),
                        Oe = x(te.internalFormat, Fe, ye, te.colorSpace),
                        De = ve(E);
                    K && Qe(E) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, De, Oe, E.width, E.height) : Qe(E) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, De, Oe, E.width, E.height) : r.renderbufferStorage(r.RENDERBUFFER, Oe, E.width, E.height)
                }
            }
            r.bindRenderbuffer(r.RENDERBUFFER, null)
        }

        function Pe(P, E) {
            if (E && E.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(r.FRAMEBUFFER, P), !(E.depthTexture && E.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const ne = n.get(E.depthTexture);
            ne.__renderTarget = E, (!ne.__webglTexture || E.depthTexture.image.width !== E.width || E.depthTexture.image.height !== E.height) && (E.depthTexture.image.width = E.width, E.depthTexture.image.height = E.height, E.depthTexture.needsUpdate = !0), G(E.depthTexture, 0);
            const ie = ne.__webglTexture,
                te = ve(E);
            if (E.depthTexture.format === 1026) Qe(E) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ie, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ie, 0);
            else if (E.depthTexture.format === 1027) Qe(E) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ie, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ie, 0);
            else throw new Error("Unknown depthTexture format")
        }

        function Xe(P) {
            const E = n.get(P),
                K = P.isWebGLCubeRenderTarget === !0;
            if (E.__boundDepthTexture !== P.depthTexture) {
                const ne = P.depthTexture;
                if (E.__depthDisposeCallback && E.__depthDisposeCallback(), ne) {
                    const ie = () => {
                        delete E.__boundDepthTexture, delete E.__depthDisposeCallback, ne.removeEventListener("dispose", ie)
                    };
                    ne.addEventListener("dispose", ie), E.__depthDisposeCallback = ie
                }
                E.__boundDepthTexture = ne
            }
            if (P.depthTexture && !E.__autoAllocateDepthBuffer) {
                if (K) throw new Error("target.depthTexture not supported in Cube render targets");
                const ne = P.texture.mipmaps;
                ne && ne.length > 0 ? Pe(E.__webglFramebuffer[0], P) : Pe(E.__webglFramebuffer, P)
            } else if (K) {
                E.__webglDepthbuffer = [];
                for (let ne = 0; ne < 6; ne++)
                    if (t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer[ne]), E.__webglDepthbuffer[ne] === void 0) E.__webglDepthbuffer[ne] = r.createRenderbuffer(), Ye(E.__webglDepthbuffer[ne], P, !1);
                    else {
                        const ie = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                            te = E.__webglDepthbuffer[ne];
                        r.bindRenderbuffer(r.RENDERBUFFER, te), r.framebufferRenderbuffer(r.FRAMEBUFFER, ie, r.RENDERBUFFER, te)
                    }
            } else {
                const ne = P.texture.mipmaps;
                if (ne && ne.length > 0 ? t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer[0]) : t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer), E.__webglDepthbuffer === void 0) E.__webglDepthbuffer = r.createRenderbuffer(), Ye(E.__webglDepthbuffer, P, !1);
                else {
                    const ie = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                        te = E.__webglDepthbuffer;
                    r.bindRenderbuffer(r.RENDERBUFFER, te), r.framebufferRenderbuffer(r.FRAMEBUFFER, ie, r.RENDERBUFFER, te)
                }
            }
            t.bindFramebuffer(r.FRAMEBUFFER, null)
        }

        function tt(P, E, K) {
            const ne = n.get(P);
            E !== void 0 && be(ne.__webglFramebuffer, P, P.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), K !== void 0 && Xe(P)
        }

        function xe(P) {
            const E = P.texture,
                K = n.get(P),
                ne = n.get(E);
            P.addEventListener("dispose", T);
            const ie = P.textures,
                te = P.isWebGLCubeRenderTarget === !0,
                Fe = ie.length > 1;
            if (Fe || (ne.__webglTexture === void 0 && (ne.__webglTexture = r.createTexture()), ne.__version = E.version, a.memory.textures++), te) {
                K.__webglFramebuffer = [];
                for (let ye = 0; ye < 6; ye++)
                    if (E.mipmaps && E.mipmaps.length > 0) {
                        K.__webglFramebuffer[ye] = [];
                        for (let Oe = 0; Oe < E.mipmaps.length; Oe++) K.__webglFramebuffer[ye][Oe] = r.createFramebuffer()
                    } else K.__webglFramebuffer[ye] = r.createFramebuffer()
            } else {
                if (E.mipmaps && E.mipmaps.length > 0) {
                    K.__webglFramebuffer = [];
                    for (let ye = 0; ye < E.mipmaps.length; ye++) K.__webglFramebuffer[ye] = r.createFramebuffer()
                } else K.__webglFramebuffer = r.createFramebuffer();
                if (Fe)
                    for (let ye = 0, Oe = ie.length; ye < Oe; ye++) {
                        const De = n.get(ie[ye]);
                        De.__webglTexture === void 0 && (De.__webglTexture = r.createTexture(), a.memory.textures++)
                    }
                if (P.samples > 0 && Qe(P) === !1) {
                    K.__webglMultisampledFramebuffer = r.createFramebuffer(), K.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, K.__webglMultisampledFramebuffer);
                    for (let ye = 0; ye < ie.length; ye++) {
                        const Oe = ie[ye];
                        K.__webglColorRenderbuffer[ye] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, K.__webglColorRenderbuffer[ye]);
                        const De = s.convert(Oe.format, Oe.colorSpace),
                            pe = s.convert(Oe.type),
                            Ae = x(Oe.internalFormat, De, pe, Oe.colorSpace, P.isXRRenderTarget === !0),
                            Ve = ve(P);
                        r.renderbufferStorageMultisample(r.RENDERBUFFER, Ve, Ae, P.width, P.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.RENDERBUFFER, K.__webglColorRenderbuffer[ye])
                    }
                    r.bindRenderbuffer(r.RENDERBUFFER, null), P.depthBuffer && (K.__webglDepthRenderbuffer = r.createRenderbuffer(), Ye(K.__webglDepthRenderbuffer, P, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null)
                }
            }
            if (te) {
                t.bindTexture(r.TEXTURE_CUBE_MAP, ne.__webglTexture), de(r.TEXTURE_CUBE_MAP, E);
                for (let ye = 0; ye < 6; ye++)
                    if (E.mipmaps && E.mipmaps.length > 0)
                        for (let Oe = 0; Oe < E.mipmaps.length; Oe++) be(K.__webglFramebuffer[ye][Oe], P, E, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ye, Oe);
                    else be(K.__webglFramebuffer[ye], P, E, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0);
                g(E) && p(r.TEXTURE_CUBE_MAP), t.unbindTexture()
            } else if (Fe) {
                for (let ye = 0, Oe = ie.length; ye < Oe; ye++) {
                    const De = ie[ye],
                        pe = n.get(De);
                    t.bindTexture(r.TEXTURE_2D, pe.__webglTexture), de(r.TEXTURE_2D, De), be(K.__webglFramebuffer, P, De, r.COLOR_ATTACHMENT0 + ye, r.TEXTURE_2D, 0), g(De) && p(r.TEXTURE_2D)
                }
                t.unbindTexture()
            } else {
                let ye = r.TEXTURE_2D;
                if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (ye = P.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(ye, ne.__webglTexture), de(ye, E), E.mipmaps && E.mipmaps.length > 0)
                    for (let Oe = 0; Oe < E.mipmaps.length; Oe++) be(K.__webglFramebuffer[Oe], P, E, r.COLOR_ATTACHMENT0, ye, Oe);
                else be(K.__webglFramebuffer, P, E, r.COLOR_ATTACHMENT0, ye, 0);
                g(E) && p(ye), t.unbindTexture()
            }
            P.depthBuffer && Xe(P)
        }

        function R(P) {
            const E = P.textures;
            for (let K = 0, ne = E.length; K < ne; K++) {
                const ie = E[K];
                if (g(ie)) {
                    const te = v(P),
                        Fe = n.get(ie).__webglTexture;
                    t.bindTexture(te, Fe), p(te), t.unbindTexture()
                }
            }
        }
        const Ge = [],
            $e = [];

        function X(P) {
            if (P.samples > 0) {
                if (Qe(P) === !1) {
                    const E = P.textures,
                        K = P.width,
                        ne = P.height;
                    let ie = r.COLOR_BUFFER_BIT;
                    const te = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                        Fe = n.get(P),
                        ye = E.length > 1;
                    if (ye)
                        for (let De = 0; De < E.length; De++) t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + De, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + De, r.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(r.READ_FRAMEBUFFER, Fe.__webglMultisampledFramebuffer);
                    const Oe = P.texture.mipmaps;
                    Oe && Oe.length > 0 ? t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglFramebuffer[0]) : t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglFramebuffer);
                    for (let De = 0; De < E.length; De++) {
                        if (P.resolveDepthBuffer && (P.depthBuffer && (ie |= r.DEPTH_BUFFER_BIT), P.stencilBuffer && P.resolveStencilBuffer && (ie |= r.STENCIL_BUFFER_BIT)), ye) {
                            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Fe.__webglColorRenderbuffer[De]);
                            const pe = n.get(E[De]).__webglTexture;
                            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, pe, 0)
                        }
                        r.blitFramebuffer(0, 0, K, ne, 0, 0, K, ne, ie, r.NEAREST), l === !0 && (Ge.length = 0, $e.length = 0, Ge.push(r.COLOR_ATTACHMENT0 + De), P.depthBuffer && P.resolveDepthBuffer === !1 && (Ge.push(te), $e.push(te), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, $e)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Ge))
                    }
                    if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ye)
                        for (let De = 0; De < E.length; De++) {
                            t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + De, r.RENDERBUFFER, Fe.__webglColorRenderbuffer[De]);
                            const pe = n.get(E[De]).__webglTexture;
                            t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + De, r.TEXTURE_2D, pe, 0)
                        }
                    t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglMultisampledFramebuffer)
                } else if (P.depthBuffer && P.resolveDepthBuffer === !1 && l) {
                    const E = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [E])
                }
            }
        }

        function ve(P) {
            return Math.min(i.maxSamples, P.samples)
        }

        function Qe(P) {
            const E = n.get(P);
            return P.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && E.__useRenderToTexture !== !1
        }

        function Ie(P) {
            const E = a.render.frame;
            f.get(P) !== E && (f.set(P, E), P.update())
        }

        function ge(P, E) {
            const K = P.colorSpace,
                ne = P.format,
                ie = P.type;
            return P.isCompressedTexture === !0 || P.isVideoTexture === !0 || K !== yn && K !== Ir && (xt.getTransfer(K) === Rt ? (ne !== 1023 || ie !== 1009) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", K)), E
        }

        function rt(P) {
            return typeof HTMLImageElement < "u" && P instanceof HTMLImageElement ? (c.width = P.naturalWidth || P.width, c.height = P.naturalHeight || P.height) : typeof VideoFrame < "u" && P instanceof VideoFrame ? (c.width = P.displayWidth, c.height = P.displayHeight) : (c.width = P.width, c.height = P.height), c
        }
        this.allocateTextureUnit = N, this.resetTextureUnits = O, this.setTexture2D = G, this.setTexture2DArray = B, this.setTexture3D = j, this.setTextureCube = H, this.rebindTextures = tt, this.setupRenderTarget = xe, this.updateRenderTargetMipmap = R, this.updateMultisampleRenderTarget = X, this.setupDepthRenderbuffer = Xe, this.setupFrameBufferTexture = be, this.useMultisampledRTT = Qe
    }

    function HT(r, e) {
        function t(n, i = Ir) {
            let s;
            const a = xt.getTransfer(i);
            if (n === 1009) return r.UNSIGNED_BYTE;
            if (n === 1017) return r.UNSIGNED_SHORT_4_4_4_4;
            if (n === 1018) return r.UNSIGNED_SHORT_5_5_5_1;
            if (n === 35902) return r.UNSIGNED_INT_5_9_9_9_REV;
            if (n === 1010) return r.BYTE;
            if (n === 1011) return r.SHORT;
            if (n === 1012) return r.UNSIGNED_SHORT;
            if (n === 1013) return r.INT;
            if (n === 1014) return r.UNSIGNED_INT;
            if (n === 1015) return r.FLOAT;
            if (n === 1016) return r.HALF_FLOAT;
            if (n === 1021) return r.ALPHA;
            if (n === 1022) return r.RGB;
            if (n === 1023) return r.RGBA;
            if (n === 1026) return r.DEPTH_COMPONENT;
            if (n === 1027) return r.DEPTH_STENCIL;
            if (n === 1028) return r.RED;
            if (n === 1029) return r.RED_INTEGER;
            if (n === 1030) return r.RG;
            if (n === 1031) return r.RG_INTEGER;
            if (n === 1033) return r.RGBA_INTEGER;
            if (n === 33776 || n === 33777 || n === 33778 || n === 33779)
                if (a === Rt)
                    if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
                        if (n === 33776) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === 33777) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === 33778) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === 33779) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
                if (n === 33776) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === 33777) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === 33778) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === 33779) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else return null;
            if (n === 35840 || n === 35841 || n === 35842 || n === 35843)
                if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
                    if (n === 35840) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === 35841) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === 35842) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === 35843) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                } else return null;
            if (n === 36196 || n === 37492 || n === 37496)
                if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
                    if (n === 36196 || n === 37492) return a === Rt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                    if (n === 37496) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                } else return null;
            if (n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821)
                if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
                    if (n === 37808) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (n === 37809) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (n === 37810) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (n === 37811) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (n === 37812) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (n === 37813) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (n === 37814) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (n === 37815) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (n === 37816) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (n === 37817) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (n === 37818) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (n === 37819) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (n === 37820) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (n === 37821) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                } else return null;
            if (n === 36492 || n === 36494 || n === 36495)
                if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
                    if (n === 36492) return a === Rt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                    if (n === 36494) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                    if (n === 36495) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                } else return null;
            if (n === 36283 || n === 36284 || n === 36285 || n === 36286)
                if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
                    if (n === 36492) return s.COMPRESSED_RED_RGTC1_EXT;
                    if (n === 36284) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (n === 36285) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (n === 36286) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                } else return null;
            return n === 1020 ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
        }
        return {
            convert: t
        }
    }
    const VT = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
        WT = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class XT {
        constructor() {
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
        }
        init(e, t, n) {
            if (this.texture === null) {
                const i = new tn,
                    s = e.properties.get(i);
                s.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
            }
        }
        getMesh(e) {
            if (this.texture !== null && this.mesh === null) {
                const t = e.cameras[0].viewport,
                    n = new Hr({
                        vertexShader: VT,
                        fragmentShader: WT,
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                this.mesh = new ei(new Sc(20, 20), n)
            }
            return this.mesh
        }
        reset() {
            this.texture = null, this.mesh = null
        }
        getDepthTexture() {
            return this.texture
        }
    }
    class jT extends aa {
        constructor(e, t) {
            super();
            const n = this;
            let i = null,
                s = 1,
                a = null,
                o = "local-floor",
                l = 1,
                c = null,
                f = null,
                h = null,
                d = null,
                u = null,
                _ = null;
            const m = new XT,
                g = t.getContextAttributes();
            let p = null,
                v = null;
            const x = [],
                b = [],
                M = new pt;
            let D = null;
            const T = new Fn;
            T.viewport = new Tt;
            const w = new Fn;
            w.viewport = new Tt;
            const S = [T, w],
                y = new Uv;
            let C = null,
                O = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(q) {
                let ee = x[q];
                return ee === void 0 && (ee = new vf, x[q] = ee), ee.getTargetRaySpace()
            }, this.getControllerGrip = function(q) {
                let ee = x[q];
                return ee === void 0 && (ee = new vf, x[q] = ee), ee.getGripSpace()
            }, this.getHand = function(q) {
                let ee = x[q];
                return ee === void 0 && (ee = new vf, x[q] = ee), ee.getHandSpace()
            };

            function N(q) {
                const ee = b.indexOf(q.inputSource);
                if (ee === -1) return;
                const he = x[ee];
                he !== void 0 && (he.update(q.inputSource, q.frame, c || a), he.dispatchEvent({
                    type: q.type,
                    data: q.inputSource
                }))
            }

            function V() {
                i.removeEventListener("select", N), i.removeEventListener("selectstart", N), i.removeEventListener("selectend", N), i.removeEventListener("squeeze", N), i.removeEventListener("squeezestart", N), i.removeEventListener("squeezeend", N), i.removeEventListener("end", V), i.removeEventListener("inputsourceschange", G);
                for (let q = 0; q < x.length; q++) {
                    const ee = b[q];
                    ee !== null && (b[q] = null, x[q].disconnect(ee))
                }
                C = null, O = null, m.reset(), e.setRenderTarget(p), u = null, d = null, h = null, i = null, v = null, ke.stop(), n.isPresenting = !1, e.setPixelRatio(D), e.setSize(M.width, M.height, !1), n.dispatchEvent({
                    type: "sessionend"
                })
            }
            this.setFramebufferScaleFactor = function(q) {
                s = q, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function(q) {
                o = q, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function() {
                return c || a
            }, this.setReferenceSpace = function(q) {
                c = q
            }, this.getBaseLayer = function() {
                return d !== null ? d : u
            }, this.getBinding = function() {
                return h
            }, this.getFrame = function() {
                return _
            }, this.getSession = function() {
                return i
            }, this.setSession = async function(q) {
                if (i = q, i !== null) {
                    if (p = e.getRenderTarget(), i.addEventListener("select", N), i.addEventListener("selectstart", N), i.addEventListener("selectend", N), i.addEventListener("squeeze", N), i.addEventListener("squeezestart", N), i.addEventListener("squeezeend", N), i.addEventListener("end", V), i.addEventListener("inputsourceschange", G), g.xrCompatible !== !0 && await t.makeXRCompatible(), D = e.getPixelRatio(), e.getSize(M), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let he = null,
                            fe = null,
                            be = null;
                        g.depth && (be = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, he = g.stencil ? 1027 : 1026, fe = g.stencil ? 1020 : 1014);
                        const Ye = {
                            colorFormat: t.RGBA8,
                            depthFormat: be,
                            scaleFactor: s
                        };
                        h = new XRWebGLBinding(i, t), d = h.createProjectionLayer(Ye), i.updateRenderState({
                            layers: [d]
                        }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new bs(d.textureWidth, d.textureHeight, {
                            format: 1023,
                            type: 1009,
                            depthTexture: new Mm(d.textureWidth, d.textureHeight, fe, void 0, void 0, void 0, void 0, void 0, void 0, he),
                            stencilBuffer: g.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: g.antialias ? 4 : 0,
                            resolveDepthBuffer: d.ignoreDepthValues === !1,
                            resolveStencilBuffer: d.ignoreDepthValues === !1
                        })
                    } else {
                        const he = {
                            antialias: g.antialias,
                            alpha: !0,
                            depth: g.depth,
                            stencil: g.stencil,
                            framebufferScaleFactor: s
                        };
                        u = new XRWebGLLayer(i, t, he), i.updateRenderState({
                            baseLayer: u
                        }), e.setPixelRatio(1), e.setSize(u.framebufferWidth, u.framebufferHeight, !1), v = new bs(u.framebufferWidth, u.framebufferHeight, {
                            format: 1023,
                            type: 1009,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: g.stencil,
                            resolveDepthBuffer: u.ignoreDepthValues === !1,
                            resolveStencilBuffer: u.ignoreDepthValues === !1
                        })
                    }
                    v.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await i.requestReferenceSpace(o), ke.setContext(i), ke.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }, this.getEnvironmentBlendMode = function() {
                if (i !== null) return i.environmentBlendMode
            }, this.getDepthTexture = function() {
                return m.getDepthTexture()
            };

            function G(q) {
                for (let ee = 0; ee < q.removed.length; ee++) {
                    const he = q.removed[ee],
                        fe = b.indexOf(he);
                    fe >= 0 && (b[fe] = null, x[fe].disconnect(he))
                }
                for (let ee = 0; ee < q.added.length; ee++) {
                    const he = q.added[ee];
                    let fe = b.indexOf(he);
                    if (fe === -1) {
                        for (let Ye = 0; Ye < x.length; Ye++)
                            if (Ye >= b.length) {
                                b.push(he), fe = Ye;
                                break
                            } else if (b[Ye] === null) {
                            b[Ye] = he, fe = Ye;
                            break
                        }
                        if (fe === -1) break
                    }
                    const be = x[fe];
                    be && be.connect(he)
                }
            }
            const B = new Y,
                j = new Y;

            function H(q, ee, he) {
                B.setFromMatrixPosition(ee.matrixWorld), j.setFromMatrixPosition(he.matrixWorld);
                const fe = B.distanceTo(j),
                    be = ee.projectionMatrix.elements,
                    Ye = he.projectionMatrix.elements,
                    Pe = be[14] / (be[10] - 1),
                    Xe = be[14] / (be[10] + 1),
                    tt = (be[9] + 1) / be[5],
                    xe = (be[9] - 1) / be[5],
                    R = (be[8] - 1) / be[0],
                    Ge = (Ye[8] + 1) / Ye[0],
                    $e = Pe * R,
                    X = Pe * Ge,
                    ve = fe / (-R + Ge),
                    Qe = ve * -R;
                if (ee.matrixWorld.decompose(q.position, q.quaternion, q.scale), q.translateX(Qe), q.translateZ(ve), q.matrixWorld.compose(q.position, q.quaternion, q.scale), q.matrixWorldInverse.copy(q.matrixWorld).invert(), be[10] === -1) q.projectionMatrix.copy(ee.projectionMatrix), q.projectionMatrixInverse.copy(ee.projectionMatrixInverse);
                else {
                    const Ie = Pe + ve,
                        ge = Xe + ve,
                        rt = $e - Qe,
                        P = X + (fe - Qe),
                        E = tt * Xe / ge * Ie,
                        K = xe * Xe / ge * Ie;
                    q.projectionMatrix.makePerspective(rt, P, E, K, Ie, ge), q.projectionMatrixInverse.copy(q.projectionMatrix).invert()
                }
            }

            function k(q, ee) {
                ee === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(ee.matrixWorld, q.matrix), q.matrixWorldInverse.copy(q.matrixWorld).invert()
            }
            this.updateCamera = function(q) {
                if (i === null) return;
                let ee = q.near,
                    he = q.far;
                m.texture !== null && (m.depthNear > 0 && (ee = m.depthNear), m.depthFar > 0 && (he = m.depthFar)), y.near = w.near = T.near = ee, y.far = w.far = T.far = he, (C !== y.near || O !== y.far) && (i.updateRenderState({
                    depthNear: y.near,
                    depthFar: y.far
                }), C = y.near, O = y.far), T.layers.mask = q.layers.mask | 2, w.layers.mask = q.layers.mask | 4, y.layers.mask = T.layers.mask | w.layers.mask;
                const fe = q.parent,
                    be = y.cameras;
                k(y, fe);
                for (let Ye = 0; Ye < be.length; Ye++) k(be[Ye], fe);
                be.length === 2 ? H(y, T, w) : y.projectionMatrix.copy(T.projectionMatrix), F(q, y, fe)
            };

            function F(q, ee, he) {
                he === null ? q.matrix.copy(ee.matrixWorld) : (q.matrix.copy(he.matrixWorld), q.matrix.invert(), q.matrix.multiply(ee.matrixWorld)), q.matrix.decompose(q.position, q.quaternion, q.scale), q.updateMatrixWorld(!0), q.projectionMatrix.copy(ee.projectionMatrix), q.projectionMatrixInverse.copy(ee.projectionMatrixInverse), q.isPerspectiveCamera && (q.fov = oa * 2 * Math.atan(1 / q.projectionMatrix.elements[5]), q.zoom = 1)
            }
            this.getCamera = function() {
                return y
            }, this.getFoveation = function() {
                if (!(d === null && u === null)) return l
            }, this.setFoveation = function(q) {
                l = q, d !== null && (d.fixedFoveation = q), u !== null && u.fixedFoveation !== void 0 && (u.fixedFoveation = q)
            }, this.hasDepthSensing = function() {
                return m.texture !== null
            }, this.getDepthSensingMesh = function() {
                return m.getMesh(y)
            };
            let se = null;

            function de(q, ee) {
                if (f = ee.getViewerPose(c || a), _ = ee, f !== null) {
                    const he = f.views;
                    u !== null && (e.setRenderTargetFramebuffer(v, u.framebuffer), e.setRenderTarget(v));
                    let fe = !1;
                    he.length !== y.cameras.length && (y.cameras.length = 0, fe = !0);
                    for (let Pe = 0; Pe < he.length; Pe++) {
                        const Xe = he[Pe];
                        let tt = null;
                        if (u !== null) tt = u.getViewport(Xe);
                        else {
                            const R = h.getViewSubImage(d, Xe);
                            tt = R.viewport, Pe === 0 && (e.setRenderTargetTextures(v, R.colorTexture, R.depthStencilTexture), e.setRenderTarget(v))
                        }
                        let xe = S[Pe];
                        xe === void 0 && (xe = new Fn, xe.layers.enable(Pe), xe.viewport = new Tt, S[Pe] = xe), xe.matrix.fromArray(Xe.transform.matrix), xe.matrix.decompose(xe.position, xe.quaternion, xe.scale), xe.projectionMatrix.fromArray(Xe.projectionMatrix), xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(), xe.viewport.set(tt.x, tt.y, tt.width, tt.height), Pe === 0 && (y.matrix.copy(xe.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), fe === !0 && y.cameras.push(xe)
                    }
                    const be = i.enabledFeatures;
                    if (be && be.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && h) {
                        const Pe = h.getDepthInformation(he[0]);
                        Pe && Pe.isValid && Pe.texture && m.init(e, Pe, i.renderState)
                    }
                }
                for (let he = 0; he < x.length; he++) {
                    const fe = b[he],
                        be = x[he];
                    fe !== null && be !== void 0 && be.update(fe, ee, c || a)
                }
                se && se(q, ee), ee.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: ee
                }), _ = null
            }
            const ke = new Nm;
            ke.setAnimationLoop(de), this.setAnimationLoop = function(q) {
                se = q
            }, this.dispose = function() {}
        }
    }
    const ws = new ji,
        qT = new st;

    function YT(r, e) {
        function t(g, p) {
            g.matrixAutoUpdate === !0 && g.updateMatrix(), p.value.copy(g.matrix)
        }

        function n(g, p) {
            p.color.getRGB(g.fogColor.value, em(r)), p.isFog ? (g.fogNear.value = p.near, g.fogFar.value = p.far) : p.isFogExp2 && (g.fogDensity.value = p.density)
        }

        function i(g, p, v, x, b) {
            p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(g, p) : p.isMeshToonMaterial ? (s(g, p), h(g, p)) : p.isMeshPhongMaterial ? (s(g, p), f(g, p)) : p.isMeshStandardMaterial ? (s(g, p), d(g, p), p.isMeshPhysicalMaterial && u(g, p, b)) : p.isMeshMatcapMaterial ? (s(g, p), _(g, p)) : p.isMeshDepthMaterial ? s(g, p) : p.isMeshDistanceMaterial ? (s(g, p), m(g, p)) : p.isMeshNormalMaterial ? s(g, p) : p.isLineBasicMaterial ? (a(g, p), p.isLineDashedMaterial && o(g, p)) : p.isPointsMaterial ? l(g, p, v, x) : p.isSpriteMaterial ? c(g, p) : p.isShadowMaterial ? (g.color.value.copy(p.color), g.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
        }

        function s(g, p) {
            g.opacity.value = p.opacity, p.color && g.diffuse.value.copy(p.color), p.emissive && g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (g.map.value = p.map, t(p.map, g.mapTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.bumpMap && (g.bumpMap.value = p.bumpMap, t(p.bumpMap, g.bumpMapTransform), g.bumpScale.value = p.bumpScale, p.side === 1 && (g.bumpScale.value *= -1)), p.normalMap && (g.normalMap.value = p.normalMap, t(p.normalMap, g.normalMapTransform), g.normalScale.value.copy(p.normalScale), p.side === 1 && g.normalScale.value.negate()), p.displacementMap && (g.displacementMap.value = p.displacementMap, t(p.displacementMap, g.displacementMapTransform), g.displacementScale.value = p.displacementScale, g.displacementBias.value = p.displacementBias), p.emissiveMap && (g.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, g.emissiveMapTransform)), p.specularMap && (g.specularMap.value = p.specularMap, t(p.specularMap, g.specularMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
            const v = e.get(p),
                x = v.envMap,
                b = v.envMapRotation;
            x && (g.envMap.value = x, ws.copy(b), ws.x *= -1, ws.y *= -1, ws.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (ws.y *= -1, ws.z *= -1), g.envMapRotation.value.setFromMatrix4(qT.makeRotationFromEuler(ws)), g.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = p.reflectivity, g.ior.value = p.ior, g.refractionRatio.value = p.refractionRatio), p.lightMap && (g.lightMap.value = p.lightMap, g.lightMapIntensity.value = p.lightMapIntensity, t(p.lightMap, g.lightMapTransform)), p.aoMap && (g.aoMap.value = p.aoMap, g.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, g.aoMapTransform))
        }

        function a(g, p) {
            g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, p.map && (g.map.value = p.map, t(p.map, g.mapTransform))
        }

        function o(g, p) {
            g.dashSize.value = p.dashSize, g.totalSize.value = p.dashSize + p.gapSize, g.scale.value = p.scale
        }

        function l(g, p, v, x) {
            g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, g.size.value = p.size * v, g.scale.value = x * .5, p.map && (g.map.value = p.map, t(p.map, g.uvTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
        }

        function c(g, p) {
            g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, g.rotation.value = p.rotation, p.map && (g.map.value = p.map, t(p.map, g.mapTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
        }

        function f(g, p) {
            g.specular.value.copy(p.specular), g.shininess.value = Math.max(p.shininess, 1e-4)
        }

        function h(g, p) {
            p.gradientMap && (g.gradientMap.value = p.gradientMap)
        }

        function d(g, p) {
            g.metalness.value = p.metalness, p.metalnessMap && (g.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, g.metalnessMapTransform)), g.roughness.value = p.roughness, p.roughnessMap && (g.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, g.roughnessMapTransform)), p.envMap && (g.envMapIntensity.value = p.envMapIntensity)
        }

        function u(g, p, v) {
            g.ior.value = p.ior, p.sheen > 0 && (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), g.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (g.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, g.sheenColorMapTransform)), p.sheenRoughnessMap && (g.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))), p.clearcoat > 0 && (g.clearcoat.value = p.clearcoat, g.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (g.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, g.clearcoatMapTransform)), p.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (g.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === 1 && g.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (g.dispersion.value = p.dispersion), p.iridescence > 0 && (g.iridescence.value = p.iridescence, g.iridescenceIOR.value = p.iridescenceIOR, g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (g.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, g.iridescenceMapTransform)), p.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), p.transmission > 0 && (g.transmission.value = p.transmission, g.transmissionSamplerMap.value = v.texture, g.transmissionSamplerSize.value.set(v.width, v.height), p.transmissionMap && (g.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, g.transmissionMapTransform)), g.thickness.value = p.thickness, p.thicknessMap && (g.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = p.attenuationDistance, g.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (g.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (g.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = p.specularIntensity, g.specularColor.value.copy(p.specularColor), p.specularColorMap && (g.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, g.specularColorMapTransform)), p.specularIntensityMap && (g.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, g.specularIntensityMapTransform))
        }

        function _(g, p) {
            p.matcap && (g.matcap.value = p.matcap)
        }

        function m(g, p) {
            const v = e.get(p).light;
            g.referencePosition.value.setFromMatrixPosition(v.matrixWorld), g.nearDistance.value = v.shadow.camera.near, g.farDistance.value = v.shadow.camera.far
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: i
        }
    }

    function KT(r, e, t, n) {
        let i = {},
            s = {},
            a = [];
        const o = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);

        function l(v, x) {
            const b = x.program;
            n.uniformBlockBinding(v, b)
        }

        function c(v, x) {
            let b = i[v.id];
            b === void 0 && (_(v), b = f(v), i[v.id] = b, v.addEventListener("dispose", g));
            const M = x.program;
            n.updateUBOMapping(v, M);
            const D = e.render.frame;
            s[v.id] !== D && (d(v), s[v.id] = D)
        }

        function f(v) {
            const x = h();
            v.__bindingPointIndex = x;
            const b = r.createBuffer(),
                M = v.__size,
                D = v.usage;
            return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, M, D), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b
        }

        function h() {
            for (let v = 0; v < o; v++)
                if (a.indexOf(v) === -1) return a.push(v), v;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
        }

        function d(v) {
            const x = i[v.id],
                b = v.uniforms,
                M = v.__cache;
            r.bindBuffer(r.UNIFORM_BUFFER, x);
            for (let D = 0, T = b.length; D < T; D++) {
                const w = Array.isArray(b[D]) ? b[D] : [b[D]];
                for (let S = 0, y = w.length; S < y; S++) {
                    const C = w[S];
                    if (u(C, D, S, M) === !0) {
                        const O = C.__offset,
                            N = Array.isArray(C.value) ? C.value : [C.value];
                        let V = 0;
                        for (let G = 0; G < N.length; G++) {
                            const B = N[G],
                                j = m(B);
                            typeof B == "number" || typeof B == "boolean" ? (C.__data[0] = B, r.bufferSubData(r.UNIFORM_BUFFER, O + V, C.__data)) : B.isMatrix3 ? (C.__data[0] = B.elements[0], C.__data[1] = B.elements[1], C.__data[2] = B.elements[2], C.__data[3] = 0, C.__data[4] = B.elements[3], C.__data[5] = B.elements[4], C.__data[6] = B.elements[5], C.__data[7] = 0, C.__data[8] = B.elements[6], C.__data[9] = B.elements[7], C.__data[10] = B.elements[8], C.__data[11] = 0) : (B.toArray(C.__data, V), V += j.storage / Float32Array.BYTES_PER_ELEMENT)
                        }
                        r.bufferSubData(r.UNIFORM_BUFFER, O, C.__data)
                    }
                }
            }
            r.bindBuffer(r.UNIFORM_BUFFER, null)
        }

        function u(v, x, b, M) {
            const D = v.value,
                T = x + "_" + b;
            if (M[T] === void 0) return typeof D == "number" || typeof D == "boolean" ? M[T] = D : M[T] = D.clone(), !0; {
                const w = M[T];
                if (typeof D == "number" || typeof D == "boolean") {
                    if (w !== D) return M[T] = D, !0
                } else if (w.equals(D) === !1) return w.copy(D), !0
            }
            return !1
        }

        function _(v) {
            const x = v.uniforms;
            let b = 0;
            const M = 16;
            for (let T = 0, w = x.length; T < w; T++) {
                const S = Array.isArray(x[T]) ? x[T] : [x[T]];
                for (let y = 0, C = S.length; y < C; y++) {
                    const O = S[y],
                        N = Array.isArray(O.value) ? O.value : [O.value];
                    for (let V = 0, G = N.length; V < G; V++) {
                        const B = N[V],
                            j = m(B),
                            H = b % M,
                            k = H % j.boundary,
                            F = H + k;
                        b += k, F !== 0 && M - F < j.storage && (b += M - F), O.__data = new Float32Array(j.storage / Float32Array.BYTES_PER_ELEMENT), O.__offset = b, b += j.storage
                    }
                }
            }
            const D = b % M;
            return D > 0 && (b += M - D), v.__size = b, v.__cache = {}, this
        }

        function m(v) {
            const x = {
                boundary: 0,
                storage: 0
            };
            return typeof v == "number" || typeof v == "boolean" ? (x.boundary = 4, x.storage = 4) : v.isVector2 ? (x.boundary = 8, x.storage = 8) : v.isVector3 || v.isColor ? (x.boundary = 16, x.storage = 12) : v.isVector4 ? (x.boundary = 16, x.storage = 16) : v.isMatrix3 ? (x.boundary = 48, x.storage = 48) : v.isMatrix4 ? (x.boundary = 64, x.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), x
        }

        function g(v) {
            const x = v.target;
            x.removeEventListener("dispose", g);
            const b = a.indexOf(x.__bindingPointIndex);
            a.splice(b, 1), r.deleteBuffer(i[x.id]), delete i[x.id], delete s[x.id]
        }

        function p() {
            for (const v in i) r.deleteBuffer(i[v]);
            a = [], i = {}, s = {}
        }
        return {
            bind: l,
            update: c,
            dispose: p
        }
    }
    class $T {
        constructor(e = {}) {
            const {
                canvas: t = Cx(),
                context: n = null,
                depth: i = !0,
                stencil: s = !1,
                alpha: a = !1,
                antialias: o = !1,
                premultipliedAlpha: l = !0,
                preserveDrawingBuffer: c = !1,
                powerPreference: f = "default",
                failIfMajorPerformanceCaveat: h = !1,
                reverseDepthBuffer: d = !1
            } = e;
            this.isWebGLRenderer = !0;
            let u;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                u = n.getContextAttributes().alpha
            } else u = a;
            const _ = new Uint32Array(4),
                m = new Int32Array(4);
            let g = null,
                p = null;
            const v = [],
                x = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const b = this;
            let M = !1;
            this._outputColorSpace = Yt;
            let D = 0,
                T = 0,
                w = null,
                S = -1,
                y = null;
            const C = new Tt,
                O = new Tt;
            let N = null;
            const V = new it(0);
            let G = 0,
                B = t.width,
                j = t.height,
                H = 1,
                k = null,
                F = null;
            const se = new Tt(0, 0, B, j),
                de = new Tt(0, 0, B, j);
            let ke = !1;
            const q = new Af;
            let ee = !1,
                he = !1;
            const fe = new st,
                be = new st,
                Ye = new Y,
                Pe = new Tt,
                Xe = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
            let tt = !1;

            function xe() {
                return w === null ? H : 1
            }
            let R = n;

            function Ge(A, W) {
                return t.getContext(A, W)
            }
            try {
                const A = {
                    alpha: !0,
                    depth: i,
                    stencil: s,
                    antialias: o,
                    premultipliedAlpha: l,
                    preserveDrawingBuffer: c,
                    powerPreference: f,
                    failIfMajorPerformanceCaveat: h
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Ku}`), t.addEventListener("webglcontextlost", Ee, !1), t.addEventListener("webglcontextrestored", me, !1), t.addEventListener("webglcontextcreationerror", le, !1), R === null) {
                    const W = "webgl2";
                    if (R = Ge(W, A), R === null) throw Ge(W) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
            } catch (A) {
                throw console.error("THREE.WebGLRenderer: " + A.message), A
            }
            let $e, X, ve, Qe, Ie, ge, rt, P, E, K, ne, ie, te, Fe, ye, Oe, De, pe, Ae, Ve, He, Se, je, I;

            function Me() {
                $e = new aM(R), $e.init(), Se = new HT(R, $e), X = new QS(R, $e, e, Se), ve = new zT(R, $e), X.reverseDepthBuffer && d && ve.buffers.depth.setReversed(!0), Qe = new cM(R), Ie = new AT, ge = new GT(R, $e, ve, Ie, X, Se, Qe), rt = new tM(b), P = new sM(b), E = new Kv(R), je = new JS(R, E), K = new oM(R, E, Qe, je), ne = new fM(R, K, E, Qe), Ae = new uM(R, X, ge), Oe = new eM(Ie), ie = new DT(b, rt, P, $e, X, je, Oe), te = new YT(b, Ie), Fe = new CT, ye = new NT($e), pe = new $S(b, rt, P, ve, ne, u, l), De = new BT(b, ne, X), I = new KT(R, Qe, X, ve), Ve = new ZS(R, $e, Qe), He = new lM(R, $e, Qe), Qe.programs = ie.programs, b.capabilities = X, b.extensions = $e, b.properties = Ie, b.renderLists = Fe, b.shadowMap = De, b.state = ve, b.info = Qe
            }
            Me();
            const oe = new jT(b, R);
            this.xr = oe, this.getContext = function() {
                return R
            }, this.getContextAttributes = function() {
                return R.getContextAttributes()
            }, this.forceContextLoss = function() {
                const A = $e.get("WEBGL_lose_context");
                A && A.loseContext()
            }, this.forceContextRestore = function() {
                const A = $e.get("WEBGL_lose_context");
                A && A.restoreContext()
            }, this.getPixelRatio = function() {
                return H
            }, this.setPixelRatio = function(A) {
                A !== void 0 && (H = A, this.setSize(B, j, !1))
            }, this.getSize = function(A) {
                return A.set(B, j)
            }, this.setSize = function(A, W, Z = !0) {
                if (oe.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return
                }
                B = A, j = W, t.width = Math.floor(A * H), t.height = Math.floor(W * H), Z === !0 && (t.style.width = A + "px", t.style.height = W + "px"), this.setViewport(0, 0, A, W)
            }, this.getDrawingBufferSize = function(A) {
                return A.set(B * H, j * H).floor()
            }, this.setDrawingBufferSize = function(A, W, Z) {
                B = A, j = W, H = Z, t.width = Math.floor(A * Z), t.height = Math.floor(W * Z), this.setViewport(0, 0, A, W)
            }, this.getCurrentViewport = function(A) {
                return A.copy(C)
            }, this.getViewport = function(A) {
                return A.copy(se)
            }, this.setViewport = function(A, W, Z, $) {
                A.isVector4 ? se.set(A.x, A.y, A.z, A.w) : se.set(A, W, Z, $), ve.viewport(C.copy(se).multiplyScalar(H).round())
            }, this.getScissor = function(A) {
                return A.copy(de)
            }, this.setScissor = function(A, W, Z, $) {
                A.isVector4 ? de.set(A.x, A.y, A.z, A.w) : de.set(A, W, Z, $), ve.scissor(O.copy(de).multiplyScalar(H).round())
            }, this.getScissorTest = function() {
                return ke
            }, this.setScissorTest = function(A) {
                ve.setScissorTest(ke = A)
            }, this.setOpaqueSort = function(A) {
                k = A
            }, this.setTransparentSort = function(A) {
                F = A
            }, this.getClearColor = function(A) {
                return A.copy(pe.getClearColor())
            }, this.setClearColor = function() {
                pe.setClearColor(...arguments)
            }, this.getClearAlpha = function() {
                return pe.getClearAlpha()
            }, this.setClearAlpha = function() {
                pe.setClearAlpha(...arguments)
            }, this.clear = function(A = !0, W = !0, Z = !0) {
                let $ = 0;
                if (A) {
                    let z = !1;
                    if (w !== null) {
                        const _e = w.texture.format;
                        z = _e === 1033 || _e === 1031 || _e === 1029
                    }
                    if (z) {
                        const _e = w.texture.type,
                            Ce = _e === 1009 || _e === 1014 || _e === 1012 || _e === 1020 || _e === 1017 || _e === 1018,
                            ze = pe.getClearColor(),
                            Le = pe.getClearAlpha(),
                            qe = ze.r,
                            Je = ze.g,
                            We = ze.b;
                        Ce ? (_[0] = qe, _[1] = Je, _[2] = We, _[3] = Le, R.clearBufferuiv(R.COLOR, 0, _)) : (m[0] = qe, m[1] = Je, m[2] = We, m[3] = Le, R.clearBufferiv(R.COLOR, 0, m))
                    } else $ |= R.COLOR_BUFFER_BIT
                }
                W && ($ |= R.DEPTH_BUFFER_BIT), Z && ($ |= R.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), R.clear($)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", Ee, !1), t.removeEventListener("webglcontextrestored", me, !1), t.removeEventListener("webglcontextcreationerror", le, !1), pe.dispose(), Fe.dispose(), ye.dispose(), Ie.dispose(), rt.dispose(), P.dispose(), ne.dispose(), je.dispose(), I.dispose(), ie.dispose(), oe.dispose(), oe.removeEventListener("sessionstart", Q), oe.removeEventListener("sessionend", Te), ue.stop()
            };

            function Ee(A) {
                A.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = !0
            }

            function me() {
                console.log("THREE.WebGLRenderer: Context Restored."), M = !1;
                const A = Qe.autoReset,
                    W = De.enabled,
                    Z = De.autoUpdate,
                    $ = De.needsUpdate,
                    z = De.type;
                Me(), Qe.autoReset = A, De.enabled = W, De.autoUpdate = Z, De.needsUpdate = $, De.type = z
            }

            function le(A) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", A.statusMessage)
            }

            function ae(A) {
                const W = A.target;
                W.removeEventListener("dispose", ae), L(W)
            }

            function L(A) {
                re(A), Ie.remove(A)
            }

            function re(A) {
                const W = Ie.get(A).programs;
                W !== void 0 && (W.forEach(function(Z) {
                    ie.releaseProgram(Z)
                }), A.isShaderMaterial && ie.releaseShaderCache(A))
            }
            this.renderBufferDirect = function(A, W, Z, $, z, _e) {
                W === null && (W = Xe);
                const Ce = z.isMesh && z.matrixWorld.determinant() < 0,
                    ze = Et(A, W, Z, $, z);
                ve.setMaterial($, Ce);
                let Le = Z.index,
                    qe = 1;
                if ($.wireframe === !0) {
                    if (Le = K.getWireframeAttribute(Z), Le === void 0) return;
                    qe = 2
                }
                const Je = Z.drawRange,
                    We = Z.attributes.position;
                let lt = Je.start * qe,
                    Ct = (Je.start + Je.count) * qe;
                _e !== null && (lt = Math.max(lt, _e.start * qe), Ct = Math.min(Ct, (_e.start + _e.count) * qe)), Le !== null ? (lt = Math.max(lt, 0), Ct = Math.min(Ct, Le.count)) : We != null && (lt = Math.max(lt, 0), Ct = Math.min(Ct, We.count));
                const Xt = Ct - lt;
                if (Xt < 0 || Xt === 1 / 0) return;
                je.setup(z, $, ze, Z, Le);
                let qt, Mt = Ve;
                if (Le !== null && (qt = E.get(Le), Mt = He, Mt.setIndex(qt)), z.isMesh) $.wireframe === !0 ? (ve.setLineWidth($.wireframeLinewidth * xe()), Mt.setMode(R.LINES)) : Mt.setMode(R.TRIANGLES);
                else if (z.isLine) {
                    let Ze = $.linewidth;
                    Ze === void 0 && (Ze = 1), ve.setLineWidth(Ze * xe()), z.isLineSegments ? Mt.setMode(R.LINES) : z.isLineLoop ? Mt.setMode(R.LINE_LOOP) : Mt.setMode(R.LINE_STRIP)
                } else z.isPoints ? Mt.setMode(R.POINTS) : z.isSprite && Mt.setMode(R.TRIANGLES);
                if (z.isBatchedMesh)
                    if (z._multiDrawInstances !== null) la("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Mt.renderMultiDrawInstances(z._multiDrawStarts, z._multiDrawCounts, z._multiDrawCount, z._multiDrawInstances);
                    else if ($e.get("WEBGL_multi_draw")) Mt.renderMultiDraw(z._multiDrawStarts, z._multiDrawCounts, z._multiDrawCount);
                else {
                    const Ze = z._multiDrawStarts,
                        vn = z._multiDrawCounts,
                        Dt = z._multiDrawCount,
                        Wi = Le ? E.get(Le).bytesPerElement : 1,
                        yo = Ie.get($).currentProgram.getUniforms();
                    for (let ui = 0; ui < Dt; ui++) yo.setValue(R, "_gl_DrawID", ui), Mt.render(Ze[ui] / Wi, vn[ui])
                } else if (z.isInstancedMesh) Mt.renderInstances(lt, Xt, z.count);
                else if (Z.isInstancedBufferGeometry) {
                    const Ze = Z._maxInstanceCount !== void 0 ? Z._maxInstanceCount : 1 / 0,
                        vn = Math.min(Z.instanceCount, Ze);
                    Mt.renderInstances(lt, Xt, vn)
                } else Mt.render(lt, Xt)
            };

            function U(A, W, Z) {
                A.transparent === !0 && A.side === 2 && A.forceSinglePass === !1 ? (A.side = 1, A.needsUpdate = !0, _t(A, W, Z), A.side = 0, A.needsUpdate = !0, _t(A, W, Z), A.side = 2) : _t(A, W, Z)
            }
            this.compile = function(A, W, Z = null) {
                Z === null && (Z = A), p = ye.get(Z), p.init(W), x.push(p), Z.traverseVisible(function(z) {
                    z.isLight && z.layers.test(W.layers) && (p.pushLight(z), z.castShadow && p.pushShadow(z))
                }), A !== Z && A.traverseVisible(function(z) {
                    z.isLight && z.layers.test(W.layers) && (p.pushLight(z), z.castShadow && p.pushShadow(z))
                }), p.setupLights();
                const $ = new Set;
                return A.traverse(function(z) {
                    if (!(z.isMesh || z.isPoints || z.isLine || z.isSprite)) return;
                    const _e = z.material;
                    if (_e)
                        if (Array.isArray(_e))
                            for (let Ce = 0; Ce < _e.length; Ce++) {
                                const ze = _e[Ce];
                                U(ze, Z, z), $.add(ze)
                            } else U(_e, Z, z), $.add(_e)
                }), p = x.pop(), $
            }, this.compileAsync = function(A, W, Z = null) {
                const $ = this.compile(A, W, Z);
                return new Promise(z => {
                    function _e() {
                        if ($.forEach(function(Ce) {
                                Ie.get(Ce).currentProgram.isReady() && $.delete(Ce)
                            }), $.size === 0) {
                            z(A);
                            return
                        }
                        setTimeout(_e, 10)
                    }
                    $e.get("KHR_parallel_shader_compile") !== null ? _e() : setTimeout(_e, 10)
                })
            };
            let J = null;

            function ce(A) {
                J && J(A)
            }

            function Q() {
                ue.stop()
            }

            function Te() {
                ue.start()
            }
            const ue = new Nm;
            ue.setAnimationLoop(ce), typeof self < "u" && ue.setContext(self), this.setAnimationLoop = function(A) {
                J = A, oe.setAnimationLoop(A), A === null ? ue.stop() : ue.start()
            }, oe.addEventListener("sessionstart", Q), oe.addEventListener("sessionend", Te), this.render = function(A, W) {
                if (W !== void 0 && W.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return
                }
                if (M === !0) return;
                if (A.matrixWorldAutoUpdate === !0 && A.updateMatrixWorld(), W.parent === null && W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), oe.enabled === !0 && oe.isPresenting === !0 && (oe.cameraAutoUpdate === !0 && oe.updateCamera(W), W = oe.getCamera()), A.isScene === !0 && A.onBeforeRender(b, A, W, w), p = ye.get(A, x.length), p.init(W), x.push(p), be.multiplyMatrices(W.projectionMatrix, W.matrixWorldInverse), q.setFromProjectionMatrix(be), he = this.localClippingEnabled, ee = Oe.init(this.clippingPlanes, he), g = Fe.get(A, v.length), g.init(), v.push(g), oe.enabled === !0 && oe.isPresenting === !0) {
                    const _e = b.xr.getDepthSensingMesh();
                    _e !== null && we(_e, W, -1 / 0, b.sortObjects)
                }
                we(A, W, 0, b.sortObjects), g.finish(), b.sortObjects === !0 && g.sort(k, F), tt = oe.enabled === !1 || oe.isPresenting === !1 || oe.hasDepthSensing() === !1, tt && pe.addToRenderList(g, A), this.info.render.frame++, ee === !0 && Oe.beginShadows();
                const Z = p.state.shadowsArray;
                De.render(Z, A, W), ee === !0 && Oe.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const $ = g.opaque,
                    z = g.transmissive;
                if (p.setupLights(), W.isArrayCamera) {
                    const _e = W.cameras;
                    if (z.length > 0)
                        for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) {
                            const Le = _e[Ce];
                            Ue($, z, A, Le)
                        }
                    tt && pe.render(A);
                    for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) {
                        const Le = _e[Ce];
                        Ke(g, A, Le, Le.viewport)
                    }
                } else z.length > 0 && Ue($, z, A, W), tt && pe.render(A), Ke(g, A, W);
                w !== null && T === 0 && (ge.updateMultisampleRenderTarget(w), ge.updateRenderTargetMipmap(w)), A.isScene === !0 && A.onAfterRender(b, A, W), je.resetDefaultState(), S = -1, y = null, x.pop(), x.length > 0 ? (p = x[x.length - 1], ee === !0 && Oe.setGlobalState(b.clippingPlanes, p.state.camera)) : p = null, v.pop(), v.length > 0 ? g = v[v.length - 1] : g = null
            };

            function we(A, W, Z, $) {
                if (A.visible === !1) return;
                if (A.layers.test(W.layers)) {
                    if (A.isGroup) Z = A.renderOrder;
                    else if (A.isLOD) A.autoUpdate === !0 && A.update(W);
                    else if (A.isLight) p.pushLight(A), A.castShadow && p.pushShadow(A);
                    else if (A.isSprite) {
                        if (!A.frustumCulled || q.intersectsSprite(A)) {
                            $ && Pe.setFromMatrixPosition(A.matrixWorld).applyMatrix4(be);
                            const Ce = ne.update(A),
                                ze = A.material;
                            ze.visible && g.push(A, Ce, ze, Z, Pe.z, null)
                        }
                    } else if ((A.isMesh || A.isLine || A.isPoints) && (!A.frustumCulled || q.intersectsObject(A))) {
                        const Ce = ne.update(A),
                            ze = A.material;
                        if ($ && (A.boundingSphere !== void 0 ? (A.boundingSphere === null && A.computeBoundingSphere(), Pe.copy(A.boundingSphere.center)) : (Ce.boundingSphere === null && Ce.computeBoundingSphere(), Pe.copy(Ce.boundingSphere.center)), Pe.applyMatrix4(A.matrixWorld).applyMatrix4(be)), Array.isArray(ze)) {
                            const Le = Ce.groups;
                            for (let qe = 0, Je = Le.length; qe < Je; qe++) {
                                const We = Le[qe],
                                    lt = ze[We.materialIndex];
                                lt && lt.visible && g.push(A, Ce, lt, Z, Pe.z, We)
                            }
                        } else ze.visible && g.push(A, Ce, ze, Z, Pe.z, null)
                    }
                }
                const _e = A.children;
                for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) we(_e[Ce], W, Z, $)
            }

            function Ke(A, W, Z, $) {
                const z = A.opaque,
                    _e = A.transmissive,
                    Ce = A.transparent;
                p.setupLightsView(Z), ee === !0 && Oe.setGlobalState(b.clippingPlanes, Z), $ && ve.viewport(C.copy($)), z.length > 0 && et(z, W, Z), _e.length > 0 && et(_e, W, Z), Ce.length > 0 && et(Ce, W, Z), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1)
            }

            function Ue(A, W, Z, $) {
                if ((Z.isScene === !0 ? Z.overrideMaterial : null) !== null) return;
                p.state.transmissionRenderTarget[$.id] === void 0 && (p.state.transmissionRenderTarget[$.id] = new bs(1, 1, {
                    generateMipmaps: !0,
                    type: $e.has("EXT_color_buffer_half_float") || $e.has("EXT_color_buffer_float") ? 1016 : 1009,
                    minFilter: 1008,
                    samples: 4,
                    stencilBuffer: s,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: xt.workingColorSpace
                }));
                const _e = p.state.transmissionRenderTarget[$.id],
                    Ce = $.viewport || C;
                _e.setSize(Ce.z * b.transmissionResolutionScale, Ce.w * b.transmissionResolutionScale);
                const ze = b.getRenderTarget();
                b.setRenderTarget(_e), b.getClearColor(V), G = b.getClearAlpha(), G < 1 && b.setClearColor(16777215, .5), b.clear(), tt && pe.render(Z);
                const Le = b.toneMapping;
                b.toneMapping = 0;
                const qe = $.viewport;
                if ($.viewport !== void 0 && ($.viewport = void 0), p.setupLightsView($), ee === !0 && Oe.setGlobalState(b.clippingPlanes, $), et(A, Z, $), ge.updateMultisampleRenderTarget(_e), ge.updateRenderTargetMipmap(_e), $e.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let Je = !1;
                    for (let We = 0, lt = W.length; We < lt; We++) {
                        const Ct = W[We],
                            Xt = Ct.object,
                            qt = Ct.geometry,
                            Mt = Ct.material,
                            Ze = Ct.group;
                        if (Mt.side === 2 && Xt.layers.test($.layers)) {
                            const vn = Mt.side;
                            Mt.side = 1, Mt.needsUpdate = !0, bt(Xt, Z, $, qt, Mt, Ze), Mt.side = vn, Mt.needsUpdate = !0, Je = !0
                        }
                    }
                    Je === !0 && (ge.updateMultisampleRenderTarget(_e), ge.updateRenderTargetMipmap(_e))
                }
                b.setRenderTarget(ze), b.setClearColor(V, G), qe !== void 0 && ($.viewport = qe), b.toneMapping = Le
            }

            function et(A, W, Z) {
                const $ = W.isScene === !0 ? W.overrideMaterial : null;
                for (let z = 0, _e = A.length; z < _e; z++) {
                    const Ce = A[z],
                        ze = Ce.object,
                        Le = Ce.geometry,
                        qe = Ce.group;
                    let Je = Ce.material;
                    Je.allowOverride === !0 && $ !== null && (Je = $), ze.layers.test(Z.layers) && bt(ze, W, Z, Le, Je, qe)
                }
            }

            function bt(A, W, Z, $, z, _e) {
                A.onBeforeRender(b, W, Z, $, z, _e), A.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse, A.matrixWorld), A.normalMatrix.getNormalMatrix(A.modelViewMatrix), z.onBeforeRender(b, W, Z, $, A, _e), z.transparent === !0 && z.side === 2 && z.forceSinglePass === !1 ? (z.side = 1, z.needsUpdate = !0, b.renderBufferDirect(Z, W, $, z, A, _e), z.side = 0, z.needsUpdate = !0, b.renderBufferDirect(Z, W, $, z, A, _e), z.side = 2) : b.renderBufferDirect(Z, W, $, z, A, _e), A.onAfterRender(b, W, Z, $, z, _e)
            }

            function _t(A, W, Z) {
                W.isScene !== !0 && (W = Xe);
                const $ = Ie.get(A),
                    z = p.state.lights,
                    _e = p.state.shadowsArray,
                    Ce = z.state.version,
                    ze = ie.getParameters(A, z.state, _e, W, Z),
                    Le = ie.getProgramCacheKey(ze);
                let qe = $.programs;
                $.environment = A.isMeshStandardMaterial ? W.environment : null, $.fog = W.fog, $.envMap = (A.isMeshStandardMaterial ? P : rt).get(A.envMap || $.environment), $.envMapRotation = $.environment !== null && A.envMap === null ? W.environmentRotation : A.envMapRotation, qe === void 0 && (A.addEventListener("dispose", ae), qe = new Map, $.programs = qe);
                let Je = qe.get(Le);
                if (Je !== void 0) {
                    if ($.currentProgram === Je && $.lightsStateVersion === Ce) return ut(A, ze), Je
                } else ze.uniforms = ie.getUniforms(A), A.onBeforeCompile(ze, b), Je = ie.acquireProgram(ze, Le), qe.set(Le, Je), $.uniforms = ze.uniforms;
                const We = $.uniforms;
                return (!A.isShaderMaterial && !A.isRawShaderMaterial || A.clipping === !0) && (We.clippingPlanes = Oe.uniform), ut(A, ze), $.needsLights = cn(A), $.lightsStateVersion = Ce, $.needsLights && (We.ambientLightColor.value = z.state.ambient, We.lightProbe.value = z.state.probe, We.directionalLights.value = z.state.directional, We.directionalLightShadows.value = z.state.directionalShadow, We.spotLights.value = z.state.spot, We.spotLightShadows.value = z.state.spotShadow, We.rectAreaLights.value = z.state.rectArea, We.ltc_1.value = z.state.rectAreaLTC1, We.ltc_2.value = z.state.rectAreaLTC2, We.pointLights.value = z.state.point, We.pointLightShadows.value = z.state.pointShadow, We.hemisphereLights.value = z.state.hemi, We.directionalShadowMap.value = z.state.directionalShadowMap, We.directionalShadowMatrix.value = z.state.directionalShadowMatrix, We.spotShadowMap.value = z.state.spotShadowMap, We.spotLightMatrix.value = z.state.spotLightMatrix, We.spotLightMap.value = z.state.spotLightMap, We.pointShadowMap.value = z.state.pointShadowMap, We.pointShadowMatrix.value = z.state.pointShadowMatrix), $.currentProgram = Je, $.uniformsList = null, Je
            }

            function ct(A) {
                if (A.uniformsList === null) {
                    const W = A.currentProgram.getUniforms();
                    A.uniformsList = wc.seqWithValue(W.seq, A.uniforms)
                }
                return A.uniformsList
            }

            function ut(A, W) {
                const Z = Ie.get(A);
                Z.outputColorSpace = W.outputColorSpace, Z.batching = W.batching, Z.batchingColor = W.batchingColor, Z.instancing = W.instancing, Z.instancingColor = W.instancingColor, Z.instancingMorph = W.instancingMorph, Z.skinning = W.skinning, Z.morphTargets = W.morphTargets, Z.morphNormals = W.morphNormals, Z.morphColors = W.morphColors, Z.morphTargetsCount = W.morphTargetsCount, Z.numClippingPlanes = W.numClippingPlanes, Z.numIntersection = W.numClipIntersection, Z.vertexAlphas = W.vertexAlphas, Z.vertexTangents = W.vertexTangents, Z.toneMapping = W.toneMapping
            }

            function Et(A, W, Z, $, z) {
                W.isScene !== !0 && (W = Xe), ge.resetTextureUnits();
                const _e = W.fog,
                    Ce = $.isMeshStandardMaterial ? W.environment : null,
                    ze = w === null ? b.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : yn,
                    Le = ($.isMeshStandardMaterial ? P : rt).get($.envMap || Ce),
                    qe = $.vertexColors === !0 && !!Z.attributes.color && Z.attributes.color.itemSize === 4,
                    Je = !!Z.attributes.tangent && (!!$.normalMap || $.anisotropy > 0),
                    We = !!Z.morphAttributes.position,
                    lt = !!Z.morphAttributes.normal,
                    Ct = !!Z.morphAttributes.color;
                let Xt = 0;
                $.toneMapped && (w === null || w.isXRRenderTarget === !0) && (Xt = b.toneMapping);
                const qt = Z.morphAttributes.position || Z.morphAttributes.normal || Z.morphAttributes.color,
                    Mt = qt !== void 0 ? qt.length : 0,
                    Ze = Ie.get($),
                    vn = p.state.lights;
                if (ee === !0 && (he === !0 || A !== y)) {
                    const Vn = A === y && $.id === S;
                    Oe.setState($, A, Vn)
                }
                let Dt = !1;
                $.version === Ze.__version ? (Ze.needsLights && Ze.lightsStateVersion !== vn.state.version || Ze.outputColorSpace !== ze || z.isBatchedMesh && Ze.batching === !1 || !z.isBatchedMesh && Ze.batching === !0 || z.isBatchedMesh && Ze.batchingColor === !0 && z.colorTexture === null || z.isBatchedMesh && Ze.batchingColor === !1 && z.colorTexture !== null || z.isInstancedMesh && Ze.instancing === !1 || !z.isInstancedMesh && Ze.instancing === !0 || z.isSkinnedMesh && Ze.skinning === !1 || !z.isSkinnedMesh && Ze.skinning === !0 || z.isInstancedMesh && Ze.instancingColor === !0 && z.instanceColor === null || z.isInstancedMesh && Ze.instancingColor === !1 && z.instanceColor !== null || z.isInstancedMesh && Ze.instancingMorph === !0 && z.morphTexture === null || z.isInstancedMesh && Ze.instancingMorph === !1 && z.morphTexture !== null || Ze.envMap !== Le || $.fog === !0 && Ze.fog !== _e || Ze.numClippingPlanes !== void 0 && (Ze.numClippingPlanes !== Oe.numPlanes || Ze.numIntersection !== Oe.numIntersection) || Ze.vertexAlphas !== qe || Ze.vertexTangents !== Je || Ze.morphTargets !== We || Ze.morphNormals !== lt || Ze.morphColors !== Ct || Ze.toneMapping !== Xt || Ze.morphTargetsCount !== Mt) && (Dt = !0) : (Dt = !0, Ze.__version = $.version);
                let Wi = Ze.currentProgram;
                Dt === !0 && (Wi = _t($, W, z));
                let yo = !1,
                    ui = !1,
                    Kl = !1;
                const kt = Wi.getUniforms(),
                    Mi = Ze.uniforms;
                if (ve.useProgram(Wi.program) && (yo = !0, ui = !0, Kl = !0), $.id !== S && (S = $.id, ui = !0), yo || y !== A) {
                    ve.buffers.depth.getReversed() ? (fe.copy(A.projectionMatrix), Px(fe), Fx(fe), kt.setValue(R, "projectionMatrix", fe)) : kt.setValue(R, "projectionMatrix", A.projectionMatrix), kt.setValue(R, "viewMatrix", A.matrixWorldInverse);
                    const Jn = kt.map.cameraPosition;
                    Jn !== void 0 && Jn.setValue(R, Ye.setFromMatrixPosition(A.matrixWorld)), X.logarithmicDepthBuffer && kt.setValue(R, "logDepthBufFC", 2 / (Math.log(A.far + 1) / Math.LN2)), ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial) && kt.setValue(R, "isOrthographic", A.isOrthographicCamera === !0), y !== A && (y = A, ui = !0, Kl = !0)
                }
                if (z.isSkinnedMesh) {
                    kt.setOptional(R, z, "bindMatrix"), kt.setOptional(R, z, "bindMatrixInverse");
                    const Vn = z.skeleton;
                    Vn && (Vn.boneTexture === null && Vn.computeBoneTexture(), kt.setValue(R, "boneTexture", Vn.boneTexture, ge))
                }
                z.isBatchedMesh && (kt.setOptional(R, z, "batchingTexture"), kt.setValue(R, "batchingTexture", z._matricesTexture, ge), kt.setOptional(R, z, "batchingIdTexture"), kt.setValue(R, "batchingIdTexture", z._indirectTexture, ge), kt.setOptional(R, z, "batchingColorTexture"), z._colorsTexture !== null && kt.setValue(R, "batchingColorTexture", z._colorsTexture, ge));
                const Ti = Z.morphAttributes;
                if ((Ti.position !== void 0 || Ti.normal !== void 0 || Ti.color !== void 0) && Ae.update(z, Z, Wi), (ui || Ze.receiveShadow !== z.receiveShadow) && (Ze.receiveShadow = z.receiveShadow, kt.setValue(R, "receiveShadow", z.receiveShadow)), $.isMeshGouraudMaterial && $.envMap !== null && (Mi.envMap.value = Le, Mi.flipEnvMap.value = Le.isCubeTexture && Le.isRenderTargetTexture === !1 ? -1 : 1), $.isMeshStandardMaterial && $.envMap === null && W.environment !== null && (Mi.envMapIntensity.value = W.environmentIntensity), ui && (kt.setValue(R, "toneMappingExposure", b.toneMappingExposure), Ze.needsLights && nt(Mi, Kl), _e && $.fog === !0 && te.refreshFogUniforms(Mi, _e), te.refreshMaterialUniforms(Mi, $, H, j, p.state.transmissionRenderTarget[A.id]), wc.upload(R, ct(Ze), Mi, ge)), $.isShaderMaterial && $.uniformsNeedUpdate === !0 && (wc.upload(R, ct(Ze), Mi, ge), $.uniformsNeedUpdate = !1), $.isSpriteMaterial && kt.setValue(R, "center", z.center), kt.setValue(R, "modelViewMatrix", z.modelViewMatrix), kt.setValue(R, "normalMatrix", z.normalMatrix), kt.setValue(R, "modelMatrix", z.matrixWorld), $.isShaderMaterial || $.isRawShaderMaterial) {
                    const Vn = $.uniformsGroups;
                    for (let Jn = 0, Rp = Vn.length; Jn < Rp; Jn++) {
                        const sa = Vn[Jn];
                        I.update(sa, Wi), I.bind(sa, Wi)
                    }
                }
                return Wi
            }

            function nt(A, W) {
                A.ambientLightColor.needsUpdate = W, A.lightProbe.needsUpdate = W, A.directionalLights.needsUpdate = W, A.directionalLightShadows.needsUpdate = W, A.pointLights.needsUpdate = W, A.pointLightShadows.needsUpdate = W, A.spotLights.needsUpdate = W, A.spotLightShadows.needsUpdate = W, A.rectAreaLights.needsUpdate = W, A.hemisphereLights.needsUpdate = W
            }

            function cn(A) {
                return A.isMeshLambertMaterial || A.isMeshToonMaterial || A.isMeshPhongMaterial || A.isMeshStandardMaterial || A.isShadowMaterial || A.isShaderMaterial && A.lights === !0
            }
            this.getActiveCubeFace = function() {
                return D
            }, this.getActiveMipmapLevel = function() {
                return T
            }, this.getRenderTarget = function() {
                return w
            }, this.setRenderTargetTextures = function(A, W, Z) {
                const $ = Ie.get(A);
                $.__autoAllocateDepthBuffer = A.resolveDepthBuffer === !1, $.__autoAllocateDepthBuffer === !1 && ($.__useRenderToTexture = !1), Ie.get(A.texture).__webglTexture = W, Ie.get(A.depthTexture).__webglTexture = $.__autoAllocateDepthBuffer ? void 0 : Z, $.__hasExternalTextures = !0
            }, this.setRenderTargetFramebuffer = function(A, W) {
                const Z = Ie.get(A);
                Z.__webglFramebuffer = W, Z.__useDefaultFramebuffer = W === void 0
            };
            const Bt = R.createFramebuffer();
            this.setRenderTarget = function(A, W = 0, Z = 0) {
                w = A, D = W, T = Z;
                let $ = !0,
                    z = null,
                    _e = !1,
                    Ce = !1;
                if (A) {
                    const Le = Ie.get(A);
                    if (Le.__useDefaultFramebuffer !== void 0) ve.bindFramebuffer(R.FRAMEBUFFER, null), $ = !1;
                    else if (Le.__webglFramebuffer === void 0) ge.setupRenderTarget(A);
                    else if (Le.__hasExternalTextures) ge.rebindTextures(A, Ie.get(A.texture).__webglTexture, Ie.get(A.depthTexture).__webglTexture);
                    else if (A.depthBuffer) {
                        const We = A.depthTexture;
                        if (Le.__boundDepthTexture !== We) {
                            if (We !== null && Ie.has(We) && (A.width !== We.image.width || A.height !== We.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            ge.setupDepthRenderbuffer(A)
                        }
                    }
                    const qe = A.texture;
                    (qe.isData3DTexture || qe.isDataArrayTexture || qe.isCompressedArrayTexture) && (Ce = !0);
                    const Je = Ie.get(A).__webglFramebuffer;
                    A.isWebGLCubeRenderTarget ? (Array.isArray(Je[W]) ? z = Je[W][Z] : z = Je[W], _e = !0) : A.samples > 0 && ge.useMultisampledRTT(A) === !1 ? z = Ie.get(A).__webglMultisampledFramebuffer : Array.isArray(Je) ? z = Je[Z] : z = Je, C.copy(A.viewport), O.copy(A.scissor), N = A.scissorTest
                } else C.copy(se).multiplyScalar(H).floor(), O.copy(de).multiplyScalar(H).floor(), N = ke;
                if (Z !== 0 && (z = Bt), ve.bindFramebuffer(R.FRAMEBUFFER, z) && $ && ve.drawBuffers(A, z), ve.viewport(C), ve.scissor(O), ve.setScissorTest(N), _e) {
                    const Le = Ie.get(A.texture);
                    R.framebufferTexture2D(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_CUBE_MAP_POSITIVE_X + W, Le.__webglTexture, Z)
                } else if (Ce) {
                    const Le = Ie.get(A.texture),
                        qe = W;
                    R.framebufferTextureLayer(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, Le.__webglTexture, Z, qe)
                } else if (A !== null && Z !== 0) {
                    const Le = Ie.get(A.texture);
                    R.framebufferTexture2D(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_2D, Le.__webglTexture, Z)
                }
                S = -1
            }, this.readRenderTargetPixels = function(A, W, Z, $, z, _e, Ce, ze = 0) {
                if (!(A && A.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return
                }
                let Le = Ie.get(A).__webglFramebuffer;
                if (A.isWebGLCubeRenderTarget && Ce !== void 0 && (Le = Le[Ce]), Le) {
                    ve.bindFramebuffer(R.FRAMEBUFFER, Le);
                    try {
                        const qe = A.textures[ze],
                            Je = qe.format,
                            We = qe.type;
                        if (!X.textureFormatReadable(Je)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return
                        }
                        if (!X.textureTypeReadable(We)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return
                        }
                        W >= 0 && W <= A.width - $ && Z >= 0 && Z <= A.height - z && (A.textures.length > 1 && R.readBuffer(R.COLOR_ATTACHMENT0 + ze), R.readPixels(W, Z, $, z, Se.convert(Je), Se.convert(We), _e))
                    } finally {
                        const qe = w !== null ? Ie.get(w).__webglFramebuffer : null;
                        ve.bindFramebuffer(R.FRAMEBUFFER, qe)
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(A, W, Z, $, z, _e, Ce, ze = 0) {
                if (!(A && A.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let Le = Ie.get(A).__webglFramebuffer;
                if (A.isWebGLCubeRenderTarget && Ce !== void 0 && (Le = Le[Ce]), Le)
                    if (W >= 0 && W <= A.width - $ && Z >= 0 && Z <= A.height - z) {
                        ve.bindFramebuffer(R.FRAMEBUFFER, Le);
                        const qe = A.textures[ze],
                            Je = qe.format,
                            We = qe.type;
                        if (!X.textureFormatReadable(Je)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                        if (!X.textureTypeReadable(We)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                        const lt = R.createBuffer();
                        R.bindBuffer(R.PIXEL_PACK_BUFFER, lt), R.bufferData(R.PIXEL_PACK_BUFFER, _e.byteLength, R.STREAM_READ), A.textures.length > 1 && R.readBuffer(R.COLOR_ATTACHMENT0 + ze), R.readPixels(W, Z, $, z, Se.convert(Je), Se.convert(We), 0);
                        const Ct = w !== null ? Ie.get(w).__webglFramebuffer : null;
                        ve.bindFramebuffer(R.FRAMEBUFFER, Ct);
                        const Xt = R.fenceSync(R.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        return R.flush(), await Rx(R, Xt, 4), R.bindBuffer(R.PIXEL_PACK_BUFFER, lt), R.getBufferSubData(R.PIXEL_PACK_BUFFER, 0, _e), R.deleteBuffer(lt), R.deleteSync(Xt), _e
                    } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
            }, this.copyFramebufferToTexture = function(A, W = null, Z = 0) {
                const $ = Math.pow(2, -Z),
                    z = Math.floor(A.image.width * $),
                    _e = Math.floor(A.image.height * $),
                    Ce = W !== null ? W.x : 0,
                    ze = W !== null ? W.y : 0;
                ge.setTexture2D(A, 0), R.copyTexSubImage2D(R.TEXTURE_2D, Z, 0, 0, Ce, ze, z, _e), ve.unbindTexture()
            };
            const un = R.createFramebuffer(),
                fn = R.createFramebuffer();
            this.copyTextureToTexture = function(A, W, Z = null, $ = null, z = 0, _e = null) {
                _e === null && (z !== 0 ? (la("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), _e = z, z = 0) : _e = 0);
                let Ce, ze, Le, qe, Je, We, lt, Ct, Xt;
                const qt = A.isCompressedTexture ? A.mipmaps[_e] : A.image;
                if (Z !== null) Ce = Z.max.x - Z.min.x, ze = Z.max.y - Z.min.y, Le = Z.isBox3 ? Z.max.z - Z.min.z : 1, qe = Z.min.x, Je = Z.min.y, We = Z.isBox3 ? Z.min.z : 0;
                else {
                    const Ti = Math.pow(2, -z);
                    Ce = Math.floor(qt.width * Ti), ze = Math.floor(qt.height * Ti), A.isDataArrayTexture ? Le = qt.depth : A.isData3DTexture ? Le = Math.floor(qt.depth * Ti) : Le = 1, qe = 0, Je = 0, We = 0
                }
                $ !== null ? (lt = $.x, Ct = $.y, Xt = $.z) : (lt = 0, Ct = 0, Xt = 0);
                const Mt = Se.convert(W.format),
                    Ze = Se.convert(W.type);
                let vn;
                W.isData3DTexture ? (ge.setTexture3D(W, 0), vn = R.TEXTURE_3D) : W.isDataArrayTexture || W.isCompressedArrayTexture ? (ge.setTexture2DArray(W, 0), vn = R.TEXTURE_2D_ARRAY) : (ge.setTexture2D(W, 0), vn = R.TEXTURE_2D), R.pixelStorei(R.UNPACK_FLIP_Y_WEBGL, W.flipY), R.pixelStorei(R.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha), R.pixelStorei(R.UNPACK_ALIGNMENT, W.unpackAlignment);
                const Dt = R.getParameter(R.UNPACK_ROW_LENGTH),
                    Wi = R.getParameter(R.UNPACK_IMAGE_HEIGHT),
                    yo = R.getParameter(R.UNPACK_SKIP_PIXELS),
                    ui = R.getParameter(R.UNPACK_SKIP_ROWS),
                    Kl = R.getParameter(R.UNPACK_SKIP_IMAGES);
                R.pixelStorei(R.UNPACK_ROW_LENGTH, qt.width), R.pixelStorei(R.UNPACK_IMAGE_HEIGHT, qt.height), R.pixelStorei(R.UNPACK_SKIP_PIXELS, qe), R.pixelStorei(R.UNPACK_SKIP_ROWS, Je), R.pixelStorei(R.UNPACK_SKIP_IMAGES, We);
                const kt = A.isDataArrayTexture || A.isData3DTexture,
                    Mi = W.isDataArrayTexture || W.isData3DTexture;
                if (A.isDepthTexture) {
                    const Ti = Ie.get(A),
                        Vn = Ie.get(W),
                        Jn = Ie.get(Ti.__renderTarget),
                        Rp = Ie.get(Vn.__renderTarget);
                    ve.bindFramebuffer(R.READ_FRAMEBUFFER, Jn.__webglFramebuffer), ve.bindFramebuffer(R.DRAW_FRAMEBUFFER, Rp.__webglFramebuffer);
                    for (let sa = 0; sa < Le; sa++) kt && (R.framebufferTextureLayer(R.READ_FRAMEBUFFER, R.COLOR_ATTACHMENT0, Ie.get(A).__webglTexture, z, We + sa), R.framebufferTextureLayer(R.DRAW_FRAMEBUFFER, R.COLOR_ATTACHMENT0, Ie.get(W).__webglTexture, _e, Xt + sa)), R.blitFramebuffer(qe, Je, Ce, ze, lt, Ct, Ce, ze, R.DEPTH_BUFFER_BIT, R.NEAREST);
                    ve.bindFramebuffer(R.READ_FRAMEBUFFER, null), ve.bindFramebuffer(R.DRAW_FRAMEBUFFER, null)
                } else if (z !== 0 || A.isRenderTargetTexture || Ie.has(A)) {
                    const Ti = Ie.get(A),
                        Vn = Ie.get(W);
                    ve.bindFramebuffer(R.READ_FRAMEBUFFER, un), ve.bindFramebuffer(R.DRAW_FRAMEBUFFER, fn);
                    for (let Jn = 0; Jn < Le; Jn++) kt ? R.framebufferTextureLayer(R.READ_FRAMEBUFFER, R.COLOR_ATTACHMENT0, Ti.__webglTexture, z, We + Jn) : R.framebufferTexture2D(R.READ_FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_2D, Ti.__webglTexture, z), Mi ? R.framebufferTextureLayer(R.DRAW_FRAMEBUFFER, R.COLOR_ATTACHMENT0, Vn.__webglTexture, _e, Xt + Jn) : R.framebufferTexture2D(R.DRAW_FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_2D, Vn.__webglTexture, _e), z !== 0 ? R.blitFramebuffer(qe, Je, Ce, ze, lt, Ct, Ce, ze, R.COLOR_BUFFER_BIT, R.NEAREST) : Mi ? R.copyTexSubImage3D(vn, _e, lt, Ct, Xt + Jn, qe, Je, Ce, ze) : R.copyTexSubImage2D(vn, _e, lt, Ct, qe, Je, Ce, ze);
                    ve.bindFramebuffer(R.READ_FRAMEBUFFER, null), ve.bindFramebuffer(R.DRAW_FRAMEBUFFER, null)
                } else Mi ? A.isDataTexture || A.isData3DTexture ? R.texSubImage3D(vn, _e, lt, Ct, Xt, Ce, ze, Le, Mt, Ze, qt.data) : W.isCompressedArrayTexture ? R.compressedTexSubImage3D(vn, _e, lt, Ct, Xt, Ce, ze, Le, Mt, qt.data) : R.texSubImage3D(vn, _e, lt, Ct, Xt, Ce, ze, Le, Mt, Ze, qt) : A.isDataTexture ? R.texSubImage2D(R.TEXTURE_2D, _e, lt, Ct, Ce, ze, Mt, Ze, qt.data) : A.isCompressedTexture ? R.compressedTexSubImage2D(R.TEXTURE_2D, _e, lt, Ct, qt.width, qt.height, Mt, qt.data) : R.texSubImage2D(R.TEXTURE_2D, _e, lt, Ct, Ce, ze, Mt, Ze, qt);
                R.pixelStorei(R.UNPACK_ROW_LENGTH, Dt), R.pixelStorei(R.UNPACK_IMAGE_HEIGHT, Wi), R.pixelStorei(R.UNPACK_SKIP_PIXELS, yo), R.pixelStorei(R.UNPACK_SKIP_ROWS, ui), R.pixelStorei(R.UNPACK_SKIP_IMAGES, Kl), _e === 0 && W.generateMipmaps && R.generateMipmap(vn), ve.unbindTexture()
            }, this.copyTextureToTexture3D = function(A, W, Z = null, $ = null, z = 0) {
                return la('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(A, W, Z, $, z)
            }, this.initRenderTarget = function(A) {
                Ie.get(A).__webglFramebuffer === void 0 && ge.setupRenderTarget(A)
            }, this.initTexture = function(A) {
                A.isCubeTexture ? ge.setTextureCube(A, 0) : A.isData3DTexture ? ge.setTexture3D(A, 0) : A.isDataArrayTexture || A.isCompressedArrayTexture ? ge.setTexture2DArray(A, 0) : ge.setTexture2D(A, 0), ve.unbindTexture()
            }, this.resetState = function() {
                D = 0, T = 0, w = null, ve.reset(), je.reset()
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        get coordinateSystem() {
            return 2e3
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorSpace = xt._getDrawingBufferColorSpace(e), t.unpackColorSpace = xt._getUnpackColorSpace()
        }
    }
    /**
     * @vue/shared v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    /*! #__NO_SIDE_EFFECTS__ */
    function JT(r) {
        const e = Object.create(null);
        for (const t of r.split(",")) e[t] = 1;
        return t => t in e
    }
    const Kf = {},
        Rc = () => {},
        ug = Object.assign,
        ZT = Object.prototype.hasOwnProperty,
        $f = (r, e) => ZT.call(r, e),
        Li = Array.isArray,
        Bo = r => Pc(r) === "[object Map]",
        QT = r => Pc(r) === "[object Set]",
        Cs = r => typeof r == "function",
        eE = r => typeof r == "string",
        ko = r => typeof r == "symbol",
        Fa = r => r !== null && typeof r == "object",
        tE = r => (Fa(r) || Cs(r)) && Cs(r.then) && Cs(r.catch),
        nE = Object.prototype.toString,
        Pc = r => nE.call(r),
        iE = r => Pc(r).slice(8, -1),
        rE = r => Pc(r) === "[object Object]",
        Jf = r => eE(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r,
        jr = (r, e) => !Object.is(r, e);
    let fg;
    const Zf = () => fg || (fg = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
    /**
     * @vue/reactivity v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    let It;
    const Qf = new WeakSet;
    class sE {
        constructor(e) {
            this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0
        }
        pause() {
            this.flags |= 64
        }
        resume() {
            this.flags & 64 && (this.flags &= -65, Qf.has(this) && (Qf.delete(this), this.trigger()))
        }
        notify() {
            this.flags & 2 && !(this.flags & 32) || this.flags & 8 || aE(this)
        }
        run() {
            if (!(this.flags & 1)) return this.fn();
            this.flags |= 2, gg(this), dg(this);
            const e = It,
                t = Ii;
            It = this, Ii = !0;
            try {
                return this.fn()
            } finally {
                pg(this), It = e, Ii = t, this.flags &= -3
            }
        }
        stop() {
            if (this.flags & 1) {
                for (let e = this.deps; e; e = e.nextDep) ih(e);
                this.deps = this.depsTail = void 0, gg(this), this.onStop && this.onStop(), this.flags &= -2
            }
        }
        trigger() {
            this.flags & 64 ? Qf.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
        }
        runIfDirty() {
            nh(this) && this.run()
        }
        get dirty() {
            return nh(this)
        }
    }
    let hg = 0,
        zo, Go;

    function aE(r, e = !1) {
        if (r.flags |= 8, e) {
            r.next = Go, Go = r;
            return
        }
        r.next = zo, zo = r
    }

    function eh() {
        hg++
    }

    function th() {
        if (--hg > 0) return;
        if (Go) {
            let e = Go;
            for (Go = void 0; e;) {
                const t = e.next;
                e.next = void 0, e.flags &= -9, e = t
            }
        }
        let r;
        for (; zo;) {
            let e = zo;
            for (zo = void 0; e;) {
                const t = e.next;
                if (e.next = void 0, e.flags &= -9, e.flags & 1) try {
                    e.trigger()
                } catch (n) {
                    r || (r = n)
                }
                e = t
            }
        }
        if (r) throw r
    }

    function dg(r) {
        for (let e = r.deps; e; e = e.nextDep) e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e
    }

    function pg(r) {
        let e, t = r.depsTail,
            n = t;
        for (; n;) {
            const i = n.prevDep;
            n.version === -1 ? (n === t && (t = i), ih(n), lE(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i
        }
        r.deps = e, r.depsTail = t
    }

    function nh(r) {
        for (let e = r.deps; e; e = e.nextDep)
            if (e.dep.version !== e.version || e.dep.computed && (oE(e.dep.computed) || e.dep.version !== e.version)) return !0;
        return !!r._dirty
    }

    function oE(r) {
        if (r.flags & 4 && !(r.flags & 16) || (r.flags &= -17, r.globalVersion === Fc)) return;
        r.globalVersion = Fc;
        const e = r.dep;
        if (r.flags |= 2, e.version > 0 && !r.isSSR && r.deps && !nh(r)) {
            r.flags &= -3;
            return
        }
        const t = It,
            n = Ii;
        It = r, Ii = !0;
        try {
            dg(r);
            const i = r.fn(r._value);
            (e.version === 0 || jr(i, r._value)) && (r._value = i, e.version++)
        } catch (i) {
            throw e.version++, i
        } finally {
            It = t, Ii = n, pg(r), r.flags &= -3
        }
    }

    function ih(r, e = !1) {
        const {
            dep: t,
            prevSub: n,
            nextSub: i
        } = r;
        if (n && (n.nextSub = i, r.prevSub = void 0), i && (i.prevSub = n, r.nextSub = void 0), t.subs === r && (t.subs = n, !n && t.computed)) {
            t.computed.flags &= -5;
            for (let s = t.computed.deps; s; s = s.nextDep) ih(s, !0)
        }!e && !--t.sc && t.map && t.map.delete(t.key)
    }

    function lE(r) {
        const {
            prevDep: e,
            nextDep: t
        } = r;
        e && (e.nextDep = t, r.prevDep = void 0), t && (t.prevDep = e, r.nextDep = void 0)
    }
    let Ii = !0;
    const mg = [];

    function rh() {
        mg.push(Ii), Ii = !1
    }

    function sh() {
        const r = mg.pop();
        Ii = r === void 0 ? !0 : r
    }

    function gg(r) {
        const {
            cleanup: e
        } = r;
        if (r.cleanup = void 0, e) {
            const t = It;
            It = void 0;
            try {
                e()
            } finally {
                It = t
            }
        }
    }
    let Fc = 0;
    class cE {
        constructor(e, t) {
            this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
        }
    }
    class _g {
        constructor(e) {
            this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
        }
        track(e) {
            if (!It || !Ii || It === this.computed) return;
            let t = this.activeLink;
            if (t === void 0 || t.sub !== It) t = this.activeLink = new cE(It, this), It.deps ? (t.prevDep = It.depsTail, It.depsTail.nextDep = t, It.depsTail = t) : It.deps = It.depsTail = t, bg(t);
            else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
                const n = t.nextDep;
                n.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = n), t.prevDep = It.depsTail, t.nextDep = void 0, It.depsTail.nextDep = t, It.depsTail = t, It.deps === t && (It.deps = n)
            }
            return t
        }
        trigger(e) {
            this.version++, Fc++, this.notify(e)
        }
        notify(e) {
            eh();
            try {
                for (let t = this.subs; t; t = t.prevSub) t.sub.notify() && t.sub.dep.notify()
            } finally {
                th()
            }
        }
    }

    function bg(r) {
        if (r.dep.sc++, r.sub.flags & 4) {
            const e = r.dep.computed;
            if (e && !r.dep.subs) {
                e.flags |= 20;
                for (let n = e.deps; n; n = n.nextDep) bg(n)
            }
            const t = r.dep.subs;
            t !== r && (r.prevSub = t, t && (t.nextSub = r)), r.dep.subs = r
        }
    }
    const ah = new WeakMap,
        Rs = Symbol(""),
        oh = Symbol(""),
        Ho = Symbol("");

    function Wn(r, e, t) {
        if (Ii && It) {
            let n = ah.get(r);
            n || ah.set(r, n = new Map);
            let i = n.get(t);
            i || (n.set(t, i = new _g), i.map = n, i.key = t), i.track()
        }
    }

    function qr(r, e, t, n, i, s) {
        const a = ah.get(r);
        if (!a) {
            Fc++;
            return
        }
        const o = l => {
            l && l.trigger()
        };
        if (eh(), e === "clear") a.forEach(o);
        else {
            const l = Li(r),
                c = l && Jf(t);
            if (l && t === "length") {
                const f = Number(n);
                a.forEach((h, d) => {
                    (d === "length" || d === Ho || !ko(d) && d >= f) && o(h)
                })
            } else switch ((t !== void 0 || a.has(void 0)) && o(a.get(t)), c && o(a.get(Ho)), e) {
                case "add":
                    l ? c && o(a.get("length")) : (o(a.get(Rs)), Bo(r) && o(a.get(oh)));
                    break;
                case "delete":
                    l || (o(a.get(Rs)), Bo(r) && o(a.get(oh)));
                    break;
                case "set":
                    Bo(r) && o(a.get(Rs));
                    break
            }
        }
        th()
    }

    function La(r) {
        const e = Pt(r);
        return e === r ? e : (Wn(e, "iterate", Ho), Ni(r) ? e : e.map(In))
    }

    function lh(r) {
        return Wn(r = Pt(r), "iterate", Ho), r
    }
    const uE = {
        __proto__: null,
        [Symbol.iterator]() {
            return ch(this, Symbol.iterator, In)
        },
        concat(...r) {
            return La(this).concat(...r.map(e => Li(e) ? La(e) : e))
        },
        entries() {
            return ch(this, "entries", r => (r[1] = In(r[1]), r))
        },
        every(r, e) {
            return _r(this, "every", r, e, void 0, arguments)
        },
        filter(r, e) {
            return _r(this, "filter", r, e, t => t.map(In), arguments)
        },
        find(r, e) {
            return _r(this, "find", r, e, In, arguments)
        },
        findIndex(r, e) {
            return _r(this, "findIndex", r, e, void 0, arguments)
        },
        findLast(r, e) {
            return _r(this, "findLast", r, e, In, arguments)
        },
        findLastIndex(r, e) {
            return _r(this, "findLastIndex", r, e, void 0, arguments)
        },
        forEach(r, e) {
            return _r(this, "forEach", r, e, void 0, arguments)
        },
        includes(...r) {
            return uh(this, "includes", r)
        },
        indexOf(...r) {
            return uh(this, "indexOf", r)
        },
        join(r) {
            return La(this).join(r)
        },
        lastIndexOf(...r) {
            return uh(this, "lastIndexOf", r)
        },
        map(r, e) {
            return _r(this, "map", r, e, void 0, arguments)
        },
        pop() {
            return Vo(this, "pop")
        },
        push(...r) {
            return Vo(this, "push", r)
        },
        reduce(r, ...e) {
            return xg(this, "reduce", r, e)
        },
        reduceRight(r, ...e) {
            return xg(this, "reduceRight", r, e)
        },
        shift() {
            return Vo(this, "shift")
        },
        some(r, e) {
            return _r(this, "some", r, e, void 0, arguments)
        },
        splice(...r) {
            return Vo(this, "splice", r)
        },
        toReversed() {
            return La(this).toReversed()
        },
        toSorted(r) {
            return La(this).toSorted(r)
        },
        toSpliced(...r) {
            return La(this).toSpliced(...r)
        },
        unshift(...r) {
            return Vo(this, "unshift", r)
        },
        values() {
            return ch(this, "values", In)
        }
    };

    function ch(r, e, t) {
        const n = lh(r),
            i = n[e]();
        return n !== r && !Ni(r) && (i._next = i.next, i.next = () => {
            const s = i._next();
            return s.value && (s.value = t(s.value)), s
        }), i
    }
    const fE = Array.prototype;

    function _r(r, e, t, n, i, s) {
        const a = lh(r),
            o = a !== r && !Ni(r),
            l = a[e];
        if (l !== fE[e]) {
            const h = l.apply(r, s);
            return o ? In(h) : h
        }
        let c = t;
        a !== r && (o ? c = function(h, d) {
            return t.call(this, In(h), d, r)
        } : t.length > 2 && (c = function(h, d) {
            return t.call(this, h, d, r)
        }));
        const f = l.call(a, c, n);
        return o && i ? i(f) : f
    }

    function xg(r, e, t, n) {
        const i = lh(r);
        let s = t;
        return i !== r && (Ni(r) ? t.length > 3 && (s = function(a, o, l) {
            return t.call(this, a, o, l, r)
        }) : s = function(a, o, l) {
            return t.call(this, a, In(o), l, r)
        }), i[e](s, ...n)
    }

    function uh(r, e, t) {
        const n = Pt(r);
        Wn(n, "iterate", Ho);
        const i = n[e](...t);
        return (i === -1 || i === !1) && DE(t[0]) ? (t[0] = Pt(t[0]), n[e](...t)) : i
    }

    function Vo(r, e, t = []) {
        rh(), eh();
        const n = Pt(r)[e].apply(r, t);
        return th(), sh(), n
    }
    const hE = JT("__proto__,__v_isRef,__isVue"),
        vg = new Set(Object.getOwnPropertyNames(Symbol).filter(r => r !== "arguments" && r !== "caller").map(r => Symbol[r]).filter(ko));

    function dE(r) {
        ko(r) || (r = String(r));
        const e = Pt(this);
        return Wn(e, "has", r), e.hasOwnProperty(r)
    }
    class yg {
        constructor(e = !1, t = !1) {
            this._isReadonly = e, this._isShallow = t
        }
        get(e, t, n) {
            if (t === "__v_skip") return e.__v_skip;
            const i = this._isReadonly,
                s = this._isShallow;
            if (t === "__v_isReactive") return !i;
            if (t === "__v_isReadonly") return i;
            if (t === "__v_isShallow") return s;
            if (t === "__v_raw") return n === (i ? s ? ME : Tg : s ? SE : Mg).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
            const a = Li(e);
            if (!i) {
                let l;
                if (a && (l = uE[t])) return l;
                if (t === "hasOwnProperty") return dE
            }
            const o = Reflect.get(e, t, Ki(e) ? e : n);
            return (ko(t) ? vg.has(t) : hE(t)) || (i || Wn(e, "get", t), s) ? o : Ki(o) ? a && Jf(t) ? o : o.value : Fa(o) ? i ? Dg(o) : Eg(o) : o
        }
    }
    class pE extends yg {
        constructor(e = !1) {
            super(!1, e)
        }
        set(e, t, n, i) {
            let s = e[t];
            if (!this._isShallow) {
                const l = Ps(s);
                if (!Ni(n) && !Ps(n) && (s = Pt(s), n = Pt(n)), !Li(e) && Ki(s) && !Ki(n)) return l ? !1 : (s.value = n, !0)
            }
            const a = Li(e) && Jf(t) ? Number(t) < e.length : $f(e, t),
                o = Reflect.set(e, t, n, Ki(e) ? e : i);
            return e === Pt(i) && (a ? jr(n, s) && qr(e, "set", t, n) : qr(e, "add", t, n)), o
        }
        deleteProperty(e, t) {
            const n = $f(e, t);
            e[t];
            const i = Reflect.deleteProperty(e, t);
            return i && n && qr(e, "delete", t, void 0), i
        }
        has(e, t) {
            const n = Reflect.has(e, t);
            return (!ko(t) || !vg.has(t)) && Wn(e, "has", t), n
        }
        ownKeys(e) {
            return Wn(e, "iterate", Li(e) ? "length" : Rs), Reflect.ownKeys(e)
        }
    }
    class mE extends yg {
        constructor(e = !1) {
            super(!0, e)
        }
        set(e, t) {
            return !0
        }
        deleteProperty(e, t) {
            return !0
        }
    }
    const gE = new pE,
        _E = new mE,
        fh = r => r,
        Lc = r => Reflect.getPrototypeOf(r);

    function bE(r, e, t) {
        return function(...n) {
            const i = this.__v_raw,
                s = Pt(i),
                a = Bo(s),
                o = r === "entries" || r === Symbol.iterator && a,
                l = r === "keys" && a,
                c = i[r](...n),
                f = t ? fh : e ? hh : In;
            return !e && Wn(s, "iterate", l ? oh : Rs), {
                next() {
                    const {
                        value: h,
                        done: d
                    } = c.next();
                    return d ? {
                        value: h,
                        done: d
                    } : {
                        value: o ? [f(h[0]), f(h[1])] : f(h),
                        done: d
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
        }
    }

    function Ic(r) {
        return function(...e) {
            return r === "delete" ? !1 : r === "clear" ? void 0 : this
        }
    }

    function xE(r, e) {
        const t = {
            get(i) {
                const s = this.__v_raw,
                    a = Pt(s),
                    o = Pt(i);
                r || (jr(i, o) && Wn(a, "get", i), Wn(a, "get", o));
                const {
                    has: l
                } = Lc(a), c = e ? fh : r ? hh : In;
                if (l.call(a, i)) return c(s.get(i));
                if (l.call(a, o)) return c(s.get(o));
                s !== a && s.get(i)
            },
            get size() {
                const i = this.__v_raw;
                return !r && Wn(Pt(i), "iterate", Rs), Reflect.get(i, "size", i)
            },
            has(i) {
                const s = this.__v_raw,
                    a = Pt(s),
                    o = Pt(i);
                return r || (jr(i, o) && Wn(a, "has", i), Wn(a, "has", o)), i === o ? s.has(i) : s.has(i) || s.has(o)
            },
            forEach(i, s) {
                const a = this,
                    o = a.__v_raw,
                    l = Pt(o),
                    c = e ? fh : r ? hh : In;
                return !r && Wn(l, "iterate", Rs), o.forEach((f, h) => i.call(s, c(f), c(h), a))
            }
        };
        return ug(t, r ? {
            add: Ic("add"),
            set: Ic("set"),
            delete: Ic("delete"),
            clear: Ic("clear")
        } : {
            add(i) {
                !e && !Ni(i) && !Ps(i) && (i = Pt(i));
                const s = Pt(this);
                return Lc(s).has.call(s, i) || (s.add(i), qr(s, "add", i, i)), this
            },
            set(i, s) {
                !e && !Ni(s) && !Ps(s) && (s = Pt(s));
                const a = Pt(this),
                    {
                        has: o,
                        get: l
                    } = Lc(a);
                let c = o.call(a, i);
                c || (i = Pt(i), c = o.call(a, i));
                const f = l.call(a, i);
                return a.set(i, s), c ? jr(s, f) && qr(a, "set", i, s) : qr(a, "add", i, s), this
            },
            delete(i) {
                const s = Pt(this),
                    {
                        has: a,
                        get: o
                    } = Lc(s);
                let l = a.call(s, i);
                l || (i = Pt(i), l = a.call(s, i)), o && o.call(s, i);
                const c = s.delete(i);
                return l && qr(s, "delete", i, void 0), c
            },
            clear() {
                const i = Pt(this),
                    s = i.size !== 0,
                    a = i.clear();
                return s && qr(i, "clear", void 0, void 0), a
            }
        }), ["keys", "values", "entries", Symbol.iterator].forEach(i => {
            t[i] = bE(i, r, e)
        }), t
    }

    function Sg(r, e) {
        const t = xE(r, e);
        return (n, i, s) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? n : Reflect.get($f(t, i) && i in n ? t : n, i, s)
    }
    const vE = {
            get: Sg(!1, !1)
        },
        yE = {
            get: Sg(!0, !1)
        },
        Mg = new WeakMap,
        SE = new WeakMap,
        Tg = new WeakMap,
        ME = new WeakMap;

    function TE(r) {
        switch (r) {
            case "Object":
            case "Array":
                return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
                return 2;
            default:
                return 0
        }
    }

    function EE(r) {
        return r.__v_skip || !Object.isExtensible(r) ? 0 : TE(iE(r))
    }

    function Eg(r) {
        return Ps(r) ? r : Ag(r, !1, gE, vE, Mg)
    }

    function Dg(r) {
        return Ag(r, !0, _E, yE, Tg)
    }

    function Ag(r, e, t, n, i) {
        if (!Fa(r) || r.__v_raw && !(e && r.__v_isReactive)) return r;
        const s = i.get(r);
        if (s) return s;
        const a = EE(r);
        if (a === 0) return r;
        const o = new Proxy(r, a === 2 ? n : t);
        return i.set(r, o), o
    }

    function Nc(r) {
        return Ps(r) ? Nc(r.__v_raw) : !!(r && r.__v_isReactive)
    }

    function Ps(r) {
        return !!(r && r.__v_isReadonly)
    }

    function Ni(r) {
        return !!(r && r.__v_isShallow)
    }

    function DE(r) {
        return r ? !!r.__v_raw : !1
    }

    function Pt(r) {
        const e = r && r.__v_raw;
        return e ? Pt(e) : r
    }
    const In = r => Fa(r) ? Eg(r) : r,
        hh = r => Fa(r) ? Dg(r) : r;

    function Ki(r) {
        return r ? r.__v_isRef === !0 : !1
    }

    function wg(r) {
        return AE(r, !0)
    }

    function AE(r, e) {
        return Ki(r) ? r : new wE(r, e)
    }
    class wE {
        constructor(e, t) {
            this.dep = new _g, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Pt(e), this._value = t ? e : In(e), this.__v_isShallow = t
        }
        get value() {
            return this.dep.track(), this._value
        }
        set value(e) {
            const t = this._rawValue,
                n = this.__v_isShallow || Ni(e) || Ps(e);
            e = n ? e : Pt(e), jr(e, t) && (this._rawValue = e, this._value = n ? e : In(e), this.dep.trigger())
        }
    }

    function CE(r) {
        return Ki(r) ? r.value : r
    }
    const Oc = {},
        Uc = new WeakMap;
    let Fs;

    function RE(r, e = !1, t = Fs) {
        if (t) {
            let n = Uc.get(t);
            n || Uc.set(t, n = []), n.push(r)
        }
    }

    function PE(r, e, t = Kf) {
        const {
            immediate: n,
            deep: i,
            once: s,
            scheduler: a,
            augmentJob: o,
            call: l
        } = t, c = x => i ? x : Ni(x) || i === !1 || i === 0 ? Yr(x, 1) : Yr(x);
        let f, h, d, u, _ = !1,
            m = !1;
        if (Ki(r) ? (h = () => r.value, _ = Ni(r)) : Nc(r) ? (h = () => c(r), _ = !0) : Li(r) ? (m = !0, _ = r.some(x => Nc(x) || Ni(x)), h = () => r.map(x => {
                if (Ki(x)) return x.value;
                if (Nc(x)) return c(x);
                if (Cs(x)) return l ? l(x, 2) : x()
            })) : Cs(r) ? e ? h = l ? () => l(r, 2) : r : h = () => {
                if (d) {
                    rh();
                    try {
                        d()
                    } finally {
                        sh()
                    }
                }
                const x = Fs;
                Fs = f;
                try {
                    return l ? l(r, 3, [u]) : r(u)
                } finally {
                    Fs = x
                }
            } : h = Rc, e && i) {
            const x = h,
                b = i === !0 ? 1 / 0 : i;
            h = () => Yr(x(), b)
        }
        const g = () => {
            f.stop()
        };
        if (s && e) {
            const x = e;
            e = (...b) => {
                x(...b), g()
            }
        }
        let p = m ? new Array(r.length).fill(Oc) : Oc;
        const v = x => {
            if (!(!(f.flags & 1) || !f.dirty && !x))
                if (e) {
                    const b = f.run();
                    if (i || _ || (m ? b.some((M, D) => jr(M, p[D])) : jr(b, p))) {
                        d && d();
                        const M = Fs;
                        Fs = f;
                        try {
                            const D = [b, p === Oc ? void 0 : m && p[0] === Oc ? [] : p, u];
                            l ? l(e, 3, D) : e(...D), p = b
                        } finally {
                            Fs = M
                        }
                    }
                } else f.run()
        };
        return o && o(v), f = new sE(h), f.scheduler = a ? () => a(v, !1) : v, u = x => RE(x, !1, f), d = f.onStop = () => {
            const x = Uc.get(f);
            if (x) {
                if (l) l(x, 4);
                else
                    for (const b of x) b();
                Uc.delete(f)
            }
        }, e ? n ? v(!0) : p = f.run() : a ? a(v.bind(null, !0), !0) : f.run(), g.pause = f.pause.bind(f), g.resume = f.resume.bind(f), g.stop = g, g
    }

    function Yr(r, e = 1 / 0, t) {
        if (e <= 0 || !Fa(r) || r.__v_skip || (t = t || new Set, t.has(r))) return r;
        if (t.add(r), e--, Ki(r)) Yr(r.value, e, t);
        else if (Li(r))
            for (let n = 0; n < r.length; n++) Yr(r[n], e, t);
        else if (QT(r) || Bo(r)) r.forEach(n => {
            Yr(n, e, t)
        });
        else if (rE(r)) {
            for (const n in r) Yr(r[n], e, t);
            for (const n of Object.getOwnPropertySymbols(r)) Object.prototype.propertyIsEnumerable.call(r, n) && Yr(r[n], e, t)
        }
        return r
    }
    /**
     * @vue/runtime-core v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    function dh(r, e, t, n) {
        try {
            return n ? r(...n) : r()
        } catch (i) {
            Rg(i, e, t)
        }
    }

    function Cg(r, e, t, n) {
        if (Cs(r)) {
            const i = dh(r, e, t, n);
            return i && tE(i) && i.catch(s => {
                Rg(s, e, t)
            }), i
        }
        if (Li(r)) {
            const i = [];
            for (let s = 0; s < r.length; s++) i.push(Cg(r[s], e, t, n));
            return i
        }
    }

    function Rg(r, e, t, n = !0) {
        const i = e ? e.vnode : null,
            {
                errorHandler: s,
                throwUnhandledErrorInProduction: a
            } = e && e.appContext.config || Kf;
        if (e) {
            let o = e.parent;
            const l = e.proxy,
                c = `https://vuejs.org/error-reference/#runtime-${t}`;
            for (; o;) {
                const f = o.ec;
                if (f) {
                    for (let h = 0; h < f.length; h++)
                        if (f[h](r, l, c) === !1) return
                }
                o = o.parent
            }
            if (s) {
                rh(), dh(s, null, 10, [r, l, c]), sh();
                return
            }
        }
        FE(r, t, i, n, a)
    }

    function FE(r, e, t, n = !0, i = !1) {
        if (i) throw r;
        console.error(r)
    }
    const di = [];
    let br = -1;
    const Ia = [];
    let Kr = null,
        Na = 0;
    const LE = Promise.resolve();
    let ph = null;

    function IE(r) {
        let e = br + 1,
            t = di.length;
        for (; e < t;) {
            const n = e + t >>> 1,
                i = di[n],
                s = Wo(i);
            s < r || s === r && i.flags & 2 ? e = n + 1 : t = n
        }
        return e
    }

    function NE(r) {
        if (!(r.flags & 1)) {
            const e = Wo(r),
                t = di[di.length - 1];
            !t || !(r.flags & 2) && e >= Wo(t) ? di.push(r) : di.splice(IE(e), 0, r), r.flags |= 1, Pg()
        }
    }

    function Pg() {
        ph || (ph = LE.then(Fg))
    }

    function OE(r) {
        Li(r) ? Ia.push(...r) : Kr && r.id === -1 ? Kr.splice(Na + 1, 0, r) : r.flags & 1 || (Ia.push(r), r.flags |= 1), Pg()
    }

    function UE(r) {
        if (Ia.length) {
            const e = [...new Set(Ia)].sort((t, n) => Wo(t) - Wo(n));
            if (Ia.length = 0, Kr) {
                Kr.push(...e);
                return
            }
            for (Kr = e, Na = 0; Na < Kr.length; Na++) {
                const t = Kr[Na];
                t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2
            }
            Kr = null, Na = 0
        }
    }
    const Wo = r => r.id == null ? r.flags & 2 ? -1 : 1 / 0 : r.id;

    function Fg(r) {
        try {
            for (br = 0; br < di.length; br++) {
                const e = di[br];
                e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), dh(e, e.i, e.i ? 15 : 14), e.flags & 4 || (e.flags &= -2))
            }
        } finally {
            for (; br < di.length; br++) {
                const e = di[br];
                e && (e.flags &= -2)
            }
            br = -1, di.length = 0, UE(), ph = null, (di.length || Ia.length) && Fg()
        }
    }
    let BE = null;
    Zf().requestIdleCallback, Zf().cancelIdleCallback;
    let kE = null;

    function zE(r, e, t = !1) {
        const n = mh || BE;
        if (n || kE) {
            const i = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
            if (i && r in i) return i[r];
            if (arguments.length > 1) return t && Cs(e) ? e.call(n && n.proxy) : e
        }
    }
    const GE = jE,
        HE = Symbol.for("v-scx"),
        VE = () => zE(HE);

    function WE(r, e, t) {
        return XE(r, e, t)
    }

    function XE(r, e, t = Kf) {
        const {
            immediate: n,
            deep: i,
            flush: s,
            once: a
        } = t, o = ug({}, t), l = e && n || !e && s !== "post";
        let c;
        if (gh) {
            if (s === "sync") {
                const u = VE();
                c = u.__watcherHandles || (u.__watcherHandles = [])
            } else if (!l) {
                const u = () => {};
                return u.stop = Rc, u.resume = Rc, u.pause = Rc, u
            }
        }
        const f = mh;
        o.call = (u, _, m) => Cg(u, f, _, m);
        let h = !1;
        s === "post" ? o.scheduler = u => {
            GE(u, f && f.suspense)
        } : s !== "sync" && (h = !0, o.scheduler = (u, _) => {
            _ ? u() : NE(u)
        }), o.augmentJob = u => {
            e && (u.flags |= 4), h && (u.flags |= 2, f && (u.id = f.uid, u.i = f))
        };
        const d = PE(r, e, o);
        return gh && (c ? c.push(d) : l && d()), d
    }

    function jE(r, e) {
        e && e.pendingBranch ? Li(r) ? e.effects.push(...r) : e.effects.push(r) : OE(r)
    }
    let mh = null; {
        const r = Zf(),
            e = (t, n) => {
                let i;
                return (i = r[t]) || (i = r[t] = []), i.push(n), s => {
                    i.length > 1 ? i.forEach(a => a(s)) : i[0](s)
                }
            };
        e("__VUE_INSTANCE_SETTERS__", t => mh = t), e("__VUE_SSR_SETTERS__", t => gh = t)
    }
    let gh = !1;

    function Xo(r, e) {
        return CE(r)
    }
    typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;

    function qE(...r) {
        if (r.length === 2) {
            const [e, t] = r;
            e.value = t
        }
        if (r.length === 3) {
            const [e, t, n] = r;
            e[t] = n
        }
    }
    const YE = `
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump;
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`,
        KE = `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        csm_Bump = vec3(0.0);
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`,
        $E = `
    varying mat4 csm_internal_vModelViewMatrix;
`,
        JE = `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,
        ZE = `
    varying mat4 csm_internal_vModelViewMatrix;
`,
        QE = `
    
`,
        Ne = {
            diffuse: "csm_DiffuseColor",
            roughness: "csm_Roughness",
            metalness: "csm_Metalness",
            emissive: "csm_Emissive",
            ao: "csm_AO",
            bump: "csm_Bump",
            fragNormal: "csm_FragNormal",
            clearcoat: "csm_Clearcoat",
            clearcoatRoughness: "csm_ClearcoatRoughness",
            clearcoatNormal: "csm_ClearcoatNormal",
            transmission: "csm_Transmission",
            thickness: "csm_Thickness",
            iridescence: "csm_Iridescence",
            pointSize: "csm_PointSize",
            fragColor: "csm_FragColor",
            depthAlpha: "csm_DepthAlpha",
            unlitFac: "csm_UnlitFac",
            position: "csm_Position",
            positionRaw: "csm_PositionRaw",
            normal: "csm_Normal"
        },
        eD = {
            [`${Ne.position}`]: "*",
            [`${Ne.positionRaw}`]: "*",
            [`${Ne.normal}`]: "*",
            [`${Ne.depthAlpha}`]: "*",
            [`${Ne.pointSize}`]: ["PointsMaterial"],
            [`${Ne.diffuse}`]: "*",
            [`${Ne.fragColor}`]: "*",
            [`${Ne.fragNormal}`]: "*",
            [`${Ne.unlitFac}`]: "*",
            [`${Ne.emissive}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.roughness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.metalness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.iridescence}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.ao}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"],
            [`${Ne.bump}`]: ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"],
            [`${Ne.clearcoat}`]: ["MeshPhysicalMaterial"],
            [`${Ne.clearcoatRoughness}`]: ["MeshPhysicalMaterial"],
            [`${Ne.clearcoatNormal}`]: ["MeshPhysicalMaterial"],
            [`${Ne.transmission}`]: ["MeshPhysicalMaterial"],
            [`${Ne.thickness}`]: ["MeshPhysicalMaterial"]
        },
        tD = {
            "*": {
                "#include <lights_physical_fragment>": at.lights_physical_fragment,
                "#include <transmission_fragment>": at.transmission_fragment
            },
            [`${Ne.normal}`]: {
                "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${Ne.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
            },
            [`${Ne.position}`]: {
                "#include <begin_vertex>": `
    vec3 transformed = ${Ne.position};
  `
            },
            [`${Ne.positionRaw}`]: {
                "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = ${Ne.positionRaw};
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `
            },
            [`${Ne.pointSize}`]: {
                "gl_PointSize = size;": `
    gl_PointSize = ${Ne.pointSize};
    `
            },
            [`${Ne.diffuse}`]: {
                "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${Ne.diffuse};
  `
            },
            [`${Ne.fragColor}`]: {
                "#include <opaque_fragment>": `
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${Ne.fragColor}, ${Ne.unlitFac});
  `
            },
            [`${Ne.emissive}`]: {
                "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${Ne.emissive};
    `
            },
            [`${Ne.roughness}`]: {
                "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${Ne.roughness};
    `
            },
            [`${Ne.metalness}`]: {
                "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${Ne.metalness};
    `
            },
            [`${Ne.ao}`]: {
                "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${Ne.ao};
    `
            },
            [`${Ne.bump}`]: {
                "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = ${Ne.bump} - (dot(${Ne.bump}, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `
            },
            [`${Ne.fragNormal}`]: {
                "#include <normal_fragment_maps>": `
      #include <normal_fragment_maps>
      normal = ${Ne.fragNormal};
    `
            },
            [`${Ne.depthAlpha}`]: {
                "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${Ne.depthAlpha} );
    `,
                "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      if(${Ne.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,
                "gl_FragColor = packDepthToRGBA( dist );": `
      if(${Ne.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `
            },
            [`${Ne.clearcoat}`]: {
                "material.clearcoat = clearcoat;": `material.clearcoat = ${Ne.clearcoat};`
            },
            [`${Ne.clearcoatRoughness}`]: {
                "material.clearcoatRoughness = clearcoatRoughness;": `material.clearcoatRoughness = ${Ne.clearcoatRoughness};`
            },
            [`${Ne.clearcoatNormal}`]: {
                "#include <clearcoat_normal_fragment_begin>": `
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `
            },
            [`${Ne.transmission}`]: {
                "material.transmission = transmission;": `
      material.transmission = ${Ne.transmission};
    `
            },
            [`${Ne.thickness}`]: {
                "material.thickness = thickness;": `
      material.thickness = ${Ne.thickness};
    `
            },
            [`${Ne.iridescence}`]: {
                "material.iridescence = iridescence;": `
      material.iridescence = ${Ne.iridescence};
    `
            }
        },
        nD = {
            clearcoat: [Ne.clearcoat, Ne.clearcoatNormal, Ne.clearcoatRoughness],
            transmission: [Ne.transmission],
            iridescence: [Ne.iridescence]
        };

    function iD(r) {
        let e = 0;
        for (let n = 0; n < r.length; n++) e = r.charCodeAt(n) + (e << 6) + (e << 16) - e;
        const t = e >>> 0;
        return String(t)
    }

    function rD(r) {
        try {
            new r
        } catch (e) {
            if (e.message.indexOf("is not a constructor") >= 0) return !1
        }
        return !0
    }

    function Lg(r) {
        return r.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "")
    }
    class sD extends fi {
        constructor({
            baseMaterial: e,
            vertexShader: t,
            fragmentShader: n,
            uniforms: i,
            patchMap: s,
            cacheKey: a,
            ...o
        }) {
            if (!e) throw new Error("CustomShaderMaterial: baseMaterial is required.");
            let l;
            if (rD(e)) {
                const d = Object.keys(o).length === 0;
                l = new e(d ? void 0 : o)
            } else l = e, Object.assign(l, o);
            if (["ShaderMaterial", "RawShaderMaterial"].includes(l.type)) throw new Error(`CustomShaderMaterial does not support ${l.type} as a base material.`);
            super(), this.uniforms = {}, this.vertexShader = "", this.fragmentShader = "";
            const c = l;
            c.name = `CustomShaderMaterial<${l.name||l.type}>`, c.update = this.update.bind(c), c.__csm = {
                prevOnBeforeCompile: l.onBeforeCompile,
                baseMaterial: l,
                vertexShader: t,
                fragmentShader: n,
                uniforms: i,
                patchMap: s,
                cacheKey: a
            };
            const f = { ...c.uniforms || {},
                ...i || {}
            };
            c.uniforms = this.uniforms = f, c.vertexShader = this.vertexShader = t || "", c.fragmentShader = this.fragmentShader = n || "", c.update({
                fragmentShader: c.fragmentShader,
                vertexShader: c.vertexShader,
                uniforms: c.uniforms,
                patchMap: s,
                cacheKey: a
            }), Object.assign(this, c);
            const h = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(c));
            for (const d in h) {
                const u = h[d];
                (u.get || u.set) && Object.defineProperty(this, d, u)
            }
            return Object.defineProperty(this, "type", {
                get() {
                    return l.type
                },
                set(d) {
                    l.type = d
                }
            }), this
        }
        update({
            fragmentShader: e,
            vertexShader: t,
            uniforms: n,
            cacheKey: i,
            patchMap: s
        }) {
            const a = Lg(t || ""),
                o = Lg(e || ""),
                l = this;
            n && (l.uniforms = n), t && (l.vertexShader = t), e && (l.fragmentShader = e), Object.entries(nD).forEach(([d, u]) => {
                for (const _ in u) {
                    const m = u[_];
                    (o && o.includes(m) || a && a.includes(m)) && (l[d] || (l[d] = 1))
                }
            });
            const c = l.__csm.prevOnBeforeCompile,
                f = (d, u, _) => {
                    let m, g = "";
                    if (u) {
                        const p = u.search(/void\s+main\s*\(\s*\)\s*{/);
                        if (p !== -1) {
                            g = u.slice(0, p);
                            let v = 0,
                                x = -1;
                            for (let b = p; b < u.length; b++)
                                if (u[b] === "{" && v++, u[b] === "}" && (v--, v === 0)) {
                                    x = b;
                                    break
                                }
                            if (x !== -1) {
                                const b = u.slice(p, x + 1);
                                m = b.slice(b.indexOf("{") + 1, -1)
                            }
                        } else g = u
                    }
                    if (_ && u && u.includes(Ne.fragColor) && m && (m = `csm_UnlitFac = 1.0;
` + m), d.includes("//~CSM_DEFAULTS")) {
                        d = d.replace("void main() {", `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${g}
          
          void main() {
          `);
                        const p = d.lastIndexOf("//~CSM_MAIN_END");
                        if (p !== -1) {
                            const v = `
            ${m?`${m}`:""}
            //~CSM_MAIN_END
          `;
                            d = d.slice(0, p) + v + d.slice(p)
                        }
                    } else {
                        const p = /void\s*main\s*\(\s*\)\s*{/gm;
                        d = d.replace(p, `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${_?ZE:$E}
          ${YE}
  
          ${g}
          
          void main() {
            {
              ${KE}
            }
            ${_?QE:JE}

            ${m?`${m}`:""}
            //~CSM_MAIN_END
          `)
                    }
                    return d
                };
            l.onBeforeCompile = (d, u) => {
                c ? .(d, u);
                const _ = s || {},
                    m = l.type,
                    g = m ? `#define IS_${m.toUpperCase()};
` : `#define IS_UNKNOWN;
`;
                d.vertexShader = g + `#define IS_VERTEX
` + d.vertexShader, d.fragmentShader = g + `#define IS_FRAGMENT
` + d.fragmentShader;
                const p = v => {
                    for (const x in v) {
                        const b = x === "*" || a && a.includes(x);
                        if (x === "*" || o && o.includes(x) || b) {
                            const M = eD[x];
                            if (M && M !== "*" && (Array.isArray(M) ? !M.includes(m) : M !== m)) {
                                console.error(`CustomShaderMaterial: ${x} is not available in ${m}. Shader cannot compile.`);
                                return
                            }
                            const D = v[x];
                            for (const T in D) {
                                const w = D[T];
                                if (typeof w == "object") {
                                    const S = w.type,
                                        y = w.value;
                                    S === "fs" ? d.fragmentShader = d.fragmentShader.replace(T, y) : S === "vs" && (d.vertexShader = d.vertexShader.replace(T, y))
                                } else w && (d.vertexShader = d.vertexShader.replace(T, w), d.fragmentShader = d.fragmentShader.replace(T, w))
                            }
                        }
                    }
                };
                p(tD), p(_), d.vertexShader = f(d.vertexShader, a, !1), d.fragmentShader = f(d.fragmentShader, o, !0), n && (d.uniforms = { ...d.uniforms,
                    ...l.uniforms
                }), l.uniforms = d.uniforms
            };
            const h = l.customProgramCacheKey;
            l.customProgramCacheKey = () => (i ? .() || iD((a || "") + (o || ""))) + h ? .call(l), l.needsUpdate = !0
        }
        clone() {
            const e = this;
            return new e.constructor({
                baseMaterial: e.__csm.baseMaterial.clone(),
                vertexShader: e.__csm.vertexShader,
                fragmentShader: e.__csm.fragmentShader,
                uniforms: e.__csm.uniforms,
                patchMap: e.__csm.patchMap,
                cacheKey: e.__csm.cacheKey
            })
        }
    }
    class aD {
        constructor(e) {
            this.loader = new wm(e)
        }
        async load(e) {
            if (Array.isArray(e)) {
                const t = e.map(n => this.#e(n));
                return await Promise.all(t)
            } else return await this.#e(e)
        }#
        e(e) {
            return new Promise(t => {
                this.loader.load(e, n => {
                    t(n)
                })
            })
        }
    }

    function Ig(r, e) {
        if (e === 0) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
        if (e === 2 || e === 1) {
            let t = r.getIndex();
            if (t === null) {
                const a = [],
                    o = r.getAttribute("position");
                if (o !== void 0) {
                    for (let l = 0; l < o.count; l++) a.push(l);
                    r.setIndex(a), t = r.getIndex()
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r
            }
            const n = t.count - 2,
                i = [];
            if (e === 2)
                for (let a = 1; a <= n; a++) i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
            else
                for (let a = 0; a < n; a++) a % 2 === 0 ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2))) : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
            i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = r.clone();
            return s.setIndex(i), s.clearGroups(), s
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r
    }
    let oD = class extends Ts {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                return new hD(t)
            }), this.register(function(t) {
                return new dD(t)
            }), this.register(function(t) {
                return new SD(t)
            }), this.register(function(t) {
                return new MD(t)
            }), this.register(function(t) {
                return new TD(t)
            }), this.register(function(t) {
                return new mD(t)
            }), this.register(function(t) {
                return new gD(t)
            }), this.register(function(t) {
                return new _D(t)
            }), this.register(function(t) {
                return new bD(t)
            }), this.register(function(t) {
                return new fD(t)
            }), this.register(function(t) {
                return new xD(t)
            }), this.register(function(t) {
                return new pD(t)
            }), this.register(function(t) {
                return new yD(t)
            }), this.register(function(t) {
                return new vD(t)
            }), this.register(function(t) {
                return new cD(t)
            }), this.register(function(t) {
                return new ED(t)
            }), this.register(function(t) {
                return new DD(t)
            })
        }
        load(e, t, n, i) {
            const s = this;
            let a;
            if (this.resourcePath !== "") a = this.resourcePath;
            else if (this.path !== "") {
                const c = Oo.extractUrlBase(e);
                a = Oo.resolveURL(c, this.path)
            } else a = Oo.extractUrlBase(e);
            this.manager.itemStart(e);
            const o = function(c) {
                    i ? i(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e)
                },
                l = new Tc(this.manager);
            l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
                try {
                    s.parse(c, a, function(f) {
                        t(f), s.manager.itemEnd(e)
                    }, o)
                } catch (f) {
                    o(f)
                }
            }, n, o)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, i) {
            let s;
            const a = {},
                o = {},
                l = new TextDecoder;
            if (typeof e == "string") s = JSON.parse(e);
            else if (e instanceof ArrayBuffer)
                if (l.decode(new Uint8Array(e, 0, 4)) === Ng) {
                    try {
                        a[mt.KHR_BINARY_GLTF] = new AD(e)
                    } catch (h) {
                        i && i(h);
                        return
                    }
                    s = JSON.parse(a[mt.KHR_BINARY_GLTF].content)
                } else s = JSON.parse(l.decode(e));
            else s = e;
            if (s.asset === void 0 || s.asset.version[0] < 2) {
                i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return
            }
            const c = new zD(s, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            c.fileLoader.setRequestHeader(this.requestHeader);
            for (let f = 0; f < this.pluginCallbacks.length; f++) {
                const h = this.pluginCallbacks[f](c);
                h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[h.name] = h, a[h.name] = !0
            }
            if (s.extensionsUsed)
                for (let f = 0; f < s.extensionsUsed.length; ++f) {
                    const h = s.extensionsUsed[f],
                        d = s.extensionsRequired || [];
                    switch (h) {
                        case mt.KHR_MATERIALS_UNLIT:
                            a[h] = new uD;
                            break;
                        case mt.KHR_DRACO_MESH_COMPRESSION:
                            a[h] = new wD(s, this.dracoLoader);
                            break;
                        case mt.KHR_TEXTURE_TRANSFORM:
                            a[h] = new CD;
                            break;
                        case mt.KHR_MESH_QUANTIZATION:
                            a[h] = new RD;
                            break;
                        default:
                            d.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                    }
                }
            c.setExtensions(a), c.setPlugins(o), c.parse(n, i)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise(function(i, s) {
                n.parse(e, t, i, s)
            })
        }
    };

    function lD() {
        let r = {};
        return {
            get: function(e) {
                return r[e]
            },
            add: function(e, t) {
                r[e] = t
            },
            remove: function(e) {
                delete r[e]
            },
            removeAll: function() {
                r = {}
            }
        }
    }
    const mt = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class cD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const s = t[n];
                s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
            }
        }
        _loadLight(e) {
            const t = this.parser,
                n = "light:" + e;
            let i = t.cache.get(n);
            if (i) return i;
            const s = t.json,
                l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
            let c;
            const f = new it(16777215);
            l.color !== void 0 && f.setRGB(l.color[0], l.color[1], l.color[2], yn);
            const h = l.range !== void 0 ? l.range : 0;
            switch (l.type) {
                case "directional":
                    c = new Nv(f), c.target.position.set(0, 0, -1), c.add(c.target);
                    break;
                case "point":
                    c = new Lv(f), c.distance = h;
                    break;
                case "spot":
                    c = new Pv(f), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
            }
            return c.position.set(0, 0, 0), xr(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(n, i), i
        }
        getDependency(e, t) {
            if (e === "light") return this._loadLight(t)
        }
        createNodeAttachment(e) {
            const t = this,
                n = this.parser,
                s = n.json.nodes[e],
                o = (s.extensions && s.extensions[this.name] || {}).light;
            return o === void 0 ? null : this._loadLight(o).then(function(l) {
                return n._getNodeRef(t.cache, o, l)
            })
        }
    }
    class uD {
        constructor() {
            this.name = mt.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return Gr
        }
        extendParams(e, t, n) {
            const i = [];
            e.color = new it(1, 1, 1), e.opacity = 1;
            const s = t.pbrMetallicRoughness;
            if (s) {
                if (Array.isArray(s.baseColorFactor)) {
                    const a = s.baseColorFactor;
                    e.color.setRGB(a[0], a[1], a[2], yn), e.opacity = a[3]
                }
                s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, Yt))
            }
            return Promise.all(i)
        }
    }
    class fD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_EMISSIVE_STRENGTH
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name].emissiveStrength;
            return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve()
        }
    }
    class hD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
                const o = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new pt(o, o)
            }
            return Promise.all(s)
        }
    }
    class dD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_DISPERSION
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name];
            return t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0, Promise.resolve()
        }
    }
    class pD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_IRIDESCENCE
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s)
        }
    }
    class mD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [];
            t.sheenColor = new it(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = i.extensions[this.name];
            if (a.sheenColorFactor !== void 0) {
                const o = a.sheenColorFactor;
                t.sheenColor.setRGB(o[0], o[1], o[2], yn)
            }
            return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Yt)), a.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s)
        }
    }
    class gD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s)
        }
    }
    class _D {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
            const o = a.attenuationColor || [1, 1, 1];
            return t.attenuationColor = new it().setRGB(o[0], o[1], o[2], yn), Promise.all(s)
        }
    }
    class bD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_IOR
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name];
            return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
        }
    }
    class xD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [1, 1, 1];
            return t.specularColor = new it().setRGB(o[0], o[1], o[2], yn), a.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Yt)), Promise.all(s)
        }
    }
    class vD {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_MATERIALS_BUMP
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s)
        }
    }
    class yD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_ANISOTROPY
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : qi
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s)
        }
    }
    class SD {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                n = t.json,
                i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const s = i.extensions[this.name],
                a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, s.source, a)
        }
    }
    class MD {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_TEXTURE_WEBP
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                s = i.textures[e];
            if (!s.extensions || !s.extensions[t]) return null;
            const a = s.extensions[t],
                o = i.images[a.source];
            let l = n.textureLoader;
            if (o.uri) {
                const c = n.options.manager.getHandler(o.uri);
                c !== null && (l = c)
            }
            return n.loadTextureImage(e, a.source, l)
        }
    }
    class TD {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_TEXTURE_AVIF
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                s = i.textures[e];
            if (!s.extensions || !s.extensions[t]) return null;
            const a = s.extensions[t],
                o = i.images[a.source];
            let l = n.textureLoader;
            if (o.uri) {
                const c = n.options.manager.getHandler(o.uri);
                c !== null && (l = c)
            }
            return n.loadTextureImage(e, a.source, l)
        }
    }
    class ED {
        constructor(e) {
            this.name = mt.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const i = n.extensions[this.name],
                    s = this.parser.getDependency("buffer", i.buffer),
                    a = this.parser.options.meshoptDecoder;
                if (!a || !a.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return s.then(function(o) {
                    const l = i.byteOffset || 0,
                        c = i.byteLength || 0,
                        f = i.count,
                        h = i.byteStride,
                        d = new Uint8Array(o, l, c);
                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(f, h, d, i.mode, i.filter).then(function(u) {
                        return u.buffer
                    }) : a.ready.then(function() {
                        const u = new ArrayBuffer(f * h);
                        return a.decodeGltfBuffer(new Uint8Array(u), f, h, d, i.mode, i.filter), u
                    })
                })
            } else return null
        }
    }
    class DD {
        constructor(e) {
            this.name = mt.EXT_MESH_GPU_INSTANCING, this.parser = e
        }
        createNodeMesh(e) {
            const t = this.parser.json,
                n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const i = t.meshes[n.mesh];
            for (const c of i.primitives)
                if (c.mode !== pi.TRIANGLES && c.mode !== pi.TRIANGLE_STRIP && c.mode !== pi.TRIANGLE_FAN && c.mode !== void 0) return null;
            const a = n.extensions[this.name].attributes,
                o = [],
                l = {};
            for (const c in a) o.push(this.parser.getDependency("accessor", a[c]).then(f => (l[c] = f, l[c])));
            return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then(c => {
                const f = c.pop(),
                    h = f.isGroup ? f.children : [f],
                    d = c[0].count,
                    u = [];
                for (const _ of h) {
                    const m = new st,
                        g = new Y,
                        p = new Nr,
                        v = new Y(1, 1, 1),
                        x = new cv(_.geometry, _.material, d);
                    for (let b = 0; b < d; b++) l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, b), l.ROTATION && p.fromBufferAttribute(l.ROTATION, b), l.SCALE && v.fromBufferAttribute(l.SCALE, b), x.setMatrixAt(b, m.compose(g, p, v));
                    for (const b in l)
                        if (b === "_COLOR_0") {
                            const M = l[b];
                            x.instanceColor = new Ef(M.array, M.itemSize, M.normalized)
                        } else b !== "TRANSLATION" && b !== "ROTATION" && b !== "SCALE" && _.geometry.setAttribute(b, l[b]);
                    zt.prototype.copy.call(x, _), this.parser.assignFinalMaterial(x), u.push(x)
                }
                return f.isGroup ? (f.clear(), f.add(...u), f) : u[0]
            }))
        }
    }
    const Ng = "glTF",
        jo = 12,
        Og = {
            JSON: 1313821514,
            BIN: 5130562
        };
    class AD {
        constructor(e) {
            this.name = mt.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, jo),
                n = new TextDecoder;
            if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== Ng) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - jo,
                s = new DataView(e, jo);
            let a = 0;
            for (; a < i;) {
                const o = s.getUint32(a, !0);
                a += 4;
                const l = s.getUint32(a, !0);
                if (a += 4, l === Og.JSON) {
                    const c = new Uint8Array(e, jo + a, o);
                    this.content = n.decode(c)
                } else if (l === Og.BIN) {
                    const c = jo + a;
                    this.body = e.slice(c, c + o)
                }
                a += o
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class wD {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = mt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const n = this.json,
                i = this.dracoLoader,
                s = e.extensions[this.name].bufferView,
                a = e.extensions[this.name].attributes,
                o = {},
                l = {},
                c = {};
            for (const f in a) {
                const h = bh[f] || f.toLowerCase();
                o[h] = a[f]
            }
            for (const f in e.attributes) {
                const h = bh[f] || f.toLowerCase();
                if (a[f] !== void 0) {
                    const d = n.accessors[e.attributes[f]],
                        u = Oa[d.componentType];
                    c[h] = u.name, l[h] = d.normalized === !0
                }
            }
            return t.getDependency("bufferView", s).then(function(f) {
                return new Promise(function(h, d) {
                    i.decodeDracoFile(f, function(u) {
                        for (const _ in u.attributes) {
                            const m = u.attributes[_],
                                g = l[_];
                            g !== void 0 && (m.normalized = g)
                        }
                        h(u)
                    }, o, c, yn, d)
                })
            })
        }
    }
    class CD {
        constructor() {
            this.name = mt.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
        }
    }
    class RD {
        constructor() {
            this.name = mt.KHR_MESH_QUANTIZATION
        }
    }
    class Ug extends Io {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                s = e * i * 3 + i;
            for (let a = 0; a !== i; a++) t[a] = n[s + a];
            return t
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                l = o * 2,
                c = o * 3,
                f = i - t,
                h = (n - t) / f,
                d = h * h,
                u = d * h,
                _ = e * c,
                m = _ - c,
                g = -2 * u + 3 * d,
                p = u - d,
                v = 1 - g,
                x = p - d + h;
            for (let b = 0; b !== o; b++) {
                const M = a[m + b + o],
                    D = a[m + b + l] * f,
                    T = a[_ + b + o],
                    w = a[_ + b] * f;
                s[b] = v * M + x * D + g * T + p * w
            }
            return s
        }
    }
    const PD = new Nr;
    class FD extends Ug {
        interpolate_(e, t, n, i) {
            const s = super.interpolate_(e, t, n, i);
            return PD.fromArray(s).normalize().toArray(s), s
        }
    }
    const pi = {
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6
        },
        Oa = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        Bg = {
            9728: 1003,
            9729: 1006,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008
        },
        kg = {
            33071: 1001,
            33648: 1002,
            10497: 1e3
        },
        _h = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        bh = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        $r = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        LD = {
            CUBICSPLINE: void 0,
            LINEAR: 2301,
            STEP: 2300
        },
        xh = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
        };

    function ID(r) {
        return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Pf({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: 0
        })), r.DefaultMaterial
    }

    function Ls(r, e, t) {
        for (const n in t.extensions) r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n])
    }

    function xr(r, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
    }

    function ND(r, e, t) {
        let n = !1,
            i = !1,
            s = !1;
        for (let c = 0, f = e.length; c < f; c++) {
            const h = e[c];
            if (h.POSITION !== void 0 && (n = !0), h.NORMAL !== void 0 && (i = !0), h.COLOR_0 !== void 0 && (s = !0), n && i && s) break
        }
        if (!n && !i && !s) return Promise.resolve(r);
        const a = [],
            o = [],
            l = [];
        for (let c = 0, f = e.length; c < f; c++) {
            const h = e[c];
            if (n) {
                const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : r.attributes.position;
                a.push(d)
            }
            if (i) {
                const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : r.attributes.normal;
                o.push(d)
            }
            if (s) {
                const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : r.attributes.color;
                l.push(d)
            }
        }
        return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(function(c) {
            const f = c[0],
                h = c[1],
                d = c[2];
            return n && (r.morphAttributes.position = f), i && (r.morphAttributes.normal = h), s && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r
        })
    }

    function OD(r, e) {
        if (r.updateMorphTargets(), e.weights !== void 0)
            for (let t = 0, n = e.weights.length; t < n; t++) r.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const t = e.extras.targetNames;
            if (r.morphTargetInfluences.length === t.length) {
                r.morphTargetDictionary = {};
                for (let n = 0, i = t.length; n < i; n++) r.morphTargetDictionary[t[n]] = n
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function UD(r) {
        let e;
        const t = r.extensions && r.extensions[mt.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + vh(t.attributes) : e = r.indices + ":" + vh(r.attributes) + ":" + r.mode, r.targets !== void 0)
            for (let n = 0, i = r.targets.length; n < i; n++) e += ":" + vh(r.targets[n]);
        return e
    }

    function vh(r) {
        let e = "";
        const t = Object.keys(r).sort();
        for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
        return e
    }

    function yh(r) {
        switch (r) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }

    function BD(r) {
        return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : r.search(/\.ktx2($|\?)/i) > 0 || r.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png"
    }
    const kD = new st;
    class zD {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new lD, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1,
                i = -1,
                s = !1,
                a = -1;
            if (typeof navigator < "u") {
                const o = navigator.userAgent;
                n = /^((?!chrome|android).)*safari/i.test(o) === !0;
                const l = o.match(/Version\/(\d+)/);
                i = n && l ? parseInt(l[1], 10) : -1, s = o.indexOf("Firefox") > -1, a = s ? o.match(/Firefox\/([0-9]+)\./)[1] : -1
            }
            typeof createImageBitmap > "u" || n && i < 17 || s && a < 98 ? this.textureLoader = new wm(this.options.manager) : this.textureLoader = new Ov(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Tc(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const n = this,
                i = this.json,
                s = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
                return a._markDefs && a._markDefs()
            }), Promise.all(this._invokeAll(function(a) {
                return a.beforeRoot && a.beforeRoot()
            })).then(function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            }).then(function(a) {
                const o = {
                    scene: a[0][i.scene || 0],
                    scenes: a[0],
                    animations: a[1],
                    cameras: a[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                return Ls(s, o, i), xr(o, i), Promise.all(n._invokeAll(function(l) {
                    return l.afterRoot && l.afterRoot(o)
                })).then(function() {
                    for (const l of o.scenes) l.updateMatrixWorld();
                    e(o)
                })
            }).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [],
                t = this.json.skins || [],
                n = this.json.meshes || [];
            for (let i = 0, s = t.length; i < s; i++) {
                const a = t[i].joints;
                for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = !0
            }
            for (let i = 0, s = e.length; i < s; i++) {
                const a = e[i];
                a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera)
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(),
                s = (a, o) => {
                    const l = this.associations.get(a);
                    l != null && this.associations.set(o, l);
                    for (const [c, f] of a.children.entries()) s(f, o.children[c])
                };
            return s(n, i), i.name += "_instance_" + e.uses[t]++, i
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const i = e(t[n]);
                if (i) return i
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const s = e(t[i]);
                s && n.push(s)
            }
            return n
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne(function(s) {
                            return s.loadNode && s.loadNode(t)
                        });
                        break;
                    case "mesh":
                        i = this._invokeOne(function(s) {
                            return s.loadMesh && s.loadMesh(t)
                        });
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne(function(s) {
                            return s.loadBufferView && s.loadBufferView(t)
                        });
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne(function(s) {
                            return s.loadMaterial && s.loadMaterial(t)
                        });
                        break;
                    case "texture":
                        i = this._invokeOne(function(s) {
                            return s.loadTexture && s.loadTexture(t)
                        });
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne(function(s) {
                            return s.loadAnimation && s.loadAnimation(t)
                        });
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne(function(s) {
                                return s != this && s.getDependency && s.getDependency(e, t)
                            }), !i) throw new Error("Unknown type: " + e);
                        break
                }
                this.cache.add(n, i)
            }
            return i
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this,
                    i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(i.map(function(s, a) {
                    return n.getDependency(e, a)
                })), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const t = this.json.buffers[e],
                n = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[mt.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise(function(s, a) {
                n.load(Oo.resolveURL(t.uri, i.path), s, void 0, function() {
                    a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                })
            })
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(n) {
                const i = t.byteLength || 0,
                    s = t.byteOffset || 0;
                return n.slice(s, s + i)
            })
        }
        loadAccessor(e) {
            const t = this,
                n = this.json,
                i = this.json.accessors[e];
            if (i.bufferView === void 0 && i.sparse === void 0) {
                const a = _h[i.type],
                    o = Oa[i.componentType],
                    l = i.normalized === !0,
                    c = new o(i.count * a);
                return Promise.resolve(new _n(c, a, l))
            }
            const s = [];
            return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(a) {
                const o = a[0],
                    l = _h[i.type],
                    c = Oa[i.componentType],
                    f = c.BYTES_PER_ELEMENT,
                    h = f * l,
                    d = i.byteOffset || 0,
                    u = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
                    _ = i.normalized === !0;
                let m, g;
                if (u && u !== h) {
                    const p = Math.floor(d / u),
                        v = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                    let x = t.cache.get(v);
                    x || (m = new c(o, p * u, i.count * u / f), x = new rv(m, u / f), t.cache.add(v, x)), g = new yf(x, l, d % u / f, _)
                } else o === null ? m = new c(i.count * l) : m = new c(o, d, i.count * l), g = new _n(m, l, _);
                if (i.sparse !== void 0) {
                    const p = _h.SCALAR,
                        v = Oa[i.sparse.indices.componentType],
                        x = i.sparse.indices.byteOffset || 0,
                        b = i.sparse.values.byteOffset || 0,
                        M = new v(a[1], x, i.sparse.count * p),
                        D = new c(a[2], b, i.sparse.count * l);
                    o !== null && (g = new _n(g.array.slice(), g.itemSize, g.normalized)), g.normalized = !1;
                    for (let T = 0, w = M.length; T < w; T++) {
                        const S = M[T];
                        if (g.setX(S, D[T * l]), l >= 2 && g.setY(S, D[T * l + 1]), l >= 3 && g.setZ(S, D[T * l + 2]), l >= 4 && g.setW(S, D[T * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                    g.normalized = _
                }
                return g
            })
        }
        loadTexture(e) {
            const t = this.json,
                n = this.options,
                s = t.textures[e].source,
                a = t.images[s];
            let o = this.textureLoader;
            if (a.uri) {
                const l = n.manager.getHandler(a.uri);
                l !== null && (o = l)
            }
            return this.loadTextureImage(e, s, o)
        }
        loadTextureImage(e, t, n) {
            const i = this,
                s = this.json,
                a = s.textures[e],
                o = s.images[t],
                l = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[l]) return this.textureCache[l];
            const c = this.loadImageSource(t, n).then(function(f) {
                f.flipY = !1, f.name = a.name || o.name || "", f.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (f.name = o.uri);
                const d = (s.samplers || {})[a.sampler] || {};
                return f.magFilter = Bg[d.magFilter] || 1006, f.minFilter = Bg[d.minFilter] || 1008, f.wrapS = kg[d.wrapS] || 1e3, f.wrapT = kg[d.wrapT] || 1e3, f.generateMipmaps = !f.isCompressedTexture && f.minFilter !== 1003 && f.minFilter !== 1006, i.associations.set(f, {
                    textures: e
                }), f
            }).catch(function() {
                return null
            });
            return this.textureCache[l] = c, c
        }
        loadImageSource(e, t) {
            const n = this,
                i = this.json,
                s = this.options;
            if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone());
            const a = i.images[e],
                o = self.URL || self.webkitURL;
            let l = a.uri || "",
                c = !1;
            if (a.bufferView !== void 0) l = n.getDependency("bufferView", a.bufferView).then(function(h) {
                c = !0;
                const d = new Blob([h], {
                    type: a.mimeType
                });
                return l = o.createObjectURL(d), l
            });
            else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const f = Promise.resolve(l).then(function(h) {
                return new Promise(function(d, u) {
                    let _ = d;
                    t.isImageBitmapLoader === !0 && (_ = function(m) {
                        const g = new tn(m);
                        g.needsUpdate = !0, d(g)
                    }), t.load(Oo.resolveURL(h, s.path), _, void 0, u)
                })
            }).then(function(h) {
                return c === !0 && o.revokeObjectURL(l), xr(h, a), h.userData.mimeType = a.mimeType || BD(a.uri), h
            }).catch(function(h) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h
            });
            return this.sourceCache[e] = f, f
        }
        assignTexture(e, t, n, i) {
            const s = this;
            return this.getDependency("texture", n.index).then(function(a) {
                if (!a) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), s.extensions[mt.KHR_TEXTURE_TRANSFORM]) {
                    const o = n.extensions !== void 0 ? n.extensions[mt.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        const l = s.associations.get(a);
                        a = s.extensions[mt.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l)
                    }
                }
                return i !== void 0 && (a.colorSpace = i), e[t] = a, a
            })
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = t.attributes.tangent === void 0,
                s = t.attributes.color !== void 0,
                a = t.attributes.normal === void 0;
            if (e.isPoints) {
                const o = "PointsMaterial:" + n.uuid;
                let l = this.cache.get(o);
                l || (l = new vm, fi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l
            } else if (e.isLine) {
                const o = "LineBasicMaterial:" + n.uuid;
                let l = this.cache.get(o);
                l || (l = new mm, fi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l
            }
            if (i || s || a) {
                let o = "ClonedMaterial:" + n.uuid + ":";
                i && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
                let l = this.cache.get(o);
                l || (l = n.clone(), s && (l.vertexColors = !0), a && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l
            }
            e.material = n
        }
        getMaterialType() {
            return Pf
        }
        loadMaterial(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                s = n.materials[e];
            let a;
            const o = {},
                l = s.extensions || {},
                c = [];
            if (l[mt.KHR_MATERIALS_UNLIT]) {
                const h = i[mt.KHR_MATERIALS_UNLIT];
                a = h.getMaterialType(), c.push(h.extendParams(o, s, t))
            } else {
                const h = s.pbrMetallicRoughness || {};
                if (o.color = new it(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
                    const d = h.baseColorFactor;
                    o.color.setRGB(d[0], d[1], d[2], yn), o.opacity = d[3]
                }
                h.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", h.baseColorTexture, Yt)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
                    return d.getMaterialType && d.getMaterialType(e)
                }), c.push(Promise.all(this._invokeAll(function(d) {
                    return d.extendMaterialParams && d.extendMaterialParams(e, o)
                })))
            }
            s.doubleSided === !0 && (o.side = 2);
            const f = s.alphaMode || xh.OPAQUE;
            if (f === xh.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, f === xh.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && a !== Gr && (c.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new pt(1, 1), s.normalTexture.scale !== void 0)) {
                const h = s.normalTexture.scale;
                o.normalScale.set(h, h)
            }
            if (s.occlusionTexture !== void 0 && a !== Gr && (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== Gr) {
                const h = s.emissiveFactor;
                o.emissive = new it().setRGB(h[0], h[1], h[2], yn)
            }
            return s.emissiveTexture !== void 0 && a !== Gr && c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Yt)), Promise.all(c).then(function() {
                const h = new a(o);
                return s.name && (h.name = s.name), xr(h, s), t.associations.set(h, {
                    materials: e
                }), s.extensions && Ls(i, h, s), h
            })
        }
        createUniqueName(e) {
            const t = wt.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
        }
        loadGeometries(e) {
            const t = this,
                n = this.extensions,
                i = this.primitiveCache;

            function s(o) {
                return n[mt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
                    return zg(l, o, t)
                })
            }
            const a = [];
            for (let o = 0, l = e.length; o < l; o++) {
                const c = e[o],
                    f = UD(c),
                    h = i[f];
                if (h) a.push(h.promise);
                else {
                    let d;
                    c.extensions && c.extensions[mt.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = zg(new Pi, c, t), i[f] = {
                        primitive: c,
                        promise: d
                    }, a.push(d)
                }
            }
            return Promise.all(a)
        }
        loadMesh(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                s = n.meshes[e],
                a = s.primitives,
                o = [];
            for (let l = 0, c = a.length; l < c; l++) {
                const f = a[l].material === void 0 ? ID(this.cache) : this.getDependency("material", a[l].material);
                o.push(f)
            }
            return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
                const c = l.slice(0, l.length - 1),
                    f = l[l.length - 1],
                    h = [];
                for (let u = 0, _ = f.length; u < _; u++) {
                    const m = f[u],
                        g = a[u];
                    let p;
                    const v = c[u];
                    if (g.mode === pi.TRIANGLES || g.mode === pi.TRIANGLE_STRIP || g.mode === pi.TRIANGLE_FAN || g.mode === void 0) p = s.isSkinnedMesh === !0 ? new av(m, v) : new ei(m, v), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), g.mode === pi.TRIANGLE_STRIP ? p.geometry = Ig(p.geometry, 1) : g.mode === pi.TRIANGLE_FAN && (p.geometry = Ig(p.geometry, 2));
                    else if (g.mode === pi.LINES) p = new hv(m, v);
                    else if (g.mode === pi.LINE_STRIP) p = new Cf(m, v);
                    else if (g.mode === pi.LINE_LOOP) p = new dv(m, v);
                    else if (g.mode === pi.POINTS) p = new pv(m, v);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
                    Object.keys(p.geometry.morphAttributes).length > 0 && OD(p, s), p.name = t.createUniqueName(s.name || "mesh_" + e), xr(p, s), g.extensions && Ls(i, p, g), t.assignFinalMaterial(p), h.push(p)
                }
                for (let u = 0, _ = h.length; u < _; u++) t.associations.set(h[u], {
                    meshes: e,
                    primitives: u
                });
                if (h.length === 1) return s.extensions && Ls(i, h[0], s), h[0];
                const d = new Wr;
                s.extensions && Ls(i, d, s), t.associations.set(d, {
                    meshes: e
                });
                for (let u = 0, _ = h.length; u < _; u++) d.add(h[u]);
                return d
            })
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e],
                i = n[n.type];
            if (!i) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return
            }
            return n.type === "perspective" ? t = new Fn(wx.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Of(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), xr(t, n), Promise.resolve(t)
        }
        loadSkin(e) {
            const t = this.json.skins[e],
                n = [];
            for (let i = 0, s = t.joints.length; i < s; i++) n.push(this._loadNodeShallow(t.joints[i]));
            return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
                const s = i.pop(),
                    a = i,
                    o = [],
                    l = [];
                for (let c = 0, f = a.length; c < f; c++) {
                    const h = a[c];
                    if (h) {
                        o.push(h);
                        const d = new st;
                        s !== null && d.fromArray(s.array, c * 16), l.push(d)
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
                }
                return new Tf(o, l)
            })
        }
        loadAnimation(e) {
            const t = this.json,
                n = this,
                i = t.animations[e],
                s = i.name ? i.name : "animation_" + e,
                a = [],
                o = [],
                l = [],
                c = [],
                f = [];
            for (let h = 0, d = i.channels.length; h < d; h++) {
                const u = i.channels[h],
                    _ = i.samplers[u.sampler],
                    m = u.target,
                    g = m.node,
                    p = i.parameters !== void 0 ? i.parameters[_.input] : _.input,
                    v = i.parameters !== void 0 ? i.parameters[_.output] : _.output;
                m.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", v)), c.push(_), f.push(m))
            }
            return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(c), Promise.all(f)]).then(function(h) {
                const d = h[0],
                    u = h[1],
                    _ = h[2],
                    m = h[3],
                    g = h[4],
                    p = [];
                for (let v = 0, x = d.length; v < x; v++) {
                    const b = d[v],
                        M = u[v],
                        D = _[v],
                        T = m[v],
                        w = g[v];
                    if (b === void 0) continue;
                    b.updateMatrix && b.updateMatrix();
                    const S = n._createAnimationTracks(b, M, D, T, w);
                    if (S)
                        for (let y = 0; y < S.length; y++) p.push(S[y])
                }
                return new Tv(s, void 0, p)
            })
        }
        createNodeMesh(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e];
            return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
                const a = n._getNodeRef(n.meshCache, i.mesh, s);
                return i.weights !== void 0 && a.traverse(function(o) {
                    if (o.isMesh)
                        for (let l = 0, c = i.weights.length; l < c; l++) o.morphTargetInfluences[l] = i.weights[l]
                }), a
            })
        }
        loadNode(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e],
                s = n._loadNodeShallow(e),
                a = [],
                o = i.children || [];
            for (let c = 0, f = o.length; c < f; c++) a.push(n.getDependency("node", o[c]));
            const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
            return Promise.all([s, Promise.all(a), l]).then(function(c) {
                const f = c[0],
                    h = c[1],
                    d = c[2];
                d !== null && f.traverse(function(u) {
                    u.isSkinnedMesh && u.bind(d, kD)
                });
                for (let u = 0, _ = h.length; u < _; u++) f.add(h[u]);
                return f
            })
        }
        _loadNodeShallow(e) {
            const t = this.json,
                n = this.extensions,
                i = this;
            if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
            const s = t.nodes[e],
                a = s.name ? i.createUniqueName(s.name) : "",
                o = [],
                l = i._invokeOne(function(c) {
                    return c.createNodeMesh && c.createNodeMesh(e)
                });
            return l && o.push(l), s.camera !== void 0 && o.push(i.getDependency("camera", s.camera).then(function(c) {
                return i._getNodeRef(i.cameraCache, s.camera, c)
            })), i._invokeAll(function(c) {
                return c.createNodeAttachment && c.createNodeAttachment(e)
            }).forEach(function(c) {
                o.push(c)
            }), this.nodeCache[e] = Promise.all(o).then(function(c) {
                let f;
                if (s.isBone === !0 ? f = new um : c.length > 1 ? f = new Wr : c.length === 1 ? f = c[0] : f = new zt, f !== c[0])
                    for (let h = 0, d = c.length; h < d; h++) f.add(c[h]);
                if (s.name && (f.userData.name = s.name, f.name = a), xr(f, s), s.extensions && Ls(n, f, s), s.matrix !== void 0) {
                    const h = new st;
                    h.fromArray(s.matrix), f.applyMatrix4(h)
                } else s.translation !== void 0 && f.position.fromArray(s.translation), s.rotation !== void 0 && f.quaternion.fromArray(s.rotation), s.scale !== void 0 && f.scale.fromArray(s.scale);
                if (!i.associations.has(f)) i.associations.set(f, {});
                else if (s.mesh !== void 0 && i.meshCache.refs[s.mesh] > 1) {
                    const h = i.associations.get(f);
                    i.associations.set(f, { ...h
                    })
                }
                return i.associations.get(f).nodes = e, f
            }), this.nodeCache[e]
        }
        loadScene(e) {
            const t = this.extensions,
                n = this.json.scenes[e],
                i = this,
                s = new Wr;
            n.name && (s.name = i.createUniqueName(n.name)), xr(s, n), n.extensions && Ls(t, s, n);
            const a = n.nodes || [],
                o = [];
            for (let l = 0, c = a.length; l < c; l++) o.push(i.getDependency("node", a[l]));
            return Promise.all(o).then(function(l) {
                for (let f = 0, h = l.length; f < h; f++) s.add(l[f]);
                const c = f => {
                    const h = new Map;
                    for (const [d, u] of i.associations)(d instanceof fi || d instanceof tn) && h.set(d, u);
                    return f.traverse(d => {
                        const u = i.associations.get(d);
                        u != null && h.set(d, u)
                    }), h
                };
                return i.associations = c(s), s
            })
        }
        _createAnimationTracks(e, t, n, i, s) {
            const a = [],
                o = e.name ? e.name : e.uuid,
                l = [];
            $r[s.path] === $r.weights ? e.traverse(function(d) {
                d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid)
            }) : l.push(o);
            let c;
            switch ($r[s.path]) {
                case $r.weights:
                    c = Ea;
                    break;
                case $r.rotation:
                    c = Da;
                    break;
                case $r.translation:
                case $r.scale:
                    c = wa;
                    break;
                default:
                    switch (n.itemSize) {
                        case 1:
                            c = Ea;
                            break;
                        case 2:
                        case 3:
                        default:
                            c = wa;
                            break
                    }
                    break
            }
            const f = i.interpolation !== void 0 ? LD[i.interpolation] : 2301,
                h = this._getArrayFromAccessor(n);
            for (let d = 0, u = l.length; d < u; d++) {
                const _ = new c(l[d] + "." + $r[s.path], t.array, h, f);
                i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), a.push(_)
            }
            return a
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const n = yh(t.constructor),
                    i = new Float32Array(t.length);
                for (let s = 0, a = t.length; s < a; s++) i[s] = t[s] * n;
                t = i
            }
            return t
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(n) {
                const i = this instanceof Da ? FD : Ug;
                return new i(this.times, this.values, this.getValueSize() / 3, n)
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
        }
    }

    function GD(r, e, t) {
        const n = e.attributes,
            i = new cr;
        if (n.POSITION !== void 0) {
            const o = t.json.accessors[n.POSITION],
                l = o.min,
                c = o.max;
            if (l !== void 0 && c !== void 0) {
                if (i.set(new Y(l[0], l[1], l[2]), new Y(c[0], c[1], c[2])), o.normalized) {
                    const f = yh(Oa[o.componentType]);
                    i.min.multiplyScalar(f), i.max.multiplyScalar(f)
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return
            }
        } else return;
        const s = e.targets;
        if (s !== void 0) {
            const o = new Y,
                l = new Y;
            for (let c = 0, f = s.length; c < f; c++) {
                const h = s[c];
                if (h.POSITION !== void 0) {
                    const d = t.json.accessors[h.POSITION],
                        u = d.min,
                        _ = d.max;
                    if (u !== void 0 && _ !== void 0) {
                        if (l.setX(Math.max(Math.abs(u[0]), Math.abs(_[0]))), l.setY(Math.max(Math.abs(u[1]), Math.abs(_[1]))), l.setZ(Math.max(Math.abs(u[2]), Math.abs(_[2]))), d.normalized) {
                            const m = yh(Oa[d.componentType]);
                            l.multiplyScalar(m)
                        }
                        o.max(l)
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }
            i.expandByVector(o)
        }
        r.boundingBox = i;
        const a = new Xi;
        i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, r.boundingSphere = a
    }

    function zg(r, e, t) {
        const n = e.attributes,
            i = [];

        function s(a, o) {
            return t.getDependency("accessor", a).then(function(l) {
                r.setAttribute(o, l)
            })
        }
        for (const a in n) {
            const o = bh[a] || a.toLowerCase();
            o in r.attributes || i.push(s(n[a], o))
        }
        if (e.indices !== void 0 && !r.index) {
            const a = t.getDependency("accessor", e.indices).then(function(o) {
                r.setIndex(o)
            });
            i.push(a)
        }
        return xt.workingColorSpace !== yn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${xt.workingColorSpace}" not supported.`), xr(r, e), GD(r, e, t), Promise.all(i).then(function() {
            return e.targets !== void 0 ? ND(r, e.targets, t) : r
        })
    }
    const Sh = new WeakMap;
    class HD extends Ts {
        constructor(e) {
            super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }
        setDecoderPath(e) {
            return this.decoderPath = e, this
        }
        setDecoderConfig(e) {
            return this.decoderConfig = e, this
        }
        setWorkerLimit(e) {
            return this.workerLimit = e, this
        }
        load(e, t, n, i) {
            const s = new Tc(this.manager);
            s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, a => {
                this.parse(a, t, i)
            }, n, i)
        }
        parse(e, t, n = () => {}) {
            this.decodeDracoFile(e, t, null, null, Yt, n).catch(n)
        }
        decodeDracoFile(e, t, n, i, s = yn, a = () => {}) {
            const o = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n,
                vertexColorSpace: s
            };
            return this.decodeGeometry(e, o).then(t).catch(a)
        }
        decodeGeometry(e, t) {
            const n = JSON.stringify(t);
            if (Sh.has(e)) {
                const l = Sh.get(e);
                if (l.key === n) return l.promise;
                if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let i;
            const s = this.workerNextTaskID++,
                a = e.byteLength,
                o = this._getWorker(s, a).then(l => (i = l, new Promise((c, f) => {
                    i._callbacks[s] = {
                        resolve: c,
                        reject: f
                    }, i.postMessage({
                        type: "decode",
                        id: s,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }))).then(l => this._createGeometry(l.geometry));
            return o.catch(() => !0).then(() => {
                i && s && this._releaseTask(i, s)
            }), Sh.set(e, {
                key: n,
                promise: o
            }), o
        }
        _createGeometry(e) {
            const t = new Pi;
            e.index && t.setIndex(new _n(e.index.array, 1));
            for (let n = 0; n < e.attributes.length; n++) {
                const i = e.attributes[n],
                    s = i.name,
                    a = i.array,
                    o = i.itemSize,
                    l = new _n(a, o);
                s === "color" && (this._assignVertexColorSpace(l, i.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(s, l)
            }
            return t
        }
        _assignVertexColorSpace(e, t) {
            if (t !== Yt) return;
            const n = new it;
            for (let i = 0, s = e.count; i < s; i++) n.fromBufferAttribute(e, i), xt.colorSpaceToWorking(n, Yt), e.setXYZ(i, n.r, n.g, n.b)
        }
        _loadLibrary(e, t) {
            const n = new Tc(this.manager);
            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, s) => {
                n.load(e, i, void 0, s)
            })
        }
        preload() {
            return this._initDecoder(), this
        }
        _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
                t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(n => {
                const i = n[0];
                e || (this.decoderConfig.wasmBinary = n[1]);
                const s = VD.toString(),
                    a = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([a]))
            }), this.decoderPending
        }
        _getWorker(e, t) {
            return this._initDecoder().then(() => {
                if (this.workerPool.length < this.workerLimit) {
                    const i = new Worker(this.workerSourceURL);
                    i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), i.onmessage = function(s) {
                        const a = s.data;
                        switch (a.type) {
                            case "decode":
                                i._callbacks[a.id].resolve(a);
                                break;
                            case "error":
                                i._callbacks[a.id].reject(a);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"')
                        }
                    }, this.workerPool.push(i)
                } else this.workerPool.sort(function(i, s) {
                    return i._taskLoad > s._taskLoad ? -1 : 1
                });
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[e] = t, n._taskLoad += t, n
            })
        }
        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
        }
        debug() {
            console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
        }
        dispose() {
            for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
            return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
        }
    }

    function VD() {
        let r, e;
        onmessage = function(a) {
            const o = a.data;
            switch (o.type) {
                case "init":
                    r = o.decoderConfig, e = new Promise(function(f) {
                        r.onModuleLoaded = function(h) {
                            f({
                                draco: h
                            })
                        }, DracoDecoderModule(r)
                    });
                    break;
                case "decode":
                    const l = o.buffer,
                        c = o.taskConfig;
                    e.then(f => {
                        const h = f.draco,
                            d = new h.Decoder;
                        try {
                            const u = t(h, d, new Int8Array(l), c),
                                _ = u.attributes.map(m => m.array.buffer);
                            u.index && _.push(u.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: o.id,
                                geometry: u
                            }, _)
                        } catch (u) {
                            console.error(u), self.postMessage({
                                type: "error",
                                id: o.id,
                                error: u.message
                            })
                        } finally {
                            h.destroy(d)
                        }
                    });
                    break
            }
        };

        function t(a, o, l, c) {
            const f = c.attributeIDs,
                h = c.attributeTypes;
            let d, u;
            const _ = o.GetEncodedGeometryType(l);
            if (_ === a.TRIANGULAR_MESH) d = new a.Mesh, u = o.DecodeArrayToMesh(l, l.byteLength, d);
            else if (_ === a.POINT_CLOUD) d = new a.PointCloud, u = o.DecodeArrayToPointCloud(l, l.byteLength, d);
            else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
            if (!u.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + u.error_msg());
            const m = {
                index: null,
                attributes: []
            };
            for (const g in f) {
                const p = self[h[g]];
                let v, x;
                if (c.useUniqueIDs) x = f[g], v = o.GetAttributeByUniqueId(d, x);
                else {
                    if (x = o.GetAttributeId(d, a[f[g]]), x === -1) continue;
                    v = o.GetAttribute(d, x)
                }
                const b = i(a, o, d, g, p, v);
                g === "color" && (b.vertexColorSpace = c.vertexColorSpace), m.attributes.push(b)
            }
            return _ === a.TRIANGULAR_MESH && (m.index = n(a, o, d)), a.destroy(d), m
        }

        function n(a, o, l) {
            const f = l.num_faces() * 3,
                h = f * 4,
                d = a._malloc(h);
            o.GetTrianglesUInt32Array(l, h, d);
            const u = new Uint32Array(a.HEAPF32.buffer, d, f).slice();
            return a._free(d), {
                array: u,
                itemSize: 1
            }
        }

        function i(a, o, l, c, f, h) {
            const d = h.num_components(),
                _ = l.num_points() * d,
                m = _ * f.BYTES_PER_ELEMENT,
                g = s(a, f),
                p = a._malloc(m);
            o.GetAttributeDataArrayForAllPoints(l, h, g, m, p);
            const v = new f(a.HEAPF32.buffer, p, _).slice();
            return a._free(p), {
                name: c,
                array: v,
                itemSize: d
            }
        }

        function s(a, o) {
            switch (o) {
                case Float32Array:
                    return a.DT_FLOAT32;
                case Int8Array:
                    return a.DT_INT8;
                case Int16Array:
                    return a.DT_INT16;
                case Int32Array:
                    return a.DT_INT32;
                case Uint8Array:
                    return a.DT_UINT8;
                case Uint16Array:
                    return a.DT_UINT16;
                case Uint32Array:
                    return a.DT_UINT32
            }
        }
    }
    var WD = function() {
        var r = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
            e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb",
            t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
            n = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
        if (typeof WebAssembly != "object") return {
            supported: !1
        };
        var i = WebAssembly.validate(t) ? e : r,
            s, a = WebAssembly.instantiate(o(i), {}).then(function(p) {
                s = p.instance, s.exports.__wasm_call_ctors()
            });

        function o(p) {
            for (var v = new Uint8Array(p.length), x = 0; x < p.length; ++x) {
                var b = p.charCodeAt(x);
                v[x] = b > 96 ? b - 97 : b > 64 ? b - 39 : b + 4
            }
            for (var M = 0, x = 0; x < p.length; ++x) v[M++] = v[x] < 60 ? n[v[x]] : (v[x] - 60) * 64 + v[++x];
            return v.buffer.slice(0, M)
        }

        function l(p, v, x, b, M, D) {
            var T = s.exports.sbrk,
                w = x + 3 & -4,
                S = T(w * b),
                y = T(M.length),
                C = new Uint8Array(s.exports.memory.buffer);
            C.set(M, y);
            var O = p(S, x, b, y, M.length);
            if (O == 0 && D && D(S, w, b), v.set(C.subarray(S, S + x * b)), T(S - T(0)), O != 0) throw new Error("Malformed buffer data: " + O)
        }
        var c = {
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            },
            f = {
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            },
            h = [],
            d = 0;

        function u(p) {
            var v = {
                object: new Worker(p),
                pending: 0,
                requests: {}
            };
            return v.object.onmessage = function(x) {
                var b = x.data;
                v.pending -= b.count, v.requests[b.id][b.action](b.value), delete v.requests[b.id]
            }, v
        }

        function _(p) {
            for (var v = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + l.toString() + g.toString(), x = new Blob([v], {
                    type: "text/javascript"
                }), b = URL.createObjectURL(x), M = 0; M < p; ++M) h[M] = u(b);
            URL.revokeObjectURL(b)
        }

        function m(p, v, x, b, M) {
            for (var D = h[0], T = 1; T < h.length; ++T) h[T].pending < D.pending && (D = h[T]);
            return new Promise(function(w, S) {
                var y = new Uint8Array(x),
                    C = d++;
                D.pending += p, D.requests[C] = {
                    resolve: w,
                    reject: S
                }, D.object.postMessage({
                    id: C,
                    count: p,
                    size: v,
                    source: y,
                    mode: b,
                    filter: M
                }, [y.buffer])
            })
        }

        function g(p) {
            a.then(function() {
                var v = p.data;
                try {
                    var x = new Uint8Array(v.count * v.size);
                    l(s.exports[v.mode], x, v.count, v.size, v.source, s.exports[v.filter]), self.postMessage({
                        id: v.id,
                        count: v.count,
                        action: "resolve",
                        value: x
                    }, [x.buffer])
                } catch (b) {
                    self.postMessage({
                        id: v.id,
                        count: v.count,
                        action: "reject",
                        value: b
                    })
                }
            })
        }
        return {
            ready: a,
            supported: !0,
            useWorkers: function(p) {
                _(p)
            },
            decodeVertexBuffer: function(p, v, x, b, M) {
                l(s.exports.meshopt_decodeVertexBuffer, p, v, x, b, s.exports[c[M]])
            },
            decodeIndexBuffer: function(p, v, x, b) {
                l(s.exports.meshopt_decodeIndexBuffer, p, v, x, b)
            },
            decodeIndexSequence: function(p, v, x, b) {
                l(s.exports.meshopt_decodeIndexSequence, p, v, x, b)
            },
            decodeGltfBuffer: function(p, v, x, b, M, D) {
                l(s.exports[f[M]], p, v, x, b, s.exports[c[D]])
            },
            decodeGltfBufferAsync: function(p, v, x, b, M) {
                return h.length > 0 ? m(p, v, x, f[b], c[M]) : a.then(function() {
                    var D = new Uint8Array(p * v);
                    return l(s.exports[f[b]], D, p, v, x, s.exports[c[M]]), D
                })
            }
        }
    }();
    class XD {
        constructor(e) {
            this.dracoLoader = new HD, this.loader = new oD(e), this.dracoLoader.setDecoderPath("/draco/"), this.dracoLoader.preload(), this.loader.setDRACOLoader(this.dracoLoader), this.loader.setMeshoptDecoder(WD)
        }
        async load(e) {
            if (Array.isArray(e)) {
                const t = e.map(n => this.#e(n));
                return await Promise.all(t)
            } else return await this.#e(e)
        }#
        e(e) {
            return new Promise(t => {
                this.loader.load(e, n => {
                    t(n)
                })
            })
        }
    }
    const qo = new Am;
    qo.onProgress = (r, e, t) => {
        console.log(`Loaded ${e} resources out of ${t} -> ${r}`)
    }, new aD(qo);
    const jD = new XD(qo);

    function vr(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
    }

    function Gg(r, e) {
        r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
    }
    /*!
     * GSAP 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var ti = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Ua = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        Mh, Tn, Ut, $i = 1e8,
        En = 1 / $i,
        Th = Math.PI * 2,
        qD = Th / 4,
        YD = 0,
        Hg = Math.sqrt,
        KD = Math.cos,
        $D = Math.sin,
        dn = function(e) {
            return typeof e == "string"
        },
        jt = function(e) {
            return typeof e == "function"
        },
        yr = function(e) {
            return typeof e == "number"
        },
        Eh = function(e) {
            return typeof e > "u"
        },
        Ji = function(e) {
            return typeof e == "object"
        },
        Xn = function(e) {
            return e !== !1
        },
        Dh = function() {
            return typeof window < "u"
        },
        Bc = function(e) {
            return jt(e) || dn(e)
        },
        Vg = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
        Dn = Array.isArray,
        Ah = /(?:-?\.?\d|\.)+/gi,
        Wg = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        Ba = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        wh = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        Xg = /[+-]=-?[.\d]+/,
        jg = /[^,'"\[\]\s]+/gi,
        JD = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        Gt, Zi, Ch, Rh, ni = {},
        kc = {},
        qg, Yg = function(e) {
            return (kc = Ns(e, ni)) && Yn
        },
        Ph = function(e, t) {
            return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
        },
        Yo = function(e, t) {
            return !t && console.warn(e)
        },
        Kg = function(e, t) {
            return e && (ni[e] = t) && kc && (kc[e] = t) || ni
        },
        Ko = function() {
            return 0
        },
        ZD = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        },
        zc = {
            suppressEvents: !0,
            kill: !1
        },
        QD = {
            suppressEvents: !0
        },
        Fh = {},
        Jr = [],
        Lh = {},
        $g, ii = {},
        Ih = {},
        Jg = 30,
        Gc = [],
        Nh = "",
        Oh = function(e) {
            var t = e[0],
                n, i;
            if (Ji(t) || jt(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
                for (i = Gc.length; i-- && !Gc[i].targetTest(t););
                n = Gc[i]
            }
            for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new D_(e[i], n))) || e.splice(i, 1);
            return e
        },
        Is = function(e) {
            return e._gsap || Oh(_i(e))[0]._gsap
        },
        Zg = function(e, t, n) {
            return (n = e[t]) && jt(n) ? e[t]() : Eh(n) && e.getAttribute && e.getAttribute(t) || n
        },
        jn = function(e, t) {
            return (e = e.split(",")).forEach(t) || e
        },
        Kt = function(e) {
            return Math.round(e * 1e5) / 1e5 || 0
        },
        pn = function(e) {
            return Math.round(e * 1e7) / 1e7 || 0
        },
        ka = function(e, t) {
            var n = t.charAt(0),
                i = parseFloat(t.substr(2));
            return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
        },
        eA = function(e, t) {
            for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
            return i < n
        },
        Hc = function() {
            var e = Jr.length,
                t = Jr.slice(0),
                n, i;
            for (Lh = {}, Jr.length = 0, n = 0; n < e; n++) i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
        },
        Qg = function(e, t, n, i) {
            Jr.length && !Tn && Hc(), e.render(t, n, Tn && t < 0 && (e._initted || e._startAt)), Jr.length && !Tn && Hc()
        },
        e_ = function(e) {
            var t = parseFloat(e);
            return (t || t === 0) && (e + "").match(jg).length < 2 ? t : dn(e) ? e.trim() : e
        },
        t_ = function(e) {
            return e
        },
        mi = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        tA = function(e) {
            return function(t, n) {
                for (var i in n) i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
            }
        },
        Ns = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        n_ = function r(e, t) {
            for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Ji(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
            return e
        },
        Vc = function(e, t) {
            var n = {},
                i;
            for (i in e) i in t || (n[i] = e[i]);
            return n
        },
        $o = function(e) {
            var t = e.parent || Gt,
                n = e.keyframes ? tA(Dn(e.keyframes)) : mi;
            if (Xn(e.inherit))
                for (; t;) n(e, t.vars.defaults), t = t.parent || t._dp;
            return e
        },
        nA = function(e, t) {
            for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
            return n < 0
        },
        i_ = function(e, t, n, i, s) {
            var a = e[i],
                o;
            if (s)
                for (o = t[s]; a && a[s] > o;) a = a._prev;
            return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t
        },
        Wc = function(e, t, n, i) {
            n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
            var s = t._prev,
                a = t._next;
            s ? s._next = a : e[n] === t && (e[n] = a), a ? a._prev = s : e[i] === t && (e[i] = s), t._next = t._prev = t.parent = null
        },
        Zr = function(e, t) {
            e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
        },
        Os = function(e, t) {
            if (e && (!t || t._end > e._dur || t._start < 0))
                for (var n = e; n;) n._dirty = 1, n = n.parent;
            return e
        },
        iA = function(e) {
            for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
            return e
        },
        Uh = function(e, t, n, i) {
            return e._startAt && (Tn ? e._startAt.revert(zc) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
        },
        rA = function r(e) {
            return !e || e._ts && r(e.parent)
        },
        r_ = function(e) {
            return e._repeat ? za(e._tTime, e = e.duration() + e._rDelay) * e : 0
        },
        za = function(e, t) {
            var n = Math.floor(e /= t);
            return e && n === e ? n - 1 : n
        },
        Xc = function(e, t) {
            return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        },
        jc = function(e) {
            return e._end = pn(e._start + (e._tDur / Math.abs(e._ts || e._rts || En) || 0))
        },
        qc = function(e, t) {
            var n = e._dp;
            return n && n.smoothChildTiming && e._ts && (e._start = pn(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), jc(e), n._dirty || Os(n, e)), e
        },
        s_ = function(e, t) {
            var n;
            if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Xc(e.rawTime(), t), (!t._dur || Zo(0, t.totalDuration(), n) - t._tTime > En) && t.render(n, !0)), Os(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                if (e._dur < e.duration())
                    for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                e._zTime = -1e-8
            }
        },
        Qi = function(e, t, n, i) {
            return t.parent && Zr(t), t._start = pn((yr(n) ? n : n || e !== Gt ? gi(e, n, t) : e._time) + t._delay), t._end = pn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), i_(e, t, "_first", "_last", e._sort ? "_start" : 0), Bh(t) || (e._recent = t), i || s_(e, t), e._ts < 0 && qc(e, e._tTime), e
        },
        a_ = function(e, t) {
            return (ni.ScrollTrigger || Ph("scrollTrigger", t)) && ni.ScrollTrigger.create(t, e)
        },
        o_ = function(e, t, n, i, s) {
            if (qh(e, t, s), !e._initted) return 1;
            if (!n && e._pt && !Tn && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && $g !== si.frame) return Jr.push(e), e._lazy = [s, i], 1
        },
        sA = function r(e) {
            var t = e.parent;
            return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t))
        },
        Bh = function(e) {
            var t = e.data;
            return t === "isFromStart" || t === "isStart"
        },
        aA = function(e, t, n, i) {
            var s = e.ratio,
                a = t < 0 || !t && (!e._start && sA(e) && !(!e._initted && Bh(e)) || (e._ts < 0 || e._dp._ts < 0) && !Bh(e)) ? 0 : 1,
                o = e._rDelay,
                l = 0,
                c, f, h;
            if (o && e._repeat && (l = Zo(0, e._tDur, t), f = za(l, o), e._yoyo && f & 1 && (a = 1 - a), f !== za(e._tTime, o) && (s = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== s || Tn || i || e._zTime === En || !t && e._zTime) {
                if (!e._initted && o_(e, t, i, n, l)) return;
                for (h = e._zTime, e._zTime = t || (n ? En : 0), n || (n = t && !h), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, c = e._pt; c;) c.r(a, c.d), c = c._next;
                t < 0 && Uh(e, t, n, !0), e._onUpdate && !n && ri(e, "onUpdate"), l && e._repeat && !n && e.parent && ri(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && Zr(e, 1), !n && !Tn && (ri(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
            } else e._zTime || (e._zTime = t)
        },
        oA = function(e, t, n) {
            var i;
            if (n > t)
                for (i = e._first; i && i._start <= n;) {
                    if (i.data === "isPause" && i._start > t) return i;
                    i = i._next
                } else
                    for (i = e._last; i && i._start >= n;) {
                        if (i.data === "isPause" && i._start < t) return i;
                        i = i._prev
                    }
        },
        Ga = function(e, t, n, i) {
            var s = e._repeat,
                a = pn(t) || 0,
                o = e._tTime / e._tDur;
            return o && !i && (e._time *= a / e._dur), e._dur = a, e._tDur = s ? s < 0 ? 1e10 : pn(a * (s + 1) + e._rDelay * s) : a, o > 0 && !i && qc(e, e._tTime = e._tDur * o), e.parent && jc(e), n || Os(e.parent, e), e
        },
        l_ = function(e) {
            return e instanceof Nn ? Os(e) : Ga(e, e._dur)
        },
        lA = {
            _start: 0,
            endTime: Ko,
            totalDuration: Ko
        },
        gi = function r(e, t, n) {
            var i = e.labels,
                s = e._recent || lA,
                a = e.duration() >= $i ? s.endTime(!1) : e._dur,
                o, l, c;
            return dn(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? s : n).totalDuration() / 100 : 1)) : o < 0 ? (t in i || (i[t] = a), i[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && n && (l = l / 100 * (Dn(n) ? n[0] : n).totalDuration()), o > 1 ? r(e, t.substr(0, o - 1), n) + l : a + l)) : t == null ? a : +t
        },
        Jo = function(e, t, n) {
            var i = yr(t[1]),
                s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
                a = t[s],
                o, l;
            if (i && (a.duration = t[1]), a.parent = n, e) {
                for (o = a, l = n; l && !("immediateRender" in o);) o = l.vars.defaults || {}, l = Xn(l.vars.inherit) && l.parent;
                a.immediateRender = Xn(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1]
            }
            return new Zt(t[0], a, t[s + 1])
        },
        Qr = function(e, t) {
            return e || e === 0 ? t(e) : t
        },
        Zo = function(e, t, n) {
            return n < e ? e : n > t ? t : n
        },
        An = function(e, t) {
            return !dn(e) || !(t = JD.exec(e)) ? "" : t[1]
        },
        cA = function(e, t, n) {
            return Qr(n, function(i) {
                return Zo(e, t, i)
            })
        },
        kh = [].slice,
        c_ = function(e, t) {
            return e && Ji(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Ji(e[0])) && !e.nodeType && e !== Zi
        },
        uA = function(e, t, n) {
            return n === void 0 && (n = []), e.forEach(function(i) {
                var s;
                return dn(i) && !t || c_(i, 1) ? (s = n).push.apply(s, _i(i)) : n.push(i)
            }) || n
        },
        _i = function(e, t, n) {
            return Ut && !t && Ut.selector ? Ut.selector(e) : dn(e) && !n && (Ch || !Va()) ? kh.call((t || Rh).querySelectorAll(e), 0) : Dn(e) ? uA(e, n) : c_(e) ? kh.call(e, 0) : e ? [e] : []
        },
        zh = function(e) {
            return e = _i(e)[0] || Yo("Invalid scope") || {},
                function(t) {
                    var n = e.current || e.nativeElement || e;
                    return _i(t, n.querySelectorAll ? n : n === e ? Yo("Invalid scope") || Rh.createElement("div") : e)
                }
        },
        u_ = function(e) {
            return e.sort(function() {
                return .5 - Math.random()
            })
        },
        f_ = function(e) {
            if (jt(e)) return e;
            var t = Ji(e) ? e : {
                    each: e
                },
                n = Us(t.ease),
                i = t.from || 0,
                s = parseFloat(t.base) || 0,
                a = {},
                o = i > 0 && i < 1,
                l = isNaN(i) || o,
                c = t.axis,
                f = i,
                h = i;
            return dn(i) ? f = h = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[i] || 0 : !o && l && (f = i[0], h = i[1]),
                function(d, u, _) {
                    var m = (_ || t).length,
                        g = a[m],
                        p, v, x, b, M, D, T, w, S;
                    if (!g) {
                        if (S = t.grid === "auto" ? 0 : (t.grid || [1, $i])[1], !S) {
                            for (T = -1e8; T < (T = _[S++].getBoundingClientRect().left) && S < m;);
                            S < m && S--
                        }
                        for (g = a[m] = [], p = l ? Math.min(S, m) * f - .5 : i % S, v = S === $i ? 0 : l ? m * h / S - .5 : i / S | 0, T = 0, w = $i, D = 0; D < m; D++) x = D % S - p, b = v - (D / S | 0), g[D] = M = c ? Math.abs(c === "y" ? b : x) : Hg(x * x + b * b), M > T && (T = M), M < w && (w = M);
                        i === "random" && u_(g), g.max = T - w, g.min = w, g.v = m = (parseFloat(t.amount) || parseFloat(t.each) * (S > m ? m - 1 : c ? c === "y" ? m / S : S : Math.max(S, m / S)) || 0) * (i === "edges" ? -1 : 1), g.b = m < 0 ? s - m : s, g.u = An(t.amount || t.each) || 0, n = n && m < 0 ? M_(n) : n
                    }
                    return m = (g[d] - g.min) / g.max || 0, pn(g.b + (n ? n(m) : m) * g.v) + g.u
                }
        },
        Gh = function(e) {
            var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
            return function(n) {
                var i = pn(Math.round(parseFloat(n) / e) * e * t);
                return (i - i % 1) / t + (yr(n) ? 0 : An(n))
            }
        },
        h_ = function(e, t) {
            var n = Dn(e),
                i, s;
            return !n && Ji(e) && (i = n = e.radius || $i, e.values ? (e = _i(e.values), (s = !yr(e[0])) && (i *= i)) : e = Gh(e.increment)), Qr(t, n ? jt(e) ? function(a) {
                return s = e(a), Math.abs(s - a) <= i ? s : a
            } : function(a) {
                for (var o = parseFloat(s ? a.x : a), l = parseFloat(s ? a.y : 0), c = $i, f = 0, h = e.length, d, u; h--;) s ? (d = e[h].x - o, u = e[h].y - l, d = d * d + u * u) : d = Math.abs(e[h] - o), d < c && (c = d, f = h);
                return f = !i || c <= i ? e[f] : a, s || f === a || yr(a) ? f : f + An(a)
            } : Gh(e))
        },
        d_ = function(e, t, n, i) {
            return Qr(Dn(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
                return Dn(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
            })
        },
        fA = function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return function(i) {
                return t.reduce(function(s, a) {
                    return a(s)
                }, i)
            }
        },
        hA = function(e, t) {
            return function(n) {
                return e(parseFloat(n)) + (t || An(n))
            }
        },
        dA = function(e, t, n) {
            return m_(e, t, 0, 1, n)
        },
        p_ = function(e, t, n) {
            return Qr(n, function(i) {
                return e[~~t(i)]
            })
        },
        pA = function r(e, t, n) {
            var i = t - e;
            return Dn(e) ? p_(e, r(0, e.length), t) : Qr(n, function(s) {
                return (i + (s - e) % i) % i + e
            })
        },
        mA = function r(e, t, n) {
            var i = t - e,
                s = i * 2;
            return Dn(e) ? p_(e, r(0, e.length - 1), t) : Qr(n, function(a) {
                return a = (s + (a - e) % s) % s || 0, e + (a > i ? s - a : a)
            })
        },
        Qo = function(e) {
            for (var t = 0, n = "", i, s, a, o; ~(i = e.indexOf("random(", t));) a = e.indexOf(")", i), o = e.charAt(i + 7) === "[", s = e.substr(i + 7, a - i - 7).match(o ? jg : Ah), n += e.substr(t, i - t) + d_(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), t = a + 1;
            return n + e.substr(t, e.length - t)
        },
        m_ = function(e, t, n, i, s) {
            var a = t - e,
                o = i - n;
            return Qr(s, function(l) {
                return n + ((l - e) / a * o || 0)
            })
        },
        gA = function r(e, t, n, i) {
            var s = isNaN(e + t) ? 0 : function(u) {
                return (1 - u) * e + u * t
            };
            if (!s) {
                var a = dn(e),
                    o = {},
                    l, c, f, h, d;
                if (n === !0 && (i = 1) && (n = null), a) e = {
                    p: e
                }, t = {
                    p: t
                };
                else if (Dn(e) && !Dn(t)) {
                    for (f = [], h = e.length, d = h - 2, c = 1; c < h; c++) f.push(r(e[c - 1], e[c]));
                    h--, s = function(_) {
                        _ *= h;
                        var m = Math.min(d, ~~_);
                        return f[m](_ - m)
                    }, n = t
                } else i || (e = Ns(Dn(e) ? [] : {}, e));
                if (!f) {
                    for (l in t) Xh.call(o, e, l, "get", t[l]);
                    s = function(_) {
                        return $h(_, o) || (a ? e.p : e)
                    }
                }
            }
            return Qr(n, s)
        },
        g_ = function(e, t, n) {
            var i = e.labels,
                s = $i,
                a, o, l;
            for (a in i) o = i[a] - t, o < 0 == !!n && o && s > (o = Math.abs(o)) && (l = a, s = o);
            return l
        },
        ri = function(e, t, n) {
            var i = e.vars,
                s = i[t],
                a = Ut,
                o = e._ctx,
                l, c, f;
            if (s) return l = i[t + "Params"], c = i.callbackScope || e, n && Jr.length && Hc(), o && (Ut = o), f = l ? s.apply(c, l) : s.call(c), Ut = a, f
        },
        el = function(e) {
            return Zr(e), e.scrollTrigger && e.scrollTrigger.kill(!!Tn), e.progress() < 1 && ri(e, "onInterrupt"), e
        },
        Ha, __ = [],
        b_ = function(e) {
            if (e)
                if (e = !e.name && e.default || e, Dh() || e.headless) {
                    var t = e.name,
                        n = jt(e),
                        i = t && !n && e.init ? function() {
                            this._props = []
                        } : e,
                        s = {
                            init: Ko,
                            render: $h,
                            add: Xh,
                            kill: FA,
                            modifier: PA,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Kh,
                            aliases: {},
                            register: 0
                        };
                    if (Va(), e !== i) {
                        if (ii[t]) return;
                        mi(i, mi(Vc(e, s), a)), Ns(i.prototype, Ns(s, Vc(e, a))), ii[i.prop = t] = i, e.targetTest && (Gc.push(i), Fh[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    Kg(t, i), e.register && e.register(Yn, i, qn)
                } else __.push(e)
        },
        Ft = 255,
        tl = {
            aqua: [0, Ft, Ft],
            lime: [0, Ft, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, Ft],
            navy: [0, 0, 128],
            white: [Ft, Ft, Ft],
            olive: [128, 128, 0],
            yellow: [Ft, Ft, 0],
            orange: [Ft, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [Ft, 0, 0],
            pink: [Ft, 192, 203],
            cyan: [0, Ft, Ft],
            transparent: [Ft, Ft, Ft, 0]
        },
        Hh = function(e, t, n) {
            return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Ft + .5 | 0
        },
        x_ = function(e, t, n) {
            var i = e ? yr(e) ? [e >> 16, e >> 8 & Ft, e & Ft] : 0 : tl.black,
                s, a, o, l, c, f, h, d, u, _;
            if (!i) {
                if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), tl[e]) i = tl[e];
                else if (e.charAt(0) === "#") {
                    if (e.length < 6 && (s = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + s + s + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & Ft, i & Ft, parseInt(e.substr(7), 16) / 255];
                    e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & Ft, e & Ft]
                } else if (e.substr(0, 3) === "hsl") {
                    if (i = _ = e.match(Ah), !t) l = +i[0] % 360 / 360, c = +i[1] / 100, f = +i[2] / 100, a = f <= .5 ? f * (c + 1) : f + c - f * c, s = f * 2 - a, i.length > 3 && (i[3] *= 1), i[0] = Hh(l + 1 / 3, s, a), i[1] = Hh(l, s, a), i[2] = Hh(l - 1 / 3, s, a);
                    else if (~e.indexOf("=")) return i = e.match(Wg), n && i.length < 4 && (i[3] = 1), i
                } else i = e.match(Ah) || tl.transparent;
                i = i.map(Number)
            }
            return t && !_ && (s = i[0] / Ft, a = i[1] / Ft, o = i[2] / Ft, h = Math.max(s, a, o), d = Math.min(s, a, o), f = (h + d) / 2, h === d ? l = c = 0 : (u = h - d, c = f > .5 ? u / (2 - h - d) : u / (h + d), l = h === s ? (a - o) / u + (a < o ? 6 : 0) : h === a ? (o - s) / u + 2 : (s - a) / u + 4, l *= 60), i[0] = ~~(l + .5), i[1] = ~~(c * 100 + .5), i[2] = ~~(f * 100 + .5)), n && i.length < 4 && (i[3] = 1), i
        },
        v_ = function(e) {
            var t = [],
                n = [],
                i = -1;
            return e.split(es).forEach(function(s) {
                var a = s.match(Ba) || [];
                t.push.apply(t, a), n.push(i += a.length + 1)
            }), t.c = n, t
        },
        y_ = function(e, t, n) {
            var i = "",
                s = (e + i).match(es),
                a = t ? "hsla(" : "rgba(",
                o = 0,
                l, c, f, h;
            if (!s) return e;
            if (s = s.map(function(d) {
                    return (d = x_(d, t, 1)) && a + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
                }), n && (f = v_(e), l = n.c, l.join(i) !== f.c.join(i)))
                for (c = e.replace(es, "1").split(Ba), h = c.length - 1; o < h; o++) i += c[o] + (~l.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (f.length ? f : s.length ? s : n).shift());
            if (!c)
                for (c = e.split(es), h = c.length - 1; o < h; o++) i += c[o] + s[o];
            return i + c[h]
        },
        es = function() {
            var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                e;
            for (e in tl) r += "|" + e + "\\b";
            return new RegExp(r + ")", "gi")
        }(),
        _A = /hsl[a]?\(/,
        S_ = function(e) {
            var t = e.join(" "),
                n;
            if (es.lastIndex = 0, es.test(t)) return n = _A.test(t), e[1] = y_(e[1], n), e[0] = y_(e[0], n, v_(e[1])), !0
        },
        nl, si = function() {
            var r = Date.now,
                e = 500,
                t = 33,
                n = r(),
                i = n,
                s = 1e3 / 240,
                a = s,
                o = [],
                l, c, f, h, d, u, _ = function m(g) {
                    var p = r() - i,
                        v = g === !0,
                        x, b, M, D;
                    if ((p > e || p < 0) && (n += p - t), i += p, M = i - n, x = M - a, (x > 0 || v) && (D = ++h.frame, d = M - h.time * 1e3, h.time = M = M / 1e3, a += x + (x >= s ? 4 : s - x), b = 1), v || (l = c(m)), b)
                        for (u = 0; u < o.length; u++) o[u](M, d, D, g)
                };
            return h = {
                time: 0,
                frame: 0,
                tick: function() {
                    _(!0)
                },
                deltaRatio: function(g) {
                    return d / (1e3 / (g || 60))
                },
                wake: function() {
                    qg && (!Ch && Dh() && (Zi = Ch = window, Rh = Zi.document || {}, ni.gsap = Yn, (Zi.gsapVersions || (Zi.gsapVersions = [])).push(Yn.version), Yg(kc || Zi.GreenSockGlobals || !Zi.gsap && Zi || {}), __.forEach(b_)), f = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && h.sleep(), c = f || function(g) {
                        return setTimeout(g, a - h.time * 1e3 + 1 | 0)
                    }, nl = 1, _(2))
                },
                sleep: function() {
                    (f ? cancelAnimationFrame : clearTimeout)(l), nl = 0, c = Ko
                },
                lagSmoothing: function(g, p) {
                    e = g || 1 / 0, t = Math.min(p || 33, e)
                },
                fps: function(g) {
                    s = 1e3 / (g || 240), a = h.time * 1e3 + s
                },
                add: function(g, p, v) {
                    var x = p ? function(b, M, D, T) {
                        g(b, M, D, T), h.remove(x)
                    } : g;
                    return h.remove(g), o[v ? "unshift" : "push"](x), Va(), x
                },
                remove: function(g, p) {
                    ~(p = o.indexOf(g)) && o.splice(p, 1) && u >= p && u--
                },
                _listeners: o
            }, h
        }(),
        Va = function() {
            return !nl && si.wake()
        },
        vt = {},
        bA = /^[\d.\-M][\d.\-,\s]/,
        xA = /["']/g,
        vA = function(e) {
            for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], s = 1, a = n.length, o, l, c; s < a; s++) l = n[s], o = s !== a - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), t[i] = isNaN(c) ? c.replace(xA, "").trim() : +c, i = l.substr(o + 1).trim();
            return t
        },
        yA = function(e) {
            var t = e.indexOf("(") + 1,
                n = e.indexOf(")"),
                i = e.indexOf("(", t);
            return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
        },
        SA = function(e) {
            var t = (e + "").split("("),
                n = vt[t[0]];
            return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [vA(t[1])] : yA(e).split(",").map(e_)) : vt._CE && bA.test(e) ? vt._CE("", e) : n
        },
        M_ = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        T_ = function r(e, t) {
            for (var n = e._first, i; n;) n instanceof Nn ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
        },
        Us = function(e, t) {
            return e && (jt(e) ? e : vt[e] || SA(e)) || t
        },
        Bs = function(e, t, n, i) {
            n === void 0 && (n = function(l) {
                return 1 - t(1 - l)
            }), i === void 0 && (i = function(l) {
                return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
            });
            var s = {
                    easeIn: t,
                    easeOut: n,
                    easeInOut: i
                },
                a;
            return jn(e, function(o) {
                vt[o] = ni[o] = s, vt[a = o.toLowerCase()] = n;
                for (var l in s) vt[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = vt[o + "." + l] = s[l]
            }), s
        },
        E_ = function(e) {
            return function(t) {
                return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
            }
        },
        Vh = function r(e, t, n) {
            var i = t >= 1 ? t : 1,
                s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1),
                a = s / Th * (Math.asin(1 / i) || 0),
                o = function(f) {
                    return f === 1 ? 1 : i * Math.pow(2, -10 * f) * $D((f - a) * s) + 1
                },
                l = e === "out" ? o : e === "in" ? function(c) {
                    return 1 - o(1 - c)
                } : E_(o);
            return s = Th / s, l.config = function(c, f) {
                return r(e, c, f)
            }, l
        },
        Wh = function r(e, t) {
            t === void 0 && (t = 1.70158);
            var n = function(a) {
                    return a ? --a * a * ((t + 1) * a + t) + 1 : 0
                },
                i = e === "out" ? n : e === "in" ? function(s) {
                    return 1 - n(1 - s)
                } : E_(n);
            return i.config = function(s) {
                return r(e, s)
            }, i
        };
    jn("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
            var t = e < 5 ? e + 1 : e;
            Bs(r + ",Power" + (t - 1), e ? function(n) {
                return Math.pow(n, t)
            } : function(n) {
                return n
            }, function(n) {
                return 1 - Math.pow(1 - n, t)
            }, function(n) {
                return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
            })
        }), vt.Linear.easeNone = vt.none = vt.Linear.easeIn, Bs("Elastic", Vh("in"), Vh("out"), Vh()),
        function(r, e) {
            var t = 1 / e,
                n = 2 * t,
                i = 2.5 * t,
                s = function(o) {
                    return o < t ? r * o * o : o < n ? r * Math.pow(o - 1.5 / e, 2) + .75 : o < i ? r * (o -= 2.25 / e) * o + .9375 : r * Math.pow(o - 2.625 / e, 2) + .984375
                };
            Bs("Bounce", function(a) {
                return 1 - s(1 - a)
            }, s)
        }(7.5625, 2.75), Bs("Expo", function(r) {
            return r ? Math.pow(2, 10 * (r - 1)) : 0
        }), Bs("Circ", function(r) {
            return -(Hg(1 - r * r) - 1)
        }), Bs("Sine", function(r) {
            return r === 1 ? 1 : -KD(r * qD) + 1
        }), Bs("Back", Wh("in"), Wh("out"), Wh()), vt.SteppedEase = vt.steps = ni.SteppedEase = {
            config: function(e, t) {
                e === void 0 && (e = 1);
                var n = 1 / e,
                    i = e + (t ? 0 : 1),
                    s = t ? 1 : 0,
                    a = 1 - En;
                return function(o) {
                    return ((i * Zo(0, a, o) | 0) + s) * n
                }
            }
        }, Ua.ease = vt["quad.out"], jn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
            return Nh += r + "," + r + "Params,"
        });
    var D_ = function(e, t) {
            this.id = YD++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Zg, this.set = t ? t.getSetter : Kh
        },
        il = function() {
            function r(t) {
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ga(this, +t.duration, 1, 1), this.data = t.data, Ut && (this._ctx = Ut, Ut.data.push(this)), nl || si.wake()
            }
            var e = r.prototype;
            return e.delay = function(n) {
                return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
            }, e.duration = function(n) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
            }, e.totalDuration = function(n) {
                return arguments.length ? (this._dirty = 0, Ga(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function(n, i) {
                if (Va(), !arguments.length) return this._tTime;
                var s = this._dp;
                if (s && s.smoothChildTiming && this._ts) {
                    for (qc(this, n), !s._dp || s.parent || s_(s, this); s && s.parent;) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Qi(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === En || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), Qg(this, n, i)), this
            }, e.time = function(n, i) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + r_(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
            }, e.totalProgress = function(n, i) {
                return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
            }, e.progress = function(n, i) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + r_(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
            }, e.iteration = function(n, i) {
                var s = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (n - 1) * s, i) : this._repeat ? za(this._tTime, s) + 1 : 1
            }, e.timeScale = function(n, i) {
                if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
                if (this._rts === n) return this;
                var s = this.parent && this._ts ? Xc(this.parent._time, this) : this._tTime;
                return this._rts = +n || 0, this._ts = this._ps || n === -1e-8 ? 0 : this._rts, this.totalTime(Zo(-Math.abs(this._delay), this._tDur, s), i !== !1), jc(this), iA(this)
            }, e.paused = function(n) {
                return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Va(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== En && (this._tTime -= En)))), this) : this._ps
            }, e.startTime = function(n) {
                if (arguments.length) {
                    this._start = n;
                    var i = this.parent || this._dp;
                    return i && (i._sort || !this.parent) && Qi(i, this, n - this._delay), this
                }
                return this._start
            }, e.endTime = function(n) {
                return this._start + (Xn(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, e.rawTime = function(n) {
                var i = this.parent || this._dp;
                return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Xc(i.rawTime(n), this) : this._tTime : this._tTime
            }, e.revert = function(n) {
                n === void 0 && (n = QD);
                var i = Tn;
                return Tn = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Tn = i, this
            }, e.globalTime = function(n) {
                for (var i = this, s = arguments.length ? n : i.rawTime(); i;) s = i._start + s / (Math.abs(i._ts) || 1), i = i._dp;
                return !this.parent && this._sat ? this._sat.globalTime(n) : s
            }, e.repeat = function(n) {
                return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, l_(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
            }, e.repeatDelay = function(n) {
                if (arguments.length) {
                    var i = this._time;
                    return this._rDelay = n, l_(this), i ? this.time(i) : this
                }
                return this._rDelay
            }, e.yoyo = function(n) {
                return arguments.length ? (this._yoyo = n, this) : this._yoyo
            }, e.seek = function(n, i) {
                return this.totalTime(gi(this, n), Xn(i))
            }, e.restart = function(n, i) {
                return this.play().totalTime(n ? -this._delay : 0, Xn(i))
            }, e.play = function(n, i) {
                return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
            }, e.reverse = function(n, i) {
                return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1)
            }, e.pause = function(n, i) {
                return n != null && this.seek(n, i), this.paused(!0)
            }, e.resume = function() {
                return this.paused(!1)
            }, e.reversed = function(n) {
                return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function() {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, e.isActive = function() {
                var n = this.parent || this._dp,
                    i = this._start,
                    s;
                return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= i && s < this.endTime(!0) - En)
            }, e.eventCallback = function(n, i, s) {
                var a = this.vars;
                return arguments.length > 1 ? (i ? (a[n] = i, s && (a[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = i)) : delete a[n], this) : a[n]
            }, e.then = function(n) {
                var i = this;
                return new Promise(function(s) {
                    var a = jt(n) ? n : t_,
                        o = function() {
                            var c = i.then;
                            i.then = null, jt(a) && (a = a(i)) && (a.then || a === i) && (i.then = c), s(a), i.then = c
                        };
                    i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o
                })
            }, e.kill = function() {
                el(this)
            }, r
        }();
    mi(il.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Nn = function(r) {
        Gg(e, r);

        function e(n, i) {
            var s;
            return n === void 0 && (n = {}), s = r.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = Xn(n.sortChildren), Gt && Qi(n.parent || Gt, vr(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && a_(vr(s), n.scrollTrigger), s
        }
        var t = e.prototype;
        return t.to = function(i, s, a) {
            return Jo(0, arguments, this), this
        }, t.from = function(i, s, a) {
            return Jo(1, arguments, this), this
        }, t.fromTo = function(i, s, a, o) {
            return Jo(2, arguments, this), this
        }, t.set = function(i, s, a) {
            return s.duration = 0, s.parent = this, $o(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Zt(i, s, gi(this, a), 1), this
        }, t.call = function(i, s, a) {
            return Qi(this, Zt.delayedCall(0, i, s), a)
        }, t.staggerTo = function(i, s, a, o, l, c, f) {
            return a.duration = s, a.stagger = a.stagger || o, a.onComplete = c, a.onCompleteParams = f, a.parent = this, new Zt(i, a, gi(this, l)), this
        }, t.staggerFrom = function(i, s, a, o, l, c, f) {
            return a.runBackwards = 1, $o(a).immediateRender = Xn(a.immediateRender), this.staggerTo(i, s, a, o, l, c, f)
        }, t.staggerFromTo = function(i, s, a, o, l, c, f, h) {
            return o.startAt = a, $o(o).immediateRender = Xn(o.immediateRender), this.staggerTo(i, s, o, l, c, f, h)
        }, t.render = function(i, s, a) {
            var o = this._time,
                l = this._dirty ? this.totalDuration() : this._tDur,
                c = this._dur,
                f = i <= 0 ? 0 : pn(i),
                h = this._zTime < 0 != i < 0 && (this._initted || !c),
                d, u, _, m, g, p, v, x, b, M, D, T;
            if (this !== Gt && f > l && i >= 0 && (f = l), f !== this._tTime || a || h) {
                if (o !== this._time && c && (f += this._time - o, i += this._time - o), d = f, b = this._start, x = this._ts, p = !x, h && (c || (o = this._zTime), (i || !s) && (this._zTime = i)), this._repeat) {
                    if (D = this._yoyo, g = c + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(g * 100 + i, s, a);
                    if (d = pn(f % g), f === l ? (m = this._repeat, d = c) : (m = ~~(f / g), m && m === f / g && (d = c, m--), d > c && (d = c)), M = za(this._tTime, g), !o && this._tTime && M !== m && this._tTime - M * g - this._dur <= 0 && (M = m), D && m & 1 && (d = c - d, T = 1), m !== M && !this._lock) {
                        var w = D && M & 1,
                            S = w === (D && m & 1);
                        if (m < M && (w = !w), o = w ? 0 : f % c ? c : f, this._lock = 1, this.render(o || (T ? 0 : pn(m * g)), s, !c)._lock = 0, this._tTime = f, !s && this.parent && ri(this, "onRepeat"), this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1), o && o !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (c = this._dur, l = this._tDur, S && (this._lock = 2, o = w ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !T && this.invalidate()), this._lock = 0, !this._ts && !p) return this;
                        T_(this, T)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (v = oA(this, pn(o), pn(d)), v && (f -= d - (d = v._start))), this._tTime = f, this._time = d, this._act = !x, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && d && !s && !m && (ri(this, "onStart"), this._tTime !== f)) return this;
                if (d >= o && i >= 0)
                    for (u = this._first; u;) {
                        if (_ = u._next, (u._act || d >= u._start) && u._ts && v !== u) {
                            if (u.parent !== this) return this.render(i, s, a);
                            if (u.render(u._ts > 0 ? (d - u._start) * u._ts : (u._dirty ? u.totalDuration() : u._tDur) + (d - u._start) * u._ts, s, a), d !== this._time || !this._ts && !p) {
                                v = 0, _ && (f += this._zTime = -1e-8);
                                break
                            }
                        }
                        u = _
                    } else {
                        u = this._last;
                        for (var y = i < 0 ? i : d; u;) {
                            if (_ = u._prev, (u._act || y <= u._end) && u._ts && v !== u) {
                                if (u.parent !== this) return this.render(i, s, a);
                                if (u.render(u._ts > 0 ? (y - u._start) * u._ts : (u._dirty ? u.totalDuration() : u._tDur) + (y - u._start) * u._ts, s, a || Tn && (u._initted || u._startAt)), d !== this._time || !this._ts && !p) {
                                    v = 0, _ && (f += this._zTime = y ? -1e-8 : En);
                                    break
                                }
                            }
                            u = _
                        }
                    }
                if (v && !s && (this.pause(), v.render(d >= o ? 0 : -1e-8)._zTime = d >= o ? 1 : -1, this._ts)) return this._start = b, jc(this), this.render(i, s, a);
                this._onUpdate && !s && ri(this, "onUpdate", !0), (f === l && this._tTime >= this.totalDuration() || !f && o) && (b === this._start || Math.abs(x) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (f === l && this._ts > 0 || !f && this._ts < 0) && Zr(this, 1), !s && !(i < 0 && !o) && (f || o || !l) && (ri(this, f === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, t.add = function(i, s) {
            var a = this;
            if (yr(s) || (s = gi(this, s, i)), !(i instanceof il)) {
                if (Dn(i)) return i.forEach(function(o) {
                    return a.add(o, s)
                }), this;
                if (dn(i)) return this.addLabel(i, s);
                if (jt(i)) i = Zt.delayedCall(0, i);
                else return this
            }
            return this !== i ? Qi(this, i, s) : this
        }, t.getChildren = function(i, s, a, o) {
            i === void 0 && (i = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -1e8);
            for (var l = [], c = this._first; c;) c._start >= o && (c instanceof Zt ? s && l.push(c) : (a && l.push(c), i && l.push.apply(l, c.getChildren(!0, s, a)))), c = c._next;
            return l
        }, t.getById = function(i) {
            for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)
                if (s[a].vars.id === i) return s[a]
        }, t.remove = function(i) {
            return dn(i) ? this.removeLabel(i) : jt(i) ? this.killTweensOf(i) : (Wc(this, i), i === this._recent && (this._recent = this._last), Os(this))
        }, t.totalTime = function(i, s) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = pn(si.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, s), this._forcing = 0, this) : this._tTime
        }, t.addLabel = function(i, s) {
            return this.labels[i] = gi(this, s), this
        }, t.removeLabel = function(i) {
            return delete this.labels[i], this
        }, t.addPause = function(i, s, a) {
            var o = Zt.delayedCall(0, s || Ko, a);
            return o.data = "isPause", this._hasPause = 1, Qi(this, o, gi(this, i))
        }, t.removePause = function(i) {
            var s = this._first;
            for (i = gi(this, i); s;) s._start === i && s.data === "isPause" && Zr(s), s = s._next
        }, t.killTweensOf = function(i, s, a) {
            for (var o = this.getTweensOf(i, a), l = o.length; l--;) ts !== o[l] && o[l].kill(i, s);
            return this
        }, t.getTweensOf = function(i, s) {
            for (var a = [], o = _i(i), l = this._first, c = yr(s), f; l;) l instanceof Zt ? eA(l._targets, o) && (c ? (!ts || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && a.push(l) : (f = l.getTweensOf(o, s)).length && a.push.apply(a, f), l = l._next;
            return a
        }, t.tweenTo = function(i, s) {
            s = s || {};
            var a = this,
                o = gi(a, i),
                l = s,
                c = l.startAt,
                f = l.onStart,
                h = l.onStartParams,
                d = l.immediateRender,
                u, _ = Zt.to(a, mi({
                    ease: s.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: o,
                    overwrite: "auto",
                    duration: s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || En,
                    onStart: function() {
                        if (a.pause(), !u) {
                            var g = s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale());
                            _._dur !== g && Ga(_, g, 0, 1).render(_._time, !0, !0), u = 1
                        }
                        f && f.apply(_, h || [])
                    }
                }, s));
            return d ? _.render(0) : _
        }, t.tweenFromTo = function(i, s, a) {
            return this.tweenTo(s, mi({
                startAt: {
                    time: gi(this, i)
                }
            }, a))
        }, t.recent = function() {
            return this._recent
        }, t.nextLabel = function(i) {
            return i === void 0 && (i = this._time), g_(this, gi(this, i))
        }, t.previousLabel = function(i) {
            return i === void 0 && (i = this._time), g_(this, gi(this, i), 1)
        }, t.currentLabel = function(i) {
            return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + En)
        }, t.shiftChildren = function(i, s, a) {
            a === void 0 && (a = 0);
            for (var o = this._first, l = this.labels, c; o;) o._start >= a && (o._start += i, o._end += i), o = o._next;
            if (s)
                for (c in l) l[c] >= a && (l[c] += i);
            return Os(this)
        }, t.invalidate = function(i) {
            var s = this._first;
            for (this._lock = 0; s;) s.invalidate(i), s = s._next;
            return r.prototype.invalidate.call(this, i)
        }, t.clear = function(i) {
            i === void 0 && (i = !0);
            for (var s = this._first, a; s;) a = s._next, this.remove(s), s = a;
            return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Os(this)
        }, t.totalDuration = function(i) {
            var s = 0,
                a = this,
                o = a._last,
                l = $i,
                c, f, h;
            if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -i : i));
            if (a._dirty) {
                for (h = a.parent; o;) c = o._prev, o._dirty && o.totalDuration(), f = o._start, f > l && a._sort && o._ts && !a._lock ? (a._lock = 1, Qi(a, o, f - o._delay, 1)._lock = 0) : l = f, f < 0 && o._ts && (s -= f, (!h && !a._dp || h && h.smoothChildTiming) && (a._start += f / a._ts, a._time -= f, a._tTime -= f), a.shiftChildren(-f, !1, -1 / 0), l = 0), o._end > s && o._ts && (s = o._end), o = c;
                Ga(a, a === Gt && a._time > s ? a._time : s, 1, 1), a._dirty = 0
            }
            return a._tDur
        }, e.updateRoot = function(i) {
            if (Gt._ts && (Qg(Gt, Xc(i, Gt)), $g = si.frame), si.frame >= Jg) {
                Jg += ti.autoSleep || 120;
                var s = Gt._first;
                if ((!s || !s._ts) && ti.autoSleep && si._listeners.length < 2) {
                    for (; s && !s._ts;) s = s._next;
                    s || si.sleep()
                }
            }
        }, e
    }(il);
    mi(Nn.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var MA = function(e, t, n, i, s, a, o) {
            var l = new qn(this._pt, e, t, 0, 1, F_, null, s),
                c = 0,
                f = 0,
                h, d, u, _, m, g, p, v;
            for (l.b = n, l.e = i, n += "", i += "", (p = ~i.indexOf("random(")) && (i = Qo(i)), a && (v = [n, i], a(v, e, t), n = v[0], i = v[1]), d = n.match(wh) || []; h = wh.exec(i);) _ = h[0], m = i.substring(c, h.index), u ? u = (u + 1) % 5 : m.substr(-5) === "rgba(" && (u = 1), _ !== d[f++] && (g = parseFloat(d[f - 1]) || 0, l._pt = {
                _next: l._pt,
                p: m || f === 1 ? m : ",",
                s: g,
                c: _.charAt(1) === "=" ? ka(g, _) - g : parseFloat(_) - g,
                m: u && u < 4 ? Math.round : 0
            }, c = wh.lastIndex);
            return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = o, (Xg.test(i) || p) && (l.e = 0), this._pt = l, l
        },
        Xh = function(e, t, n, i, s, a, o, l, c, f) {
            jt(i) && (i = i(s || 0, e, a));
            var h = e[t],
                d = n !== "get" ? n : jt(h) ? c ? e[t.indexOf("set") || !jt(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : h,
                u = jt(h) ? c ? wA : R_ : Yh,
                _;
            if (dn(i) && (~i.indexOf("random(") && (i = Qo(i)), i.charAt(1) === "=" && (_ = ka(d, i) + (An(d) || 0), (_ || _ === 0) && (i = _))), !f || d !== i || jh) return !isNaN(d * i) && i !== "" ? (_ = new qn(this._pt, e, t, +d || 0, i - (d || 0), typeof h == "boolean" ? RA : P_, 0, u), c && (_.fp = c), o && _.modifier(o, this, e), this._pt = _) : (!h && !(t in e) && Ph(t, i), MA.call(this, e, t, d, i, u, l || ti.stringFilter, c))
        },
        TA = function(e, t, n, i, s) {
            if (jt(e) && (e = rl(e, s, t, n, i)), !Ji(e) || e.style && e.nodeType || Dn(e) || Vg(e)) return dn(e) ? rl(e, s, t, n, i) : e;
            var a = {},
                o;
            for (o in e) a[o] = rl(e[o], s, t, n, i);
            return a
        },
        A_ = function(e, t, n, i, s, a) {
            var o, l, c, f;
            if (ii[e] && (o = new ii[e]).init(s, o.rawVars ? t[e] : TA(t[e], i, s, a, n), n, i, a) !== !1 && (n._pt = l = new qn(n._pt, s, e, 0, 1, o.render, o, 0, o.priority), n !== Ha))
                for (c = n._ptLookup[n._targets.indexOf(s)], f = o._props.length; f--;) c[o._props[f]] = l;
            return o
        },
        ts, jh, qh = function r(e, t, n) {
            var i = e.vars,
                s = i.ease,
                a = i.startAt,
                o = i.immediateRender,
                l = i.lazy,
                c = i.onUpdate,
                f = i.runBackwards,
                h = i.yoyoEase,
                d = i.keyframes,
                u = i.autoRevert,
                _ = e._dur,
                m = e._startAt,
                g = e._targets,
                p = e.parent,
                v = p && p.data === "nested" ? p.vars.targets : g,
                x = e._overwrite === "auto" && !Mh,
                b = e.timeline,
                M, D, T, w, S, y, C, O, N, V, G, B, j;
            if (b && (!d || !s) && (s = "none"), e._ease = Us(s, Ua.ease), e._yEase = h ? M_(Us(h === !0 ? s : h, Ua.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !b && !!i.runBackwards, !b || d && !i.stagger) {
                if (O = g[0] ? Is(g[0]).harness : 0, B = O && i[O.prop], M = Vc(i, Fh), m && (m._zTime < 0 && m.progress(1), t < 0 && f && o && !u ? m.render(-1, !0) : m.revert(f && _ ? zc : ZD), m._lazy = 0), a) {
                    if (Zr(e._startAt = Zt.set(g, mi({
                            data: "isStart",
                            overwrite: !1,
                            parent: p,
                            immediateRender: !0,
                            lazy: !m && Xn(l),
                            startAt: null,
                            delay: 0,
                            onUpdate: c && function() {
                                return ri(e, "onUpdate")
                            },
                            stagger: 0
                        }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Tn || !o && !u) && e._startAt.revert(zc), o && _ && t <= 0 && n <= 0) {
                        t && (e._zTime = t);
                        return
                    }
                } else if (f && _ && !m) {
                    if (t && (o = !1), T = mi({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: o && !m && Xn(l),
                            immediateRender: o,
                            stagger: 0,
                            parent: p
                        }, M), B && (T[O.prop] = B), Zr(e._startAt = Zt.set(g, T)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Tn ? e._startAt.revert(zc) : e._startAt.render(-1, !0)), e._zTime = t, !o) r(e._startAt, En, En);
                    else if (!t) return
                }
                for (e._pt = e._ptCache = 0, l = _ && Xn(l) || l && !_, D = 0; D < g.length; D++) {
                    if (S = g[D], C = S._gsap || Oh(g)[D]._gsap, e._ptLookup[D] = V = {}, Lh[C.id] && Jr.length && Hc(), G = v === g ? D : v.indexOf(S), O && (N = new O).init(S, B || M, e, G, v) !== !1 && (e._pt = w = new qn(e._pt, S, N.name, 0, 1, N.render, N, 0, N.priority), N._props.forEach(function(H) {
                            V[H] = w
                        }), N.priority && (y = 1)), !O || B)
                        for (T in M) ii[T] && (N = A_(T, M, e, G, S, v)) ? N.priority && (y = 1) : V[T] = w = Xh.call(e, S, T, "get", M[T], G, v, 0, i.stringFilter);
                    e._op && e._op[D] && e.kill(S, e._op[D]), x && e._pt && (ts = e, Gt.killTweensOf(S, V, e.globalTime(t)), j = !e.parent, ts = 0), e._pt && l && (Lh[C.id] = 1)
                }
                y && L_(e), e._onInit && e._onInit(e)
            }
            e._onUpdate = c, e._initted = (!e._op || e._pt) && !j, d && t <= 0 && b.render($i, !0, !0)
        },
        EA = function(e, t, n, i, s, a, o, l) {
            var c = (e._pt && e._ptCache || (e._ptCache = {}))[t],
                f, h, d, u;
            if (!c)
                for (c = e._ptCache[t] = [], d = e._ptLookup, u = e._targets.length; u--;) {
                    if (f = d[u][t], f && f.d && f.d._pt)
                        for (f = f.d._pt; f && f.p !== t && f.fp !== t;) f = f._next;
                    if (!f) return jh = 1, e.vars[t] = "+=0", qh(e, o), jh = 0, l ? Yo(t + " not eligible for reset") : 1;
                    c.push(f)
                }
            for (u = c.length; u--;) h = c[u], f = h._pt || h, f.s = (i || i === 0) && !s ? i : f.s + (i || 0) + a * f.c, f.c = n - f.s, h.e && (h.e = Kt(n) + An(h.e)), h.b && (h.b = f.s + An(h.b))
        },
        DA = function(e, t) {
            var n = e[0] ? Is(e[0]).harness : 0,
                i = n && n.aliases,
                s, a, o, l;
            if (!i) return t;
            s = Ns({}, t);
            for (a in i)
                if (a in s)
                    for (l = i[a].split(","), o = l.length; o--;) s[l[o]] = s[a];
            return s
        },
        AA = function(e, t, n, i) {
            var s = t.ease || i || "power1.inOut",
                a, o;
            if (Dn(t)) o = n[e] || (n[e] = []), t.forEach(function(l, c) {
                return o.push({
                    t: c / (t.length - 1) * 100,
                    v: l,
                    e: s
                })
            });
            else
                for (a in t) o = n[a] || (n[a] = []), a === "ease" || o.push({
                    t: parseFloat(e),
                    v: t[a],
                    e: s
                })
        },
        rl = function(e, t, n, i, s) {
            return jt(e) ? e.call(t, n, i, s) : dn(e) && ~e.indexOf("random(") ? Qo(e) : e
        },
        w_ = Nh + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        C_ = {};
    jn(w_ + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
        return C_[r] = 1
    });
    var Zt = function(r) {
        Gg(e, r);

        function e(n, i, s, a) {
            var o;
            typeof i == "number" && (s.duration = i, i = s, s = null), o = r.call(this, a ? i : $o(i)) || this;
            var l = o.vars,
                c = l.duration,
                f = l.delay,
                h = l.immediateRender,
                d = l.stagger,
                u = l.overwrite,
                _ = l.keyframes,
                m = l.defaults,
                g = l.scrollTrigger,
                p = l.yoyoEase,
                v = i.parent || Gt,
                x = (Dn(n) || Vg(n) ? yr(n[0]) : "length" in i) ? [n] : _i(n),
                b, M, D, T, w, S, y, C;
            if (o._targets = x.length ? Oh(x) : Yo("GSAP target " + n + " not found. https://gsap.com", !ti.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = u, _ || d || Bc(c) || Bc(f)) {
                if (i = o.vars, b = o.timeline = new Nn({
                        data: "nested",
                        defaults: m || {},
                        targets: v && v.data === "nested" ? v.vars.targets : x
                    }), b.kill(), b.parent = b._dp = vr(o), b._start = 0, d || Bc(c) || Bc(f)) {
                    if (T = x.length, y = d && f_(d), Ji(d))
                        for (w in d) ~w_.indexOf(w) && (C || (C = {}), C[w] = d[w]);
                    for (M = 0; M < T; M++) D = Vc(i, C_), D.stagger = 0, p && (D.yoyoEase = p), C && Ns(D, C), S = x[M], D.duration = +rl(c, vr(o), M, S, x), D.delay = (+rl(f, vr(o), M, S, x) || 0) - o._delay, !d && T === 1 && D.delay && (o._delay = f = D.delay, o._start += f, D.delay = 0), b.to(S, D, y ? y(M, S, x) : 0), b._ease = vt.none;
                    b.duration() ? c = f = 0 : o.timeline = 0
                } else if (_) {
                    $o(mi(b.vars.defaults, {
                        ease: "none"
                    })), b._ease = Us(_.ease || i.ease || "none");
                    var O = 0,
                        N, V, G;
                    if (Dn(_)) _.forEach(function(B) {
                        return b.to(x, B, ">")
                    }), b.duration();
                    else {
                        D = {};
                        for (w in _) w === "ease" || w === "easeEach" || AA(w, _[w], D, _.easeEach);
                        for (w in D)
                            for (N = D[w].sort(function(B, j) {
                                    return B.t - j.t
                                }), O = 0, M = 0; M < N.length; M++) V = N[M], G = {
                                ease: V.e,
                                duration: (V.t - (M ? N[M - 1].t : 0)) / 100 * c
                            }, G[w] = V.v, b.to(x, G, O), O += G.duration;
                        b.duration() < c && b.to({}, {
                            duration: c - b.duration()
                        })
                    }
                }
                c || o.duration(c = b.duration())
            } else o.timeline = 0;
            return u === !0 && !Mh && (ts = vr(o), Gt.killTweensOf(x), ts = 0), Qi(v, vr(o), s), i.reversed && o.reverse(), i.paused && o.paused(!0), (h || !c && !_ && o._start === pn(v._time) && Xn(h) && rA(vr(o)) && v.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -f) || 0)), g && a_(vr(o), g), o
        }
        var t = e.prototype;
        return t.render = function(i, s, a) {
            var o = this._time,
                l = this._tDur,
                c = this._dur,
                f = i < 0,
                h = i > l - En && !f ? l : i < En ? 0 : i,
                d, u, _, m, g, p, v, x, b;
            if (!c) aA(this, i, s, a);
            else if (h !== this._tTime || !i || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f) {
                if (d = h, x = this.timeline, this._repeat) {
                    if (m = c + this._rDelay, this._repeat < -1 && f) return this.totalTime(m * 100 + i, s, a);
                    if (d = pn(h % m), h === l ? (_ = this._repeat, d = c) : (_ = ~~(h / m), _ && _ === pn(h / m) && (d = c, _--), d > c && (d = c)), p = this._yoyo && _ & 1, p && (b = this._yEase, d = c - d), g = za(this._tTime, m), d === o && !a && this._initted && _ === g) return this._tTime = h, this;
                    _ !== g && (x && this._yEase && T_(x, p), this.vars.repeatRefresh && !p && !this._lock && this._time !== m && this._initted && (this._lock = a = 1, this.render(pn(m * _), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (o_(this, f ? i : d, a, s, h)) return this._tTime = 0, this;
                    if (o !== this._time && !(a && this.vars.repeatRefresh && _ !== g)) return this;
                    if (c !== this._dur) return this.render(i, s, a)
                }
                if (this._tTime = h, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (b || this._ease)(d / c), this._from && (this.ratio = v = 1 - v), d && !o && !s && !_ && (ri(this, "onStart"), this._tTime !== h)) return this;
                for (u = this._pt; u;) u.r(v, u.d), u = u._next;
                x && x.render(i < 0 ? i : x._dur * x._ease(d / this._dur), s, a) || this._startAt && (this._zTime = i), this._onUpdate && !s && (f && Uh(this, i, s, a), ri(this, "onUpdate")), this._repeat && _ !== g && this.vars.onRepeat && !s && this.parent && ri(this, "onRepeat"), (h === this._tDur || !h) && this._tTime === h && (f && !this._onUpdate && Uh(this, i, !0, !0), (i || !c) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && Zr(this, 1), !s && !(f && !o) && (h || o || p) && (ri(this, h === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom()))
            }
            return this
        }, t.targets = function() {
            return this._targets
        }, t.invalidate = function(i) {
            return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i)
        }, t.resetTo = function(i, s, a, o, l) {
            nl || si.wake(), this._ts || this.play();
            var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                f;
            return this._initted || qh(this, c), f = this._ease(c / this._dur), EA(this, i, s, a, o, f, c, l) ? this.resetTo(i, s, a, o, 1) : (qc(this, 0), this.parent || i_(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, t.kill = function(i, s) {
            if (s === void 0 && (s = "all"), !i && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? el(this) : this;
            if (this.timeline) {
                var a = this.timeline.totalDuration();
                return this.timeline.killTweensOf(i, s, ts && ts.vars.overwrite !== !0)._first || el(this), this.parent && a !== this.timeline.totalDuration() && Ga(this, this._dur * this.timeline._tDur / a, 0, 1), this
            }
            var o = this._targets,
                l = i ? _i(i) : o,
                c = this._ptLookup,
                f = this._pt,
                h, d, u, _, m, g, p;
            if ((!s || s === "all") && nA(o, l)) return s === "all" && (this._pt = 0), el(this);
            for (h = this._op = this._op || [], s !== "all" && (dn(s) && (m = {}, jn(s, function(v) {
                    return m[v] = 1
                }), s = m), s = DA(o, s)), p = o.length; p--;)
                if (~l.indexOf(o[p])) {
                    d = c[p], s === "all" ? (h[p] = s, _ = d, u = {}) : (u = h[p] = h[p] || {}, _ = s);
                    for (m in _) g = d && d[m], g && ((!("kill" in g.d) || g.d.kill(m) === !0) && Wc(this, g, "_pt"), delete d[m]), u !== "all" && (u[m] = 1)
                }
            return this._initted && !this._pt && f && el(this), this
        }, e.to = function(i, s) {
            return new e(i, s, arguments[2])
        }, e.from = function(i, s) {
            return Jo(1, arguments)
        }, e.delayedCall = function(i, s, a, o) {
            return new e(s, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: i,
                onComplete: s,
                onReverseComplete: s,
                onCompleteParams: a,
                onReverseCompleteParams: a,
                callbackScope: o
            })
        }, e.fromTo = function(i, s, a) {
            return Jo(2, arguments)
        }, e.set = function(i, s) {
            return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(i, s)
        }, e.killTweensOf = function(i, s, a) {
            return Gt.killTweensOf(i, s, a)
        }, e
    }(il);
    mi(Zt.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), jn("staggerTo,staggerFrom,staggerFromTo", function(r) {
        Zt[r] = function() {
            var e = new Nn,
                t = kh.call(arguments, 0);
            return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t)
        }
    });
    var Yh = function(e, t, n) {
            return e[t] = n
        },
        R_ = function(e, t, n) {
            return e[t](n)
        },
        wA = function(e, t, n, i) {
            return e[t](i.fp, n)
        },
        CA = function(e, t, n) {
            return e.setAttribute(t, n)
        },
        Kh = function(e, t) {
            return jt(e[t]) ? R_ : Eh(e[t]) && e.setAttribute ? CA : Yh
        },
        P_ = function(e, t) {
            return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
        },
        RA = function(e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        },
        F_ = function(e, t) {
            var n = t._pt,
                i = "";
            if (!e && t.b) i = t.b;
            else if (e === 1 && t.e) i = t.e;
            else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
                i += t.c
            }
            t.set(t.t, t.p, i, t)
        },
        $h = function(e, t) {
            for (var n = t._pt; n;) n.r(e, n.d), n = n._next
        },
        PA = function(e, t, n, i) {
            for (var s = this._pt, a; s;) a = s._next, s.p === i && s.modifier(e, t, n), s = a
        },
        FA = function(e) {
            for (var t = this._pt, n, i; t;) i = t._next, t.p === e && !t.op || t.op === e ? Wc(this, t, "_pt") : t.dep || (n = 1), t = i;
            return !n
        },
        LA = function(e, t, n, i) {
            i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
        },
        L_ = function(e) {
            for (var t = e._pt, n, i, s, a; t;) {
                for (n = t._next, i = s; i && i.pr > t.pr;) i = i._next;
                (t._prev = i ? i._prev : a) ? t._prev._next = t: s = t, (t._next = i) ? i._prev = t : a = t, t = n
            }
            e._pt = s
        },
        qn = function() {
            function r(t, n, i, s, a, o, l, c, f) {
                this.t = n, this.s = s, this.c = a, this.p = i, this.r = o || P_, this.d = l || this, this.set = c || Yh, this.pr = f || 0, this._next = t, t && (t._prev = this)
            }
            var e = r.prototype;
            return e.modifier = function(n, i, s) {
                this.mSet = this.mSet || this.set, this.set = LA, this.m = n, this.mt = s, this.tween = i
            }, r
        }();
    jn(Nh + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
        return Fh[r] = 1
    }), ni.TweenMax = ni.TweenLite = Zt, ni.TimelineLite = ni.TimelineMax = Nn, Gt = new Nn({
        sortChildren: !1,
        defaults: Ua,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), ti.stringFilter = S_;
    var ks = [],
        Yc = {},
        IA = [],
        I_ = 0,
        NA = 0,
        Jh = function(e) {
            return (Yc[e] || IA).map(function(t) {
                return t()
            })
        },
        Zh = function() {
            var e = Date.now(),
                t = [];
            e - I_ > 2 && (Jh("matchMediaInit"), ks.forEach(function(n) {
                var i = n.queries,
                    s = n.conditions,
                    a, o, l, c;
                for (o in i) a = Zi.matchMedia(i[o]).matches, a && (l = 1), a !== s[o] && (s[o] = a, c = 1);
                c && (n.revert(), l && t.push(n))
            }), Jh("matchMediaRevert"), t.forEach(function(n) {
                return n.onMatch(n, function(i) {
                    return n.add(null, i)
                })
            }), I_ = e, Jh("matchMedia"))
        },
        N_ = function() {
            function r(t, n) {
                this.selector = n && zh(n), this.data = [], this._r = [], this.isReverted = !1, this.id = NA++, t && this.add(t)
            }
            var e = r.prototype;
            return e.add = function(n, i, s) {
                jt(n) && (s = i, i = n, n = jt);
                var a = this,
                    o = function() {
                        var c = Ut,
                            f = a.selector,
                            h;
                        return c && c !== a && c.data.push(a), s && (a.selector = zh(s)), Ut = a, h = i.apply(a, arguments), jt(h) && a._r.push(h), Ut = c, a.selector = f, a.isReverted = !1, h
                    };
                return a.last = o, n === jt ? o(a, function(l) {
                    return a.add(null, l)
                }) : n ? a[n] = o : o
            }, e.ignore = function(n) {
                var i = Ut;
                Ut = null, n(this), Ut = i
            }, e.getTweens = function() {
                var n = [];
                return this.data.forEach(function(i) {
                    return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof Zt && !(i.parent && i.parent.data === "nested") && n.push(i)
                }), n
            }, e.clear = function() {
                this._r.length = this.data.length = 0
            }, e.kill = function(n, i) {
                var s = this;
                if (n ? function() {
                        for (var o = s.getTweens(), l = s.data.length, c; l--;) c = s.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(f) {
                            return o.splice(o.indexOf(f), 1)
                        }));
                        for (o.map(function(f) {
                                return {
                                    g: f._dur || f._delay || f._sat && !f._sat.vars.immediateRender ? f.globalTime(0) : -1 / 0,
                                    t: f
                                }
                            }).sort(function(f, h) {
                                return h.g - f.g || -1 / 0
                            }).forEach(function(f) {
                                return f.t.revert(n)
                            }), l = s.data.length; l--;) c = s.data[l], c instanceof Nn ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof Zt) && c.revert && c.revert(n);
                        s._r.forEach(function(f) {
                            return f(n, s)
                        }), s.isReverted = !0
                    }() : this.data.forEach(function(o) {
                        return o.kill && o.kill()
                    }), this.clear(), i)
                    for (var a = ks.length; a--;) ks[a].id === this.id && ks.splice(a, 1)
            }, e.revert = function(n) {
                this.kill(n || {})
            }, r
        }(),
        OA = function() {
            function r(t) {
                this.contexts = [], this.scope = t, Ut && Ut.data.push(this)
            }
            var e = r.prototype;
            return e.add = function(n, i, s) {
                Ji(n) || (n = {
                    matches: n
                });
                var a = new N_(0, s || this.scope),
                    o = a.conditions = {},
                    l, c, f;
                Ut && !a.selector && (a.selector = Ut.selector), this.contexts.push(a), i = a.add("onMatch", i), a.queries = n;
                for (c in n) c === "all" ? f = 1 : (l = Zi.matchMedia(n[c]), l && (ks.indexOf(a) < 0 && ks.push(a), (o[c] = l.matches) && (f = 1), l.addListener ? l.addListener(Zh) : l.addEventListener("change", Zh)));
                return f && i(a, function(h) {
                    return a.add(null, h)
                }), this
            }, e.revert = function(n) {
                this.kill(n || {})
            }, e.kill = function(n) {
                this.contexts.forEach(function(i) {
                    return i.kill(n, !0)
                })
            }, r
        }(),
        Kc = {
            registerPlugin: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                t.forEach(function(i) {
                    return b_(i)
                })
            },
            timeline: function(e) {
                return new Nn(e)
            },
            getTweensOf: function(e, t) {
                return Gt.getTweensOf(e, t)
            },
            getProperty: function(e, t, n, i) {
                dn(e) && (e = _i(e)[0]);
                var s = Is(e || {}).get,
                    a = n ? t_ : e_;
                return n === "native" && (n = ""), e && (t ? a((ii[t] && ii[t].get || s)(e, t, n, i)) : function(o, l, c) {
                    return a((ii[o] && ii[o].get || s)(e, o, l, c))
                })
            },
            quickSetter: function(e, t, n) {
                if (e = _i(e), e.length > 1) {
                    var i = e.map(function(f) {
                            return Yn.quickSetter(f, t, n)
                        }),
                        s = i.length;
                    return function(f) {
                        for (var h = s; h--;) i[h](f)
                    }
                }
                e = e[0] || {};
                var a = ii[t],
                    o = Is(e),
                    l = o.harness && (o.harness.aliases || {})[t] || t,
                    c = a ? function(f) {
                        var h = new a;
                        Ha._pt = 0, h.init(e, n ? f + n : f, Ha, 0, [e]), h.render(1, h), Ha._pt && $h(1, Ha)
                    } : o.set(e, l);
                return a ? c : function(f) {
                    return c(e, l, n ? f + n : f, o, 1)
                }
            },
            quickTo: function(e, t, n) {
                var i, s = Yn.to(e, Ns((i = {}, i[t] = "+=0.1", i.paused = !0, i), n || {})),
                    a = function(l, c, f) {
                        return s.resetTo(t, l, c, f)
                    };
                return a.tween = s, a
            },
            isTweening: function(e) {
                return Gt.getTweensOf(e, !0).length > 0
            },
            defaults: function(e) {
                return e && e.ease && (e.ease = Us(e.ease, Ua.ease)), n_(Ua, e || {})
            },
            config: function(e) {
                return n_(ti, e || {})
            },
            registerEffect: function(e) {
                var t = e.name,
                    n = e.effect,
                    i = e.plugins,
                    s = e.defaults,
                    a = e.extendTimeline;
                (i || "").split(",").forEach(function(o) {
                    return o && !ii[o] && !ni[o] && Yo(t + " effect requires " + o + " plugin.")
                }), Ih[t] = function(o, l, c) {
                    return n(_i(o), mi(l || {}, s), c)
                }, a && (Nn.prototype[t] = function(o, l, c) {
                    return this.add(Ih[t](o, Ji(l) ? l : (c = l) && {}, this), c)
                })
            },
            registerEase: function(e, t) {
                vt[e] = Us(t)
            },
            parseEase: function(e, t) {
                return arguments.length ? Us(e, t) : vt
            },
            getById: function(e) {
                return Gt.getById(e)
            },
            exportRoot: function(e, t) {
                e === void 0 && (e = {});
                var n = new Nn(e),
                    i, s;
                for (n.smoothChildTiming = Xn(e.smoothChildTiming), Gt.remove(n), n._dp = 0, n._time = n._tTime = Gt._time, i = Gt._first; i;) s = i._next, (t || !(!i._dur && i instanceof Zt && i.vars.onComplete === i._targets[0])) && Qi(n, i, i._start - i._delay), i = s;
                return Qi(Gt, n, 0), n
            },
            context: function(e, t) {
                return e ? new N_(e, t) : Ut
            },
            matchMedia: function(e) {
                return new OA(e)
            },
            matchMediaRefresh: function() {
                return ks.forEach(function(e) {
                    var t = e.conditions,
                        n, i;
                    for (i in t) t[i] && (t[i] = !1, n = 1);
                    n && e.revert()
                }) || Zh()
            },
            addEventListener: function(e, t) {
                var n = Yc[e] || (Yc[e] = []);
                ~n.indexOf(t) || n.push(t)
            },
            removeEventListener: function(e, t) {
                var n = Yc[e],
                    i = n && n.indexOf(t);
                i >= 0 && n.splice(i, 1)
            },
            utils: {
                wrap: pA,
                wrapYoyo: mA,
                distribute: f_,
                random: d_,
                snap: h_,
                normalize: dA,
                getUnit: An,
                clamp: cA,
                splitColor: x_,
                toArray: _i,
                selector: zh,
                mapRange: m_,
                pipe: fA,
                unitize: hA,
                interpolate: gA,
                shuffle: u_
            },
            install: Yg,
            effects: Ih,
            ticker: si,
            updateRoot: Nn.updateRoot,
            plugins: ii,
            globalTimeline: Gt,
            core: {
                PropTween: qn,
                globals: Kg,
                Tween: Zt,
                Timeline: Nn,
                Animation: il,
                getCache: Is,
                _removeLinkedListItem: Wc,
                reverting: function() {
                    return Tn
                },
                context: function(e) {
                    return e && Ut && (Ut.data.push(e), e._ctx = Ut), Ut
                },
                suppressOverwrites: function(e) {
                    return Mh = e
                }
            }
        };
    jn("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
        return Kc[r] = Zt[r]
    }), si.add(Nn.updateRoot), Ha = Kc.to({}, {
        duration: 0
    });
    var UA = function(e, t) {
            for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
            return n
        },
        BA = function(e, t) {
            var n = e._targets,
                i, s, a;
            for (i in t)
                for (s = n.length; s--;) a = e._ptLookup[s][i], a && (a = a.d) && (a._pt && (a = UA(a, i)), a && a.modifier && a.modifier(t[i], e, n[s], i))
        },
        Qh = function(e, t) {
            return {
                name: e,
                rawVars: 1,
                init: function(i, s, a) {
                    a._onInit = function(o) {
                        var l, c;
                        if (dn(s) && (l = {}, jn(s, function(f) {
                                return l[f] = 1
                            }), s = l), t) {
                            l = {};
                            for (c in s) l[c] = t(s[c]);
                            s = l
                        }
                        BA(o, s)
                    }
                }
            }
        },
        Yn = Kc.registerPlugin({
            name: "attr",
            init: function(e, t, n, i, s) {
                var a, o, l;
                this.tween = n;
                for (a in t) l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], i, s, 0, 0, a), o.op = a, o.b = l, this._props.push(a)
            },
            render: function(e, t) {
                for (var n = t._pt; n;) Tn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
            }
        }, {
            name: "endArray",
            init: function(e, t) {
                for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
            }
        }, Qh("roundProps", Gh), Qh("modifiers"), Qh("snap", h_)) || Kc;
    Zt.version = Nn.version = Yn.version = "3.12.5", qg = 1, Dh() && Va(), vt.Power0, vt.Power1, vt.Power2, vt.Power3, vt.Power4, vt.Linear, vt.Quad, vt.Cubic, vt.Quart, vt.Quint, vt.Strong, vt.Elastic, vt.Back, vt.SteppedEase, vt.Bounce, vt.Sine, vt.Expo, vt.Circ;
    /*!
     * CSSPlugin 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var O_, ns, Wa, ed, zs, U_, td, kA = function() {
            return typeof window < "u"
        },
        Sr = {},
        Gs = 180 / Math.PI,
        Xa = Math.PI / 180,
        ja = Math.atan2,
        B_ = 1e8,
        nd = /([A-Z])/g,
        zA = /(left|right|width|margin|padding|x)/i,
        GA = /[\s,\(]\S/,
        er = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        id = function(e, t) {
            return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
        },
        HA = function(e, t) {
            return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
        },
        VA = function(e, t) {
            return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
        },
        WA = function(e, t) {
            var n = t.s + t.c * e;
            t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
        },
        k_ = function(e, t) {
            return t.set(t.t, t.p, e ? t.e : t.b, t)
        },
        z_ = function(e, t) {
            return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
        },
        XA = function(e, t, n) {
            return e.style[t] = n
        },
        jA = function(e, t, n) {
            return e.style.setProperty(t, n)
        },
        qA = function(e, t, n) {
            return e._gsap[t] = n
        },
        YA = function(e, t, n) {
            return e._gsap.scaleX = e._gsap.scaleY = n
        },
        KA = function(e, t, n, i, s) {
            var a = e._gsap;
            a.scaleX = a.scaleY = n, a.renderTransform(s, a)
        },
        $A = function(e, t, n, i, s) {
            var a = e._gsap;
            a[t] = n, a.renderTransform(s, a)
        },
        Ht = "transform",
        Kn = Ht + "Origin",
        JA = function r(e, t) {
            var n = this,
                i = this.target,
                s = i.style,
                a = i._gsap;
            if (e in Sr && s) {
                if (this.tfm = this.tfm || {}, e !== "transform") e = er[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
                    return n.tfm[o] = Mr(i, o)
                }) : this.tfm[e] = a.x ? a[e] : Mr(i, e), e === Kn && (this.tfm.zOrigin = a.zOrigin);
                else return er.transform.split(",").forEach(function(o) {
                    return r.call(n, o, t)
                });
                if (this.props.indexOf(Ht) >= 0) return;
                a.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(Kn, t, "")), e = Ht
            }(s || t) && this.props.push(e, t, s[e])
        },
        G_ = function(e) {
            e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
        },
        ZA = function() {
            var e = this.props,
                t = this.target,
                n = t.style,
                i = t._gsap,
                s, a;
            for (s = 0; s < e.length; s += 3) e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(nd, "-$1").toLowerCase());
            if (this.tfm) {
                for (a in this.tfm) i[a] = this.tfm[a];
                i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = td(), (!s || !s.isStart) && !n[Ht] && (G_(n), i.zOrigin && n[Kn] && (n[Kn] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1)
            }
        },
        H_ = function(e, t) {
            var n = {
                target: e,
                props: [],
                revert: ZA,
                save: JA
            };
            return e._gsap || Yn.core.getCache(e), t && t.split(",").forEach(function(i) {
                return n.save(i)
            }), n
        },
        V_, rd = function(e, t) {
            var n = ns.createElementNS ? ns.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ns.createElement(e);
            return n && n.style ? n : ns.createElement(e)
        },
        tr = function r(e, t, n) {
            var i = getComputedStyle(e);
            return i[t] || i.getPropertyValue(t.replace(nd, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, qa(t) || t, 1) || ""
        },
        W_ = "O,Moz,ms,Ms,Webkit".split(","),
        qa = function(e, t, n) {
            var i = t || zs,
                s = i.style,
                a = 5;
            if (e in s && !n) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(W_[a] + e in s););
            return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? W_[a] : "") + e
        },
        sd = function() {
            kA() && window.document && (O_ = window, ns = O_.document, Wa = ns.documentElement, zs = rd("div") || {
                style: {}
            }, rd("div"), Ht = qa(Ht), Kn = Ht + "Origin", zs.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", V_ = !!qa("perspective"), td = Yn.core.reverting, ed = 1)
        },
        ad = function r(e) {
            var t = rd("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                n = this.parentNode,
                i = this.nextSibling,
                s = this.style.cssText,
                a;
            if (Wa.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
                a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = r
            } catch {} else this._gsapBBox && (a = this._gsapBBox());
            return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), Wa.removeChild(t), this.style.cssText = s, a
        },
        X_ = function(e, t) {
            for (var n = t.length; n--;)
                if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
        },
        j_ = function(e) {
            var t;
            try {
                t = e.getBBox()
            } catch {
                t = ad.call(e, !0)
            }
            return t && (t.width || t.height) || e.getBBox === ad || (t = ad.call(e, !0)), t && !t.width && !t.x && !t.y ? {
                x: +X_(e, ["x", "cx", "x1"]) || 0,
                y: +X_(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            } : t
        },
        q_ = function(e) {
            return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && j_(e))
        },
        Hs = function(e, t) {
            if (t) {
                var n = e.style,
                    i;
                t in Sr && t !== Kn && (t = Ht), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(nd, "-$1").toLowerCase())) : n.removeAttribute(t)
            }
        },
        is = function(e, t, n, i, s, a) {
            var o = new qn(e._pt, t, n, 0, 1, a ? z_ : k_);
            return e._pt = o, o.b = i, o.e = s, e._props.push(n), o
        },
        Y_ = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        QA = {
            grid: 1,
            flex: 1
        },
        rs = function r(e, t, n, i) {
            var s = parseFloat(n) || 0,
                a = (n + "").trim().substr((s + "").length) || "px",
                o = zs.style,
                l = zA.test(t),
                c = e.tagName.toLowerCase() === "svg",
                f = (c ? "client" : "offset") + (l ? "Width" : "Height"),
                h = 100,
                d = i === "px",
                u = i === "%",
                _, m, g, p;
            if (i === a || !s || Y_[i] || Y_[a]) return s;
            if (a !== "px" && !d && (s = r(e, t, n, "px")), p = e.getCTM && q_(e), (u || a === "%") && (Sr[t] || ~t.indexOf("adius"))) return _ = p ? e.getBBox()[l ? "width" : "height"] : e[f], Kt(u ? s / _ * h : s / 100 * _);
            if (o[l ? "width" : "height"] = h + (d ? a : i), m = ~t.indexOf("adius") || i === "em" && e.appendChild && !c ? e : e.parentNode, p && (m = (e.ownerSVGElement || {}).parentNode), (!m || m === ns || !m.appendChild) && (m = ns.body), g = m._gsap, g && u && g.width && l && g.time === si.time && !g.uncache) return Kt(s / g.width * h);
            if (u && (t === "height" || t === "width")) {
                var v = e.style[t];
                e.style[t] = h + i, _ = e[f], v ? e.style[t] = v : Hs(e, t)
            } else(u || a === "%") && !QA[tr(m, "display")] && (o.position = tr(e, "position")), m === e && (o.position = "static"), m.appendChild(zs), _ = zs[f], m.removeChild(zs), o.position = "absolute";
            return l && u && (g = Is(m), g.time = si.time, g.width = m[f]), Kt(d ? _ * s / h : _ && s ? h / _ * s : 0)
        },
        Mr = function(e, t, n, i) {
            var s;
            return ed || sd(), t in er && t !== "transform" && (t = er[t], ~t.indexOf(",") && (t = t.split(",")[0])), Sr[t] && t !== "transform" ? (s = al(e, i), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : Jc(tr(e, Kn)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = $c[t] && $c[t](e, t, n) || tr(e, t) || Zg(e, t) || (t === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? rs(e, t, s, n) + n : s
        },
        ew = function(e, t, n, i) {
            if (!n || n === "none") {
                var s = qa(t, e, 1),
                    a = s && tr(e, s, 1);
                a && a !== n ? (t = s, n = a) : t === "borderColor" && (n = tr(e, "borderTopColor"))
            }
            var o = new qn(this._pt, e.style, t, 0, 1, F_),
                l = 0,
                c = 0,
                f, h, d, u, _, m, g, p, v, x, b, M;
            if (o.b = n, o.e = i, n += "", i += "", i === "auto" && (m = e.style[t], e.style[t] = i, i = tr(e, t) || i, m ? e.style[t] = m : Hs(e, t)), f = [n, i], S_(f), n = f[0], i = f[1], d = n.match(Ba) || [], M = i.match(Ba) || [], M.length) {
                for (; h = Ba.exec(i);) g = h[0], v = i.substring(l, h.index), _ ? _ = (_ + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (_ = 1), g !== (m = d[c++] || "") && (u = parseFloat(m) || 0, b = m.substr((u + "").length), g.charAt(1) === "=" && (g = ka(u, g) + b), p = parseFloat(g), x = g.substr((p + "").length), l = Ba.lastIndex - x.length, x || (x = x || ti.units[t] || b, l === i.length && (i += x, o.e += x)), b !== x && (u = rs(e, t, m, x) || 0), o._pt = {
                    _next: o._pt,
                    p: v || c === 1 ? v : ",",
                    s: u,
                    c: p - u,
                    m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
                });
                o.c = l < i.length ? i.substring(l, i.length) : ""
            } else o.r = t === "display" && i === "none" ? z_ : k_;
            return Xg.test(i) && (o.e = 0), this._pt = o, o
        },
        K_ = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        tw = function(e) {
            var t = e.split(" "),
                n = t[0],
                i = t[1] || "50%";
            return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = K_[n] || n, t[1] = K_[i] || i, t.join(" ")
        },
        nw = function(e, t) {
            if (t.tween && t.tween._time === t.tween._dur) {
                var n = t.t,
                    i = n.style,
                    s = t.u,
                    a = n._gsap,
                    o, l, c;
                if (s === "all" || s === !0) i.cssText = "", l = 1;
                else
                    for (s = s.split(","), c = s.length; --c > -1;) o = s[c], Sr[o] && (l = 1, o = o === "transformOrigin" ? Kn : Ht), Hs(n, o);
                l && (Hs(n, Ht), a && (a.svg && n.removeAttribute("transform"), al(n, 1), a.uncache = 1, G_(i)))
            }
        },
        $c = {
            clearProps: function(e, t, n, i, s) {
                if (s.data !== "isFromStart") {
                    var a = e._pt = new qn(e._pt, t, n, 0, 0, nw);
                    return a.u = i, a.pr = -10, a.tween = s, e._props.push(n), 1
                }
            }
        },
        sl = [1, 0, 0, 1, 0, 0],
        $_ = {},
        J_ = function(e) {
            return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
        },
        Z_ = function(e) {
            var t = tr(e, Ht);
            return J_(t) ? sl : t.substr(7).match(Wg).map(Kt)
        },
        od = function(e, t) {
            var n = e._gsap || Is(e),
                i = e.style,
                s = Z_(e),
                a, o, l, c;
            return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? sl : s) : (s === sl && !e.offsetParent && e !== Wa && !n.svg && (l = i.display, i.display = "block", a = e.parentNode, (!a || !e.offsetParent) && (c = 1, o = e.nextElementSibling, Wa.appendChild(e)), s = Z_(e), l ? i.display = l : Hs(e, "display"), c && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Wa.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
        },
        ld = function(e, t, n, i, s, a) {
            var o = e._gsap,
                l = s || od(e, !0),
                c = o.xOrigin || 0,
                f = o.yOrigin || 0,
                h = o.xOffset || 0,
                d = o.yOffset || 0,
                u = l[0],
                _ = l[1],
                m = l[2],
                g = l[3],
                p = l[4],
                v = l[5],
                x = t.split(" "),
                b = parseFloat(x[0]) || 0,
                M = parseFloat(x[1]) || 0,
                D, T, w, S;
            n ? l !== sl && (T = u * g - _ * m) && (w = b * (g / T) + M * (-m / T) + (m * v - g * p) / T, S = b * (-_ / T) + M * (u / T) - (u * v - _ * p) / T, b = w, M = S) : (D = j_(e), b = D.x + (~x[0].indexOf("%") ? b / 100 * D.width : b), M = D.y + (~(x[1] || x[0]).indexOf("%") ? M / 100 * D.height : M)), i || i !== !1 && o.smooth ? (p = b - c, v = M - f, o.xOffset = h + (p * u + v * m) - p, o.yOffset = d + (p * _ + v * g) - v) : o.xOffset = o.yOffset = 0, o.xOrigin = b, o.yOrigin = M, o.smooth = !!i, o.origin = t, o.originIsAbsolute = !!n, e.style[Kn] = "0px 0px", a && (is(a, o, "xOrigin", c, b), is(a, o, "yOrigin", f, M), is(a, o, "xOffset", h, o.xOffset), is(a, o, "yOffset", d, o.yOffset)), e.setAttribute("data-svg-origin", b + " " + M)
        },
        al = function(e, t) {
            var n = e._gsap || new D_(e);
            if ("x" in n && !t && !n.uncache) return n;
            var i = e.style,
                s = n.scaleX < 0,
                a = "px",
                o = "deg",
                l = getComputedStyle(e),
                c = tr(e, Kn) || "0",
                f, h, d, u, _, m, g, p, v, x, b, M, D, T, w, S, y, C, O, N, V, G, B, j, H, k, F, se, de, ke, q, ee;
            return f = h = d = m = g = p = v = x = b = 0, u = _ = 1, n.svg = !!(e.getCTM && q_(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[Ht] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Ht] !== "none" ? l[Ht] : "")), i.scale = i.rotate = i.translate = "none"), T = od(e, n.svg), n.svg && (n.uncache ? (H = e.getBBox(), c = n.xOrigin - H.x + "px " + (n.yOrigin - H.y) + "px", j = "") : j = !t && e.getAttribute("data-svg-origin"), ld(e, j || c, !!j || n.originIsAbsolute, n.smooth !== !1, T)), M = n.xOrigin || 0, D = n.yOrigin || 0, T !== sl && (C = T[0], O = T[1], N = T[2], V = T[3], f = G = T[4], h = B = T[5], T.length === 6 ? (u = Math.sqrt(C * C + O * O), _ = Math.sqrt(V * V + N * N), m = C || O ? ja(O, C) * Gs : 0, v = N || V ? ja(N, V) * Gs + m : 0, v && (_ *= Math.abs(Math.cos(v * Xa))), n.svg && (f -= M - (M * C + D * N), h -= D - (M * O + D * V))) : (ee = T[6], ke = T[7], F = T[8], se = T[9], de = T[10], q = T[11], f = T[12], h = T[13], d = T[14], w = ja(ee, de), g = w * Gs, w && (S = Math.cos(-w), y = Math.sin(-w), j = G * S + F * y, H = B * S + se * y, k = ee * S + de * y, F = G * -y + F * S, se = B * -y + se * S, de = ee * -y + de * S, q = ke * -y + q * S, G = j, B = H, ee = k), w = ja(-N, de), p = w * Gs, w && (S = Math.cos(-w), y = Math.sin(-w), j = C * S - F * y, H = O * S - se * y, k = N * S - de * y, q = V * y + q * S, C = j, O = H, N = k), w = ja(O, C), m = w * Gs, w && (S = Math.cos(w), y = Math.sin(w), j = C * S + O * y, H = G * S + B * y, O = O * S - C * y, B = B * S - G * y, C = j, G = H), g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0, p = 180 - p), u = Kt(Math.sqrt(C * C + O * O + N * N)), _ = Kt(Math.sqrt(B * B + ee * ee)), w = ja(G, B), v = Math.abs(w) > 2e-4 ? w * Gs : 0, b = q ? 1 / (q < 0 ? -q : q) : 0), n.svg && (j = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !J_(tr(e, Ht)), j && e.setAttribute("transform", j))), Math.abs(v) > 90 && Math.abs(v) < 270 && (s ? (u *= -1, v += m <= 0 ? 180 : -180, m += m <= 0 ? 180 : -180) : (_ *= -1, v += v <= 0 ? 180 : -180)), t = t || n.uncache, n.x = f - ((n.xPercent = f && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + a, n.y = h - ((n.yPercent = h && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + a, n.z = d + a, n.scaleX = Kt(u), n.scaleY = Kt(_), n.rotation = Kt(m) + o, n.rotationX = Kt(g) + o, n.rotationY = Kt(p) + o, n.skewX = v + o, n.skewY = x + o, n.transformPerspective = b + a, (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (i[Kn] = Jc(c)), n.xOffset = n.yOffset = 0, n.force3D = ti.force3D, n.renderTransform = n.svg ? rw : V_ ? Q_ : iw, n.uncache = 0, n
        },
        Jc = function(e) {
            return (e = e.split(" "))[0] + " " + e[1]
        },
        cd = function(e, t, n) {
            var i = An(t);
            return Kt(parseFloat(t) + parseFloat(rs(e, "x", n + "px", i))) + i
        },
        iw = function(e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Q_(e, t)
        },
        Vs = "0deg",
        ol = "0px",
        Ws = ") ",
        Q_ = function(e, t) {
            var n = t || this,
                i = n.xPercent,
                s = n.yPercent,
                a = n.x,
                o = n.y,
                l = n.z,
                c = n.rotation,
                f = n.rotationY,
                h = n.rotationX,
                d = n.skewX,
                u = n.skewY,
                _ = n.scaleX,
                m = n.scaleY,
                g = n.transformPerspective,
                p = n.force3D,
                v = n.target,
                x = n.zOrigin,
                b = "",
                M = p === "auto" && e && e !== 1 || p === !0;
            if (x && (h !== Vs || f !== Vs)) {
                var D = parseFloat(f) * Xa,
                    T = Math.sin(D),
                    w = Math.cos(D),
                    S;
                D = parseFloat(h) * Xa, S = Math.cos(D), a = cd(v, a, T * S * -x), o = cd(v, o, -Math.sin(D) * -x), l = cd(v, l, w * S * -x + x)
            }
            g !== ol && (b += "perspective(" + g + Ws), (i || s) && (b += "translate(" + i + "%, " + s + "%) "), (M || a !== ol || o !== ol || l !== ol) && (b += l !== ol || M ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + Ws), c !== Vs && (b += "rotate(" + c + Ws), f !== Vs && (b += "rotateY(" + f + Ws), h !== Vs && (b += "rotateX(" + h + Ws), (d !== Vs || u !== Vs) && (b += "skew(" + d + ", " + u + Ws), (_ !== 1 || m !== 1) && (b += "scale(" + _ + ", " + m + Ws), v.style[Ht] = b || "translate(0, 0)"
        },
        rw = function(e, t) {
            var n = t || this,
                i = n.xPercent,
                s = n.yPercent,
                a = n.x,
                o = n.y,
                l = n.rotation,
                c = n.skewX,
                f = n.skewY,
                h = n.scaleX,
                d = n.scaleY,
                u = n.target,
                _ = n.xOrigin,
                m = n.yOrigin,
                g = n.xOffset,
                p = n.yOffset,
                v = n.forceCSS,
                x = parseFloat(a),
                b = parseFloat(o),
                M, D, T, w, S;
            l = parseFloat(l), c = parseFloat(c), f = parseFloat(f), f && (f = parseFloat(f), c += f, l += f), l || c ? (l *= Xa, c *= Xa, M = Math.cos(l) * h, D = Math.sin(l) * h, T = Math.sin(l - c) * -d, w = Math.cos(l - c) * d, c && (f *= Xa, S = Math.tan(c - f), S = Math.sqrt(1 + S * S), T *= S, w *= S, f && (S = Math.tan(f), S = Math.sqrt(1 + S * S), M *= S, D *= S)), M = Kt(M), D = Kt(D), T = Kt(T), w = Kt(w)) : (M = h, w = d, D = T = 0), (x && !~(a + "").indexOf("px") || b && !~(o + "").indexOf("px")) && (x = rs(u, "x", a, "px"), b = rs(u, "y", o, "px")), (_ || m || g || p) && (x = Kt(x + _ - (_ * M + m * T) + g), b = Kt(b + m - (_ * D + m * w) + p)), (i || s) && (S = u.getBBox(), x = Kt(x + i / 100 * S.width), b = Kt(b + s / 100 * S.height)), S = "matrix(" + M + "," + D + "," + T + "," + w + "," + x + "," + b + ")", u.setAttribute("transform", S), v && (u.style[Ht] = S)
        },
        sw = function(e, t, n, i, s) {
            var a = 360,
                o = dn(s),
                l = parseFloat(s) * (o && ~s.indexOf("rad") ? Gs : 1),
                c = l - i,
                f = i + c + "deg",
                h, d;
            return o && (h = s.split("_")[1], h === "short" && (c %= a, c !== c % (a / 2) && (c += c < 0 ? a : -360)), h === "cw" && c < 0 ? c = (c + a * B_) % a - ~~(c / a) * a : h === "ccw" && c > 0 && (c = (c - a * B_) % a - ~~(c / a) * a)), e._pt = d = new qn(e._pt, t, n, i, c, HA), d.e = f, d.u = "deg", e._props.push(n), d
        },
        eb = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        aw = function(e, t, n) {
            var i = eb({}, n._gsap),
                s = "perspective,force3D,transformOrigin,svgOrigin",
                a = n.style,
                o, l, c, f, h, d, u, _;
            i.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), a[Ht] = t, o = al(n, 1), Hs(n, Ht), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[Ht], a[Ht] = t, o = al(n, 1), a[Ht] = c);
            for (l in Sr) c = i[l], f = o[l], c !== f && s.indexOf(l) < 0 && (u = An(c), _ = An(f), h = u !== _ ? rs(n, l, c, _) : parseFloat(c), d = parseFloat(f), e._pt = new qn(e._pt, o, l, h, d - h, id), e._pt.u = _ || 0, e._props.push(l));
            eb(o, i)
        };
    jn("padding,margin,Width,Radius", function(r, e) {
        var t = "Top",
            n = "Right",
            i = "Bottom",
            s = "Left",
            a = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function(o) {
                return e < 2 ? r + o : "border" + o + r
            });
        $c[e > 1 ? "border" + r : r] = function(o, l, c, f, h) {
            var d, u;
            if (arguments.length < 4) return d = a.map(function(_) {
                return Mr(o, _, c)
            }), u = d.join(" "), u.split(d[0]).length === 5 ? d[0] : u;
            d = (f + "").split(" "), u = {}, a.forEach(function(_, m) {
                return u[_] = d[m] = d[m] || d[(m - 1) / 2 | 0]
            }), o.init(l, u, h)
        }
    });
    var tb = {
        name: "css",
        register: sd,
        targetTest: function(e) {
            return e.style && e.nodeType
        },
        init: function(e, t, n, i, s) {
            var a = this._props,
                o = e.style,
                l = n.vars.startAt,
                c, f, h, d, u, _, m, g, p, v, x, b, M, D, T, w;
            ed || sd(), this.styles = this.styles || H_(e), w = this.styles.props, this.tween = n;
            for (m in t)
                if (m !== "autoRound" && (f = t[m], !(ii[m] && A_(m, t, n, i, e, s)))) {
                    if (u = typeof f, _ = $c[m], u === "function" && (f = f.call(n, i, e, s), u = typeof f), u === "string" && ~f.indexOf("random(") && (f = Qo(f)), _) _(this, e, m, f, n) && (T = 1);
                    else if (m.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(m) + "").trim(), f += "", es.lastIndex = 0, es.test(c) || (g = An(c), p = An(f)), p ? g !== p && (c = rs(e, m, c, p) + p) : g && (f += g), this.add(o, "setProperty", c, f, i, s, 0, 0, m), a.push(m), w.push(m, 0, o[m]);
                    else if (u !== "undefined") {
                        if (l && m in l ? (c = typeof l[m] == "function" ? l[m].call(n, i, e, s) : l[m], dn(c) && ~c.indexOf("random(") && (c = Qo(c)), An(c + "") || c === "auto" || (c += ti.units[m] || An(Mr(e, m)) || ""), (c + "").charAt(1) === "=" && (c = Mr(e, m))) : c = Mr(e, m), d = parseFloat(c), v = u === "string" && f.charAt(1) === "=" && f.substr(0, 2), v && (f = f.substr(2)), h = parseFloat(f), m in er && (m === "autoAlpha" && (d === 1 && Mr(e, "visibility") === "hidden" && h && (d = 0), w.push("visibility", 0, o.visibility), is(this, o, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), m !== "scale" && m !== "transform" && (m = er[m], ~m.indexOf(",") && (m = m.split(",")[0]))), x = m in Sr, x) {
                            if (this.styles.save(m), b || (M = e._gsap, M.renderTransform && !t.parseTransform || al(e, t.parseTransform), D = t.smoothOrigin !== !1 && M.smooth, b = this._pt = new qn(this._pt, o, Ht, 0, 1, M.renderTransform, M, 0, -1), b.dep = 1), m === "scale") this._pt = new qn(this._pt, M, "scaleY", M.scaleY, (v ? ka(M.scaleY, v + h) : h) - M.scaleY || 0, id), this._pt.u = 0, a.push("scaleY", m), m += "X";
                            else if (m === "transformOrigin") {
                                w.push(Kn, 0, o[Kn]), f = tw(f), M.svg ? ld(e, f, 0, D, 0, this) : (p = parseFloat(f.split(" ")[2]) || 0, p !== M.zOrigin && is(this, M, "zOrigin", M.zOrigin, p), is(this, o, m, Jc(c), Jc(f)));
                                continue
                            } else if (m === "svgOrigin") {
                                ld(e, f, 1, D, 0, this);
                                continue
                            } else if (m in $_) {
                                sw(this, M, m, d, v ? ka(d, v + f) : f);
                                continue
                            } else if (m === "smoothOrigin") {
                                is(this, M, "smooth", M.smooth, f);
                                continue
                            } else if (m === "force3D") {
                                M[m] = f;
                                continue
                            } else if (m === "transform") {
                                aw(this, f, e);
                                continue
                            }
                        } else m in o || (m = qa(m) || m);
                        if (x || (h || h === 0) && (d || d === 0) && !GA.test(f) && m in o) g = (c + "").substr((d + "").length), h || (h = 0), p = An(f) || (m in ti.units ? ti.units[m] : g), g !== p && (d = rs(e, m, c, p)), this._pt = new qn(this._pt, x ? M : o, m, d, (v ? ka(d, v + h) : h) - d, !x && (p === "px" || m === "zIndex") && t.autoRound !== !1 ? WA : id), this._pt.u = p || 0, g !== p && p !== "%" && (this._pt.b = c, this._pt.r = VA);
                        else if (m in o) ew.call(this, e, m, c, v ? v + f : f);
                        else if (m in e) this.add(e, m, c || e[m], v ? v + f : f, i, s);
                        else if (m !== "parseTransform") {
                            Ph(m, f);
                            continue
                        }
                        x || (m in o ? w.push(m, 0, o[m]) : w.push(m, 1, c || e[m])), a.push(m)
                    }
                }
            T && L_(this)
        },
        render: function(e, t) {
            if (t.tween._time || !td())
                for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
            else t.styles.revert()
        },
        get: Mr,
        aliases: er,
        getSetter: function(e, t, n) {
            var i = er[t];
            return i && i.indexOf(",") < 0 && (t = i), t in Sr && t !== Kn && (e._gsap.x || Mr(e, "x")) ? n && U_ === n ? t === "scale" ? YA : qA : (U_ = n || {}) && (t === "scale" ? KA : $A) : e.style && !Eh(e.style[t]) ? XA : ~t.indexOf("-") ? jA : Kh(e, t)
        },
        core: {
            _removeProperty: Hs,
            _getMatrix: od
        }
    };
    Yn.utils.checkPrefix = qa, Yn.core.getStyleSaver = H_,
        function(r, e, t, n) {
            var i = jn(r + "," + e + "," + t, function(s) {
                Sr[s] = 1
            });
            jn(e, function(s) {
                ti.units[s] = "deg", $_[s] = 1
            }), er[i[13]] = r + "," + e, jn(n, function(s) {
                var a = s.split(":");
                er[a[1]] = i[a[0]]
            })
        }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), jn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
            ti.units[r] = "px"
        }), Yn.registerPlugin(tb);
    var Zc = Yn.registerPlugin(tb) || Yn;
    Zc.core.Tween;

    function ow(r, e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, n.key, n)
        }
    }

    function lw(r, e, t) {
        return e && ow(r.prototype, e), r
    }
    /*!
     * Observer 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var bn, Qc, ai, ss, as, Ya, nb, Xs, ll, ib, Tr, Oi, rb, sb = function() {
            return bn || typeof window < "u" && (bn = window.gsap) && bn.registerPlugin && bn
        },
        ab = 1,
        Ka = [],
        gt = [],
        nr = [],
        cl = Date.now,
        ud = function(e, t) {
            return t
        },
        cw = function() {
            var e = ll.core,
                t = e.bridge || {},
                n = e._scrollers,
                i = e._proxies;
            n.push.apply(n, gt), i.push.apply(i, nr), gt = n, nr = i, ud = function(a, o) {
                return t[a](o)
            }
        },
        os = function(e, t) {
            return ~nr.indexOf(e) && nr[nr.indexOf(e) + 1][t]
        },
        ul = function(e) {
            return !!~ib.indexOf(e)
        },
        On = function(e, t, n, i, s) {
            return e.addEventListener(t, n, {
                passive: i !== !1,
                capture: !!s
            })
        },
        Un = function(e, t, n, i) {
            return e.removeEventListener(t, n, !!i)
        },
        eu = "scrollLeft",
        tu = "scrollTop",
        fd = function() {
            return Tr && Tr.isPressed || gt.cache++
        },
        nu = function(e, t) {
            var n = function i(s) {
                if (s || s === 0) {
                    ab && (ai.history.scrollRestoration = "manual");
                    var a = Tr && Tr.isPressed;
                    s = i.v = Math.round(s) || (Tr && Tr.iOS ? 1 : 0), e(s), i.cacheID = gt.cache, a && ud("ss", s)
                } else(t || gt.cache !== i.cacheID || ud("ref")) && (i.cacheID = gt.cache, i.v = e());
                return i.v + i.offset
            };
            return n.offset = 0, e && n
        },
        Bn = {
            s: eu,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: nu(function(r) {
                return arguments.length ? ai.scrollTo(r, sn.sc()) : ai.pageXOffset || ss[eu] || as[eu] || Ya[eu] || 0
            })
        },
        sn = {
            s: tu,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: Bn,
            sc: nu(function(r) {
                return arguments.length ? ai.scrollTo(Bn.sc(), r) : ai.pageYOffset || ss[tu] || as[tu] || Ya[tu] || 0
            })
        },
        $n = function(e, t) {
            return (t && t._ctx && t._ctx.selector || bn.utils.toArray)(e)[0] || (typeof e == "string" && bn.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
        },
        ls = function(e, t) {
            var n = t.s,
                i = t.sc;
            ul(e) && (e = ss.scrollingElement || as);
            var s = gt.indexOf(e),
                a = i === sn.sc ? 1 : 2;
            !~s && (s = gt.push(e) - 1), gt[s + a] || On(e, "scroll", fd);
            var o = gt[s + a],
                l = o || (gt[s + a] = nu(os(e, n), !0) || (ul(e) ? i : nu(function(c) {
                    return arguments.length ? e[n] = c : e[n]
                })));
            return l.target = e, o || (l.smooth = bn.getProperty(e, "scrollBehavior") === "smooth"), l
        },
        hd = function(e, t, n) {
            var i = e,
                s = e,
                a = cl(),
                o = a,
                l = t || 50,
                c = Math.max(500, l * 3),
                f = function(_, m) {
                    var g = cl();
                    m || g - a > l ? (s = i, i = _, o = a, a = g) : n ? i += _ : i = s + (_ - s) / (g - o) * (a - o)
                },
                h = function() {
                    s = i = n ? 0 : i, o = a = 0
                },
                d = function(_) {
                    var m = o,
                        g = s,
                        p = cl();
                    return (_ || _ === 0) && _ !== i && f(_), a === o || p - o > c ? 0 : (i + (n ? g : -g)) / ((n ? p : a) - m) * 1e3
                };
            return {
                update: f,
                reset: h,
                getVelocity: d
            }
        },
        fl = function(e, t) {
            return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
        },
        ob = function(e) {
            var t = Math.max.apply(Math, e),
                n = Math.min.apply(Math, e);
            return Math.abs(t) >= Math.abs(n) ? t : n
        },
        lb = function() {
            ll = bn.core.globals().ScrollTrigger, ll && ll.core && cw()
        },
        cb = function(e) {
            return bn = e || sb(), !Qc && bn && typeof document < "u" && document.body && (ai = window, ss = document, as = ss.documentElement, Ya = ss.body, ib = [ai, ss, as, Ya], bn.utils.clamp, rb = bn.core.context || function() {}, Xs = "onpointerenter" in Ya ? "pointer" : "mouse", nb = Vt.isTouch = ai.matchMedia && ai.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in ai || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Oi = Vt.eventTypes = ("ontouchstart" in as ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in as ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                return ab = 0
            }, 500), lb(), Qc = 1), Qc
        };
    Bn.op = sn, gt.cache = 0;
    var Vt = function() {
        function r(t) {
            this.init(t)
        }
        var e = r.prototype;
        return e.init = function(n) {
            Qc || cb(bn) || console.warn("Please gsap.registerPlugin(Observer)"), ll || lb();
            var i = n.tolerance,
                s = n.dragMinimum,
                a = n.type,
                o = n.target,
                l = n.lineHeight,
                c = n.debounce,
                f = n.preventDefault,
                h = n.onStop,
                d = n.onStopDelay,
                u = n.ignore,
                _ = n.wheelSpeed,
                m = n.event,
                g = n.onDragStart,
                p = n.onDragEnd,
                v = n.onDrag,
                x = n.onPress,
                b = n.onRelease,
                M = n.onRight,
                D = n.onLeft,
                T = n.onUp,
                w = n.onDown,
                S = n.onChangeX,
                y = n.onChangeY,
                C = n.onChange,
                O = n.onToggleX,
                N = n.onToggleY,
                V = n.onHover,
                G = n.onHoverEnd,
                B = n.onMove,
                j = n.ignoreCheck,
                H = n.isNormalizer,
                k = n.onGestureStart,
                F = n.onGestureEnd,
                se = n.onWheel,
                de = n.onEnable,
                ke = n.onDisable,
                q = n.onClick,
                ee = n.scrollSpeed,
                he = n.capture,
                fe = n.allowClicks,
                be = n.lockAxis,
                Ye = n.onLockAxis;
            this.target = o = $n(o) || as, this.vars = n, u && (u = bn.utils.toArray(u)), i = i || 1e-9, s = s || 0, _ = _ || 1, ee = ee || 1, a = a || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(ai.getComputedStyle(Ya).lineHeight) || 22);
            var Pe, Xe, tt, xe, R, Ge, $e, X = this,
                ve = 0,
                Qe = 0,
                Ie = n.passive || !f,
                ge = ls(o, Bn),
                rt = ls(o, sn),
                P = ge(),
                E = rt(),
                K = ~a.indexOf("touch") && !~a.indexOf("pointer") && Oi[0] === "pointerdown",
                ne = ul(o),
                ie = o.ownerDocument || ss,
                te = [0, 0, 0],
                Fe = [0, 0, 0],
                ye = 0,
                Oe = function() {
                    return ye = cl()
                },
                De = function(J, ce) {
                    return (X.event = J) && u && ~u.indexOf(J.target) || ce && K && J.pointerType !== "touch" || j && j(J, ce)
                },
                pe = function() {
                    X._vx.reset(), X._vy.reset(), Xe.pause(), h && h(X)
                },
                Ae = function() {
                    var J = X.deltaX = ob(te),
                        ce = X.deltaY = ob(Fe),
                        Q = Math.abs(J) >= i,
                        Te = Math.abs(ce) >= i;
                    C && (Q || Te) && C(X, J, ce, te, Fe), Q && (M && X.deltaX > 0 && M(X), D && X.deltaX < 0 && D(X), S && S(X), O && X.deltaX < 0 != ve < 0 && O(X), ve = X.deltaX, te[0] = te[1] = te[2] = 0), Te && (w && X.deltaY > 0 && w(X), T && X.deltaY < 0 && T(X), y && y(X), N && X.deltaY < 0 != Qe < 0 && N(X), Qe = X.deltaY, Fe[0] = Fe[1] = Fe[2] = 0), (xe || tt) && (B && B(X), tt && (v(X), tt = !1), xe = !1), Ge && !(Ge = !1) && Ye && Ye(X), R && (se(X), R = !1), Pe = 0
                },
                Ve = function(J, ce, Q) {
                    te[Q] += J, Fe[Q] += ce, X._vx.update(J), X._vy.update(ce), c ? Pe || (Pe = requestAnimationFrame(Ae)) : Ae()
                },
                He = function(J, ce) {
                    be && !$e && (X.axis = $e = Math.abs(J) > Math.abs(ce) ? "x" : "y", Ge = !0), $e !== "y" && (te[2] += J, X._vx.update(J, !0)), $e !== "x" && (Fe[2] += ce, X._vy.update(ce, !0)), c ? Pe || (Pe = requestAnimationFrame(Ae)) : Ae()
                },
                Se = function(J) {
                    if (!De(J, 1)) {
                        J = fl(J, f);
                        var ce = J.clientX,
                            Q = J.clientY,
                            Te = ce - X.x,
                            ue = Q - X.y,
                            we = X.isDragging;
                        X.x = ce, X.y = Q, (we || Math.abs(X.startX - ce) >= s || Math.abs(X.startY - Q) >= s) && (v && (tt = !0), we || (X.isDragging = !0), He(Te, ue), we || g && g(X))
                    }
                },
                je = X.onPress = function(U) {
                    De(U, 1) || U && U.button || (X.axis = $e = null, Xe.pause(), X.isPressed = !0, U = fl(U), ve = Qe = 0, X.startX = X.x = U.clientX, X.startY = X.y = U.clientY, X._vx.reset(), X._vy.reset(), On(H ? o : ie, Oi[1], Se, Ie, !0), X.deltaX = X.deltaY = 0, x && x(X))
                },
                I = X.onRelease = function(U) {
                    if (!De(U, 1)) {
                        Un(H ? o : ie, Oi[1], Se, !0);
                        var J = !isNaN(X.y - X.startY),
                            ce = X.isDragging,
                            Q = ce && (Math.abs(X.x - X.startX) > 3 || Math.abs(X.y - X.startY) > 3),
                            Te = fl(U);
                        !Q && J && (X._vx.reset(), X._vy.reset(), f && fe && bn.delayedCall(.08, function() {
                            if (cl() - ye > 300 && !U.defaultPrevented) {
                                if (U.target.click) U.target.click();
                                else if (ie.createEvent) {
                                    var ue = ie.createEvent("MouseEvents");
                                    ue.initMouseEvent("click", !0, !0, ai, 1, Te.screenX, Te.screenY, Te.clientX, Te.clientY, !1, !1, !1, !1, 0, null), U.target.dispatchEvent(ue)
                                }
                            }
                        })), X.isDragging = X.isGesturing = X.isPressed = !1, h && ce && !H && Xe.restart(!0), p && ce && p(X), b && b(X, Q)
                    }
                },
                Me = function(J) {
                    return J.touches && J.touches.length > 1 && (X.isGesturing = !0) && k(J, X.isDragging)
                },
                oe = function() {
                    return (X.isGesturing = !1) || F(X)
                },
                Ee = function(J) {
                    if (!De(J)) {
                        var ce = ge(),
                            Q = rt();
                        Ve((ce - P) * ee, (Q - E) * ee, 1), P = ce, E = Q, h && Xe.restart(!0)
                    }
                },
                me = function(J) {
                    if (!De(J)) {
                        J = fl(J, f), se && (R = !0);
                        var ce = (J.deltaMode === 1 ? l : J.deltaMode === 2 ? ai.innerHeight : 1) * _;
                        Ve(J.deltaX * ce, J.deltaY * ce, 0), h && !H && Xe.restart(!0)
                    }
                },
                le = function(J) {
                    if (!De(J)) {
                        var ce = J.clientX,
                            Q = J.clientY,
                            Te = ce - X.x,
                            ue = Q - X.y;
                        X.x = ce, X.y = Q, xe = !0, h && Xe.restart(!0), (Te || ue) && He(Te, ue)
                    }
                },
                ae = function(J) {
                    X.event = J, V(X)
                },
                L = function(J) {
                    X.event = J, G(X)
                },
                re = function(J) {
                    return De(J) || fl(J, f) && q(X)
                };
            Xe = X._dc = bn.delayedCall(d || .25, pe).pause(), X.deltaX = X.deltaY = 0, X._vx = hd(0, 50, !0), X._vy = hd(0, 50, !0), X.scrollX = ge, X.scrollY = rt, X.isDragging = X.isGesturing = X.isPressed = !1, rb(this), X.enable = function(U) {
                return X.isEnabled || (On(ne ? ie : o, "scroll", fd), a.indexOf("scroll") >= 0 && On(ne ? ie : o, "scroll", Ee, Ie, he), a.indexOf("wheel") >= 0 && On(o, "wheel", me, Ie, he), (a.indexOf("touch") >= 0 && nb || a.indexOf("pointer") >= 0) && (On(o, Oi[0], je, Ie, he), On(ie, Oi[2], I), On(ie, Oi[3], I), fe && On(o, "click", Oe, !0, !0), q && On(o, "click", re), k && On(ie, "gesturestart", Me), F && On(ie, "gestureend", oe), V && On(o, Xs + "enter", ae), G && On(o, Xs + "leave", L), B && On(o, Xs + "move", le)), X.isEnabled = !0, U && U.type && je(U), de && de(X)), X
            }, X.disable = function() {
                X.isEnabled && (Ka.filter(function(U) {
                    return U !== X && ul(U.target)
                }).length || Un(ne ? ie : o, "scroll", fd), X.isPressed && (X._vx.reset(), X._vy.reset(), Un(H ? o : ie, Oi[1], Se, !0)), Un(ne ? ie : o, "scroll", Ee, he), Un(o, "wheel", me, he), Un(o, Oi[0], je, he), Un(ie, Oi[2], I), Un(ie, Oi[3], I), Un(o, "click", Oe, !0), Un(o, "click", re), Un(ie, "gesturestart", Me), Un(ie, "gestureend", oe), Un(o, Xs + "enter", ae), Un(o, Xs + "leave", L), Un(o, Xs + "move", le), X.isEnabled = X.isPressed = X.isDragging = !1, ke && ke(X))
            }, X.kill = X.revert = function() {
                X.disable();
                var U = Ka.indexOf(X);
                U >= 0 && Ka.splice(U, 1), Tr === X && (Tr = 0)
            }, Ka.push(X), H && ul(o) && (Tr = X), X.enable(m)
        }, lw(r, [{
            key: "velocityX",
            get: function() {
                return this._vx.getVelocity()
            }
        }, {
            key: "velocityY",
            get: function() {
                return this._vy.getVelocity()
            }
        }]), r
    }();
    Vt.version = "3.12.5", Vt.create = function(r) {
        return new Vt(r)
    }, Vt.register = cb, Vt.getAll = function() {
        return Ka.slice()
    }, Vt.getById = function(r) {
        return Ka.filter(function(e) {
            return e.vars.id === r
        })[0]
    }, sb() && bn.registerPlugin(Vt);
    /*!
     * matrix 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Er, js, dd, iu, hl, ru, su, dl, Ui = "transform",
        pd = Ui + "Origin",
        ub, md = function(e) {
            var t = e.ownerDocument || e;
            for (!(Ui in e.style) && ("msTransform" in e.style) && (Ui = "msTransform", pd = Ui + "Origin"); t.parentNode && (t = t.parentNode););
            if (js = window, su = new Dr, t) {
                Er = t, dd = t.documentElement, iu = t.body, dl = Er.createElementNS("http://www.w3.org/2000/svg", "g"), dl.style.transform = "none";
                var n = t.createElement("div"),
                    i = t.createElement("div"),
                    s = t && (t.body || t.firstElementChild);
                s && s.appendChild && (s.appendChild(n), n.appendChild(i), n.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), ub = i.offsetParent !== n, s.removeChild(n))
            }
            return t
        },
        uw = function(e) {
            for (var t, n; e && e !== iu;) n = e._gsap, n && n.uncache && n.get(e, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), t ? t.push(n) : t = [n]), e = e.parentNode;
            return t
        },
        fb = [],
        hb = [],
        gd = function() {
            return js.pageYOffset || Er.scrollTop || dd.scrollTop || iu.scrollTop || 0
        },
        _d = function() {
            return js.pageXOffset || Er.scrollLeft || dd.scrollLeft || iu.scrollLeft || 0
        },
        bd = function(e) {
            return e.ownerSVGElement || ((e.tagName + "").toLowerCase() === "svg" ? e : null)
        },
        fw = function r(e) {
            if (js.getComputedStyle(e).position === "fixed") return !0;
            if (e = e.parentNode, e && e.nodeType === 1) return r(e)
        },
        xd = function r(e, t) {
            if (e.parentNode && (Er || md(e))) {
                var n = bd(e),
                    i = n ? n.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                    s = n ? t ? "rect" : "g" : "div",
                    a = t !== 2 ? 0 : 100,
                    o = t === 3 ? 100 : 0,
                    l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                    c = Er.createElementNS ? Er.createElementNS(i.replace(/^https/, "http"), s) : Er.createElement(s);
                return t && (n ? (ru || (ru = r(e)), c.setAttribute("width", .01), c.setAttribute("height", .01), c.setAttribute("transform", "translate(" + a + "," + o + ")"), ru.appendChild(c)) : (hl || (hl = r(e), hl.style.cssText = l), c.style.cssText = l + "width:0.1px;height:0.1px;top:" + o + "px;left:" + a + "px", hl.appendChild(c))), c
            }
            throw "Need document and parent."
        },
        hw = function(e) {
            for (var t = new Dr, n = 0; n < e.numberOfItems; n++) t.multiply(e.getItem(n).matrix);
            return t
        },
        db = function(e) {
            var t = e.getCTM(),
                n;
            return t || (n = e.style[Ui], e.style[Ui] = "none", e.appendChild(dl), t = dl.getCTM(), e.removeChild(dl), n ? e.style[Ui] = n : e.style.removeProperty(Ui.replace(/([A-Z])/g, "-$1").toLowerCase())), t || su.clone()
        },
        dw = function(e, t) {
            var n = bd(e),
                i = e === n,
                s = n ? fb : hb,
                a = e.parentNode,
                o, l, c, f, h, d;
            if (e === js) return e;
            if (s.length || s.push(xd(e, 1), xd(e, 2), xd(e, 3)), o = n ? ru : hl, n) i ? (c = db(e), f = -c.e / c.a, h = -c.f / c.d, l = su) : e.getBBox ? (c = e.getBBox(), l = e.transform ? e.transform.baseVal : {}, l = l.numberOfItems ? l.numberOfItems > 1 ? hw(l) : l.getItem(0).matrix : su, f = l.a * c.x + l.c * c.y, h = l.b * c.x + l.d * c.y) : (l = new Dr, f = h = 0), t && e.tagName.toLowerCase() === "g" && (f = h = 0), (i ? n : a).appendChild(o), o.setAttribute("transform", "matrix(" + l.a + "," + l.b + "," + l.c + "," + l.d + "," + (l.e + f) + "," + (l.f + h) + ")");
            else {
                if (f = h = 0, ub)
                    for (l = e.offsetParent, c = e; c && (c = c.parentNode) && c !== l && c.parentNode;)(js.getComputedStyle(c)[Ui] + "").length > 4 && (f = c.offsetLeft, h = c.offsetTop, c = 0);
                if (d = js.getComputedStyle(e), d.position !== "absolute" && d.position !== "fixed")
                    for (l = e.offsetParent; a && a !== l;) f += a.scrollLeft || 0, h += a.scrollTop || 0, a = a.parentNode;
                c = o.style, c.top = e.offsetTop - h + "px", c.left = e.offsetLeft - f + "px", c[Ui] = d[Ui], c[pd] = d[pd], c.position = d.position === "fixed" ? "fixed" : "absolute", e.parentNode.appendChild(o)
            }
            return o
        },
        vd = function(e, t, n, i, s, a, o) {
            return e.a = t, e.b = n, e.c = i, e.d = s, e.e = a, e.f = o, e
        },
        Dr = function() {
            function r(t, n, i, s, a, o) {
                t === void 0 && (t = 1), n === void 0 && (n = 0), i === void 0 && (i = 0), s === void 0 && (s = 1), a === void 0 && (a = 0), o === void 0 && (o = 0), vd(this, t, n, i, s, a, o)
            }
            var e = r.prototype;
            return e.inverse = function() {
                var n = this.a,
                    i = this.b,
                    s = this.c,
                    a = this.d,
                    o = this.e,
                    l = this.f,
                    c = n * a - i * s || 1e-10;
                return vd(this, a / c, -i / c, -s / c, n / c, (s * l - a * o) / c, -(n * l - i * o) / c)
            }, e.multiply = function(n) {
                var i = this.a,
                    s = this.b,
                    a = this.c,
                    o = this.d,
                    l = this.e,
                    c = this.f,
                    f = n.a,
                    h = n.c,
                    d = n.b,
                    u = n.d,
                    _ = n.e,
                    m = n.f;
                return vd(this, f * i + d * a, f * s + d * o, h * i + u * a, h * s + u * o, l + _ * i + m * a, c + _ * s + m * o)
            }, e.clone = function() {
                return new r(this.a, this.b, this.c, this.d, this.e, this.f)
            }, e.equals = function(n) {
                var i = this.a,
                    s = this.b,
                    a = this.c,
                    o = this.d,
                    l = this.e,
                    c = this.f;
                return i === n.a && s === n.b && a === n.c && o === n.d && l === n.e && c === n.f
            }, e.apply = function(n, i) {
                i === void 0 && (i = {});
                var s = n.x,
                    a = n.y,
                    o = this.a,
                    l = this.b,
                    c = this.c,
                    f = this.d,
                    h = this.e,
                    d = this.f;
                return i.x = s * o + a * c + h || 0, i.y = s * l + a * f + d || 0, i
            }, r
        }();

    function xn(r, e, t, n) {
        if (!r || !r.parentNode || (Er || md(r)).documentElement === r) return new Dr;
        var i = uw(r),
            s = bd(r),
            a = s ? fb : hb,
            o = dw(r, t),
            l = a[0].getBoundingClientRect(),
            c = a[1].getBoundingClientRect(),
            f = a[2].getBoundingClientRect(),
            h = o.parentNode,
            d = !n && fw(r),
            u = new Dr((c.left - l.left) / 100, (c.top - l.top) / 100, (f.left - l.left) / 100, (f.top - l.top) / 100, l.left + (d ? 0 : _d()), l.top + (d ? 0 : gd()));
        if (h.removeChild(o), i)
            for (l = i.length; l--;) c = i[l], c.scaleX = c.scaleY = 0, c.renderTransform(1, c);
        return e ? u.inverse() : u
    }

    function pb(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
    }

    function pw(r, e) {
        r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
    }
    var yt, Lt, oi, Bi, Ar, yd, wr, Sd, pl, cs, mb, Md, ml, Td, gl, ki, _l, au, gb, Ed, ou = 0,
        _b = function() {
            return typeof window < "u"
        },
        bb = function() {
            return yt || _b() && (yt = window.gsap) && yt.registerPlugin && yt
        },
        us = function(e) {
            return typeof e == "function"
        },
        bl = function(e) {
            return typeof e == "object"
        },
        zi = function(e) {
            return typeof e > "u"
        },
        lu = function() {
            return !1
        },
        xl = "transform",
        Dd = "transformOrigin",
        fs = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        vl = Array.isArray,
        cu = function(e, t) {
            var n = oi.createElementNS ? oi.createElementNS("http://www.w3.org/1999/xhtml".replace(/^https/, "http"), e) : oi.createElement(e);
            return n.style ? n : oi.createElement(e)
        },
        xb = 180 / Math.PI,
        $a = 1e20,
        mw = new Dr,
        hs = Date.now || function() {
            return new Date().getTime()
        },
        qs = [],
        Ja = {},
        gw = 0,
        _w = /^(?:a|input|textarea|button|select)$/i,
        vb = 0,
        Za = {},
        Cr = {},
        yb = function(e, t) {
            var n = {},
                i;
            for (i in e) n[i] = t ? e[i] * t : e[i];
            return n
        },
        bw = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        Sb = function r(e, t) {
            for (var n = e.length, i; n--;) t ? e[n].style.touchAction = t : e[n].style.removeProperty("touch-action"), i = e[n].children, i && i.length && r(i, t)
        },
        Mb = function() {
            return qs.forEach(function(e) {
                return e()
            })
        },
        xw = function(e) {
            qs.push(e), qs.length === 1 && yt.ticker.add(Mb)
        },
        Tb = function() {
            return !qs.length && yt.ticker.remove(Mb)
        },
        Eb = function(e) {
            for (var t = qs.length; t--;) qs[t] === e && qs.splice(t, 1);
            yt.to(Tb, {
                overwrite: !0,
                delay: 15,
                duration: 0,
                onComplete: Tb,
                data: "_draggable"
            })
        },
        vw = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        an = function(e, t, n, i) {
            if (e.addEventListener) {
                var s = ml[t];
                i = i || (mb ? {
                    passive: !1
                } : null), e.addEventListener(s || t, n, i), s && t !== s && e.addEventListener(t, n, i)
            }
        },
        Qt = function(e, t, n, i) {
            if (e.removeEventListener) {
                var s = ml[t];
                e.removeEventListener(s || t, n, i), s && t !== s && e.removeEventListener(t, n, i)
            }
        },
        bi = function(e) {
            e.preventDefault && e.preventDefault(), e.preventManipulation && e.preventManipulation()
        },
        yw = function(e, t) {
            for (var n = e.length; n--;)
                if (e[n].identifier === t) return !0
        },
        Sw = function r(e) {
            Td = e.touches && ou < e.touches.length, Qt(e.target, "touchend", r)
        },
        Db = function(e) {
            Td = e.touches && ou < e.touches.length, an(e.target, "touchend", Sw)
        },
        Qa = function(e) {
            return Lt.pageYOffset || e.scrollTop || e.documentElement.scrollTop || e.body.scrollTop || 0
        },
        eo = function(e) {
            return Lt.pageXOffset || e.scrollLeft || e.documentElement.scrollLeft || e.body.scrollLeft || 0
        },
        Ab = function r(e, t) {
            an(e, "scroll", t), to(e.parentNode) || r(e.parentNode, t)
        },
        wb = function r(e, t) {
            Qt(e, "scroll", t), to(e.parentNode) || r(e.parentNode, t)
        },
        to = function(e) {
            return !e || e === Bi || e.nodeType === 9 || e === oi.body || e === Lt || !e.nodeType || !e.parentNode
        },
        Cb = function(e, t) {
            var n = t === "x" ? "Width" : "Height",
                i = "scroll" + n,
                s = "client" + n;
            return Math.max(0, to(e) ? Math.max(Bi[i], Ar[i]) - (Lt["inner" + n] || Bi[s] || Ar[s]) : e[i] - e[s])
        },
        Ad = function r(e, t) {
            var n = Cb(e, "x"),
                i = Cb(e, "y");
            to(e) ? e = Cr : r(e.parentNode, t), e._gsMaxScrollX = n, e._gsMaxScrollY = i, t || (e._gsScrollX = e.scrollLeft || 0, e._gsScrollY = e.scrollTop || 0)
        },
        wd = function(e, t, n) {
            var i = e.style;
            i && (zi(i[t]) && (t = pl(t, e) || t), n == null ? i.removeProperty && i.removeProperty(t.replace(/([A-Z])/g, "-$1").toLowerCase()) : i[t] = n)
        },
        yl = function(e) {
            return Lt.getComputedStyle(e instanceof Element ? e : e.host || (e.parentNode || {}).host || e)
        },
        Ys = {},
        no = function(e) {
            if (e === Lt) return Ys.left = Ys.top = 0, Ys.width = Ys.right = Bi.clientWidth || e.innerWidth || Ar.clientWidth || 0, Ys.height = Ys.bottom = (e.innerHeight || 0) - 20 < Bi.clientHeight ? Bi.clientHeight : e.innerHeight || Ar.clientHeight || 0, Ys;
            var t = e.ownerDocument || oi,
                n = zi(e.pageX) ? !e.nodeType && !zi(e.left) && !zi(e.top) ? e : cs(e)[0].getBoundingClientRect() : {
                    left: e.pageX - eo(t),
                    top: e.pageY - Qa(t),
                    right: e.pageX - eo(t) + 1,
                    bottom: e.pageY - Qa(t) + 1
                };
            return zi(n.right) && !zi(n.width) ? (n.right = n.left + n.width, n.bottom = n.top + n.height) : zi(n.width) && (n = {
                width: n.right - n.left,
                height: n.bottom - n.top,
                right: n.right,
                left: n.left,
                bottom: n.bottom,
                top: n.top
            }), n
        },
        $t = function(e, t, n) {
            var i = e.vars,
                s = i[n],
                a = e._listeners[t],
                o;
            return us(s) && (o = s.apply(i.callbackScope || e, i[n + "Params"] || [e.pointerEvent])), a && e.dispatchEvent(t) === !1 && (o = !1), o
        },
        Rb = function(e, t) {
            var n = cs(e)[0],
                i, s, a;
            return !n.nodeType && n !== Lt ? zi(e.left) ? (s = e.min || e.minX || e.minRotation || 0, i = e.min || e.minY || 0, {
                left: s,
                top: i,
                width: (e.max || e.maxX || e.maxRotation || 0) - s,
                height: (e.max || e.maxY || 0) - i
            }) : (a = {
                x: 0,
                y: 0
            }, {
                left: e.left - a.x,
                top: e.top - a.y,
                width: e.width,
                height: e.height
            }) : Mw(n, t)
        },
        xi = {},
        Mw = function(e, t) {
            t = cs(t)[0];
            var n = e.getBBox && e.ownerSVGElement,
                i = e.ownerDocument || oi,
                s, a, o, l, c, f, h, d, u, _, m, g, p;
            if (e === Lt) o = Qa(i), s = eo(i), a = s + (i.documentElement.clientWidth || e.innerWidth || i.body.clientWidth || 0), l = o + ((e.innerHeight || 0) - 20 < i.documentElement.clientHeight ? i.documentElement.clientHeight : e.innerHeight || i.body.clientHeight || 0);
            else {
                if (t === Lt || zi(t)) return e.getBoundingClientRect();
                s = o = 0, n ? (_ = e.getBBox(), m = _.width, g = _.height) : (e.viewBox && (_ = e.viewBox.baseVal) && (s = _.x || 0, o = _.y || 0, m = _.width, g = _.height), m || (p = yl(e), _ = p.boxSizing === "border-box", m = (parseFloat(p.width) || e.clientWidth || 0) + (_ ? 0 : parseFloat(p.borderLeftWidth) + parseFloat(p.borderRightWidth)), g = (parseFloat(p.height) || e.clientHeight || 0) + (_ ? 0 : parseFloat(p.borderTopWidth) + parseFloat(p.borderBottomWidth)))), a = m, l = g
            }
            return e === t ? {
                left: s,
                top: o,
                width: a - s,
                height: l - o
            } : (c = xn(t, !0).multiply(xn(e)), f = c.apply({
                x: s,
                y: o
            }), h = c.apply({
                x: a,
                y: o
            }), d = c.apply({
                x: a,
                y: l
            }), u = c.apply({
                x: s,
                y: l
            }), s = Math.min(f.x, h.x, d.x, u.x), o = Math.min(f.y, h.y, d.y, u.y), {
                left: s,
                top: o,
                width: Math.max(f.x, h.x, d.x, u.x) - s,
                height: Math.max(f.y, h.y, d.y, u.y) - o
            })
        },
        Cd = function(e, t, n, i, s, a) {
            var o = {},
                l, c, f;
            if (t)
                if (s !== 1 && t instanceof Array) {
                    if (o.end = l = [], f = t.length, bl(t[0]))
                        for (c = 0; c < f; c++) l[c] = yb(t[c], s);
                    else
                        for (c = 0; c < f; c++) l[c] = t[c] * s;
                    n += 1.1, i -= 1.1
                } else us(t) ? o.end = function(h) {
                    var d = t.call(e, h),
                        u, _;
                    if (s !== 1)
                        if (bl(d)) {
                            u = {};
                            for (_ in d) u[_] = d[_] * s;
                            d = u
                        } else d *= s;
                    return d
                } : o.end = t;
            return (n || n === 0) && (o.max = n), (i || i === 0) && (o.min = i), a && (o.velocity = 0), o
        },
        Tw = function r(e) {
            var t;
            return !e || !e.getAttribute || e === Ar ? !1 : (t = e.getAttribute("data-clickable")) === "true" || t !== "false" && (_w.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true") ? !0 : r(e.parentNode)
        },
        uu = function(e, t) {
            for (var n = e.length, i; n--;) i = e[n], i.ondragstart = i.onselectstart = t ? null : lu, yt.set(i, {
                lazy: !0,
                userSelect: t ? "text" : "none"
            })
        },
        Ew = function r(e) {
            if (yl(e).position === "fixed") return !0;
            if (e = e.parentNode, e && e.nodeType === 1) return r(e)
        },
        Pb, Rd, Dw = function(e, t) {
            e = yt.utils.toArray(e)[0], t = t || {};
            var n = document.createElement("div"),
                i = n.style,
                s = e.firstChild,
                a = 0,
                o = 0,
                l = e.scrollTop,
                c = e.scrollLeft,
                f = e.scrollWidth,
                h = e.scrollHeight,
                d = 0,
                u = 0,
                _ = 0,
                m, g, p, v, x, b;
            Pb && t.force3D !== !1 ? (x = "translate3d(", b = "px,0px)") : xl && (x = "translate(", b = "px)"), this.scrollTop = function(M, D) {
                if (!arguments.length) return -this.top();
                this.top(-M, D)
            }, this.scrollLeft = function(M, D) {
                if (!arguments.length) return -this.left();
                this.left(-M, D)
            }, this.left = function(M, D) {
                if (!arguments.length) return -(e.scrollLeft + o);
                var T = e.scrollLeft - c,
                    w = o;
                if ((T > 2 || T < -2) && !D) {
                    c = e.scrollLeft, yt.killTweensOf(this, {
                        left: 1,
                        scrollLeft: 1
                    }), this.left(-c), t.onKill && t.onKill();
                    return
                }
                M = -M, M < 0 ? (o = M - .5 | 0, M = 0) : M > u ? (o = M - u | 0, M = u) : o = 0, (o || w) && (this._skip || (i[xl] = x + -o + "px," + -a + b), o + d >= 0 && (i.paddingRight = o + d + "px")), e.scrollLeft = M | 0, c = e.scrollLeft
            }, this.top = function(M, D) {
                if (!arguments.length) return -(e.scrollTop + a);
                var T = e.scrollTop - l,
                    w = a;
                if ((T > 2 || T < -2) && !D) {
                    l = e.scrollTop, yt.killTweensOf(this, {
                        top: 1,
                        scrollTop: 1
                    }), this.top(-l), t.onKill && t.onKill();
                    return
                }
                M = -M, M < 0 ? (a = M - .5 | 0, M = 0) : M > _ ? (a = M - _ | 0, M = _) : a = 0, (a || w) && (this._skip || (i[xl] = x + -o + "px," + -a + b)), e.scrollTop = M | 0, l = e.scrollTop
            }, this.maxScrollTop = function() {
                return _
            }, this.maxScrollLeft = function() {
                return u
            }, this.disable = function() {
                for (s = n.firstChild; s;) v = s.nextSibling, e.appendChild(s), s = v;
                e === n.parentNode && e.removeChild(n)
            }, this.enable = function() {
                if (s = e.firstChild, s !== n) {
                    for (; s;) v = s.nextSibling, n.appendChild(s), s = v;
                    e.appendChild(n), this.calibrate()
                }
            }, this.calibrate = function(M) {
                var D = e.clientWidth === m,
                    T, w, S;
                l = e.scrollTop, c = e.scrollLeft, !(D && e.clientHeight === g && n.offsetHeight === p && f === e.scrollWidth && h === e.scrollHeight && !M) && ((a || o) && (w = this.left(), S = this.top(), this.left(-e.scrollLeft), this.top(-e.scrollTop)), T = yl(e), (!D || M) && (i.display = "block", i.width = "auto", i.paddingRight = "0px", d = Math.max(0, e.scrollWidth - e.clientWidth), d && (d += parseFloat(T.paddingLeft) + (Rd ? parseFloat(T.paddingRight) : 0))), i.display = "inline-block", i.position = "relative", i.overflow = "visible", i.verticalAlign = "top", i.boxSizing = "content-box", i.width = "100%", i.paddingRight = d + "px", Rd && (i.paddingBottom = T.paddingBottom), m = e.clientWidth, g = e.clientHeight, f = e.scrollWidth, h = e.scrollHeight, u = e.scrollWidth - m, _ = e.scrollHeight - g, p = n.offsetHeight, i.display = "block", (w || S) && (this.left(w), this.top(S)))
            }, this.content = n, this.element = e, this._skip = !1, this.enable()
        },
        Pd = function(e) {
            if (_b() && document.body) {
                var t = window && window.navigator;
                Lt = window, oi = document, Bi = oi.documentElement, Ar = oi.body, yd = cu("div"), au = !!window.PointerEvent, wr = cu("div"), wr.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab", _l = wr.style.cursor === "grab" ? "grab" : "move", gl = t && t.userAgent.toLowerCase().indexOf("android") !== -1, Md = "ontouchstart" in Bi && "orientation" in Lt || t && (t.MaxTouchPoints > 0 || t.msMaxTouchPoints > 0), Rd = function() {
                    var n = cu("div"),
                        i = cu("div"),
                        s = i.style,
                        a = Ar,
                        o;
                    return s.display = "inline-block", s.position = "relative", n.style.cssText = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden", n.appendChild(i), a.appendChild(n), o = i.offsetHeight + 18 > n.scrollHeight, a.removeChild(n), o
                }(), ml = function(n) {
                    for (var i = n.split(","), s = ("onpointerdown" in yd ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in yd ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : n).split(","), a = {}, o = 4; --o > -1;) a[i[o]] = s[o], a[s[o]] = i[o];
                    try {
                        Bi.addEventListener("test", null, Object.defineProperty({}, "passive", {
                            get: function() {
                                mb = 1
                            }
                        }))
                    } catch {}
                    return a
                }("touchstart,touchmove,touchend,touchcancel"), an(oi, "touchcancel", lu), an(Lt, "touchmove", lu), Ar && Ar.addEventListener("touchstart", lu), an(oi, "contextmenu", function() {
                    for (var n in Ja) Ja[n].isPressed && Ja[n].endDrag()
                }), yt = Sd = bb()
            }
            yt ? (ki = yt.plugins.inertia, gb = yt.core.context || function() {}, pl = yt.utils.checkPrefix, xl = pl(xl), Dd = pl(Dd), cs = yt.utils.toArray, Ed = yt.core.getStyleSaver, Pb = !!pl("perspective")) : e && console.warn("Please gsap.registerPlugin(Draggable)")
        },
        Aw = function() {
            function r(t) {
                this._listeners = {}, this.target = t || this
            }
            var e = r.prototype;
            return e.addEventListener = function(n, i) {
                var s = this._listeners[n] || (this._listeners[n] = []);
                ~s.indexOf(i) || s.push(i)
            }, e.removeEventListener = function(n, i) {
                var s = this._listeners[n],
                    a = s && s.indexOf(i);
                a >= 0 && s.splice(a, 1)
            }, e.dispatchEvent = function(n) {
                var i = this,
                    s;
                return (this._listeners[n] || []).forEach(function(a) {
                    return a.call(i, {
                        type: n,
                        target: i.target
                    }) === !1 && (s = !1)
                }), s
            }, r
        }(),
        io = function(r) {
            pw(e, r);

            function e(t, n) {
                var i;
                i = r.call(this) || this, Sd || Pd(1), t = cs(t)[0], i.styles = Ed && Ed(t, "transform,left,top"), ki || (ki = yt.plugins.inertia), i.vars = n = yb(n || {}), i.target = t, i.x = i.y = i.rotation = 0, i.dragResistance = parseFloat(n.dragResistance) || 0, i.edgeResistance = isNaN(n.edgeResistance) ? 1 : parseFloat(n.edgeResistance) || 0, i.lockAxis = n.lockAxis, i.autoScroll = n.autoScroll || 0, i.lockedAxis = null, i.allowEventDefault = !!n.allowEventDefault, yt.getProperty(t, "x");
                var s = (n.type || "x,y").toLowerCase(),
                    a = ~s.indexOf("x") || ~s.indexOf("y"),
                    o = s.indexOf("rotation") !== -1,
                    l = o ? "rotation" : a ? "x" : "left",
                    c = a ? "y" : "top",
                    f = !!(~s.indexOf("x") || ~s.indexOf("left") || s === "scroll"),
                    h = !!(~s.indexOf("y") || ~s.indexOf("top") || s === "scroll"),
                    d = n.minimumMovement || 2,
                    u = pb(i),
                    _ = cs(n.trigger || n.handle || t),
                    m = {},
                    g = 0,
                    p = !1,
                    v = n.autoScrollMarginTop || 40,
                    x = n.autoScrollMarginRight || 40,
                    b = n.autoScrollMarginBottom || 40,
                    M = n.autoScrollMarginLeft || 40,
                    D = n.clickableTest || Tw,
                    T = 0,
                    w = t._gsap || yt.core.getCache(t),
                    S = Ew(t),
                    y = function(L, re) {
                        return parseFloat(w.get(t, L, re))
                    },
                    C = t.ownerDocument || oi,
                    O, N, V, G, B, j, H, k, F, se, de, ke, q, ee, he, fe, be, Ye, Pe, Xe, tt, xe, R, Ge, $e, X, ve, Qe, Ie, ge, rt, P, E, K = function(L) {
                        return bi(L), L.stopImmediatePropagation && L.stopImmediatePropagation(), !1
                    },
                    ne = function ae(L) {
                        if (u.autoScroll && u.isDragging && (p || be)) {
                            var re = t,
                                U = u.autoScroll * 15,
                                J, ce, Q, Te, ue, we, Ke, Ue;
                            for (p = !1, Cr.scrollTop = Lt.pageYOffset != null ? Lt.pageYOffset : C.documentElement.scrollTop != null ? C.documentElement.scrollTop : C.body.scrollTop, Cr.scrollLeft = Lt.pageXOffset != null ? Lt.pageXOffset : C.documentElement.scrollLeft != null ? C.documentElement.scrollLeft : C.body.scrollLeft, Te = u.pointerX - Cr.scrollLeft, ue = u.pointerY - Cr.scrollTop; re && !ce;) ce = to(re.parentNode), J = ce ? Cr : re.parentNode, Q = ce ? {
                                bottom: Math.max(Bi.clientHeight, Lt.innerHeight || 0),
                                right: Math.max(Bi.clientWidth, Lt.innerWidth || 0),
                                left: 0,
                                top: 0
                            } : J.getBoundingClientRect(), we = Ke = 0, h && (Ue = J._gsMaxScrollY - J.scrollTop, Ue < 0 ? Ke = Ue : ue > Q.bottom - b && Ue ? (p = !0, Ke = Math.min(Ue, U * (1 - Math.max(0, Q.bottom - ue) / b) | 0)) : ue < Q.top + v && J.scrollTop && (p = !0, Ke = -Math.min(J.scrollTop, U * (1 - Math.max(0, ue - Q.top) / v) | 0)), Ke && (J.scrollTop += Ke)), f && (Ue = J._gsMaxScrollX - J.scrollLeft, Ue < 0 ? we = Ue : Te > Q.right - x && Ue ? (p = !0, we = Math.min(Ue, U * (1 - Math.max(0, Q.right - Te) / x) | 0)) : Te < Q.left + M && J.scrollLeft && (p = !0, we = -Math.min(J.scrollLeft, U * (1 - Math.max(0, Te - Q.left) / M) | 0)), we && (J.scrollLeft += we)), ce && (we || Ke) && (Lt.scrollTo(J.scrollLeft, J.scrollTop), Me(u.pointerX + we, u.pointerY + Ke)), re = J
                        }
                        if (be) {
                            var et = u.x,
                                bt = u.y;
                            o ? (u.deltaX = et - parseFloat(w.rotation), u.rotation = et, w.rotation = et + "deg", w.renderTransform(1, w)) : N ? (h && (u.deltaY = bt - N.top(), N.top(bt)), f && (u.deltaX = et - N.left(), N.left(et))) : a ? (h && (u.deltaY = bt - parseFloat(w.y), w.y = bt + "px"), f && (u.deltaX = et - parseFloat(w.x), w.x = et + "px"), w.renderTransform(1, w)) : (h && (u.deltaY = bt - parseFloat(t.style.top || 0), t.style.top = bt + "px"), f && (u.deltaX = et - parseFloat(t.style.left || 0), t.style.left = et + "px")), k && !L && !Qe && (Qe = !0, $t(u, "drag", "onDrag") === !1 && (f && (u.x -= u.deltaX), h && (u.y -= u.deltaY), ae(!0)), Qe = !1)
                        }
                        be = !1
                    },
                    ie = function(L, re) {
                        var U = u.x,
                            J = u.y,
                            ce, Q;
                        t._gsap || (w = yt.core.getCache(t)), w.uncache && yt.getProperty(t, "x"), a ? (u.x = parseFloat(w.x), u.y = parseFloat(w.y)) : o ? u.x = u.rotation = parseFloat(w.rotation) : N ? (u.y = N.top(), u.x = N.left()) : (u.y = parseFloat(t.style.top || (Q = yl(t)) && Q.top) || 0, u.x = parseFloat(t.style.left || (Q || {}).left) || 0), (Pe || Xe || tt) && !re && (u.isDragging || u.isThrowing) && (tt && (Za.x = u.x, Za.y = u.y, ce = tt(Za), ce.x !== u.x && (u.x = ce.x, be = !0), ce.y !== u.y && (u.y = ce.y, be = !0)), Pe && (ce = Pe(u.x), ce !== u.x && (u.x = ce, o && (u.rotation = ce), be = !0)), Xe && (ce = Xe(u.y), ce !== u.y && (u.y = ce), be = !0)), be && ne(!0), L || (u.deltaX = u.x - U, u.deltaY = u.y - J, $t(u, "throwupdate", "onThrowUpdate"))
                    },
                    te = function(L, re, U, J) {
                        return re == null && (re = -1e20), U == null && (U = $a), us(L) ? function(ce) {
                            var Q = u.isPressed ? 1 - u.edgeResistance : 1;
                            return L.call(u, (ce > U ? U + (ce - U) * Q : ce < re ? re + (ce - re) * Q : ce) * J) * J
                        } : vl(L) ? function(ce) {
                            for (var Q = L.length, Te = 0, ue = $a, we, Ke; --Q > -1;) we = L[Q], Ke = we - ce, Ke < 0 && (Ke = -Ke), Ke < ue && we >= re && we <= U && (Te = Q, ue = Ke);
                            return L[Te]
                        } : isNaN(L) ? function(ce) {
                            return ce
                        } : function() {
                            return L * J
                        }
                    },
                    Fe = function(L, re, U, J, ce, Q, Te) {
                        return Q = Q && Q < $a ? Q * Q : $a, us(L) ? function(ue) {
                            var we = u.isPressed ? 1 - u.edgeResistance : 1,
                                Ke = ue.x,
                                Ue = ue.y,
                                et, bt, _t;
                            return ue.x = Ke = Ke > U ? U + (Ke - U) * we : Ke < re ? re + (Ke - re) * we : Ke, ue.y = Ue = Ue > ce ? ce + (Ue - ce) * we : Ue < J ? J + (Ue - J) * we : Ue, et = L.call(u, ue), et !== ue && (ue.x = et.x, ue.y = et.y), Te !== 1 && (ue.x *= Te, ue.y *= Te), Q < $a && (bt = ue.x - Ke, _t = ue.y - Ue, bt * bt + _t * _t > Q && (ue.x = Ke, ue.y = Ue)), ue
                        } : vl(L) ? function(ue) {
                            for (var we = L.length, Ke = 0, Ue = $a, et, bt, _t, ct; --we > -1;) _t = L[we], et = _t.x - ue.x, bt = _t.y - ue.y, ct = et * et + bt * bt, ct < Ue && (Ke = we, Ue = ct);
                            return Ue <= Q ? L[Ke] : ue
                        } : function(ue) {
                            return ue
                        }
                    },
                    ye = function() {
                        var L, re, U, J;
                        H = !1, N ? (N.calibrate(), u.minX = de = -N.maxScrollLeft(), u.minY = q = -N.maxScrollTop(), u.maxX = se = u.maxY = ke = 0, H = !0) : n.bounds && (L = Rb(n.bounds, t.parentNode), o ? (u.minX = de = L.left, u.maxX = se = L.left + L.width, u.minY = q = u.maxY = ke = 0) : !zi(n.bounds.maxX) || !zi(n.bounds.maxY) ? (L = n.bounds, u.minX = de = L.minX, u.minY = q = L.minY, u.maxX = se = L.maxX, u.maxY = ke = L.maxY) : (re = Rb(t, t.parentNode), u.minX = de = Math.round(y(l, "px") + L.left - re.left), u.minY = q = Math.round(y(c, "px") + L.top - re.top), u.maxX = se = Math.round(de + (L.width - re.width)), u.maxY = ke = Math.round(q + (L.height - re.height))), de > se && (u.minX = se, u.maxX = se = de, de = u.minX), q > ke && (u.minY = ke, u.maxY = ke = q, q = u.minY), o && (u.minRotation = de, u.maxRotation = se), H = !0), n.liveSnap && (U = n.liveSnap === !0 ? n.snap || {} : n.liveSnap, J = vl(U) || us(U), o ? (Pe = te(J ? U : U.rotation, de, se, 1), Xe = null) : U.points ? tt = Fe(J ? U : U.points, de, se, q, ke, U.radius, N ? -1 : 1) : (f && (Pe = te(J ? U : U.x || U.left || U.scrollLeft, de, se, N ? -1 : 1)), h && (Xe = te(J ? U : U.y || U.top || U.scrollTop, q, ke, N ? -1 : 1))))
                    },
                    Oe = function() {
                        u.isThrowing = !1, $t(u, "throwcomplete", "onThrowComplete")
                    },
                    De = function() {
                        u.isThrowing = !1
                    },
                    pe = function(L, re) {
                        var U, J, ce, Q;
                        L && ki ? (L === !0 && (U = n.snap || n.liveSnap || {}, J = vl(U) || us(U), L = {
                            resistance: (n.throwResistance || n.resistance || 1e3) / (o ? 10 : 1)
                        }, o ? L.rotation = Cd(u, J ? U : U.rotation, se, de, 1, re) : (f && (L[l] = Cd(u, J ? U : U.points || U.x || U.left, se, de, N ? -1 : 1, re || u.lockedAxis === "x")), h && (L[c] = Cd(u, J ? U : U.points || U.y || U.top, ke, q, N ? -1 : 1, re || u.lockedAxis === "y")), (U.points || vl(U) && bl(U[0])) && (L.linkedProps = l + "," + c, L.radius = U.radius))), u.isThrowing = !0, Q = isNaN(n.overshootTolerance) ? n.edgeResistance === 1 ? 0 : 1 - u.edgeResistance + .2 : n.overshootTolerance, L.duration || (L.duration = {
                            max: Math.max(n.minDuration || 0, "maxDuration" in n ? n.maxDuration : 2),
                            min: isNaN(n.minDuration) ? Q === 0 || bl(L) && L.resistance > 1e3 ? 0 : .5 : n.minDuration,
                            overshoot: Q
                        }), u.tween = ce = yt.to(N || t, {
                            inertia: L,
                            data: "_draggable",
                            inherit: !1,
                            onComplete: Oe,
                            onInterrupt: De,
                            onUpdate: n.fastMode ? $t : ie,
                            onUpdateParams: n.fastMode ? [u, "onthrowupdate", "onThrowUpdate"] : U && U.radius ? [!1, !0] : []
                        }), n.fastMode || (N && (N._skip = !0), ce.render(1e9, !0, !0), ie(!0, !0), u.endX = u.x, u.endY = u.y, o && (u.endRotation = u.x), ce.play(0), ie(!0, !0), N && (N._skip = !1))) : H && u.applyBounds()
                    },
                    Ae = function(L) {
                        var re = Ge,
                            U;
                        Ge = xn(t.parentNode, !0), L && u.isPressed && !Ge.equals(re || new Dr) && (U = re.inverse().apply({
                            x: V,
                            y: G
                        }), Ge.apply(U, U), V = U.x, G = U.y), Ge.equals(mw) && (Ge = null)
                    },
                    Ve = function() {
                        var L = 1 - u.edgeResistance,
                            re = S ? eo(C) : 0,
                            U = S ? Qa(C) : 0,
                            J, ce, Q;
                        a && (w.x = y(l, "px") + "px", w.y = y(c, "px") + "px", w.renderTransform()), Ae(!1), xi.x = u.pointerX - re, xi.y = u.pointerY - U, Ge && Ge.apply(xi, xi), V = xi.x, G = xi.y, be && (Me(u.pointerX, u.pointerY), ne(!0)), P = xn(t), N ? (ye(), j = N.top(), B = N.left()) : (He() ? (ie(!0, !0), ye()) : u.applyBounds(), o ? (J = t.ownerSVGElement ? [w.xOrigin - t.getBBox().x, w.yOrigin - t.getBBox().y] : (yl(t)[Dd] || "0 0").split(" "), fe = u.rotationOrigin = xn(t).apply({
                            x: parseFloat(J[0]) || 0,
                            y: parseFloat(J[1]) || 0
                        }), ie(!0, !0), ce = u.pointerX - fe.x - re, Q = fe.y - u.pointerY + U, B = u.x, j = u.y = Math.atan2(Q, ce) * xb) : (j = y(c, "px"), B = y(l, "px"))), H && L && (B > se ? B = se + (B - se) / L : B < de && (B = de - (de - B) / L), o || (j > ke ? j = ke + (j - ke) / L : j < q && (j = q - (q - j) / L))), u.startX = B = fs(B), u.startY = j = fs(j)
                    },
                    He = function() {
                        return u.tween && u.tween.isActive()
                    },
                    Se = function() {
                        wr.parentNode && !He() && !u.isDragging && wr.parentNode.removeChild(wr)
                    },
                    je = function(L, re) {
                        var U;
                        if (!O || u.isPressed || !L || (L.type === "mousedown" || L.type === "pointerdown") && !re && hs() - T < 30 && ml[u.pointerEvent.type]) {
                            rt && L && O && bi(L);
                            return
                        }
                        if ($e = He(), E = !1, u.pointerEvent = L, ml[L.type] ? (R = ~L.type.indexOf("touch") ? L.currentTarget || L.target : C, an(R, "touchend", oe), an(R, "touchmove", I), an(R, "touchcancel", oe), an(C, "touchstart", Db)) : (R = null, an(C, "mousemove", I)), ve = null, (!au || !R) && (an(C, "mouseup", oe), L && L.target && an(L.target, "mouseup", oe)), xe = D.call(u, L.target) && n.dragClickables === !1 && !re, xe) {
                            an(L.target, "change", oe), $t(u, "pressInit", "onPressInit"), $t(u, "press", "onPress"), uu(_, !0), rt = !1;
                            return
                        }
                        if (X = !R || f === h || u.vars.allowNativeTouchScrolling === !1 || u.vars.allowContextMenu && L && (L.ctrlKey || L.which > 2) ? !1 : f ? "y" : "x", rt = !X && !u.allowEventDefault, rt && (bi(L), an(Lt, "touchforcechange", bi)), L.changedTouches ? (L = ee = L.changedTouches[0], he = L.identifier) : L.pointerId ? he = L.pointerId : ee = he = null, ou++, xw(ne), G = u.pointerY = L.pageY, V = u.pointerX = L.pageX, $t(u, "pressInit", "onPressInit"), (X || u.autoScroll) && Ad(t.parentNode), t.parentNode && u.autoScroll && !N && !o && t.parentNode._gsMaxScrollX && !wr.parentNode && !t.getBBox && (wr.style.width = t.parentNode.scrollWidth + "px", t.parentNode.appendChild(wr)), Ve(), u.tween && u.tween.kill(), u.isThrowing = !1, yt.killTweensOf(N || t, m, !0), N && yt.killTweensOf(t, {
                                scrollTo: 1
                            }, !0), u.tween = u.lockedAxis = null, (n.zIndexBoost || !o && !N && n.zIndexBoost !== !1) && (t.style.zIndex = e.zIndex++), u.isPressed = !0, k = !!(n.onDrag || u._listeners.drag), F = !!(n.onMove || u._listeners.move), n.cursor !== !1 || n.activeCursor)
                            for (U = _.length; --U > -1;) yt.set(_[U], {
                                cursor: n.activeCursor || n.cursor || (_l === "grab" ? "grabbing" : _l)
                            });
                        $t(u, "press", "onPress")
                    },
                    I = function(L) {
                        var re = L,
                            U, J, ce, Q, Te, ue;
                        if (!O || Td || !u.isPressed || !L) {
                            rt && L && O && bi(L);
                            return
                        }
                        if (u.pointerEvent = L, U = L.changedTouches, U) {
                            if (L = U[0], L !== ee && L.identifier !== he) {
                                for (Q = U.length; --Q > -1 && (L = U[Q]).identifier !== he && L.target !== t;);
                                if (Q < 0) return
                            }
                        } else if (L.pointerId && he && L.pointerId !== he) return;
                        if (R && X && !ve && (xi.x = L.pageX - (S ? eo(C) : 0), xi.y = L.pageY - (S ? Qa(C) : 0), Ge && Ge.apply(xi, xi), J = xi.x, ce = xi.y, Te = Math.abs(J - V), ue = Math.abs(ce - G), (Te !== ue && (Te > d || ue > d) || gl && X === ve) && (ve = Te > ue && f ? "x" : "y", X && ve !== X && an(Lt, "touchforcechange", bi), u.vars.lockAxisOnTouchScroll !== !1 && f && h && (u.lockedAxis = ve === "x" ? "y" : "x", us(u.vars.onLockAxis) && u.vars.onLockAxis.call(u, re)), gl && X === ve))) {
                            oe(re);
                            return
                        }!u.allowEventDefault && (!X || ve && X !== ve) && re.cancelable !== !1 ? (bi(re), rt = !0) : rt && (rt = !1), u.autoScroll && (p = !0), Me(L.pageX, L.pageY, F)
                    },
                    Me = function(L, re, U) {
                        var J = 1 - u.dragResistance,
                            ce = 1 - u.edgeResistance,
                            Q = u.pointerX,
                            Te = u.pointerY,
                            ue = j,
                            we = u.x,
                            Ke = u.y,
                            Ue = u.endX,
                            et = u.endY,
                            bt = u.endRotation,
                            _t = be,
                            ct, ut, Et, nt, cn, Bt;
                        u.pointerX = L, u.pointerY = re, S && (L -= eo(C), re -= Qa(C)), o ? (nt = Math.atan2(fe.y - re, L - fe.x) * xb, cn = u.y - nt, cn > 180 ? (j -= 360, u.y = nt) : cn < -180 && (j += 360, u.y = nt), u.x !== B || Math.abs(j - nt) > d ? (u.y = nt, Et = B + (j - nt) * J) : Et = B) : (Ge && (Bt = L * Ge.a + re * Ge.c + Ge.e, re = L * Ge.b + re * Ge.d + Ge.f, L = Bt), ut = re - G, ct = L - V, ut < d && ut > -d && (ut = 0), ct < d && ct > -d && (ct = 0), (u.lockAxis || u.lockedAxis) && (ct || ut) && (Bt = u.lockedAxis, Bt || (u.lockedAxis = Bt = f && Math.abs(ct) > Math.abs(ut) ? "y" : h ? "x" : null, Bt && us(u.vars.onLockAxis) && u.vars.onLockAxis.call(u, u.pointerEvent)), Bt === "y" ? ut = 0 : Bt === "x" && (ct = 0)), Et = fs(B + ct * J), nt = fs(j + ut * J)), (Pe || Xe || tt) && (u.x !== Et || u.y !== nt && !o) && (tt && (Za.x = Et, Za.y = nt, Bt = tt(Za), Et = fs(Bt.x), nt = fs(Bt.y)), Pe && (Et = fs(Pe(Et))), Xe && (nt = fs(Xe(nt)))), H && (Et > se ? Et = se + Math.round((Et - se) * ce) : Et < de && (Et = de + Math.round((Et - de) * ce)), o || (nt > ke ? nt = Math.round(ke + (nt - ke) * ce) : nt < q && (nt = Math.round(q + (nt - q) * ce)))), (u.x !== Et || u.y !== nt && !o) && (o ? (u.endRotation = u.x = u.endX = Et, be = !0) : (h && (u.y = u.endY = nt, be = !0), f && (u.x = u.endX = Et, be = !0)), !U || $t(u, "move", "onMove") !== !1 ? !u.isDragging && u.isPressed && (u.isDragging = E = !0, $t(u, "dragstart", "onDragStart")) : (u.pointerX = Q, u.pointerY = Te, j = ue, u.x = we, u.y = Ke, u.endX = Ue, u.endY = et, u.endRotation = bt, be = _t))
                    },
                    oe = function ae(L, re) {
                        if (!O || !u.isPressed || L && he != null && !re && (L.pointerId && L.pointerId !== he && L.target !== t || L.changedTouches && !yw(L.changedTouches, he))) {
                            rt && L && O && bi(L);
                            return
                        }
                        u.isPressed = !1;
                        var U = L,
                            J = u.isDragging,
                            ce = u.vars.allowContextMenu && L && (L.ctrlKey || L.which > 2),
                            Q = yt.delayedCall(.001, Se),
                            Te, ue, we, Ke, Ue;
                        if (R ? (Qt(R, "touchend", ae), Qt(R, "touchmove", I), Qt(R, "touchcancel", ae), Qt(C, "touchstart", Db)) : Qt(C, "mousemove", I), Qt(Lt, "touchforcechange", bi), (!au || !R) && (Qt(C, "mouseup", ae), L && L.target && Qt(L.target, "mouseup", ae)), be = !1, J && (g = vb = hs(), u.isDragging = !1), Eb(ne), xe && !ce) {
                            L && (Qt(L.target, "change", ae), u.pointerEvent = U), uu(_, !1), $t(u, "release", "onRelease"), $t(u, "click", "onClick"), xe = !1;
                            return
                        }
                        for (ue = _.length; --ue > -1;) wd(_[ue], "cursor", n.cursor || (n.cursor !== !1 ? _l : null));
                        if (ou--, L) {
                            if (Te = L.changedTouches, Te && (L = Te[0], L !== ee && L.identifier !== he)) {
                                for (ue = Te.length; --ue > -1 && (L = Te[ue]).identifier !== he && L.target !== t;);
                                if (ue < 0 && !re) return
                            }
                            u.pointerEvent = U, u.pointerX = L.pageX, u.pointerY = L.pageY
                        }
                        return ce && U ? (bi(U), rt = !0, $t(u, "release", "onRelease")) : U && !J ? (rt = !1, $e && (n.snap || n.bounds) && pe(n.inertia || n.throwProps), $t(u, "release", "onRelease"), (!gl || U.type !== "touchmove") && U.type.indexOf("cancel") === -1 && ($t(u, "click", "onClick"), hs() - T < 300 && $t(u, "doubleclick", "onDoubleClick"), Ke = U.target || t, T = hs(), Ue = function() {
                            T !== Ie && u.enabled() && !u.isPressed && !U.defaultPrevented && (Ke.click ? Ke.click() : C.createEvent && (we = C.createEvent("MouseEvents"), we.initMouseEvent("click", !0, !0, Lt, 1, u.pointerEvent.screenX, u.pointerEvent.screenY, u.pointerX, u.pointerY, !1, !1, !1, !1, 0, null), Ke.dispatchEvent(we)))
                        }, !gl && !U.defaultPrevented && yt.delayedCall(.05, Ue))) : (pe(n.inertia || n.throwProps), !u.allowEventDefault && U && (n.dragClickables !== !1 || !D.call(u, U.target)) && J && (!X || ve && X === ve) && U.cancelable !== !1 ? (rt = !0, bi(U)) : rt = !1, $t(u, "release", "onRelease")), He() && Q.duration(u.tween.duration()), J && $t(u, "dragend", "onDragEnd"), !0
                    },
                    Ee = function(L) {
                        if (L && u.isDragging && !N) {
                            var re = L.target || t.parentNode,
                                U = re.scrollLeft - re._gsScrollX,
                                J = re.scrollTop - re._gsScrollY;
                            (U || J) && (Ge ? (V -= U * Ge.a + J * Ge.c, G -= J * Ge.d + U * Ge.b) : (V -= U, G -= J), re._gsScrollX += U, re._gsScrollY += J, Me(u.pointerX, u.pointerY))
                        }
                    },
                    me = function(L) {
                        var re = hs(),
                            U = re - T < 100,
                            J = re - g < 50,
                            ce = U && Ie === T,
                            Q = u.pointerEvent && u.pointerEvent.defaultPrevented,
                            Te = U && ge === T,
                            ue = L.isTrusted || L.isTrusted == null && U && ce;
                        if ((ce || J && u.vars.suppressClickOnDrag !== !1) && L.stopImmediatePropagation && L.stopImmediatePropagation(), U && !(u.pointerEvent && u.pointerEvent.defaultPrevented) && (!ce || ue && !Te)) {
                            ue && ce && (ge = T), Ie = T;
                            return
                        }(u.isPressed || J || U) && (!ue || !L.detail || !U || Q) && bi(L), !U && !J && !E && (L && L.target && (u.pointerEvent = L), $t(u, "click", "onClick"))
                    },
                    le = function(L) {
                        return Ge ? {
                            x: L.x * Ge.a + L.y * Ge.c + Ge.e,
                            y: L.x * Ge.b + L.y * Ge.d + Ge.f
                        } : {
                            x: L.x,
                            y: L.y
                        }
                    };
                return Ye = e.get(t), Ye && Ye.kill(), i.startDrag = function(ae, L) {
                    var re, U, J, ce;
                    je(ae || u.pointerEvent, !0), L && !u.hitTest(ae || u.pointerEvent) && (re = no(ae || u.pointerEvent), U = no(t), J = le({
                        x: re.left + re.width / 2,
                        y: re.top + re.height / 2
                    }), ce = le({
                        x: U.left + U.width / 2,
                        y: U.top + U.height / 2
                    }), V -= J.x - ce.x, G -= J.y - ce.y), u.isDragging || (u.isDragging = E = !0, $t(u, "dragstart", "onDragStart"))
                }, i.drag = I, i.endDrag = function(ae) {
                    return oe(ae || u.pointerEvent, !0)
                }, i.timeSinceDrag = function() {
                    return u.isDragging ? 0 : (hs() - g) / 1e3
                }, i.timeSinceClick = function() {
                    return (hs() - T) / 1e3
                }, i.hitTest = function(ae, L) {
                    return e.hitTest(u.target, ae, L)
                }, i.getDirection = function(ae, L) {
                    var re = ae === "velocity" && ki ? ae : bl(ae) && !o ? "element" : "start",
                        U, J, ce, Q, Te, ue;
                    return re === "element" && (Te = no(u.target), ue = no(ae)), U = re === "start" ? u.x - B : re === "velocity" ? ki.getVelocity(t, l) : Te.left + Te.width / 2 - (ue.left + ue.width / 2), o ? U < 0 ? "counter-clockwise" : "clockwise" : (L = L || 2, J = re === "start" ? u.y - j : re === "velocity" ? ki.getVelocity(t, c) : Te.top + Te.height / 2 - (ue.top + ue.height / 2), ce = Math.abs(U / J), Q = ce < 1 / L ? "" : U < 0 ? "left" : "right", ce < L && (Q !== "" && (Q += "-"), Q += J < 0 ? "up" : "down"), Q)
                }, i.applyBounds = function(ae, L) {
                    var re, U, J, ce, Q, Te;
                    if (ae && n.bounds !== ae) return n.bounds = ae, u.update(!0, L);
                    if (ie(!0), ye(), H && !He()) {
                        if (re = u.x, U = u.y, re > se ? re = se : re < de && (re = de), U > ke ? U = ke : U < q && (U = q), (u.x !== re || u.y !== U) && (J = !0, u.x = u.endX = re, o ? u.endRotation = re : u.y = u.endY = U, be = !0, ne(!0), u.autoScroll && !u.isDragging))
                            for (Ad(t.parentNode), ce = t, Cr.scrollTop = Lt.pageYOffset != null ? Lt.pageYOffset : C.documentElement.scrollTop != null ? C.documentElement.scrollTop : C.body.scrollTop, Cr.scrollLeft = Lt.pageXOffset != null ? Lt.pageXOffset : C.documentElement.scrollLeft != null ? C.documentElement.scrollLeft : C.body.scrollLeft; ce && !Te;) Te = to(ce.parentNode), Q = Te ? Cr : ce.parentNode, h && Q.scrollTop > Q._gsMaxScrollY && (Q.scrollTop = Q._gsMaxScrollY), f && Q.scrollLeft > Q._gsMaxScrollX && (Q.scrollLeft = Q._gsMaxScrollX), ce = Q;
                        u.isThrowing && (J || u.endX > se || u.endX < de || u.endY > ke || u.endY < q) && pe(n.inertia || n.throwProps, J)
                    }
                    return u
                }, i.update = function(ae, L, re) {
                    if (L && u.isPressed) {
                        var U = xn(t),
                            J = P.apply({
                                x: u.x - B,
                                y: u.y - j
                            }),
                            ce = xn(t.parentNode, !0);
                        ce.apply({
                            x: U.e - J.x,
                            y: U.f - J.y
                        }, J), u.x -= J.x - ce.e, u.y -= J.y - ce.f, ne(!0), Ve()
                    }
                    var Q = u.x,
                        Te = u.y;
                    return Ae(!L), ae ? u.applyBounds() : (be && re && ne(!0), ie(!0)), L && (Me(u.pointerX, u.pointerY), be && ne(!0)), u.isPressed && !L && (f && Math.abs(Q - u.x) > .01 || h && Math.abs(Te - u.y) > .01 && !o) && Ve(), u.autoScroll && (Ad(t.parentNode, u.isDragging), p = u.isDragging, ne(!0), wb(t, Ee), Ab(t, Ee)), u
                }, i.enable = function(ae) {
                    var L = {
                            lazy: !0
                        },
                        re, U, J;
                    if (n.cursor !== !1 && (L.cursor = n.cursor || _l), yt.utils.checkPrefix("touchCallout") && (L.touchCallout = "none"), ae !== "soft") {
                        for (Sb(_, f === h ? "none" : n.allowNativeTouchScrolling && t.scrollHeight === t.clientHeight == (t.scrollWidth === t.clientHeight) || n.allowEventDefault ? "manipulation" : f ? "pan-y" : "pan-x"), U = _.length; --U > -1;) J = _[U], au || an(J, "mousedown", je), an(J, "touchstart", je), an(J, "click", me, !0), yt.set(J, L), J.getBBox && J.ownerSVGElement && f !== h && yt.set(J.ownerSVGElement, {
                            touchAction: n.allowNativeTouchScrolling || n.allowEventDefault ? "manipulation" : f ? "pan-y" : "pan-x"
                        }), n.allowContextMenu || an(J, "contextmenu", K);
                        uu(_, !1)
                    }
                    return Ab(t, Ee), O = !0, ki && ae !== "soft" && ki.track(N || t, a ? "x,y" : o ? "rotation" : "top,left"), t._gsDragID = re = "d" + gw++, Ja[re] = u, N && (N.enable(), N.element._gsDragID = re), (n.bounds || o) && Ve(), n.bounds && u.applyBounds(), u
                }, i.disable = function(ae) {
                    for (var L = u.isDragging, re = _.length, U; --re > -1;) wd(_[re], "cursor", null);
                    if (ae !== "soft") {
                        for (Sb(_, null), re = _.length; --re > -1;) U = _[re], wd(U, "touchCallout", null), Qt(U, "mousedown", je), Qt(U, "touchstart", je), Qt(U, "click", me, !0), Qt(U, "contextmenu", K);
                        uu(_, !0), R && (Qt(R, "touchcancel", oe), Qt(R, "touchend", oe), Qt(R, "touchmove", I)), Qt(C, "mouseup", oe), Qt(C, "mousemove", I)
                    }
                    return wb(t, Ee), O = !1, ki && ae !== "soft" && (ki.untrack(N || t, a ? "x,y" : o ? "rotation" : "top,left"), u.tween && u.tween.kill()), N && N.disable(), Eb(ne), u.isDragging = u.isPressed = xe = !1, L && $t(u, "dragend", "onDragEnd"), u
                }, i.enabled = function(ae, L) {
                    return arguments.length ? ae ? u.enable(L) : u.disable(L) : O
                }, i.kill = function() {
                    return u.isThrowing = !1, u.tween && u.tween.kill(), u.disable(), yt.set(_, {
                        clearProps: "userSelect"
                    }), delete Ja[t._gsDragID], u
                }, i.revert = function() {
                    this.kill(), this.styles && this.styles.revert()
                }, ~s.indexOf("scroll") && (N = i.scrollProxy = new Dw(t, bw({
                    onKill: function() {
                        u.isPressed && oe(null)
                    }
                }, n)), t.style.overflowY = h && !Md ? "auto" : "hidden", t.style.overflowX = f && !Md ? "auto" : "hidden", t = N.content), o ? m.rotation = 1 : (f && (m[l] = 1), h && (m[c] = 1)), w.force3D = "force3D" in n ? n.force3D : !0, gb(pb(i)), i.enable(), i
            }
            return e.register = function(n) {
                yt = n, Pd()
            }, e.create = function(n, i) {
                return Sd || Pd(!0), cs(n).map(function(s) {
                    return new e(s, i)
                })
            }, e.get = function(n) {
                return Ja[(cs(n)[0] || {})._gsDragID]
            }, e.timeSinceDrag = function() {
                return (hs() - vb) / 1e3
            }, e.hitTest = function(n, i, s) {
                if (n === i) return !1;
                var a = no(n),
                    o = no(i),
                    l = a.top,
                    c = a.left,
                    f = a.right,
                    h = a.bottom,
                    d = a.width,
                    u = a.height,
                    _ = o.left > f || o.right < c || o.top > h || o.bottom < l,
                    m, g, p;
                return _ || !s ? !_ : (p = (s + "").indexOf("%") !== -1, s = parseFloat(s) || 0, m = {
                    left: Math.max(c, o.left),
                    top: Math.max(l, o.top)
                }, m.width = Math.min(f, o.right) - m.left, m.height = Math.min(h, o.bottom) - m.top, m.width < 0 || m.height < 0 ? !1 : p ? (s *= .01, g = m.width * m.height, g >= d * u * s || g >= o.width * o.height * s) : m.width > s && m.height > s)
            }, e
        }(Aw);
    vw(io.prototype, {
        pointerX: 0,
        pointerY: 0,
        startX: 0,
        startY: 0,
        deltaX: 0,
        deltaY: 0,
        isDragging: !1,
        isPressed: !1
    }), io.zIndex = 1e3, io.version = "3.12.5", bb() && yt.registerPlugin(io);
    /*!
     * VelocityTracker: 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var ir, Fd, Sl, Fb, ro, so, Ld, Lb, Ib = function() {
            return ir || typeof window < "u" && (ir = window.gsap)
        },
        Id = {},
        ww = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        Nd = function(e) {
            return Lb(e).id
        },
        Ml = function(e) {
            return Id[Nd(typeof e == "string" ? Sl(e)[0] : e)]
        },
        Nb = function(e) {
            var t = ro,
                n;
            if (e - Ld >= .05)
                for (Ld = e; t;) n = t.g(t.t, t.p), (n !== t.v1 || e - t.t1 > .2) && (t.v2 = t.v1, t.v1 = n, t.t2 = t.t1, t.t1 = e), t = t._next
        },
        Cw = {
            deg: 360,
            rad: Math.PI * 2
        },
        Od = function() {
            ir = Ib(), ir && (Sl = ir.utils.toArray, Fb = ir.utils.getUnit, Lb = ir.core.getCache, so = ir.ticker, Fd = 1)
        },
        Rw = function(e, t, n, i) {
            this.t = e, this.p = t, this.g = e._gsap.get, this.rCap = Cw[n || Fb(this.g(e, t))], this.v1 = this.v2 = 0, this.t1 = this.t2 = so.time, i && (this._next = i, i._prev = this)
        },
        Tl = function() {
            function r(t, n) {
                Fd || Od(), this.target = Sl(t)[0], Id[Nd(this.target)] = this, this._props = {}, n && this.add(n)
            }
            r.register = function(n) {
                ir = n, Od()
            };
            var e = r.prototype;
            return e.get = function(n, i) {
                var s = this._props[n] || console.warn("Not tracking " + n + " velocity."),
                    a, o, l;
                return a = parseFloat(i ? s.v1 : s.g(s.t, s.p)), o = a - parseFloat(s.v2), l = s.rCap, l && (o = o % l, o !== o % (l / 2) && (o = o < 0 ? o + l : o - l)), ww(o / ((i ? s.t1 : so.time) - s.t2))
            }, e.getAll = function() {
                var n = {},
                    i = this._props,
                    s;
                for (s in i) n[s] = this.get(s);
                return n
            }, e.isTracking = function(n) {
                return n in this._props
            }, e.add = function(n, i) {
                n in this._props || (ro || (so.add(Nb), Ld = so.time), ro = this._props[n] = new Rw(this.target, n, i, ro))
            }, e.remove = function(n) {
                var i = this._props[n],
                    s, a;
                i && (s = i._prev, a = i._next, s && (s._next = a), a ? a._prev = s : ro === i && (so.remove(Nb), ro = 0), delete this._props[n])
            }, e.kill = function(n) {
                for (var i in this._props) this.remove(i);
                n || delete Id[Nd(this.target)]
            }, r.track = function(n, i, s) {
                Fd || Od();
                for (var a = [], o = Sl(n), l = i.split(","), c = (s || "").split(","), f = o.length, h, d; f--;) {
                    for (h = Ml(o[f]) || new r(o[f]), d = l.length; d--;) h.add(l[d], c[d] || c[0]);
                    a.push(h)
                }
                return a
            }, r.untrack = function(n, i) {
                var s = (i || "").split(",");
                Sl(n).forEach(function(a) {
                    var o = Ml(a);
                    o && (s.length ? s.forEach(function(l) {
                        return o.remove(l)
                    }) : o.kill(1))
                })
            }, r.isTracking = function(n, i) {
                var s = Ml(n);
                return s && s.isTracking(i)
            }, r.getVelocity = function(n, i) {
                var s = Ml(n);
                return !s || !s.isTracking(i) ? console.warn("Not tracking velocity of " + i) : s.get(i)
            }, r
        }();
    Tl.getByTarget = Ml, Ib() && ir.registerPlugin(Tl);
    /*!
     * InertiaPlugin 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var on, Ob, Ub, Bb, Ud, El, kb, zb, Gb, Bd, Hb, Dl, kd, Vb, fu = Tl.getByTarget,
        Wb = function() {
            return on || typeof window < "u" && (on = window.gsap) && on.registerPlugin && on
        },
        Pw = function(e) {
            return typeof e == "string"
        },
        Al = function(e) {
            return typeof e == "number"
        },
        ds = function(e) {
            return typeof e == "object"
        },
        zd = function(e) {
            return typeof e == "function"
        },
        Fw = 1,
        Xb = Array.isArray,
        Lw = function(e) {
            return e
        },
        ao = 1e10,
        jb = 1 / ao,
        qb = .05,
        Iw = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        Nw = function(e, t, n) {
            for (var i in t) !(i in e) && i !== n && (e[i] = t[i]);
            return e
        },
        Ow = function r(e) {
            var t = {},
                n, i;
            for (n in e) t[n] = ds(i = e[n]) && !Xb(i) ? r(i) : i;
            return t
        },
        Yb = function(e, t, n, i, s) {
            var a = t.length,
                o = 0,
                l = ao,
                c, f, h, d;
            if (ds(e)) {
                for (; a--;) {
                    c = t[a], f = 0;
                    for (h in e) d = c[h] - e[h], f += d * d;
                    f < l && (o = a, l = f)
                }
                if ((s || ao) < ao && s < Math.sqrt(l)) return e
            } else
                for (; a--;) c = t[a], f = c - e, f < 0 && (f = -f), f < l && c >= i && c <= n && (o = a, l = f);
            return t[o]
        },
        Kb = function(e, t, n, i, s, a, o) {
            if (e.end === "auto") return e;
            var l = e.end,
                c, f;
            if (n = isNaN(n) ? ao : n, i = isNaN(i) ? -1e10 : i, ds(t)) {
                if (c = t.calculated ? t : (zd(l) ? l(t, o) : Yb(t, l, n, i, a)) || t, !t.calculated) {
                    for (f in c) t[f] = c[f];
                    t.calculated = !0
                }
                c = c[s]
            } else c = zd(l) ? l(t, o) : Xb(l) ? Yb(t, l, n, i, a) : parseFloat(l);
            return c > n ? c = n : c < i && (c = i), {
                max: c,
                min: c,
                unitFactor: e.unitFactor
            }
        },
        hu = function(e, t, n) {
            return isNaN(e[t]) ? n : +e[t]
        },
        Gd = function(e, t) {
            return t * qb * e / Bd
        },
        $b = function(e, t, n) {
            return Math.abs((t - e) * Bd / n / qb)
        },
        Jb = {
            resistance: 1,
            checkpoint: 1,
            preventOvershoot: 1,
            linkedProps: 1,
            radius: 1,
            duration: 1
        },
        Zb = function(e, t, n, i) {
            if (t.linkedProps) {
                var s = t.linkedProps.split(","),
                    a = {},
                    o, l, c, f, h, d;
                for (o = 0; o < s.length; o++) l = s[o], c = t[l], c && (Al(c.velocity) ? f = c.velocity : (h = h || fu(e), f = h && h.isTracking(l) ? h.get(l) : 0), d = Math.abs(f / hu(c, "resistance", i)), a[l] = parseFloat(n(e, l)) + Gd(f, d));
                return a
            }
        },
        Uw = function(e, t, n, i, s, a) {
            if (n === void 0 && (n = 10), i === void 0 && (i = .2), s === void 0 && (s = 1), Pw(e) && (e = Bb(e)[0]), !e) return 0;
            var o = 0,
                l = ao,
                c = t.inertia || t,
                f = Gb(e).get,
                h = hu(c, "resistance", El.resistance),
                d, u, _, m, g, p, v, x, b, M;
            M = Zb(e, c, f, h);
            for (d in c) Jb[d] || (u = c[d], ds(u) || (x = x || fu(e), x && x.isTracking(d) ? u = Al(u) ? {
                velocity: u
            } : {
                velocity: x.get(d)
            } : (m = +u || 0, _ = Math.abs(m / h))), ds(u) && (Al(u.velocity) ? m = u.velocity : (x = x || fu(e), m = x && x.isTracking(d) ? x.get(d) : 0), _ = Hb(i, n, Math.abs(m / hu(u, "resistance", h))), g = parseFloat(f(e, d)) || 0, p = g + Gd(m, _), "end" in u && (u = Kb(u, M && d in M ? M : p, u.max, u.min, d, c.radius, m), Dl === t && (Dl = c = Ow(t)), c[d] = Nw(u, c[d], "end")), "max" in u && p > +u.max + jb ? (b = u.unitFactor || El.unitFactors[d] || 1, v = g > u.max && u.min !== u.max || m * b > -15 && m * b < 45 ? i + (n - i) * .1 : $b(g, u.max, m), v + s < l && (l = v + s)) : "min" in u && p < +u.min - jb && (b = u.unitFactor || El.unitFactors[d] || 1, v = g < u.min && u.min !== u.max || m * b > -45 && m * b < 15 ? i + (n - i) * .1 : $b(g, u.min, m), v + s < l && (l = v + s)), v > o && (o = v)), _ > o && (o = _));
            return o > l && (o = l), o > n ? n : o < i ? i : o
        },
        Qb = function() {
            on = Wb(), on && (Ub = on.parseEase, Bb = on.utils.toArray, kb = on.utils.getUnit, Gb = on.core.getCache, Hb = on.utils.clamp, kd = on.core.getStyleSaver, Vb = on.core.reverting || function() {}, Ud = Ub("power3"), Bd = Ud(.05), zb = on.core.PropTween, on.config({
                resistance: 100,
                unitFactors: {
                    time: 1e3,
                    totalTime: 1e3,
                    progress: 1e3,
                    totalProgress: 1e3
                }
            }), El = on.config(), on.registerPlugin(Tl), Ob = 1)
        },
        Hd = {
            version: "3.12.5",
            name: "inertia",
            register: function(e) {
                on = e, Qb()
            },
            init: function(e, t, n, i, s) {
                Ob || Qb();
                var a = fu(e);
                if (t === "auto") {
                    if (!a) {
                        console.warn("No inertia tracking on " + e + ". InertiaPlugin.track(target) first.");
                        return
                    }
                    t = a.getAll()
                }
                this.styles = kd && typeof e.style == "object" && kd(e), this.target = e, this.tween = n, Dl = t;
                var o = e._gsap,
                    l = o.get,
                    c = t.duration,
                    f = ds(c),
                    h = t.preventOvershoot || f && c.overshoot === 0,
                    d = hu(t, "resistance", El.resistance),
                    u = Al(c) ? c : Uw(e, t, f && c.max || 10, f && c.min || .2, f && "overshoot" in c ? +c.overshoot : h ? 0 : 1),
                    _, m, g, p, v, x, b, M, D;
                t = Dl, Dl = 0, D = Zb(e, t, l, d);
                for (_ in t) Jb[_] || (m = t[_], zd(m) && (m = m(i, e, s)), Al(m) ? v = m : ds(m) && !isNaN(m.velocity) ? v = +m.velocity : a && a.isTracking(_) ? v = a.get(_) : console.warn("ERROR: No velocity was defined for " + e + " property: " + _), x = Gd(v, u), M = 0, g = l(e, _), p = kb(g), g = parseFloat(g), ds(m) && (b = g + x, "end" in m && (m = Kb(m, D && _ in D ? D : b, m.max, m.min, _, t.radius, v)), "max" in m && +m.max < b ? h || m.preventOvershoot ? x = m.max - g : M = m.max - g - x : "min" in m && +m.min > b && (h || m.preventOvershoot ? x = m.min - g : M = m.min - g - x)), this._props.push(_), this.styles && this.styles.save(_), this._pt = new zb(this._pt, e, _, g, 0, Lw, 0, o.set(e, _, this)), this._pt.u = p || 0, this._pt.c1 = x, this._pt.c2 = M);
                return n.duration(u), Fw
            },
            render: function(e, t) {
                var n = t._pt;
                if (e = Ud(t.tween._time / t.tween._dur), e || !Vb())
                    for (; n;) n.set(n.t, n.p, Iw(n.s + n.c1 * e + n.c2 * e * e) + n.u, n.d, e), n = n._next;
                else t.styles.revert()
            }
        };
    "track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(function(r) {
        return Hd[r] = Tl[r]
    }), Wb() && on.registerPlugin(Hd);
    /*!
     * Flip 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Bw = 1,
        oo, wn, Nt, wl, ps, Rr, Vd, e0 = function(e, t) {
            return e.actions.forEach(function(n) {
                return n.vars[t] && n.vars[t](n)
            })
        },
        Wd = {},
        t0 = 180 / Math.PI,
        kw = Math.PI / 180,
        du = {},
        n0 = {},
        pu = {},
        Xd = function(e) {
            return typeof e == "string" ? e.split(" ").join("").split(",") : e
        },
        zw = Xd("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
        mu = Xd("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
        Cl = function(e) {
            return oo(e)[0] || console.warn("Element not found:", e)
        },
        lo = function(e) {
            return Math.round(e * 1e4) / 1e4 || 0
        },
        jd = function(e, t, n) {
            return e.forEach(function(i) {
                return i.classList[n](t)
            })
        },
        i0 = {
            zIndex: 1,
            kill: 1,
            simple: 1,
            spin: 1,
            clearProps: 1,
            targets: 1,
            toggleClass: 1,
            onComplete: 1,
            onUpdate: 1,
            onInterrupt: 1,
            onStart: 1,
            delay: 1,
            repeat: 1,
            repeatDelay: 1,
            yoyo: 1,
            scale: 1,
            fade: 1,
            absolute: 1,
            props: 1,
            onEnter: 1,
            onLeave: 1,
            custom: 1,
            paused: 1,
            nested: 1,
            prune: 1,
            absoluteOnLeave: 1
        },
        r0 = {
            zIndex: 1,
            simple: 1,
            clearProps: 1,
            scale: 1,
            absolute: 1,
            fitChild: 1,
            getVars: 1,
            props: 1
        },
        s0 = function(e) {
            return e.replace(/([A-Z])/g, "-$1").toLowerCase()
        },
        co = function(e, t) {
            var n = {},
                i;
            for (i in e) t[i] || (n[i] = e[i]);
            return n
        },
        qd = {},
        a0 = function(e) {
            var t = qd[e] = Xd(e);
            return pu[e] = t.concat(mu), t
        },
        Gw = function(e) {
            var t = e._gsap || wn.core.getCache(e);
            return t.gmCache === wn.ticker.frame ? t.gMatrix : (t.gmCache = wn.ticker.frame, t.gMatrix = xn(e, !0, !1, !0))
        },
        Hw = function r(e, t, n) {
            n === void 0 && (n = 0);
            for (var i = e.parentNode, s = 1e3 * Math.pow(10, n) * (t ? -1 : 1), a = t ? -s * 900 : 0; e;) a += s, e = e.previousSibling;
            return i ? a + r(i, t, n + 1) : a
        },
        gu = function(e, t, n) {
            return e.forEach(function(i) {
                return i.d = Hw(n ? i.element : i.t, t)
            }), e.sort(function(i, s) {
                return i.d - s.d
            }), e
        },
        Rl = function(e, t) {
            for (var n = e.element.style, i = e.css = e.css || [], s = t.length, a, o; s--;) a = t[s], o = n[a] || n.getPropertyValue(a), i.push(o ? a : n0[a] || (n0[a] = s0(a)), o);
            return n
        },
        _u = function(e) {
            var t = e.css,
                n = e.element.style,
                i = 0;
            for (e.cache.uncache = 1; i < t.length; i += 2) t[i + 1] ? n[t[i]] = t[i + 1] : n.removeProperty(t[i]);
            !t[t.indexOf("transform") + 1] && n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"))
        },
        o0 = function(e, t) {
            e.forEach(function(n) {
                return n.a.cache.uncache = 1
            }), t || e.finalStates.forEach(_u)
        },
        Yd = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
        Kd = function(e, t, n) {
            var i = e.element,
                s = e.width,
                a = e.height,
                o = e.uncache,
                l = e.getProp,
                c = i.style,
                f = 4,
                h, d, u;
            if (typeof t != "object" && (t = e), Nt && n !== 1) return Nt._abs.push({
                t: i,
                b: e,
                a: e,
                sd: 0
            }), Nt._final.push(function() {
                return (e.cache.uncache = 1) && _u(e)
            }), i;
            for (d = l("display") === "none", (!e.isVisible || d) && (d && (Rl(e, ["display"]).display = t.display), e.matrix = t.matrix, e.width = s = e.width || t.width, e.height = a = e.height || t.height), Rl(e, Yd), u = window.getComputedStyle(i); f--;) c[Yd[f]] = u[Yd[f]];
            if (c.gridArea = "1 / 1 / 1 / 1", c.transition = "none", c.position = "absolute", c.width = s + "px", c.height = a + "px", c.top || (c.top = "0px"), c.left || (c.left = "0px"), o) h = new Ks(i);
            else if (h = co(e, du), h.position = "absolute", e.simple) {
                var _ = i.getBoundingClientRect();
                h.matrix = new Dr(1, 0, 0, 1, _.left + _d(), _.top + gd())
            } else h.matrix = xn(i, !1, !1, !0);
            return h = uo(h, e, !0), e.x = Rr(h.x, .01), e.y = Rr(h.y, .01), i
        },
        l0 = function(e, t) {
            return t !== !0 && (t = oo(t), e = e.filter(function(n) {
                if (t.indexOf((n.sd < 0 ? n.b : n.a).element) !== -1) return !0;
                n.t._gsap.renderTransform(1), n.b.isVisible && (n.t.style.width = n.b.width + "px", n.t.style.height = n.b.height + "px")
            })), e
        },
        c0 = function(e) {
            return gu(e, !0).forEach(function(t) {
                return (t.a.isVisible || t.b.isVisible) && Kd(t.sd < 0 ? t.b : t.a, t.b, 1)
            })
        },
        Vw = function(e, t) {
            return t && e.idLookup[$d(t).id] || e.elementStates[0]
        },
        $d = function(e, t, n, i) {
            return e instanceof Ks ? e : e instanceof Gi ? Vw(e, i) : new Ks(typeof e == "string" ? Cl(e) || console.warn(e + " not found") : e, t, n)
        },
        Ww = function(e, t) {
            for (var n = wn.getProperty(e.element, null, "native"), i = e.props = {}, s = t.length; s--;) i[t[s]] = (n(t[s]) + "").trim();
            return i.zIndex && (i.zIndex = parseFloat(i.zIndex) || 0), e
        },
        u0 = function(e, t) {
            var n = e.style || e,
                i;
            for (i in t) n[i] = t[i]
        },
        Xw = function(e) {
            var t = e.getAttribute("data-flip-id");
            return t || e.setAttribute("data-flip-id", t = "auto-" + Bw++), t
        },
        f0 = function(e) {
            return e.map(function(t) {
                return t.element
            })
        },
        h0 = function(e, t, n) {
            return e && t.length && n.add(e(f0(t), n, new Gi(t, 0, !0)), 0)
        },
        uo = function(e, t, n, i, s, a) {
            var o = e.element,
                l = e.cache,
                c = e.parent,
                f = e.x,
                h = e.y,
                d = t.width,
                u = t.height,
                _ = t.scaleX,
                m = t.scaleY,
                g = t.rotation,
                p = t.bounds,
                v = a && Vd && Vd(o, "transform"),
                x = e,
                b = t.matrix,
                M = b.e,
                D = b.f,
                T = e.bounds.width !== p.width || e.bounds.height !== p.height || e.scaleX !== _ || e.scaleY !== m || e.rotation !== g,
                w = !T && e.simple && t.simple && !s,
                S, y, C, O, N, V, G;
            return w || !c ? (_ = m = 1, g = S = 0) : (N = Gw(c), V = N.clone().multiply(t.ctm ? t.matrix.clone().multiply(t.ctm) : t.matrix), g = lo(Math.atan2(V.b, V.a) * t0), S = lo(Math.atan2(V.c, V.d) * t0 + g) % 360, _ = Math.sqrt(Math.pow(V.a, 2) + Math.pow(V.b, 2)), m = Math.sqrt(Math.pow(V.c, 2) + Math.pow(V.d, 2)) * Math.cos(S * kw), s && (s = oo(s)[0], O = wn.getProperty(s), G = s.getBBox && typeof s.getBBox == "function" && s.getBBox(), x = {
                scaleX: O("scaleX"),
                scaleY: O("scaleY"),
                width: G ? G.width : Math.ceil(parseFloat(O("width", "px"))),
                height: G ? G.height : parseFloat(O("height", "px"))
            }), l.rotation = g + "deg", l.skewX = S + "deg"), n ? (_ *= d === x.width || !x.width ? 1 : d / x.width, m *= u === x.height || !x.height ? 1 : u / x.height, l.scaleX = _, l.scaleY = m) : (d = Rr(d * _ / x.scaleX, 0), u = Rr(u * m / x.scaleY, 0), o.style.width = d + "px", o.style.height = u + "px"), i && u0(o, t.props), w || !c ? (f += M - e.matrix.e, h += D - e.matrix.f) : T || c !== t.parent ? (l.renderTransform(1, l), V = xn(s || o, !1, !1, !0), y = N.apply({
                x: V.e,
                y: V.f
            }), C = N.apply({
                x: M,
                y: D
            }), f += C.x - y.x, h += C.y - y.y) : (N.e = N.f = 0, C = N.apply({
                x: M - e.matrix.e,
                y: D - e.matrix.f
            }), f += C.x, h += C.y), f = Rr(f, .02), h = Rr(h, .02), a && !(a instanceof Ks) ? v && v.revert() : (l.x = f + "px", l.y = h + "px", l.renderTransform(1, l)), a && (a.x = f, a.y = h, a.rotation = g, a.skewX = S, n ? (a.scaleX = _, a.scaleY = m) : (a.width = d, a.height = u)), a || l
        },
        Jd = function(e, t) {
            return e instanceof Gi ? e : new Gi(e, t)
        },
        d0 = function(e, t, n) {
            var i = e.idLookup[n],
                s = e.alt[n];
            return s.isVisible && (!(t.getElementState(s.element) || s).isVisible || !i.isVisible) ? s : i
        },
        Zd = [],
        Qd = "width,height,overflowX,overflowY".split(","),
        bu, p0 = function(e) {
            if (e !== bu) {
                var t = ps.style,
                    n = ps.clientWidth === window.outerWidth,
                    i = ps.clientHeight === window.outerHeight,
                    s = 4;
                if (e && (n || i)) {
                    for (; s--;) Zd[s] = t[Qd[s]];
                    n && (t.width = ps.clientWidth + "px", t.overflowY = "hidden"), i && (t.height = ps.clientHeight + "px", t.overflowX = "hidden"), bu = e
                } else if (bu) {
                    for (; s--;) Zd[s] ? t[Qd[s]] = Zd[s] : t.removeProperty(s0(Qd[s]));
                    bu = e
                }
            }
        },
        ep = function(e, t, n, i) {
            e instanceof Gi && t instanceof Gi || console.warn("Not a valid state object."), n = n || {};
            var s = n,
                a = s.clearProps,
                o = s.onEnter,
                l = s.onLeave,
                c = s.absolute,
                f = s.absoluteOnLeave,
                h = s.custom,
                d = s.delay,
                u = s.paused,
                _ = s.repeat,
                m = s.repeatDelay,
                g = s.yoyo,
                p = s.toggleClass,
                v = s.nested,
                x = s.zIndex,
                b = s.scale,
                M = s.fade,
                D = s.stagger,
                T = s.spin,
                w = s.prune,
                S = ("props" in n ? n : e).props,
                y = co(n, i0),
                C = wn.timeline({
                    delay: d,
                    paused: u,
                    repeat: _,
                    repeatDelay: m,
                    yoyo: g,
                    data: "isFlip"
                }),
                O = y,
                N = [],
                V = [],
                G = [],
                B = [],
                j = T === !0 ? 1 : T || 0,
                H = typeof T == "function" ? T : function() {
                    return j
                },
                k = e.interrupted || t.interrupted,
                F = C[i !== 1 ? "to" : "from"],
                se, de, ke, q, ee, he, fe, be, Ye, Pe, Xe, tt, xe, R;
            for (de in t.idLookup) Xe = t.alt[de] ? d0(t, e, de) : t.idLookup[de], ee = Xe.element, Pe = e.idLookup[de], e.alt[de] && ee === Pe.element && (e.alt[de].isVisible || !Xe.isVisible) && (Pe = e.alt[de]), Pe ? (he = {
                t: ee,
                b: Pe,
                a: Xe,
                sd: Pe.element === ee ? 0 : Xe.isVisible ? 1 : -1
            }, G.push(he), he.sd && (he.sd < 0 && (he.b = Xe, he.a = Pe), k && Rl(he.b, S ? pu[S] : mu), M && G.push(he.swap = {
                t: Pe.element,
                b: he.b,
                a: he.a,
                sd: -he.sd,
                swap: he
            })), ee._flip = Pe.element._flip = Nt ? Nt.timeline : C) : Xe.isVisible && (G.push({
                t: ee,
                b: co(Xe, {
                    isVisible: 1
                }),
                a: Xe,
                sd: 0,
                entering: 1
            }), ee._flip = Nt ? Nt.timeline : C);
            if (S && (qd[S] || a0(S)).forEach(function(X) {
                    return y[X] = function(ve) {
                        return G[ve].a.props[X]
                    }
                }), G.finalStates = Ye = [], tt = function() {
                    for (gu(G), p0(!0), q = 0; q < G.length; q++) he = G[q], xe = he.a, R = he.b, w && !xe.isDifferent(R) && !he.entering ? G.splice(q--, 1) : (ee = he.t, v && !(he.sd < 0) && q && (xe.matrix = xn(ee, !1, !1, !0)), R.isVisible && xe.isVisible ? (he.sd < 0 ? (fe = new Ks(ee, S, e.simple), uo(fe, xe, b, 0, 0, fe), fe.matrix = xn(ee, !1, !1, !0), fe.css = he.b.css, he.a = xe = fe, M && (ee.style.opacity = k ? R.opacity : xe.opacity), D && B.push(ee)) : he.sd > 0 && M && (ee.style.opacity = k ? xe.opacity - R.opacity : "0"), uo(xe, R, b, S)) : R.isVisible !== xe.isVisible && (R.isVisible ? xe.isVisible || (R.css = xe.css, V.push(R), G.splice(q--, 1), c && v && uo(xe, R, b, S)) : (xe.isVisible && N.push(xe), G.splice(q--, 1))), b || (ee.style.maxWidth = Math.max(xe.width, R.width) + "px", ee.style.maxHeight = Math.max(xe.height, R.height) + "px", ee.style.minWidth = Math.min(xe.width, R.width) + "px", ee.style.minHeight = Math.min(xe.height, R.height) + "px"), v && p && ee.classList.add(p)), Ye.push(xe);
                    var ve;
                    if (p && (ve = Ye.map(function(ge) {
                            return ge.element
                        }), v && ve.forEach(function(ge) {
                            return ge.classList.remove(p)
                        })), p0(!1), b ? (y.scaleX = function(ge) {
                            return G[ge].a.scaleX
                        }, y.scaleY = function(ge) {
                            return G[ge].a.scaleY
                        }) : (y.width = function(ge) {
                            return G[ge].a.width + "px"
                        }, y.height = function(ge) {
                            return G[ge].a.height + "px"
                        }, y.autoRound = n.autoRound || !1), y.x = function(ge) {
                            return G[ge].a.x + "px"
                        }, y.y = function(ge) {
                            return G[ge].a.y + "px"
                        }, y.rotation = function(ge) {
                            return G[ge].a.rotation + (T ? H(ge, be[ge], be) * 360 : 0)
                        }, y.skewX = function(ge) {
                            return G[ge].a.skewX
                        }, be = G.map(function(ge) {
                            return ge.t
                        }), (x || x === 0) && (y.modifiers = {
                            zIndex: function() {
                                return x
                            }
                        }, y.zIndex = x, y.immediateRender = n.immediateRender !== !1), M && (y.opacity = function(ge) {
                            return G[ge].sd < 0 ? 0 : G[ge].sd > 0 ? G[ge].a.opacity : "+=0"
                        }), B.length) {
                        D = wn.utils.distribute(D);
                        var Qe = be.slice(B.length);
                        y.stagger = function(ge, rt) {
                            return D(~B.indexOf(rt) ? be.indexOf(G[ge].swap.t) : ge, rt, Qe)
                        }
                    }
                    if (zw.forEach(function(ge) {
                            return n[ge] && C.eventCallback(ge, n[ge], n[ge + "Params"])
                        }), h && be.length) {
                        O = co(y, i0), "scale" in h && (h.scaleX = h.scaleY = h.scale, delete h.scale);
                        for (de in h) se = co(h[de], r0), se[de] = y[de], !("duration" in se) && "duration" in y && (se.duration = y.duration), se.stagger = y.stagger, F.call(C, be, se, 0), delete O[de]
                    }(be.length || V.length || N.length) && (p && C.add(function() {
                        return jd(ve, p, C._zTime < 0 ? "remove" : "add")
                    }, 0) && !u && jd(ve, p, "add"), be.length && F.call(C, be, O, 0)), h0(o, N, C), h0(l, V, C);
                    var Ie = Nt && Nt.timeline;
                    Ie && (Ie.add(C, 0), Nt._final.push(function() {
                        return o0(G, !a)
                    })), ke = C.duration(), C.call(function() {
                        var ge = C.time() >= ke;
                        ge && !Ie && o0(G, !a), p && jd(ve, p, ge ? "remove" : "add")
                    })
                }, f && (c = G.filter(function(X) {
                    return !X.sd && !X.a.isVisible && X.b.isVisible
                }).map(function(X) {
                    return X.a.element
                })), Nt) {
                var Ge;
                c && (Ge = Nt._abs).push.apply(Ge, l0(G, c)), Nt._run.push(tt)
            } else c && c0(l0(G, c)), tt();
            var $e = Nt ? Nt.timeline : C;
            return $e.revert = function() {
                return tp($e, 1, 1)
            }, $e
        },
        jw = function r(e) {
            e.vars.onInterrupt && e.vars.onInterrupt.apply(e, e.vars.onInterruptParams || []), e.getChildren(!0, !1, !0).forEach(r)
        },
        tp = function(e, t, n) {
            if (e && e.progress() < 1 && (!e.paused() || n)) return t && (jw(e), t < 2 && e.progress(1), e.kill()), !0
        },
        xu = function(e) {
            for (var t = e.idLookup = {}, n = e.alt = {}, i = e.elementStates, s = i.length, a; s--;) a = i[s], t[a.id] ? n[a.id] = a : t[a.id] = a
        },
        Gi = function() {
            function r(t, n, i) {
                if (this.props = n && n.props, this.simple = !!(n && n.simple), i) this.targets = f0(t), this.elementStates = t, xu(this);
                else {
                    this.targets = oo(t);
                    var s = n && (n.kill === !1 || n.batch && !n.kill);
                    Nt && !s && Nt._kill.push(this), this.update(s || !!Nt)
                }
            }
            var e = r.prototype;
            return e.update = function(n) {
                var i = this;
                return this.elementStates = this.targets.map(function(s) {
                    return new Ks(s, i.props, i.simple)
                }), xu(this), this.interrupt(n), this.recordInlineStyles(), this
            }, e.clear = function() {
                return this.targets.length = this.elementStates.length = 0, xu(this), this
            }, e.fit = function(n, i, s) {
                for (var a = gu(this.elementStates.slice(0), !1, !0), o = (n || this).idLookup, l = 0, c, f; l < a.length; l++) c = a[l], s && (c.matrix = xn(c.element, !1, !1, !0)), f = o[c.id], f && uo(c, f, i, !0, 0, c), c.matrix = xn(c.element, !1, !1, !0);
                return this
            }, e.getProperty = function(n, i) {
                var s = this.getElementState(n) || du;
                return (i in s ? s : s.props || du)[i]
            }, e.add = function(n) {
                for (var i = n.targets.length, s = this.idLookup, a = this.alt, o, l, c; i--;) l = n.elementStates[i], c = s[l.id], c && (l.element === c.element || a[l.id] && a[l.id].element === l.element) ? (o = this.elementStates.indexOf(l.element === c.element ? c : a[l.id]), this.targets.splice(o, 1, n.targets[i]), this.elementStates.splice(o, 1, l)) : (this.targets.push(n.targets[i]), this.elementStates.push(l));
                return n.interrupted && (this.interrupted = !0), n.simple || (this.simple = !1), xu(this), this
            }, e.compare = function(n) {
                var i = n.idLookup,
                    s = this.idLookup,
                    a = [],
                    o = [],
                    l = [],
                    c = [],
                    f = [],
                    h = n.alt,
                    d = this.alt,
                    u = function(w, S, y) {
                        return (w.isVisible !== S.isVisible ? w.isVisible ? l : c : w.isVisible ? o : a).push(y) && f.push(y)
                    },
                    _ = function(w, S, y) {
                        return f.indexOf(y) < 0 && u(w, S, y)
                    },
                    m, g, p, v, x, b, M, D;
                for (p in i) x = h[p], b = d[p], m = x ? d0(n, this, p) : i[p], v = m.element, g = s[p], b ? (D = g.isVisible || !b.isVisible && v === g.element ? g : b, M = x && !m.isVisible && !x.isVisible && D.element === x.element ? x : m, M.isVisible && D.isVisible && M.element !== D.element ? ((M.isDifferent(D) ? o : a).push(M.element, D.element), f.push(M.element, D.element)) : u(M, D, M.element), x && M.element === x.element && (x = i[p]), _(M.element !== g.element && x ? x : M, g, g.element), _(x && x.element === b.element ? x : M, b, b.element), x && _(x, b.element === x.element ? b : g, x.element)) : (g ? g.isDifferent(m) ? u(m, g, v) : a.push(v) : l.push(v), x && _(x, g, x.element));
                for (p in s) i[p] || (c.push(s[p].element), d[p] && c.push(d[p].element));
                return {
                    changed: o,
                    unchanged: a,
                    enter: l,
                    leave: c
                }
            }, e.recordInlineStyles = function() {
                for (var n = pu[this.props] || mu, i = this.elementStates.length; i--;) Rl(this.elementStates[i], n)
            }, e.interrupt = function(n) {
                var i = this,
                    s = [];
                this.targets.forEach(function(a) {
                    var o = a._flip,
                        l = tp(o, n ? 0 : 1);
                    n && l && s.indexOf(o) < 0 && o.add(function() {
                        return i.updateVisibility()
                    }), l && s.push(o)
                }), !n && s.length && this.updateVisibility(), this.interrupted || (this.interrupted = !!s.length)
            }, e.updateVisibility = function() {
                this.elementStates.forEach(function(n) {
                    var i = n.element.getBoundingClientRect();
                    n.isVisible = !!(i.width || i.height || i.top || i.left), n.uncache = 1
                })
            }, e.getElementState = function(n) {
                return this.elementStates[this.targets.indexOf(Cl(n))]
            }, e.makeAbsolute = function() {
                return gu(this.elementStates.slice(0), !0, !0).map(Kd)
            }, r
        }(),
        Ks = function() {
            function r(t, n, i) {
                this.element = t, this.update(n, i)
            }
            var e = r.prototype;
            return e.isDifferent = function(n) {
                var i = this.bounds,
                    s = n.bounds;
                return i.top !== s.top || i.left !== s.left || i.width !== s.width || i.height !== s.height || !this.matrix.equals(n.matrix) || this.opacity !== n.opacity || this.props && n.props && JSON.stringify(this.props) !== JSON.stringify(n.props)
            }, e.update = function(n, i) {
                var s = this,
                    a = s.element,
                    o = wn.getProperty(a),
                    l = wn.core.getCache(a),
                    c = a.getBoundingClientRect(),
                    f = a.getBBox && typeof a.getBBox == "function" && a.nodeName.toLowerCase() !== "svg" && a.getBBox(),
                    h = i ? new Dr(1, 0, 0, 1, c.left + _d(), c.top + gd()) : xn(a, !1, !1, !0);
                s.getProp = o, s.element = a, s.id = Xw(a), s.matrix = h, s.cache = l, s.bounds = c, s.isVisible = !!(c.width || c.height || c.left || c.top), s.display = o("display"), s.position = o("position"), s.parent = a.parentNode, s.x = o("x"), s.y = o("y"), s.scaleX = l.scaleX, s.scaleY = l.scaleY, s.rotation = o("rotation"), s.skewX = o("skewX"), s.opacity = o("opacity"), s.width = f ? f.width : Rr(o("width", "px"), .04), s.height = f ? f.height : Rr(o("height", "px"), .04), n && Ww(s, qd[n] || a0(n)), s.ctm = a.getCTM && a.nodeName.toLowerCase() === "svg" && db(a).inverse(), s.simple = i || lo(h.a) === 1 && !lo(h.b) && !lo(h.c) && lo(h.d) === 1, s.uncache = 0
            }, r
        }(),
        qw = function() {
            function r(t, n) {
                this.vars = t, this.batch = n, this.states = [], this.timeline = n.timeline
            }
            var e = r.prototype;
            return e.getStateById = function(n) {
                for (var i = this.states.length; i--;)
                    if (this.states[i].idLookup[n]) return this.states[i]
            }, e.kill = function() {
                this.batch.remove(this)
            }, r
        }(),
        Yw = function() {
            function r(t) {
                this.id = t, this.actions = [], this._kill = [], this._final = [], this._abs = [], this._run = [], this.data = {}, this.state = new Gi, this.timeline = wn.timeline()
            }
            var e = r.prototype;
            return e.add = function(n) {
                var i = this.actions.filter(function(s) {
                    return s.vars === n
                });
                return i.length ? i[0] : (i = new qw(typeof n == "function" ? {
                    animate: n
                } : n, this), this.actions.push(i), i)
            }, e.remove = function(n) {
                var i = this.actions.indexOf(n);
                return i >= 0 && this.actions.splice(i, 1), this
            }, e.getState = function(n) {
                var i = this,
                    s = Nt,
                    a = wl;
                return Nt = this, this.state.clear(), this._kill.length = 0, this.actions.forEach(function(o) {
                    o.vars.getState && (o.states.length = 0, wl = o, o.state = o.vars.getState(o)), n && o.states.forEach(function(l) {
                        return i.state.add(l)
                    })
                }), wl = a, Nt = s, this.killConflicts(), this
            }, e.animate = function() {
                var n = this,
                    i = Nt,
                    s = this.timeline,
                    a = this.actions.length,
                    o, l;
                for (Nt = this, s.clear(), this._abs.length = this._final.length = this._run.length = 0, this.actions.forEach(function(c) {
                        c.vars.animate && c.vars.animate(c);
                        var f = c.vars.onEnter,
                            h = c.vars.onLeave,
                            d = c.targets,
                            u, _;
                        d && d.length && (f || h) && (u = new Gi, c.states.forEach(function(m) {
                            return u.add(m)
                        }), _ = u.compare(Pl.getState(d)), _.enter.length && f && f(_.enter), _.leave.length && h && h(_.leave))
                    }), c0(this._abs), this._run.forEach(function(c) {
                        return c()
                    }), l = s.duration(), o = this._final.slice(0), s.add(function() {
                        l <= s.time() && (o.forEach(function(c) {
                            return c()
                        }), e0(n, "onComplete"))
                    }), Nt = i; a--;) this.actions[a].vars.once && this.actions[a].kill();
                return e0(this, "onStart"), s.restart(), this
            }, e.loadState = function(n) {
                n || (n = function() {
                    return 0
                });
                var i = [];
                return this.actions.forEach(function(s) {
                    if (s.vars.loadState) {
                        var a, o = function l(c) {
                            c && (s.targets = c), a = i.indexOf(l), ~a && (i.splice(a, 1), i.length || n())
                        };
                        i.push(o), s.vars.loadState(o)
                    }
                }), i.length || n(), this
            }, e.setState = function() {
                return this.actions.forEach(function(n) {
                    return n.targets = n.vars.setState && n.vars.setState(n)
                }), this
            }, e.killConflicts = function(n) {
                return this.state.interrupt(n), this._kill.forEach(function(i) {
                    return i.interrupt(n)
                }), this
            }, e.run = function(n, i) {
                var s = this;
                return this !== Nt && (n || this.getState(i), this.loadState(function() {
                    s._killed || (s.setState(), s.animate())
                })), this
            }, e.clear = function(n) {
                this.state.clear(), n || (this.actions.length = 0)
            }, e.getStateById = function(n) {
                for (var i = this.actions.length, s; i--;)
                    if (s = this.actions[i].getStateById(n), s) return s;
                return this.state.idLookup[n] && this.state
            }, e.kill = function() {
                this._killed = 1, this.clear(), delete Wd[this.id]
            }, r
        }(),
        Pl = function() {
            function r() {}
            return r.getState = function(t, n) {
                var i = Jd(t, n);
                return wl && wl.states.push(i), n && n.batch && r.batch(n.batch).state.add(i), i
            }, r.from = function(t, n) {
                return n = n || {}, "clearProps" in n || (n.clearProps = !0), ep(t, Jd(n.targets || t.targets, {
                    props: n.props || t.props,
                    simple: n.simple,
                    kill: !!n.kill
                }), n, -1)
            }, r.to = function(t, n) {
                return ep(t, Jd(n.targets || t.targets, {
                    props: n.props || t.props,
                    simple: n.simple,
                    kill: !!n.kill
                }), n, 1)
            }, r.fromTo = function(t, n, i) {
                return ep(t, n, i)
            }, r.fit = function(t, n, i) {
                var s = i ? co(i, r0) : {},
                    a = i || s,
                    o = a.absolute,
                    l = a.scale,
                    c = a.getVars,
                    f = a.props,
                    h = a.runBackwards,
                    d = a.onComplete,
                    u = a.simple,
                    _ = i && i.fitChild && Cl(i.fitChild),
                    m = $d(n, f, u, t),
                    g = $d(t, 0, u, m),
                    p = f ? pu[f] : mu,
                    v = wn.context();
                return f && u0(s, m.props), Rl(g, p), h && ("immediateRender" in s || (s.immediateRender = !0), s.onComplete = function() {
                    _u(g), d && d.apply(this, arguments)
                }), o && Kd(g, m), s = uo(g, m, l || _, f, _, s.duration || c ? s : 0), v && !c && v.add(function() {
                    return function() {
                        return _u(g)
                    }
                }), c ? s : s.duration ? wn.to(g.element, s) : null
            }, r.makeAbsolute = function(t, n) {
                return (t instanceof Gi ? t : new Gi(t, n)).makeAbsolute()
            }, r.batch = function(t) {
                return t || (t = "default"), Wd[t] || (Wd[t] = new Yw(t))
            }, r.killFlipsOf = function(t, n) {
                (t instanceof Gi ? t.targets : oo(t)).forEach(function(i) {
                    return i && tp(i._flip, n !== !1 ? 1 : 2)
                })
            }, r.isFlipping = function(t) {
                var n = r.getByTarget(t);
                return !!n && n.isActive()
            }, r.getByTarget = function(t) {
                return (Cl(t) || du)._flip
            }, r.getElementState = function(t, n) {
                return new Ks(Cl(t), n)
            }, r.convertCoordinates = function(t, n, i) {
                var s = xn(n, !0, !0).multiply(xn(t));
                return i ? s.apply(i) : s
            }, r.register = function(t) {
                if (ps = typeof document < "u" && document.body, ps) {
                    wn = t, md(ps), oo = wn.utils.toArray, Vd = wn.core.getStyleSaver;
                    var n = wn.utils.snap(.1);
                    Rr = function(s, a) {
                        return n(parseFloat(s) + a)
                    }
                }
            }, r
        }();
    Pl.version = "3.12.5", typeof window < "u" && window.gsap && window.gsap.registerPlugin(Pl);
    /*!
     * ScrollTrigger 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Be, fo, St, Wt, Hi, Ot, m0, vu, Fl, Ll, Il, yu, Cn, Su, np, kn, g0, _0, ho, b0, ip, x0, zn, rp, v0, y0, ms, sp, ap, po, op, Mu, lp, cp, Tu = 1,
        Rn = Date.now,
        up = Rn(),
        vi = 0,
        Nl = 0,
        S0 = function(e, t, n) {
            var i = li(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
            return n["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e
        },
        M0 = function(e, t) {
            return t && (!li(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
        },
        Kw = function r() {
            return Nl && requestAnimationFrame(r)
        },
        T0 = function() {
            return Su = 1
        },
        E0 = function() {
            return Su = 0
        },
        rr = function(e) {
            return e
        },
        Ol = function(e) {
            return Math.round(e * 1e5) / 1e5 || 0
        },
        D0 = function() {
            return typeof window < "u"
        },
        A0 = function() {
            return Be || D0() && (Be = window.gsap) && Be.registerPlugin && Be
        },
        $s = function(e) {
            return !!~m0.indexOf(e)
        },
        w0 = function(e) {
            return (e === "Height" ? op : St["inner" + e]) || Hi["client" + e] || Ot["client" + e]
        },
        C0 = function(e) {
            return os(e, "getBoundingClientRect") || ($s(e) ? function() {
                return Uu.width = St.innerWidth, Uu.height = op, Uu
            } : function() {
                return Pr(e)
            })
        },
        $w = function(e, t, n) {
            var i = n.d,
                s = n.d2,
                a = n.a;
            return (a = os(e, "getBoundingClientRect")) ? function() {
                return a()[i]
            } : function() {
                return (t ? w0(s) : e["client" + s]) || 0
            }
        },
        Jw = function(e, t) {
            return !t || ~nr.indexOf(e) ? C0(e) : function() {
                return Uu
            }
        },
        sr = function(e, t) {
            var n = t.s,
                i = t.d2,
                s = t.d,
                a = t.a;
            return Math.max(0, (n = "scroll" + i) && (a = os(e, n)) ? a() - C0(e)()[s] : $s(e) ? (Hi[n] || Ot[n]) - w0(i) : e[n] - e["offset" + i])
        },
        Eu = function(e, t) {
            for (var n = 0; n < ho.length; n += 3)(!t || ~t.indexOf(ho[n + 1])) && e(ho[n], ho[n + 1], ho[n + 2])
        },
        li = function(e) {
            return typeof e == "string"
        },
        Gn = function(e) {
            return typeof e == "function"
        },
        Ul = function(e) {
            return typeof e == "number"
        },
        Js = function(e) {
            return typeof e == "object"
        },
        Bl = function(e, t, n) {
            return e && e.progress(t ? 0 : 1) && n && e.pause()
        },
        fp = function(e, t) {
            if (e.enabled) {
                var n = e._ctx ? e._ctx.add(function() {
                    return t(e)
                }) : t(e);
                n && n.totalTime && (e.callbackAnimation = n)
            }
        },
        mo = Math.abs,
        R0 = "left",
        P0 = "top",
        hp = "right",
        dp = "bottom",
        Zs = "width",
        Qs = "height",
        kl = "Right",
        zl = "Left",
        Gl = "Top",
        Hl = "Bottom",
        en = "padding",
        yi = "margin",
        go = "Width",
        pp = "Height",
        ln = "px",
        Si = function(e) {
            return St.getComputedStyle(e)
        },
        Zw = function(e) {
            var t = Si(e).position;
            e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
        },
        F0 = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        Pr = function(e, t) {
            var n = t && Si(e)[np] !== "matrix(1, 0, 0, 1, 0, 0)" && Be.to(e, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1),
                i = e.getBoundingClientRect();
            return n && n.progress(0).kill(), i
        },
        Du = function(e, t) {
            var n = t.d2;
            return e["offset" + n] || e["client" + n] || 0
        },
        L0 = function(e) {
            var t = [],
                n = e.labels,
                i = e.duration(),
                s;
            for (s in n) t.push(n[s] / i);
            return t
        },
        Qw = function(e) {
            return function(t) {
                return Be.utils.snap(L0(e), t)
            }
        },
        mp = function(e) {
            var t = Be.utils.snap(e),
                n = Array.isArray(e) && e.slice(0).sort(function(i, s) {
                    return i - s
                });
            return n ? function(i, s, a) {
                a === void 0 && (a = .001);
                var o;
                if (!s) return t(i);
                if (s > 0) {
                    for (i -= a, o = 0; o < n.length; o++)
                        if (n[o] >= i) return n[o];
                    return n[o - 1]
                } else
                    for (o = n.length, i += a; o--;)
                        if (n[o] <= i) return n[o];
                return n[0]
            } : function(i, s, a) {
                a === void 0 && (a = .001);
                var o = t(i);
                return !s || Math.abs(o - i) < a || o - i < 0 == s < 0 ? o : t(s < 0 ? i - e : i + e)
            }
        },
        eC = function(e) {
            return function(t, n) {
                return mp(L0(e))(t, n.direction)
            }
        },
        Au = function(e, t, n, i) {
            return n.split(",").forEach(function(s) {
                return e(t, s, i)
            })
        },
        mn = function(e, t, n, i, s) {
            return e.addEventListener(t, n, {
                passive: !i,
                capture: !!s
            })
        },
        gn = function(e, t, n, i) {
            return e.removeEventListener(t, n, !!i)
        },
        wu = function(e, t, n) {
            n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n))
        },
        I0 = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        },
        Cu = {
            toggleActions: "play",
            anticipatePin: 0
        },
        Ru = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        },
        Pu = function(e, t) {
            if (li(e)) {
                var n = e.indexOf("="),
                    i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
                ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in Ru ? Ru[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
            }
            return e
        },
        Fu = function(e, t, n, i, s, a, o, l) {
            var c = s.startColor,
                f = s.endColor,
                h = s.fontSize,
                d = s.indent,
                u = s.fontWeight,
                _ = Wt.createElement("div"),
                m = $s(n) || os(n, "pinType") === "fixed",
                g = e.indexOf("scroller") !== -1,
                p = m ? Ot : n,
                v = e.indexOf("start") !== -1,
                x = v ? c : f,
                b = "border-color:" + x + ";font-size:" + h + ";color:" + x + ";font-weight:" + u + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return b += "position:" + ((g || l) && m ? "fixed;" : "absolute;"), (g || l || !m) && (b += (i === sn ? hp : dp) + ":" + (a + parseFloat(d)) + "px;"), o && (b += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), _._isStart = v, _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), _.style.cssText = b, _.innerText = t || t === 0 ? e + "-" + t : e, p.children[0] ? p.insertBefore(_, p.children[0]) : p.appendChild(_), _._offset = _["offset" + i.op.d2], Lu(_, 0, i, v), _
        },
        Lu = function(e, t, n, i) {
            var s = {
                    display: "block"
                },
                a = n[i ? "os2" : "p2"],
                o = n[i ? "p2" : "os2"];
            e._isFlipped = i, s[n.a + "Percent"] = i ? -100 : 0, s[n.a] = i ? "1px" : 0, s["border" + a + go] = 1, s["border" + o + go] = 0, s[n.p] = t + "px", Be.set(e, s)
        },
        ft = [],
        gp = {},
        Vl, N0 = function() {
            return Rn() - vi > 34 && (Vl || (Vl = requestAnimationFrame(Fr)))
        },
        _o = function() {
            (!zn || !zn.isPressed || zn.startX > Ot.clientWidth) && (gt.cache++, zn ? Vl || (Vl = requestAnimationFrame(Fr)) : Fr(), vi || ta("scrollStart"), vi = Rn())
        },
        _p = function() {
            y0 = St.innerWidth, v0 = St.innerHeight
        },
        Wl = function() {
            gt.cache++, !Cn && !x0 && !Wt.fullscreenElement && !Wt.webkitFullscreenElement && (!rp || y0 !== St.innerWidth || Math.abs(St.innerHeight - v0) > St.innerHeight * .25) && vu.restart(!0)
        },
        ea = {},
        tC = [],
        O0 = function r() {
            return gn(ht, "scrollEnd", r) || ia(!0)
        },
        ta = function(e) {
            return ea[e] && ea[e].map(function(t) {
                return t()
            }) || tC
        },
        ci = [],
        U0 = function(e) {
            for (var t = 0; t < ci.length; t += 5)(!e || ci[t + 4] && ci[t + 4].query === e) && (ci[t].style.cssText = ci[t + 1], ci[t].getBBox && ci[t].setAttribute("transform", ci[t + 2] || ""), ci[t + 3].uncache = 1)
        },
        bp = function(e, t) {
            var n;
            for (kn = 0; kn < ft.length; kn++) n = ft[kn], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
            Mu = !0, t && U0(t), t || ta("revert")
        },
        B0 = function(e, t) {
            gt.cache++, (t || !Hn) && gt.forEach(function(n) {
                return Gn(n) && n.cacheID++ && (n.rec = 0)
            }), li(e) && (St.history.scrollRestoration = ap = e)
        },
        Hn, na = 0,
        k0, nC = function() {
            if (k0 !== na) {
                var e = k0 = na;
                requestAnimationFrame(function() {
                    return e === na && ia(!0)
                })
            }
        },
        z0 = function() {
            Ot.appendChild(po), op = !zn && po.offsetHeight || St.innerHeight, Ot.removeChild(po)
        },
        G0 = function(e) {
            return Fl(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
                return t.style.display = e ? "none" : "block"
            })
        },
        ia = function(e, t) {
            if (vi && !e && !Mu) {
                mn(ht, "scrollEnd", O0);
                return
            }
            z0(), Hn = ht.isRefreshing = !0, gt.forEach(function(i) {
                return Gn(i) && ++i.cacheID && (i.rec = i())
            });
            var n = ta("refreshInit");
            b0 && ht.sort(), t || bp(), gt.forEach(function(i) {
                Gn(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0))
            }), ft.slice(0).forEach(function(i) {
                return i.refresh()
            }), Mu = !1, ft.forEach(function(i) {
                if (i._subPinOffset && i.pin) {
                    var s = i.vars.horizontal ? "offsetWidth" : "offsetHeight",
                        a = i.pin[s];
                    i.revert(!0, 1), i.adjustPinSpacing(i.pin[s] - a), i.refresh()
                }
            }), lp = 1, G0(!0), ft.forEach(function(i) {
                var s = sr(i.scroller, i._dir),
                    a = i.vars.end === "max" || i._endClamp && i.end > s,
                    o = i._startClamp && i.start >= s;
                (a || o) && i.setPositions(o ? s - 1 : i.start, a ? Math.max(o ? s : i.start + 1, s) : i.end, !0)
            }), G0(!1), lp = 0, n.forEach(function(i) {
                return i && i.render && i.render(-1)
            }), gt.forEach(function(i) {
                Gn(i) && (i.smooth && requestAnimationFrame(function() {
                    return i.target.style.scrollBehavior = "smooth"
                }), i.rec && i(i.rec))
            }), B0(ap, 1), vu.pause(), na++, Hn = 2, Fr(2), ft.forEach(function(i) {
                return Gn(i.vars.onRefresh) && i.vars.onRefresh(i)
            }), Hn = ht.isRefreshing = !1, ta("refresh")
        },
        xp = 0,
        Iu = 1,
        Xl, Fr = function(e) {
            if (e === 2 || !Hn && !Mu) {
                ht.isUpdating = !0, Xl && Xl.update(0);
                var t = ft.length,
                    n = Rn(),
                    i = n - up >= 50,
                    s = t && ft[0].scroll();
                if (Iu = xp > s ? -1 : 1, Hn || (xp = s), i && (vi && !Su && n - vi > 200 && (vi = 0, ta("scrollEnd")), Il = up, up = n), Iu < 0) {
                    for (kn = t; kn-- > 0;) ft[kn] && ft[kn].update(0, i);
                    Iu = 1
                } else
                    for (kn = 0; kn < t; kn++) ft[kn] && ft[kn].update(0, i);
                ht.isUpdating = !1
            }
            Vl = 0
        },
        vp = [R0, P0, dp, hp, yi + Hl, yi + kl, yi + Gl, yi + zl, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        Nu = vp.concat([Zs, Qs, "boxSizing", "max" + go, "max" + pp, "position", yi, en, en + Gl, en + kl, en + Hl, en + zl]),
        iC = function(e, t, n) {
            bo(n);
            var i = e._gsap;
            if (i.spacerIsNative) bo(i.spacerState);
            else if (e._gsap.swappedIn) {
                var s = t.parentNode;
                s && (s.insertBefore(e, t), s.removeChild(t))
            }
            e._gsap.swappedIn = !1
        },
        yp = function(e, t, n, i) {
            if (!e._gsap.swappedIn) {
                for (var s = vp.length, a = t.style, o = e.style, l; s--;) l = vp[s], a[l] = n[l];
                a.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (a.display = "inline-block"), o[dp] = o[hp] = "auto", a.flexBasis = n.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[Zs] = Du(e, Bn) + ln, a[Qs] = Du(e, sn) + ln, a[en] = o[yi] = o[P0] = o[R0] = "0", bo(i), o[Zs] = o["max" + go] = n[Zs], o[Qs] = o["max" + pp] = n[Qs], o[en] = n[en], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
            }
        },
        rC = /([A-Z])/g,
        bo = function(e) {
            if (e) {
                var t = e.t.style,
                    n = e.length,
                    i = 0,
                    s, a;
                for ((e.t._gsap || Be.core.getCache(e.t)).uncache = 1; i < n; i += 2) a = e[i + 1], s = e[i], a ? t[s] = a : t[s] && t.removeProperty(s.replace(rC, "-$1").toLowerCase())
            }
        },
        Ou = function(e) {
            for (var t = Nu.length, n = e.style, i = [], s = 0; s < t; s++) i.push(Nu[s], n[Nu[s]]);
            return i.t = e, i
        },
        sC = function(e, t, n) {
            for (var i = [], s = e.length, a = n ? 8 : 0, o; a < s; a += 2) o = e[a], i.push(o, o in t ? t[o] : e[a + 1]);
            return i.t = e.t, i
        },
        Uu = {
            left: 0,
            top: 0
        },
        H0 = function(e, t, n, i, s, a, o, l, c, f, h, d, u, _) {
            Gn(e) && (e = e(l)), li(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? Pu("0" + e.substr(3), n) : 0));
            var m = u ? u.time() : 0,
                g, p, v;
            if (u && u.seek(0), isNaN(e) || (e = +e), Ul(e)) u && (e = Be.utils.mapRange(u.scrollTrigger.start, u.scrollTrigger.end, 0, d, e)), o && Lu(o, n, i, !0);
            else {
                Gn(t) && (t = t(l));
                var x = (e || "0").split(" "),
                    b, M, D, T;
                v = $n(t, l) || Ot, b = Pr(v) || {}, (!b || !b.left && !b.top) && Si(v).display === "none" && (T = v.style.display, v.style.display = "block", b = Pr(v), T ? v.style.display = T : v.style.removeProperty("display")), M = Pu(x[0], b[i.d]), D = Pu(x[1] || "0", n), e = b[i.p] - c[i.p] - f + M + s - D, o && Lu(o, D, i, n - D < 20 || o._isStart && D > 20), n -= n - D
            }
            if (_ && (l[_] = e || -.001, e < 0 && (e = 0)), a) {
                var w = e + n,
                    S = a._isStart;
                g = "scroll" + i.d2, Lu(a, w, i, S && w > 20 || !S && (h ? Math.max(Ot[g], Hi[g]) : a.parentNode[g]) <= w + 1), h && (c = Pr(o), h && (a.style[i.op.p] = c[i.op.p] - i.op.m - a._offset + ln))
            }
            return u && v && (g = Pr(v), u.seek(d), p = Pr(v), u._caScrollDist = g[i.p] - p[i.p], e = e / u._caScrollDist * d), u && u.seek(m), u ? e : Math.round(e)
        },
        aC = /(webkit|moz|length|cssText|inset)/i,
        V0 = function(e, t, n, i) {
            if (e.parentNode !== t) {
                var s = e.style,
                    a, o;
                if (t === Ot) {
                    e._stOrig = s.cssText, o = Si(e);
                    for (a in o) !+a && !aC.test(a) && o[a] && typeof s[a] == "string" && a !== "0" && (s[a] = o[a]);
                    s.top = n, s.left = i
                } else s.cssText = e._stOrig;
                Be.core.getCache(e).uncache = 1, t.appendChild(e)
            }
        },
        W0 = function(e, t, n) {
            var i = t,
                s = i;
            return function(a) {
                var o = Math.round(e());
                return o !== i && o !== s && Math.abs(o - i) > 3 && Math.abs(o - s) > 3 && (a = o, n && n()), s = i, i = a, a
            }
        },
        Bu = function(e, t, n) {
            var i = {};
            i[t.p] = "+=" + n, Be.set(e, i)
        },
        X0 = function(e, t) {
            var n = ls(e, t),
                i = "_scroll" + t.p2,
                s = function a(o, l, c, f, h) {
                    var d = a.tween,
                        u = l.onComplete,
                        _ = {};
                    c = c || n();
                    var m = W0(n, c, function() {
                        d.kill(), a.tween = 0
                    });
                    return h = f && h || 0, f = f || o - c, d && d.kill(), l[i] = o, l.inherit = !1, l.modifiers = _, _[i] = function() {
                        return m(c + f * d.ratio + h * d.ratio * d.ratio)
                    }, l.onUpdate = function() {
                        gt.cache++, a.tween && Fr()
                    }, l.onComplete = function() {
                        a.tween = 0, u && u.call(d)
                    }, d = a.tween = Be.to(e, l), d
                };
            return e[i] = n, n.wheelHandler = function() {
                return s.tween && s.tween.kill() && (s.tween = 0)
            }, mn(e, "wheel", n.wheelHandler), ht.isTouch && mn(e, "touchmove", n.wheelHandler), s
        },
        ht = function() {
            function r(t, n) {
                fo || r.register(Be) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), sp(this), this.init(t, n)
            }
            var e = r.prototype;
            return e.init = function(n, i) {
                if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Nl) {
                    this.update = this.refresh = this.kill = rr;
                    return
                }
                n = F0(li(n) || Ul(n) || n.nodeType ? {
                    trigger: n
                } : n, Cu);
                var s = n,
                    a = s.onUpdate,
                    o = s.toggleClass,
                    l = s.id,
                    c = s.onToggle,
                    f = s.onRefresh,
                    h = s.scrub,
                    d = s.trigger,
                    u = s.pin,
                    _ = s.pinSpacing,
                    m = s.invalidateOnRefresh,
                    g = s.anticipatePin,
                    p = s.onScrubComplete,
                    v = s.onSnapComplete,
                    x = s.once,
                    b = s.snap,
                    M = s.pinReparent,
                    D = s.pinSpacer,
                    T = s.containerAnimation,
                    w = s.fastScrollEnd,
                    S = s.preventOverlaps,
                    y = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Bn : sn,
                    C = !h && h !== 0,
                    O = $n(n.scroller || St),
                    N = Be.core.getCache(O),
                    V = $s(O),
                    G = ("pinType" in n ? n.pinType : os(O, "pinType") || V && "fixed") === "fixed",
                    B = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
                    j = C && n.toggleActions.split(" "),
                    H = "markers" in n ? n.markers : Cu.markers,
                    k = V ? 0 : parseFloat(Si(O)["border" + y.p2 + go]) || 0,
                    F = this,
                    se = n.onRefreshInit && function() {
                        return n.onRefreshInit(F)
                    },
                    de = $w(O, V, y),
                    ke = Jw(O, V),
                    q = 0,
                    ee = 0,
                    he = 0,
                    fe = ls(O, y),
                    be, Ye, Pe, Xe, tt, xe, R, Ge, $e, X, ve, Qe, Ie, ge, rt, P, E, K, ne, ie, te, Fe, ye, Oe, De, pe, Ae, Ve, He, Se, je, I, Me, oe, Ee, me, le, ae, L;
                if (F._startClamp = F._endClamp = !1, F._dir = y, g *= 45, F.scroller = O, F.scroll = T ? T.time.bind(T) : fe, Xe = fe(), F.vars = n, i = i || n.animation, "refreshPriority" in n && (b0 = 1, n.refreshPriority === -9999 && (Xl = F)), N.tweenScroll = N.tweenScroll || {
                        top: X0(O, sn),
                        left: X0(O, Bn)
                    }, F.tweenTo = be = N.tweenScroll[y.p], F.scrubDuration = function(Q) {
                        Me = Ul(Q) && Q, Me ? I ? I.duration(Q) : I = Be.to(i, {
                            ease: "expo",
                            totalProgress: "+=0",
                            inherit: !1,
                            duration: Me,
                            paused: !0,
                            onComplete: function() {
                                return p && p(F)
                            }
                        }) : (I && I.progress(1).kill(), I = 0)
                    }, i && (i.vars.lazy = !1, i._initted && !F.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), F.animation = i.pause(), i.scrollTrigger = F, F.scrubDuration(h), Se = 0, l || (l = i.vars.id)), b && ((!Js(b) || b.push) && (b = {
                        snapTo: b
                    }), "scrollBehavior" in Ot.style && Be.set(V ? [Ot, Hi] : O, {
                        scrollBehavior: "auto"
                    }), gt.forEach(function(Q) {
                        return Gn(Q) && Q.target === (V ? Wt.scrollingElement || Hi : O) && (Q.smooth = !1)
                    }), Pe = Gn(b.snapTo) ? b.snapTo : b.snapTo === "labels" ? Qw(i) : b.snapTo === "labelsDirectional" ? eC(i) : b.directional !== !1 ? function(Q, Te) {
                        return mp(b.snapTo)(Q, Rn() - ee < 500 ? 0 : Te.direction)
                    } : Be.utils.snap(b.snapTo), oe = b.duration || {
                        min: .1,
                        max: 2
                    }, oe = Js(oe) ? Ll(oe.min, oe.max) : Ll(oe, oe), Ee = Be.delayedCall(b.delay || Me / 2 || .1, function() {
                        var Q = fe(),
                            Te = Rn() - ee < 500,
                            ue = be.tween;
                        if ((Te || Math.abs(F.getVelocity()) < 10) && !ue && !Su && q !== Q) {
                            var we = (Q - xe) / ge,
                                Ke = i && !C ? i.totalProgress() : we,
                                Ue = Te ? 0 : (Ke - je) / (Rn() - Il) * 1e3 || 0,
                                et = Be.utils.clamp(-we, 1 - we, mo(Ue / 2) * Ue / .185),
                                bt = we + (b.inertia === !1 ? 0 : et),
                                _t, ct, ut = b,
                                Et = ut.onStart,
                                nt = ut.onInterrupt,
                                cn = ut.onComplete;
                            if (_t = Pe(bt, F), Ul(_t) || (_t = bt), ct = Math.round(xe + _t * ge), Q <= R && Q >= xe && ct !== Q) {
                                if (ue && !ue._initted && ue.data <= mo(ct - Q)) return;
                                b.inertia === !1 && (et = _t - we), be(ct, {
                                    duration: oe(mo(Math.max(mo(bt - Ke), mo(_t - Ke)) * .185 / Ue / .05 || 0)),
                                    ease: b.ease || "power3",
                                    data: mo(ct - Q),
                                    onInterrupt: function() {
                                        return Ee.restart(!0) && nt && nt(F)
                                    },
                                    onComplete: function() {
                                        F.update(), q = fe(), i && (I ? I.resetTo("totalProgress", _t, i._tTime / i._tDur) : i.progress(_t)), Se = je = i && !C ? i.totalProgress() : F.progress, v && v(F), cn && cn(F)
                                    }
                                }, Q, et * ge, ct - Q - et * ge), Et && Et(F, be.tween)
                            }
                        } else F.isActive && q !== Q && Ee.restart(!0)
                    }).pause()), l && (gp[l] = F), d = F.trigger = $n(d || u !== !0 && u), L = d && d._gsap && d._gsap.stRevert, L && (L = L(F)), u = u === !0 ? d : $n(u), li(o) && (o = {
                        targets: d,
                        className: o
                    }), u && (_ === !1 || _ === yi || (_ = !_ && u.parentNode && u.parentNode.style && Si(u.parentNode).display === "flex" ? !1 : en), F.pin = u, Ye = Be.core.getCache(u), Ye.spacer ? rt = Ye.pinState : (D && (D = $n(D), D && !D.nodeType && (D = D.current || D.nativeElement), Ye.spacerIsNative = !!D, D && (Ye.spacerState = Ou(D))), Ye.spacer = K = D || Wt.createElement("div"), K.classList.add("pin-spacer"), l && K.classList.add("pin-spacer-" + l), Ye.pinState = rt = Ou(u)), n.force3D !== !1 && Be.set(u, {
                        force3D: !0
                    }), F.spacer = K = Ye.spacer, He = Si(u), Oe = He[_ + y.os2], ie = Be.getProperty(u), te = Be.quickSetter(u, y.a, ln), yp(u, K, He), E = Ou(u)), H) {
                    Qe = Js(H) ? F0(H, I0) : I0, X = Fu("scroller-start", l, O, y, Qe, 0), ve = Fu("scroller-end", l, O, y, Qe, 0, X), ne = X["offset" + y.op.d2];
                    var re = $n(os(O, "content") || O);
                    Ge = this.markerStart = Fu("start", l, re, y, Qe, ne, 0, T), $e = this.markerEnd = Fu("end", l, re, y, Qe, ne, 0, T), T && (ae = Be.quickSetter([Ge, $e], y.a, ln)), !G && !(nr.length && os(O, "fixedMarkers") === !0) && (Zw(V ? Ot : O), Be.set([X, ve], {
                        force3D: !0
                    }), pe = Be.quickSetter(X, y.a, ln), Ve = Be.quickSetter(ve, y.a, ln))
                }
                if (T) {
                    var U = T.vars.onUpdate,
                        J = T.vars.onUpdateParams;
                    T.eventCallback("onUpdate", function() {
                        F.update(0, 0, 1), U && U.apply(T, J || [])
                    })
                }
                if (F.previous = function() {
                        return ft[ft.indexOf(F) - 1]
                    }, F.next = function() {
                        return ft[ft.indexOf(F) + 1]
                    }, F.revert = function(Q, Te) {
                        if (!Te) return F.kill(!0);
                        var ue = Q !== !1 || !F.enabled,
                            we = Cn;
                        ue !== F.isReverted && (ue && (me = Math.max(fe(), F.scroll.rec || 0), he = F.progress, le = i && i.progress()), Ge && [Ge, $e, X, ve].forEach(function(Ke) {
                            return Ke.style.display = ue ? "none" : "block"
                        }), ue && (Cn = F, F.update(ue)), u && (!M || !F.isActive) && (ue ? iC(u, K, rt) : yp(u, K, Si(u), De)), ue || F.update(ue), Cn = we, F.isReverted = ue)
                    }, F.refresh = function(Q, Te, ue, we) {
                        if (!((Cn || !F.enabled) && !Te)) {
                            if (u && Q && vi) {
                                mn(r, "scrollEnd", O0);
                                return
                            }!Hn && se && se(F), Cn = F, be.tween && !ue && (be.tween.kill(), be.tween = 0), I && I.pause(), m && i && i.revert({
                                kill: !1
                            }).invalidate(), F.isReverted || F.revert(!0, !0), F._subPinOffset = !1;
                            var Ke = de(),
                                Ue = ke(),
                                et = T ? T.duration() : sr(O, y),
                                bt = ge <= .01,
                                _t = 0,
                                ct = we || 0,
                                ut = Js(ue) ? ue.end : n.end,
                                Et = n.endTrigger || d,
                                nt = Js(ue) ? ue.start : n.start || (n.start === 0 || !d ? 0 : u ? "0 0" : "0 100%"),
                                cn = F.pinnedContainer = n.pinnedContainer && $n(n.pinnedContainer, F),
                                Bt = d && Math.max(0, ft.indexOf(F)) || 0,
                                un = Bt,
                                fn, A, W, Z, $, z, _e, Ce, ze, Le, qe, Je, We;
                            for (H && Js(ue) && (Je = Be.getProperty(X, y.p), We = Be.getProperty(ve, y.p)); un--;) z = ft[un], z.end || z.refresh(0, 1) || (Cn = F), _e = z.pin, _e && (_e === d || _e === u || _e === cn) && !z.isReverted && (Le || (Le = []), Le.unshift(z), z.revert(!0, !0)), z !== ft[un] && (Bt--, un--);
                            for (Gn(nt) && (nt = nt(F)), nt = S0(nt, "start", F), xe = H0(nt, d, Ke, y, fe(), Ge, X, F, Ue, k, G, et, T, F._startClamp && "_startClamp") || (u ? -.001 : 0), Gn(ut) && (ut = ut(F)), li(ut) && !ut.indexOf("+=") && (~ut.indexOf(" ") ? ut = (li(nt) ? nt.split(" ")[0] : "") + ut : (_t = Pu(ut.substr(2), Ke), ut = li(nt) ? nt : (T ? Be.utils.mapRange(0, T.duration(), T.scrollTrigger.start, T.scrollTrigger.end, xe) : xe) + _t, Et = d)), ut = S0(ut, "end", F), R = Math.max(xe, H0(ut || (Et ? "100% 0" : et), Et, Ke, y, fe() + _t, $e, ve, F, Ue, k, G, et, T, F._endClamp && "_endClamp")) || -.001, _t = 0, un = Bt; un--;) z = ft[un], _e = z.pin, _e && z.start - z._pinPush <= xe && !T && z.end > 0 && (fn = z.end - (F._startClamp ? Math.max(0, z.start) : z.start), (_e === d && z.start - z._pinPush < xe || _e === cn) && isNaN(nt) && (_t += fn * (1 - z.progress)), _e === u && (ct += fn));
                            if (xe += _t, R += _t, F._startClamp && (F._startClamp += _t), F._endClamp && !Hn && (F._endClamp = R || -.001, R = Math.min(R, sr(O, y))), ge = R - xe || (xe -= .01) && .001, bt && (he = Be.utils.clamp(0, 1, Be.utils.normalize(xe, R, me))), F._pinPush = ct, Ge && _t && (fn = {}, fn[y.a] = "+=" + _t, cn && (fn[y.p] = "-=" + fe()), Be.set([Ge, $e], fn)), u && !(lp && F.end >= sr(O, y))) fn = Si(u), Z = y === sn, W = fe(), Fe = parseFloat(ie(y.a)) + ct, !et && R > 1 && (qe = (V ? Wt.scrollingElement || Hi : O).style, qe = {
                                style: qe,
                                value: qe["overflow" + y.a.toUpperCase()]
                            }, V && Si(Ot)["overflow" + y.a.toUpperCase()] !== "scroll" && (qe.style["overflow" + y.a.toUpperCase()] = "scroll")), yp(u, K, fn), E = Ou(u), A = Pr(u, !0), Ce = G && ls(O, Z ? Bn : sn)(), _ ? (De = [_ + y.os2, ge + ct + ln], De.t = K, un = _ === en ? Du(u, y) + ge + ct : 0, un && (De.push(y.d, un + ln), K.style.flexBasis !== "auto" && (K.style.flexBasis = un + ln)), bo(De), cn && ft.forEach(function(lt) {
                                lt.pin === cn && lt.vars.pinSpacing !== !1 && (lt._subPinOffset = !0)
                            }), G && fe(me)) : (un = Du(u, y), un && K.style.flexBasis !== "auto" && (K.style.flexBasis = un + ln)), G && ($ = {
                                top: A.top + (Z ? W - xe : Ce) + ln,
                                left: A.left + (Z ? Ce : W - xe) + ln,
                                boxSizing: "border-box",
                                position: "fixed"
                            }, $[Zs] = $["max" + go] = Math.ceil(A.width) + ln, $[Qs] = $["max" + pp] = Math.ceil(A.height) + ln, $[yi] = $[yi + Gl] = $[yi + kl] = $[yi + Hl] = $[yi + zl] = "0", $[en] = fn[en], $[en + Gl] = fn[en + Gl], $[en + kl] = fn[en + kl], $[en + Hl] = fn[en + Hl], $[en + zl] = fn[en + zl], P = sC(rt, $, M), Hn && fe(0)), i ? (ze = i._initted, ip(1), i.render(i.duration(), !0, !0), ye = ie(y.a) - Fe + ge + ct, Ae = Math.abs(ge - ye) > 1, G && Ae && P.splice(P.length - 2, 2), i.render(0, !0, !0), ze || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), ip(0)) : ye = ge, qe && (qe.value ? qe.style["overflow" + y.a.toUpperCase()] = qe.value : qe.style.removeProperty("overflow-" + y.a));
                            else if (d && fe() && !T)
                                for (A = d.parentNode; A && A !== Ot;) A._pinOffset && (xe -= A._pinOffset, R -= A._pinOffset), A = A.parentNode;
                            Le && Le.forEach(function(lt) {
                                return lt.revert(!1, !0)
                            }), F.start = xe, F.end = R, Xe = tt = Hn ? me : fe(), !T && !Hn && (Xe < me && fe(me), F.scroll.rec = 0), F.revert(!1, !0), ee = Rn(), Ee && (q = -1, Ee.restart(!0)), Cn = 0, i && C && (i._initted || le) && i.progress() !== le && i.progress(le || 0, !0).render(i.time(), !0, !0), (bt || he !== F.progress || T || m) && (i && !C && i.totalProgress(T && xe < -.001 && !he ? Be.utils.normalize(xe, R, 0) : he, !0), F.progress = bt || (Xe - xe) / ge === he ? 0 : he), u && _ && (K._pinOffset = Math.round(F.progress * ye)), I && I.invalidate(), isNaN(Je) || (Je -= Be.getProperty(X, y.p), We -= Be.getProperty(ve, y.p), Bu(X, y, Je), Bu(Ge, y, Je - (we || 0)), Bu(ve, y, We), Bu($e, y, We - (we || 0))), bt && !Hn && F.update(), f && !Hn && !Ie && (Ie = !0, f(F), Ie = !1)
                        }
                    }, F.getVelocity = function() {
                        return (fe() - tt) / (Rn() - Il) * 1e3 || 0
                    }, F.endAnimation = function() {
                        Bl(F.callbackAnimation), i && (I ? I.progress(1) : i.paused() ? C || Bl(i, F.direction < 0, 1) : Bl(i, i.reversed()))
                    }, F.labelToScroll = function(Q) {
                        return i && i.labels && (xe || F.refresh() || xe) + i.labels[Q] / i.duration() * ge || 0
                    }, F.getTrailing = function(Q) {
                        var Te = ft.indexOf(F),
                            ue = F.direction > 0 ? ft.slice(0, Te).reverse() : ft.slice(Te + 1);
                        return (li(Q) ? ue.filter(function(we) {
                            return we.vars.preventOverlaps === Q
                        }) : ue).filter(function(we) {
                            return F.direction > 0 ? we.end <= xe : we.start >= R
                        })
                    }, F.update = function(Q, Te, ue) {
                        if (!(T && !ue && !Q)) {
                            var we = Hn === !0 ? me : F.scroll(),
                                Ke = Q ? 0 : (we - xe) / ge,
                                Ue = Ke < 0 ? 0 : Ke > 1 ? 1 : Ke || 0,
                                et = F.progress,
                                bt, _t, ct, ut, Et, nt, cn, Bt;
                            if (Te && (tt = Xe, Xe = T ? fe() : we, b && (je = Se, Se = i && !C ? i.totalProgress() : Ue)), g && u && !Cn && !Tu && vi && (!Ue && xe < we + (we - tt) / (Rn() - Il) * g ? Ue = 1e-4 : Ue === 1 && R > we + (we - tt) / (Rn() - Il) * g && (Ue = .9999)), Ue !== et && F.enabled) {
                                if (bt = F.isActive = !!Ue && Ue < 1, _t = !!et && et < 1, nt = bt !== _t, Et = nt || !!Ue != !!et, F.direction = Ue > et ? 1 : -1, F.progress = Ue, Et && !Cn && (ct = Ue && !et ? 0 : Ue === 1 ? 1 : et === 1 ? 2 : 3, C && (ut = !nt && j[ct + 1] !== "none" && j[ct + 1] || j[ct], Bt = i && (ut === "complete" || ut === "reset" || ut in i))), S && (nt || Bt) && (Bt || h || !i) && (Gn(S) ? S(F) : F.getTrailing(S).forEach(function(W) {
                                        return W.endAnimation()
                                    })), C || (I && !Cn && !Tu ? (I._dp._time - I._start !== I._time && I.render(I._dp._time - I._start), I.resetTo ? I.resetTo("totalProgress", Ue, i._tTime / i._tDur) : (I.vars.totalProgress = Ue, I.invalidate().restart())) : i && i.totalProgress(Ue, !!(Cn && (ee || Q)))), u) {
                                    if (Q && _ && (K.style[_ + y.os2] = Oe), !G) te(Ol(Fe + ye * Ue));
                                    else if (Et) {
                                        if (cn = !Q && Ue > et && R + 1 > we && we + 1 >= sr(O, y), M)
                                            if (!Q && (bt || cn)) {
                                                var un = Pr(u, !0),
                                                    fn = we - xe;
                                                V0(u, Ot, un.top + (y === sn ? fn : 0) + ln, un.left + (y === sn ? 0 : fn) + ln)
                                            } else V0(u, K);
                                        bo(bt || cn ? P : E), Ae && Ue < 1 && bt || te(Fe + (Ue === 1 && !cn ? ye : 0))
                                    }
                                }
                                b && !be.tween && !Cn && !Tu && Ee.restart(!0), o && (nt || x && Ue && (Ue < 1 || !cp)) && Fl(o.targets).forEach(function(W) {
                                    return W.classList[bt || x ? "add" : "remove"](o.className)
                                }), a && !C && !Q && a(F), Et && !Cn ? (C && (Bt && (ut === "complete" ? i.pause().totalProgress(1) : ut === "reset" ? i.restart(!0).pause() : ut === "restart" ? i.restart(!0) : i[ut]()), a && a(F)), (nt || !cp) && (c && nt && fp(F, c), B[ct] && fp(F, B[ct]), x && (Ue === 1 ? F.kill(!1, 1) : B[ct] = 0), nt || (ct = Ue === 1 ? 1 : 3, B[ct] && fp(F, B[ct]))), w && !bt && Math.abs(F.getVelocity()) > (Ul(w) ? w : 2500) && (Bl(F.callbackAnimation), I ? I.progress(1) : Bl(i, ut === "reverse" ? 1 : !Ue, 1))) : C && a && !Cn && a(F)
                            }
                            if (Ve) {
                                var A = T ? we / T.duration() * (T._caScrollDist || 0) : we;
                                pe(A + (X._isFlipped ? 1 : 0)), Ve(A)
                            }
                            ae && ae(-we / T.duration() * (T._caScrollDist || 0))
                        }
                    }, F.enable = function(Q, Te) {
                        F.enabled || (F.enabled = !0, mn(O, "resize", Wl), V || mn(O, "scroll", _o), se && mn(r, "refreshInit", se), Q !== !1 && (F.progress = he = 0, Xe = tt = q = fe()), Te !== !1 && F.refresh())
                    }, F.getTween = function(Q) {
                        return Q && be ? be.tween : I
                    }, F.setPositions = function(Q, Te, ue, we) {
                        if (T) {
                            var Ke = T.scrollTrigger,
                                Ue = T.duration(),
                                et = Ke.end - Ke.start;
                            Q = Ke.start + et * Q / Ue, Te = Ke.start + et * Te / Ue
                        }
                        F.refresh(!1, !1, {
                            start: M0(Q, ue && !!F._startClamp),
                            end: M0(Te, ue && !!F._endClamp)
                        }, we), F.update()
                    }, F.adjustPinSpacing = function(Q) {
                        if (De && Q) {
                            var Te = De.indexOf(y.d) + 1;
                            De[Te] = parseFloat(De[Te]) + Q + ln, De[1] = parseFloat(De[1]) + Q + ln, bo(De)
                        }
                    }, F.disable = function(Q, Te) {
                        if (F.enabled && (Q !== !1 && F.revert(!0, !0), F.enabled = F.isActive = !1, Te || I && I.pause(), me = 0, Ye && (Ye.uncache = 1), se && gn(r, "refreshInit", se), Ee && (Ee.pause(), be.tween && be.tween.kill() && (be.tween = 0)), !V)) {
                            for (var ue = ft.length; ue--;)
                                if (ft[ue].scroller === O && ft[ue] !== F) return;
                            gn(O, "resize", Wl), V || gn(O, "scroll", _o)
                        }
                    }, F.kill = function(Q, Te) {
                        F.disable(Q, Te), I && !Te && I.kill(), l && delete gp[l];
                        var ue = ft.indexOf(F);
                        ue >= 0 && ft.splice(ue, 1), ue === kn && Iu > 0 && kn--, ue = 0, ft.forEach(function(we) {
                            return we.scroller === F.scroller && (ue = 1)
                        }), ue || Hn || (F.scroll.rec = 0), i && (i.scrollTrigger = null, Q && i.revert({
                            kill: !1
                        }), Te || i.kill()), Ge && [Ge, $e, X, ve].forEach(function(we) {
                            return we.parentNode && we.parentNode.removeChild(we)
                        }), Xl === F && (Xl = 0), u && (Ye && (Ye.uncache = 1), ue = 0, ft.forEach(function(we) {
                            return we.pin === u && ue++
                        }), ue || (Ye.spacer = 0)), n.onKill && n.onKill(F)
                    }, ft.push(F), F.enable(!1, !1), L && L(F), i && i.add && !ge) {
                    var ce = F.update;
                    F.update = function() {
                        F.update = ce, xe || R || F.refresh()
                    }, Be.delayedCall(.01, F.update), ge = .01, xe = R = 0
                } else F.refresh();
                u && nC()
            }, r.register = function(n) {
                return fo || (Be = n || A0(), D0() && window.document && r.enable(), fo = Nl), fo
            }, r.defaults = function(n) {
                if (n)
                    for (var i in n) Cu[i] = n[i];
                return Cu
            }, r.disable = function(n, i) {
                Nl = 0, ft.forEach(function(a) {
                    return a[i ? "kill" : "disable"](n)
                }), gn(St, "wheel", _o), gn(Wt, "scroll", _o), clearInterval(yu), gn(Wt, "touchcancel", rr), gn(Ot, "touchstart", rr), Au(gn, Wt, "pointerdown,touchstart,mousedown", T0), Au(gn, Wt, "pointerup,touchend,mouseup", E0), vu.kill(), Eu(gn);
                for (var s = 0; s < gt.length; s += 3) wu(gn, gt[s], gt[s + 1]), wu(gn, gt[s], gt[s + 2])
            }, r.enable = function() {
                if (St = window, Wt = document, Hi = Wt.documentElement, Ot = Wt.body, Be && (Fl = Be.utils.toArray, Ll = Be.utils.clamp, sp = Be.core.context || rr, ip = Be.core.suppressOverwrites || rr, ap = St.history.scrollRestoration || "auto", xp = St.pageYOffset, Be.core.globals("ScrollTrigger", r), Ot)) {
                    Nl = 1, po = document.createElement("div"), po.style.height = "100vh", po.style.position = "absolute", z0(), Kw(), Vt.register(Be), r.isTouch = Vt.isTouch, ms = Vt.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), rp = Vt.isTouch === 1, mn(St, "wheel", _o), m0 = [St, Wt, Hi, Ot], Be.matchMedia ? (r.matchMedia = function(l) {
                        var c = Be.matchMedia(),
                            f;
                        for (f in l) c.add(f, l[f]);
                        return c
                    }, Be.addEventListener("matchMediaInit", function() {
                        return bp()
                    }), Be.addEventListener("matchMediaRevert", function() {
                        return U0()
                    }), Be.addEventListener("matchMedia", function() {
                        ia(0, 1), ta("matchMedia")
                    }), Be.matchMedia("(orientation: portrait)", function() {
                        return _p(), _p
                    })) : console.warn("Requires GSAP 3.11.0 or later"), _p(), mn(Wt, "scroll", _o);
                    var n = Ot.style,
                        i = n.borderTopStyle,
                        s = Be.core.Animation.prototype,
                        a, o;
                    for (s.revert || Object.defineProperty(s, "revert", {
                            value: function() {
                                return this.time(-.01, !0)
                            }
                        }), n.borderTopStyle = "solid", a = Pr(Ot), sn.m = Math.round(a.top + sn.sc()) || 0, Bn.m = Math.round(a.left + Bn.sc()) || 0, i ? n.borderTopStyle = i : n.removeProperty("border-top-style"), yu = setInterval(N0, 250), Be.delayedCall(.5, function() {
                            return Tu = 0
                        }), mn(Wt, "touchcancel", rr), mn(Ot, "touchstart", rr), Au(mn, Wt, "pointerdown,touchstart,mousedown", T0), Au(mn, Wt, "pointerup,touchend,mouseup", E0), np = Be.utils.checkPrefix("transform"), Nu.push(np), fo = Rn(), vu = Be.delayedCall(.2, ia).pause(), ho = [Wt, "visibilitychange", function() {
                            var l = St.innerWidth,
                                c = St.innerHeight;
                            Wt.hidden ? (g0 = l, _0 = c) : (g0 !== l || _0 !== c) && Wl()
                        }, Wt, "DOMContentLoaded", ia, St, "load", ia, St, "resize", Wl], Eu(mn), ft.forEach(function(l) {
                            return l.enable(0, 1)
                        }), o = 0; o < gt.length; o += 3) wu(gn, gt[o], gt[o + 1]), wu(gn, gt[o], gt[o + 2])
                }
            }, r.config = function(n) {
                "limitCallbacks" in n && (cp = !!n.limitCallbacks);
                var i = n.syncInterval;
                i && clearInterval(yu) || (yu = i) && setInterval(N0, i), "ignoreMobileResize" in n && (rp = r.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (Eu(gn) || Eu(mn, n.autoRefreshEvents || "none"), x0 = (n.autoRefreshEvents + "").indexOf("resize") === -1)
            }, r.scrollerProxy = function(n, i) {
                var s = $n(n),
                    a = gt.indexOf(s),
                    o = $s(s);
                ~a && gt.splice(a, o ? 6 : 2), i && (o ? nr.unshift(St, i, Ot, i, Hi, i) : nr.unshift(s, i))
            }, r.clearMatchMedia = function(n) {
                ft.forEach(function(i) {
                    return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
                })
            }, r.isInViewport = function(n, i, s) {
                var a = (li(n) ? $n(n) : n).getBoundingClientRect(),
                    o = a[s ? Zs : Qs] * i || 0;
                return s ? a.right - o > 0 && a.left + o < St.innerWidth : a.bottom - o > 0 && a.top + o < St.innerHeight
            }, r.positionInViewport = function(n, i, s) {
                li(n) && (n = $n(n));
                var a = n.getBoundingClientRect(),
                    o = a[s ? Zs : Qs],
                    l = i == null ? o / 2 : i in Ru ? Ru[i] * o : ~i.indexOf("%") ? parseFloat(i) * o / 100 : parseFloat(i) || 0;
                return s ? (a.left + l) / St.innerWidth : (a.top + l) / St.innerHeight
            }, r.killAll = function(n) {
                if (ft.slice(0).forEach(function(s) {
                        return s.vars.id !== "ScrollSmoother" && s.kill()
                    }), n !== !0) {
                    var i = ea.killAll || [];
                    ea = {}, i.forEach(function(s) {
                        return s()
                    })
                }
            }, r
        }();
    ht.version = "3.12.5", ht.saveStyles = function(r) {
        return r ? Fl(r).forEach(function(e) {
            if (e && e.style) {
                var t = ci.indexOf(e);
                t >= 0 && ci.splice(t, 5), ci.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Be.core.getCache(e), sp())
            }
        }) : ci
    }, ht.revert = function(r, e) {
        return bp(!r, e)
    }, ht.create = function(r, e) {
        return new ht(r, e)
    }, ht.refresh = function(r) {
        return r ? Wl() : (fo || ht.register()) && ia(!0)
    }, ht.update = function(r) {
        return ++gt.cache && Fr(r === !0 ? 2 : 0)
    }, ht.clearScrollMemory = B0, ht.maxScroll = function(r, e) {
        return sr(r, e ? Bn : sn)
    }, ht.getScrollFunc = function(r, e) {
        return ls($n(r), e ? Bn : sn)
    }, ht.getById = function(r) {
        return gp[r]
    }, ht.getAll = function() {
        return ft.filter(function(r) {
            return r.vars.id !== "ScrollSmoother"
        })
    }, ht.isScrolling = function() {
        return !!vi
    }, ht.snapDirectional = mp, ht.addEventListener = function(r, e) {
        var t = ea[r] || (ea[r] = []);
        ~t.indexOf(e) || t.push(e)
    }, ht.removeEventListener = function(r, e) {
        var t = ea[r],
            n = t && t.indexOf(e);
        n >= 0 && t.splice(n, 1)
    }, ht.batch = function(r, e) {
        var t = [],
            n = {},
            i = e.interval || .016,
            s = e.batchMax || 1e9,
            a = function(c, f) {
                var h = [],
                    d = [],
                    u = Be.delayedCall(i, function() {
                        f(h, d), h = [], d = []
                    }).pause();
                return function(_) {
                    h.length || u.restart(!0), h.push(_.trigger), d.push(_), s <= h.length && u.progress(1)
                }
            },
            o;
        for (o in e) n[o] = o.substr(0, 2) === "on" && Gn(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o];
        return Gn(s) && (s = s(), mn(ht, "refresh", function() {
            return s = e.batchMax()
        })), Fl(r).forEach(function(l) {
            var c = {};
            for (o in n) c[o] = n[o];
            c.trigger = l, t.push(ht.create(c))
        }), t
    };
    var j0 = function(e, t, n, i) {
            return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
        },
        Sp = function r(e, t) {
            t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Vt.isTouch ? " pinch-zoom" : "") : "none", e === Hi && r(Ot, t)
        },
        ku = {
            auto: 1,
            scroll: 1
        },
        oC = function(e) {
            var t = e.event,
                n = e.target,
                i = e.axis,
                s = (t.changedTouches ? t.changedTouches[0] : t).target,
                a = s._gsap || Be.core.getCache(s),
                o = Rn(),
                l;
            if (!a._isScrollT || o - a._isScrollT > 2e3) {
                for (; s && s !== Ot && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(ku[(l = Si(s)).overflowY] || ku[l.overflowX]));) s = s.parentNode;
                a._isScroll = s && s !== n && !$s(s) && (ku[(l = Si(s)).overflowY] || ku[l.overflowX]), a._isScrollT = o
            }(a._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0)
        },
        q0 = function(e, t, n, i) {
            return Vt.create({
                target: e,
                capture: !0,
                debounce: !1,
                lockAxis: !0,
                type: t,
                onWheel: i = i && oC,
                onPress: i,
                onDrag: i,
                onScroll: i,
                onEnable: function() {
                    return n && mn(Wt, Vt.eventTypes[0], K0, !1, !0)
                },
                onDisable: function() {
                    return gn(Wt, Vt.eventTypes[0], K0, !0)
                }
            })
        },
        lC = /(input|label|select|textarea)/i,
        Y0, K0 = function(e) {
            var t = lC.test(e.target.tagName);
            (t || Y0) && (e._gsapAllow = !0, Y0 = t)
        },
        cC = function(e) {
            Js(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
            var t = e,
                n = t.normalizeScrollX,
                i = t.momentum,
                s = t.allowNestedScroll,
                a = t.onRelease,
                o, l, c = $n(e.target) || Hi,
                f = Be.core.globals().ScrollSmoother,
                h = f && f.get(),
                d = ms && (e.content && $n(e.content) || h && e.content !== !1 && !h.smooth() && h.content()),
                u = ls(c, sn),
                _ = ls(c, Bn),
                m = 1,
                g = (Vt.isTouch && St.visualViewport ? St.visualViewport.scale * St.visualViewport.width : St.outerWidth) / St.innerWidth,
                p = 0,
                v = Gn(i) ? function() {
                    return i(o)
                } : function() {
                    return i || 2.8
                },
                x, b, M = q0(c, e.type, !0, s),
                D = function() {
                    return b = !1
                },
                T = rr,
                w = rr,
                S = function() {
                    l = sr(c, sn), w = Ll(ms ? 1 : 0, l), n && (T = Ll(0, sr(c, Bn))), x = na
                },
                y = function() {
                    d._gsap.y = Ol(parseFloat(d._gsap.y) + u.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", u.offset = u.cacheID = 0
                },
                C = function() {
                    if (b) {
                        requestAnimationFrame(D);
                        var H = Ol(o.deltaY / 2),
                            k = w(u.v - H);
                        if (d && k !== u.v + u.offset) {
                            u.offset = k - u.v;
                            var F = Ol((parseFloat(d && d._gsap.y) || 0) - u.offset);
                            d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + F + ", 0, 1)", d._gsap.y = F + "px", u.cacheID = gt.cache, Fr()
                        }
                        return !0
                    }
                    u.offset && y(), b = !0
                },
                O, N, V, G, B = function() {
                    S(), O.isActive() && O.vars.scrollY > l && (u() > l ? O.progress(1) && u(l) : O.resetTo("scrollY", l))
                };
            return d && Be.set(d, {
                y: "+=0"
            }), e.ignoreCheck = function(j) {
                return ms && j.type === "touchmove" && C() || m > 1.05 && j.type !== "touchstart" || o.isGesturing || j.touches && j.touches.length > 1
            }, e.onPress = function() {
                b = !1;
                var j = m;
                m = Ol((St.visualViewport && St.visualViewport.scale || 1) / g), O.pause(), j !== m && Sp(c, m > 1.01 ? !0 : n ? !1 : "x"), N = _(), V = u(), S(), x = na
            }, e.onRelease = e.onGestureStart = function(j, H) {
                if (u.offset && y(), !H) G.restart(!0);
                else {
                    gt.cache++;
                    var k = v(),
                        F, se;
                    n && (F = _(), se = F + k * .05 * -j.velocityX / .227, k *= j0(_, F, se, sr(c, Bn)), O.vars.scrollX = T(se)), F = u(), se = F + k * .05 * -j.velocityY / .227, k *= j0(u, F, se, sr(c, sn)), O.vars.scrollY = w(se), O.invalidate().duration(k).play(.01), (ms && O.vars.scrollY >= l || F >= l - 1) && Be.to({}, {
                        onUpdate: B,
                        duration: k
                    })
                }
                a && a(j)
            }, e.onWheel = function() {
                O._ts && O.pause(), Rn() - p > 1e3 && (x = 0, p = Rn())
            }, e.onChange = function(j, H, k, F, se) {
                if (na !== x && S(), H && n && _(T(F[2] === H ? N + (j.startX - j.x) : _() + H - F[1])), k) {
                    u.offset && y();
                    var de = se[2] === k,
                        ke = de ? V + j.startY - j.y : u() + k - se[1],
                        q = w(ke);
                    de && ke !== q && (V += q - ke), u(q)
                }(k || H) && Fr()
            }, e.onEnable = function() {
                Sp(c, n ? !1 : "x"), ht.addEventListener("refresh", B), mn(St, "resize", B), u.smooth && (u.target.style.scrollBehavior = "auto", u.smooth = _.smooth = !1), M.enable()
            }, e.onDisable = function() {
                Sp(c, !0), gn(St, "resize", B), ht.removeEventListener("refresh", B), M.kill()
            }, e.lockAxis = e.lockAxis !== !1, o = new Vt(e), o.iOS = ms, ms && !u() && u(1), ms && Be.ticker.add(rr), G = o._dc, O = Be.to(o, {
                ease: "power4",
                paused: !0,
                inherit: !1,
                scrollX: n ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                modifiers: {
                    scrollY: W0(u, u(), function() {
                        return O.pause()
                    })
                },
                onUpdate: Fr,
                onComplete: G.vars.onComplete
            }), o
        };
    ht.sort = function(r) {
        return ft.sort(r || function(e, t) {
            return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
        })
    }, ht.observe = function(r) {
        return new Vt(r)
    }, ht.normalizeScroll = function(r) {
        if (typeof r > "u") return zn;
        if (r === !0 && zn) return zn.enable();
        if (r === !1) {
            zn && zn.kill(), zn = r;
            return
        }
        var e = r instanceof Vt ? r : cC(r);
        return zn && zn.target === e.target && zn.kill(), $s(e.target) && (zn = e), e
    }, ht.core = {
        _getVelocityProp: hd,
        _inputObserver: q0,
        _scrollers: gt,
        _proxies: nr,
        bridge: {
            ss: function() {
                vi || ta("scrollStart"), vi = Rn()
            },
            ref: function() {
                return Cn
            }
        }
    }, A0() && Be.registerPlugin(ht);
    /*!
     * strings: 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var uC = /(?:^\s+|\s+$)/g,
        $0 = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

    function zu(r) {
        var e = r.nodeType,
            t = "";
        if (e === 1 || e === 9 || e === 11) {
            if (typeof r.textContent == "string") return r.textContent;
            for (r = r.firstChild; r; r = r.nextSibling) t += zu(r)
        } else if (e === 3 || e === 4) return r.nodeValue;
        return t
    }

    function ar(r, e, t, n) {
        if (r += "", t && (r = r.trim ? r.trim() : r.replace(uC, "")), e && e !== "") return r.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(e);
        for (var i = [], s = r.length, a = 0, o, l; a < s; a++) l = r.charAt(a), (l.charCodeAt(0) >= 55296 && l.charCodeAt(0) <= 56319 || r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039) && (o = ((r.substr(a, 12).split($0) || [])[1] || "").length || 2, l = r.substr(a, o), i.emoji = 1, a += o - 1), i.push(l === ">" ? "&gt;" : l === "<" ? "&lt;" : n && l === " " && (r.charAt(a - 1) === " " || r.charAt(a + 1) === " ") ? "&nbsp;" : l);
        return i
    }
    /*!
     * SplitText: 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var xo, Mp, J0, jl, Z0, Gu, fC = /(?:\r|\n|\t\t)/g,
        hC = /(?:\s\s+)/g,
        dC = "",
        Q0 = function(e) {
            xo = document, Mp = window, jl = jl || e || Mp.gsap || console.warn("Please gsap.registerPlugin(SplitText)"), jl && (Gu = jl.utils.toArray, Z0 = jl.core.context || function() {}, J0 = 1)
        },
        ex = function(e) {
            return Mp.getComputedStyle(e)
        },
        Tp = function(e) {
            return e.position === "absolute" || e.absolute === !0
        },
        pC = function(e, t) {
            for (var n = t.length, i; --n > -1;)
                if (i = t[n], e.substr(0, i.length) === i) return i.length
        },
        mC = " style='position:relative;display:inline-block;'",
        tx = function(e, t) {
            e === void 0 && (e = "");
            var n = ~e.indexOf("++"),
                i = 1;
            return n && (e = e.split("++").join("")),
                function() {
                    return "<" + t + mC + (e ? " class='" + e + (n ? i++ : "") + "'>" : ">")
                }
        },
        nx = function r(e, t, n) {
            var i = e.nodeType;
            if (i === 1 || i === 9 || i === 11)
                for (e = e.firstChild; e; e = e.nextSibling) r(e, t, n);
            else(i === 3 || i === 4) && (e.nodeValue = e.nodeValue.split(t).join(n))
        },
        Ep = function(e, t) {
            for (var n = t.length; --n > -1;) e.push(t[n])
        },
        ix = function(e, t, n) {
            for (var i; e && e !== t;) {
                if (i = e._next || e.nextSibling, i) return i.textContent.charAt(0) === n;
                e = e.parentNode || e._parent
            }
        },
        gC = function r(e) {
            var t = Gu(e.childNodes),
                n = t.length,
                i, s;
            for (i = 0; i < n; i++) s = t[i], s._isSplit ? r(s) : i && s.previousSibling && s.previousSibling.nodeType === 3 ? (s.previousSibling.nodeValue += s.nodeType === 3 ? s.nodeValue : s.firstChild.nodeValue, e.removeChild(s)) : s.nodeType !== 3 && (e.insertBefore(s.firstChild, s), e.removeChild(s))
        },
        or = function(e, t) {
            return parseFloat(t[e]) || 0
        },
        _C = function(e, t, n, i, s, a, o) {
            var l = ex(e),
                c = or("paddingLeft", l),
                f = -999,
                h = or("borderBottomWidth", l) + or("borderTopWidth", l),
                d = or("borderLeftWidth", l) + or("borderRightWidth", l),
                u = or("paddingTop", l) + or("paddingBottom", l),
                _ = or("paddingLeft", l) + or("paddingRight", l),
                m = or("fontSize", l) * (t.lineThreshold || .2),
                g = l.textAlign,
                p = [],
                v = [],
                x = [],
                b = t.wordDelimiter || " ",
                M = t.tag ? t.tag : t.span ? "span" : "div",
                D = t.type || t.split || "chars,words,lines",
                T = s && ~D.indexOf("lines") ? [] : null,
                w = ~D.indexOf("words"),
                S = ~D.indexOf("chars"),
                y = Tp(t),
                C = t.linesClass,
                O = ~(C || "").indexOf("++"),
                N = [],
                V = l.display === "flex",
                G = e.style.display,
                B, j, H, k, F, se, de, ke, q, ee, he, fe;
            for (O && (C = C.split("++").join("")), V && (e.style.display = "block"), j = e.getElementsByTagName("*"), H = j.length, F = [], B = 0; B < H; B++) F[B] = j[B];
            if (T || y)
                for (B = 0; B < H; B++) k = F[B], se = k.parentNode === e, (se || y || S && !w) && (fe = k.offsetTop, T && se && Math.abs(fe - f) > m && (k.nodeName !== "BR" || B === 0) && (de = [], T.push(de), f = fe), y && (k._x = k.offsetLeft, k._y = fe, k._w = k.offsetWidth, k._h = k.offsetHeight), T && ((k._isSplit && se || !S && se || w && se || !w && k.parentNode.parentNode === e && !k.parentNode._isSplit) && (de.push(k), k._x -= c, ix(k, e, b) && (k._wordEnd = !0)), k.nodeName === "BR" && (k.nextSibling && k.nextSibling.nodeName === "BR" || B === 0) && T.push([])));
            for (B = 0; B < H; B++) {
                if (k = F[B], se = k.parentNode === e, k.nodeName === "BR") {
                    T || y ? (k.parentNode && k.parentNode.removeChild(k), F.splice(B--, 1), H--) : w || e.appendChild(k);
                    continue
                }
                if (y && (q = k.style, !w && !se && (k._x += k.parentNode._x, k._y += k.parentNode._y), q.left = k._x + "px", q.top = k._y + "px", q.position = "absolute", q.display = "block", q.width = k._w + 1 + "px", q.height = k._h + "px"), !w && S)
                    if (k._isSplit)
                        for (k._next = j = k.nextSibling, k.parentNode.appendChild(k); j && j.nodeType === 3 && j.textContent === " ";) k._next = j.nextSibling, k.parentNode.appendChild(j), j = j.nextSibling;
                    else k.parentNode._isSplit ? (k._parent = k.parentNode, !k.previousSibling && k.firstChild && (k.firstChild._isFirst = !0), k.nextSibling && k.nextSibling.textContent === " " && !k.nextSibling.nextSibling && N.push(k.nextSibling), k._next = k.nextSibling && k.nextSibling._isFirst ? null : k.nextSibling, k.parentNode.removeChild(k), F.splice(B--, 1), H--) : se || (fe = !k.nextSibling && ix(k.parentNode, e, b), k.parentNode._parent && k.parentNode._parent.appendChild(k), fe && k.parentNode.appendChild(xo.createTextNode(" ")), M === "span" && (k.style.display = "inline"), p.push(k));
                else k.parentNode._isSplit && !k._isSplit && k.innerHTML !== "" ? v.push(k) : S && !k._isSplit && (M === "span" && (k.style.display = "inline"), p.push(k))
            }
            for (B = N.length; --B > -1;) N[B].parentNode.removeChild(N[B]);
            if (T) {
                for (y && (ee = xo.createElement(M), e.appendChild(ee), he = ee.offsetWidth + "px", fe = ee.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(ee)), q = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;) e.removeChild(e.firstChild);
                for (ke = b === " " && (!y || !w && !S), B = 0; B < T.length; B++) {
                    for (de = T[B], ee = xo.createElement(M), ee.style.cssText = "display:block;text-align:" + g + ";position:" + (y ? "absolute;" : "relative;"), C && (ee.className = C + (O ? B + 1 : "")), x.push(ee), H = de.length, j = 0; j < H; j++) de[j].nodeName !== "BR" && (k = de[j], ee.appendChild(k), ke && k._wordEnd && ee.appendChild(xo.createTextNode(" ")), y && (j === 0 && (ee.style.top = k._y + "px", ee.style.left = c + fe + "px"), k.style.top = "0px", fe && (k.style.left = k._x - fe + "px")));
                    H === 0 ? ee.innerHTML = "&nbsp;" : !w && !S && (gC(ee), nx(ee, "", " ")), y && (ee.style.width = he, ee.style.height = k._h + "px"), e.appendChild(ee)
                }
                e.style.cssText = q
            }
            y && (o > e.clientHeight && (e.style.height = o - u + "px", e.clientHeight < o && (e.style.height = o + h + "px")), a > e.clientWidth && (e.style.width = a - _ + "px", e.clientWidth < a && (e.style.width = a + d + "px"))), V && (G ? e.style.display = G : e.style.removeProperty("display")), Ep(n, p), w && Ep(i, v), Ep(s, x)
        },
        bC = function(e, t, n, i) {
            var s = t.tag ? t.tag : t.span ? "span" : "div",
                a = t.type || t.split || "chars,words,lines",
                o = ~a.indexOf("chars"),
                l = Tp(t),
                c = t.wordDelimiter || " ",
                f = function(y) {
                    return y === c || y === dC && c === " "
                },
                h = c !== " " ? "" : l ? "&#173; " : " ",
                d = "</" + s + ">",
                u = 1,
                _ = t.specialChars ? typeof t.specialChars == "function" ? t.specialChars : pC : null,
                m, g, p, v, x, b, M, D, T = xo.createElement("div"),
                w = e.parentNode;
            for (w.insertBefore(T, e), T.textContent = e.nodeValue, w.removeChild(e), e = T, m = zu(e), M = m.indexOf("<") !== -1, t.reduceWhiteSpace !== !1 && (m = m.replace(hC, " ").replace(fC, "")), M && (m = m.split("<").join("{{LT}}")), x = m.length, g = (m.charAt(0) === " " ? h : "") + n(), p = 0; p < x; p++)
                if (b = m.charAt(p), _ && (D = _(m.substr(p), t.specialChars))) b = m.substr(p, D || 1), g += o && b !== " " ? i() + b + "</" + s + ">" : b, p += D - 1;
                else if (f(b) && !f(m.charAt(p - 1)) && p) {
                for (g += u ? d : "", u = 0; f(m.charAt(p + 1));) g += h, p++;
                p === x - 1 ? g += h : m.charAt(p + 1) !== ")" && (g += h + n(), u = 1)
            } else b === "{" && m.substr(p, 6) === "{{LT}}" ? (g += o ? i() + "{{LT}}</" + s + ">" : "{{LT}}", p += 5) : b.charCodeAt(0) >= 55296 && b.charCodeAt(0) <= 56319 || m.charCodeAt(p + 1) >= 65024 && m.charCodeAt(p + 1) <= 65039 ? (v = ((m.substr(p, 12).split($0) || [])[1] || "").length || 2, g += o && b !== " " ? i() + m.substr(p, v) + "</" + s + ">" : m.substr(p, v), p += v - 1) : g += o && b !== " " ? i() + b + "</" + s + ">" : b;
            e.outerHTML = g + (u ? d : ""), M && nx(w, "{{LT}}", "<")
        },
        xC = function r(e, t, n, i) {
            var s = Gu(e.childNodes),
                a = s.length,
                o = Tp(t),
                l, c;
            if (e.nodeType !== 3 || a > 1) {
                for (t.absolute = !1, l = 0; l < a; l++) c = s[l], c._next = c._isFirst = c._parent = c._wordEnd = null, (c.nodeType !== 3 || /\S+/.test(c.nodeValue)) && (o && c.nodeType !== 3 && ex(c).display === "inline" && (c.style.display = "inline-block", c.style.position = "relative"), c._isSplit = !0, r(c, t, n, i));
                t.absolute = o, e._isSplit = !0;
                return
            }
            bC(e, t, n, i)
        },
        Hu = function() {
            function r(t, n) {
                J0 || Q0(), this.elements = Gu(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = n || {}, Z0(this), this.split(n)
            }
            var e = r.prototype;
            return e.split = function(n) {
                this.isSplit && this.revert(), this.vars = n = n || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                for (var i = this.elements.length, s = n.tag ? n.tag : n.span ? "span" : "div", a = tx(n.wordsClass, s), o = tx(n.charsClass, s), l, c, f; --i > -1;) f = this.elements[i], this._originals[i] = {
                    html: f.innerHTML,
                    style: f.getAttribute("style")
                }, l = f.clientHeight, c = f.clientWidth, xC(f, n, a, o), _C(f, n, this.chars, this.words, this.lines, c, l);
                return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
            }, e.revert = function() {
                var n = this._originals;
                if (!n) throw "revert() call wasn't scoped properly.";
                return this.elements.forEach(function(i, s) {
                    i.innerHTML = n[s].html, i.setAttribute("style", n[s].style)
                }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
            }, r.create = function(n, i) {
                return new r(n, i)
            }, r
        }();
    Hu.version = "3.12.5", Hu.register = Q0;
    /*!
     * ScrambleTextPlugin 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Vu = function() {
            function r(t) {
                this.chars = ar(t), this.sets = [], this.length = 50;
                for (var n = 0; n < 20; n++) this.sets[n] = ox(80, this.chars)
            }
            var e = r.prototype;
            return e.grow = function(n) {
                for (var i = 0; i < 20; i++) this.sets[i] += ox(n - this.length, this.chars);
                this.length = n
            }, r
        }(),
        ra, rx, sx = function() {
            return ra || typeof window < "u" && (ra = window.gsap) && ra.registerPlugin && ra
        },
        vC = 1,
        ax = /\s+/g,
        ox = function(e, t) {
            for (var n = t.length, i = ""; --e > -1;) i += t[~~(Math.random() * n)];
            return i
        },
        Dp = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        lx = Dp.toLowerCase(),
        yC = {
            upperCase: new Vu(Dp),
            lowerCase: new Vu(lx),
            upperAndLowerCase: new Vu(Dp + lx)
        },
        cx = function() {
            rx = ra = sx()
        },
        Wu = {
            version: "3.12.5",
            name: "scrambleText",
            register: function(e, t, n) {
                ra = e, cx()
            },
            init: function(e, t, n, i, s) {
                if (rx || cx(), this.prop = "innerHTML" in e ? "innerHTML" : "textContent" in e ? "textContent" : 0, !!this.prop) {
                    this.target = e, typeof t != "object" && (t = {
                        text: t
                    });
                    var a = t.text || t.value || "",
                        o = t.trim !== !1,
                        l = this,
                        c, f, h, d;
                    return l.delimiter = c = t.delimiter || "", l.original = ar(zu(e).replace(ax, " ").split("&nbsp;").join(""), c, o), (a === "{original}" || a === !0 || a == null) && (a = l.original.join(c)), l.text = ar((a || "").replace(ax, " "), c, o), l.hasClass = !!(t.newClass || t.oldClass), l.newClass = t.newClass, l.oldClass = t.oldClass, d = c === "", l.textHasEmoji = d && !!l.text.emoji, l.charsHaveEmoji = !!t.chars && !!ar(t.chars).emoji, l.length = d ? l.original.length : l.original.join(c).length, l.lengthDif = (d ? l.text.length : l.text.join(c).length) - l.length, l.fillChar = t.fillChar || t.chars && ~t.chars.indexOf(" ") ? "&nbsp;" : "", l.charSet = h = yC[t.chars || "upperCase"] || new Vu(t.chars), l.speed = .05 / (t.speed || 1), l.prevScrambleTime = 0, l.setIndex = Math.random() * 20 | 0, f = l.length + Math.max(l.lengthDif, 0), f > h.length && h.grow(f), l.chars = h.sets[l.setIndex], l.revealDelay = t.revealDelay || 0, l.tweenLength = t.tweenLength !== !1, l.tween = n, l.rightToLeft = !!t.rightToLeft, l._props.push("scrambleText", "text"), vC
                }
            },
            render: function(e, t) {
                var n = t.target,
                    i = t.prop,
                    s = t.text,
                    a = t.delimiter,
                    o = t.tween,
                    l = t.prevScrambleTime,
                    c = t.revealDelay,
                    f = t.setIndex,
                    h = t.chars,
                    d = t.charSet,
                    u = t.length,
                    _ = t.textHasEmoji,
                    m = t.charsHaveEmoji,
                    g = t.lengthDif,
                    p = t.tweenLength,
                    v = t.oldClass,
                    x = t.newClass,
                    b = t.rightToLeft,
                    M = t.fillChar,
                    D = t.speed,
                    T = t.original,
                    w = t.hasClass,
                    S = s.length,
                    y = o._time,
                    C = y - l,
                    O, N, V, G, B, j, H, k, F, se, de;
                c && (o._from && (y = o._dur - y), e = y === 0 ? 0 : y < c ? 1e-6 : y === o._dur ? 1 : o._ease((y - c) / (o._dur - c))), e < 0 ? e = 0 : e > 1 && (e = 1), b && (e = 1 - e), O = ~~(e * S + .5), e ? ((C > D || C < -D) && (t.setIndex = f = (f + (Math.random() * 19 | 0)) % 20, t.chars = d.sets[f], t.prevScrambleTime += C), G = h) : G = T.join(a), de = o._from ? e : 1 - e, se = u + (p ? o._from ? de * de * de : 1 - de * de * de : 1) * g, b ? e === 1 && (o._from || o.data === "isFromStart") ? (V = "", G = T.join(a)) : (H = s.slice(O).join(a), m ? V = ar(G).slice(0, se - (_ ? ar(H) : H).length + .5 | 0).join("") : V = G.substr(0, se - (_ ? ar(H) : H).length + .5 | 0), G = H) : (V = s.slice(0, O).join(a), N = (_ ? ar(V) : V).length, m ? G = ar(G).slice(N, se + .5 | 0).join("") : G = G.substr(N, se - N + .5 | 0)), w ? (k = b ? v : x, F = b ? x : v, B = k && O !== 0, j = F && O !== S, H = (B ? "<span class='" + k + "'>" : "") + V + (B ? "</span>" : "") + (j ? "<span class='" + F + "'>" : "") + a + G + (j ? "</span>" : "")) : H = V + a + G, n[i] = M === "&nbsp;" && ~H.indexOf("  ") ? H.split("  ").join("&nbsp;&nbsp;") : H
            }
        };
    Wu.emojiSafeSplit = ar, Wu.getText = zu, sx() && ra.registerPlugin(Wu);

    function SC() {
        return Zc.ticker.fps(60), Zc.registerPlugin(Vt, io, Hd, Pl, ht, Hu, Wu), ht.config({
            ignoreMobileResize: !0
        }), {
            gsap: Zc,
            Observer: Vt,
            Draggable: io,
            Flip: Pl,
            ScrollTrigger: ht,
            SplitText: Hu
        }
    }
    var MC = `uniform float u_AnimateIn;
uniform vec2 u_MousePosition;
uniform float u_InflationStrength;

varying float v_DistanceFromMouse;
varying float v_AnimateIn;

#define STROKE_WIDTH 0.8

float map(in float v, in float iMin, in float iMax, in float oMin, in float oMax) { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }

void main() {
  float distanceFromMouse = smoothstep(0.8, 0.1, min(4.0, distance(position, vec3(u_MousePosition, 0.0))));

  float animateIn = distance(vec3(position.xy, 0.0), vec3(0.0));

  float innerEdge = map(u_AnimateIn, 0.0, 1.0, -STROKE_WIDTH, 1.0);
  float outerEdge = map(u_AnimateIn + STROKE_WIDTH, STROKE_WIDTH, 1.0 + STROKE_WIDTH, -STROKE_WIDTH, 1.0 + STROKE_WIDTH);

  animateIn = smoothstep(innerEdge, innerEdge + 0.3, animateIn) *
              (1.0 - smoothstep(outerEdge, outerEdge + 0.3, animateIn));

  v_DistanceFromMouse = distanceFromMouse;
  v_AnimateIn = animateIn;
}
`,
        TC = `varying float v_DistanceFromMouse;
varying float v_AnimateIn;

void main() {
  vec3 color = vec3(v_AnimateIn);
  // csm_FragColor = vec4(color, 1.0);
}
`;
    let Xu, ql, Vi, Yl, gs, ju, Ap, Lr, _s, wp = {
            x: 0,
            y: 0
        },
        vo = !1;
    const qu = wg(!1),
        Cp = wg({
            x: -2,
            y: -2
        }),
        {
            gsap: Yu
        } = SC();
    qo.onProgress = (r, e, t) => {
        postMessage({
            modelLoaded: !0
        }), qo.onProgress = void 0
    }, self.addEventListener("message", ({
        data: r
    }) => {
        vo = r.width >= 768, r.init && ux(r.canvas, r.width, r.height, r.texture)
    }, {
        once: !0
    }), self.addEventListener("message", ({
        data: r
    }) => {
        ux && (r.resize && PC(r.width, r.height), r.dpr && FC(r.dpr), r.update && EC(), r.mouse && IC(r.x, r.y), r.drag && UC(r.x), r.isVisible !== void 0 && NC(r.isVisible))
    }), WE(qu, r => {
        Yu.to(gs.material.uniforms.u_InflationStrength, {
            value: r ? 1 : 0,
            duration: .5,
            ease: "elastic.out(1.5, 0.5)",
            overwrite: !0
        }), postMessage({
            hover: r
        })
    });

    function EC() {
        Vi.position.x = wp.x, Vi.position.y = wp.y, Vi.lookAt(gs.position), LC(), ql.render(Xu, Vi)
    }
    async function ux(r, e, t, n) {
        Lr = e, _s = t, DC(), AC(), wC(r), await CC(n), RC(), postMessage({
            init: !0
        })
    }

    function DC() {
        Xu = new iv
    }

    function AC() {
        Vi = new Fn(45, Lr / _s, .1, 100), Vi.position.set(0, 0, vo ? 2.6 : 2.3), Yl = new Wr, Yl.add(Vi), Xu.add(Yl)
    }

    function wC(r) {
        ql = new $T({
            canvas: r,
            alpha: !0,
            antialias: !0
        }), ql.setSize(Lr, _s, !1)
    }
    async function CC(r) {
        const e = new tn(r);
        e.colorSpace = Yt, e.flipY = !1, e.needsUpdate = !0;
        const t = await jD.load("/baloon.glb");
        gs = t.scene.getObjectByName("Deflated"), gs.material = new sD({
            baseMaterial: _v,
            matcap: e,
            uniforms: {
                u_AnimateIn: {
                    value: 0
                },
                u_MousePosition: {
                    value: new pt(-9999, 0)
                },
                u_InflationStrength: {
                    value: 0
                }
            },
            vertexShader: MC,
            fragmentShader: TC,
            patchMap: {
                "*": {
                    "#include <morphnormal_vertex>": `
					#ifdef USE_MORPHNORMALS
						// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
						// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
						// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
						objectNormal *= morphTargetBaseInfluence;

						for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
							objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * u_InflationStrength * distanceFromMouse;
							objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * animateIn * 0.85;
						}

					#endif
					`,
                    "#include <morphtarget_vertex>": `
					#ifdef USE_MORPHTARGETS
						// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
						// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
						// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
						transformed *= morphTargetBaseInfluence;

						for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
							transformed += getMorph( gl_VertexID, i, 0 ).xyz * u_InflationStrength * distanceFromMouse;
							transformed += getMorph( gl_VertexID, i, 0 ).xyz * animateIn * 0.85;
						}
				#endif
					`
                }
            }
        }), Xu.add(gs), ju = t.scene.getObjectByName("Hover"), ju.material = new Gr({
            color: 16777215,
            visible: !1
        }), gs.add(ju)
    }

    function RC() {
        Ap = new qv
    }

    function PC(r, e) {
        Lr = r, _s = e, vo = Lr >= 768, Vi.position.z = vo ? 2.6 : 2.3, Vi.aspect = Lr / _s, Vi.updateProjectionMatrix(), ql.setSize(Lr, _s, !1)
    }

    function FC(r) {
        ql.setPixelRatio(Math.min(r, 1))
    }

    function LC() {
        Ap.setFromCamera(new pt(Xo(Cp).x, Xo(Cp).y), Vi);
        const r = Ap.intersectObject(ju);
        qE(qu, r.length > 0), r.length && gs.material.uniforms.u_MousePosition.value.set(r[0].point.x, r[0].point.y)
    }

    function IC(r, e) {
        Yu.to(Xo(Cp), {
            x: () => r / Lr * 2 - 1,
            y: () => e / _s * -2 + 1,
            duration: .8,
            ease: "elastic.out(2, 0.45)",
            overwrite: !0
        }), Yu.to(wp, {
            x: () => (r / Lr * 2 - 1) * (vo ? .8 : .3),
            y: () => (e / _s * -2 + 1) * (vo ? .8 : .3),
            duration: .4,
            ease: "power2.out",
            overwrite: !0
        }), Xo(qu) && self.postMessage({
            mousemove: !0
        }), !Xo(qu) && self.postMessage({
            mouseleave: !0
        })
    }

    function NC(r) {
        r ? OC() : Yl.rotation.y = 0
    }

    function OC() {
        Yu.fromTo(gs.material.uniforms.u_AnimateIn, {
            value: 0
        }, {
            value: 1,
            duration: 2.5,
            ease: "power3.out",
            overwrite: !0
        })
    }

    function UC(r) {
        Yl.rotation.y = -(r * .0035)
    }
})();