(function() {
    "use strict";
    /**
     * @license
     * Copyright 2010-2025 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const Jl = "177",
        Dg = "attached",
        Ly = "detached",
        ss = "",
        Jt = "srgb",
        Dn = "srgb-linear",
        Zl = "linear",
        Rt = "srgb",
        Cg = "300 es";
    let Oa = class {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
        }
        hasEventListener(e, t) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
        }
        removeEventListener(e, t) {
            const n = this._listeners;
            if (n === void 0) return;
            const i = n[e];
            if (i !== void 0) {
                const s = i.indexOf(t);
                s !== -1 && i.splice(s, 1)
            }
        }
        dispatchEvent(e) {
            const t = this._listeners;
            if (t === void 0) return;
            const n = t[e.type];
            if (n !== void 0) {
                e.target = this;
                const i = n.slice(0);
                for (let s = 0, a = i.length; s < a; s++) i[s].call(this, e);
                e.target = null
            }
        }
    };
    const Cn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    let Rg = 1234567;
    const uc = Math.PI / 180,
        Ba = 180 / Math.PI;

    function Wi() {
        const r = Math.random() * 4294967295 | 0,
            e = Math.random() * 4294967295 | 0,
            t = Math.random() * 4294967295 | 0,
            n = Math.random() * 4294967295 | 0;
        return (Cn[r & 255] + Cn[r >> 8 & 255] + Cn[r >> 16 & 255] + Cn[r >> 24 & 255] + "-" + Cn[e & 255] + Cn[e >> 8 & 255] + "-" + Cn[e >> 16 & 15 | 64] + Cn[e >> 24 & 255] + "-" + Cn[t & 63 | 128] + Cn[t >> 8 & 255] + "-" + Cn[t >> 16 & 255] + Cn[t >> 24 & 255] + Cn[n & 255] + Cn[n >> 8 & 255] + Cn[n >> 16 & 255] + Cn[n >> 24 & 255]).toLowerCase()
    }

    function ht(r, e, t) {
        return Math.max(e, Math.min(t, r))
    }

    function xh(r, e) {
        return (r % e + e) % e
    }

    function Ny(r, e, t, n, i) {
        return n + (r - e) * (i - n) / (t - e)
    }

    function Uy(r, e, t) {
        return r !== e ? (t - r) / (e - r) : 0
    }

    function fc(r, e, t) {
        return (1 - t) * r + t * e
    }

    function Oy(r, e, t, n) {
        return fc(r, e, 1 - Math.exp(-t * n))
    }

    function By(r, e = 1) {
        return e - Math.abs(xh(r, e * 2) - e)
    }

    function ky(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r))
    }

    function zy(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10))
    }

    function Gy(r, e) {
        return r + Math.floor(Math.random() * (e - r + 1))
    }

    function Hy(r, e) {
        return r + Math.random() * (e - r)
    }

    function Vy(r) {
        return r * (.5 - Math.random())
    }

    function Wy(r) {
        r !== void 0 && (Rg = r);
        let e = Rg += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
    }

    function Xy(r) {
        return r * uc
    }

    function jy(r) {
        return r * Ba
    }

    function qy(r) {
        return (r & r - 1) === 0 && r !== 0
    }

    function Yy(r) {
        return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
    }

    function $y(r) {
        return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
    }

    function Ky(r, e, t, n, i) {
        const s = Math.cos,
            a = Math.sin,
            o = s(t / 2),
            c = a(t / 2),
            l = s((e + n) / 2),
            f = a((e + n) / 2),
            h = s((e - n) / 2),
            d = a((e - n) / 2),
            u = s((n - e) / 2),
            _ = a((n - e) / 2);
        switch (i) {
            case "XYX":
                r.set(o * f, c * h, c * d, o * l);
                break;
            case "YZY":
                r.set(c * d, o * f, c * h, o * l);
                break;
            case "ZXZ":
                r.set(c * h, c * d, o * f, o * l);
                break;
            case "XZX":
                r.set(o * f, c * _, c * u, o * l);
                break;
            case "YXY":
                r.set(c * u, o * f, c * _, o * l);
                break;
            case "ZYZ":
                r.set(c * _, c * u, o * f, o * l);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
        }
    }

    function Xi(r, e) {
        switch (e.constructor) {
            case Float32Array:
                return r;
            case Uint32Array:
                return r / 4294967295;
            case Uint16Array:
                return r / 65535;
            case Uint8Array:
                return r / 255;
            case Int32Array:
                return Math.max(r / 2147483647, -1);
            case Int16Array:
                return Math.max(r / 32767, -1);
            case Int8Array:
                return Math.max(r / 127, -1);
            default:
                throw new Error("Invalid component type.")
        }
    }

    function At(r, e) {
        switch (e.constructor) {
            case Float32Array:
                return r;
            case Uint32Array:
                return Math.round(r * 4294967295);
            case Uint16Array:
                return Math.round(r * 65535);
            case Uint8Array:
                return Math.round(r * 255);
            case Int32Array:
                return Math.round(r * 2147483647);
            case Int16Array:
                return Math.round(r * 32767);
            case Int8Array:
                return Math.round(r * 127);
            default:
                throw new Error("Invalid component type.")
        }
    }
    const Jy = {
        DEG2RAD: uc,
        RAD2DEG: Ba,
        generateUUID: Wi,
        clamp: ht,
        euclideanModulo: xh,
        mapLinear: Ny,
        inverseLerp: Uy,
        lerp: fc,
        damp: Oy,
        pingpong: By,
        smoothstep: ky,
        smootherstep: zy,
        randInt: Gy,
        randFloat: Hy,
        randFloatSpread: Vy,
        seededRandom: Wy,
        degToRad: Xy,
        radToDeg: jy,
        isPowerOfTwo: qy,
        ceilPowerOfTwo: Yy,
        floorPowerOfTwo: $y,
        setQuaternionFromProperEuler: Ky,
        normalize: At,
        denormalize: Xi
    };
    class at {
        constructor(e = 0, t = 0) {
            at.prototype.isVector2 = !0, this.x = e, this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e, this.y = t, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }
        clamp(e, t) {
            return this.x = ht(this.x, e.x, t.x), this.y = ht(this.y, e.y, t.y), this
        }
        clampScalar(e, t) {
            return this.x = ht(this.x, e, t), this.y = ht(this.y, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(ht(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(ht(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this
        }
        rotateAround(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                s = this.x - e.x,
                a = this.y - e.y;
            return this.x = s * n - a * i + e.x, this.y = s * i + a * n + e.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class as {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
        }
        static slerpFlat(e, t, n, i, s, a, o) {
            let c = n[i + 0],
                l = n[i + 1],
                f = n[i + 2],
                h = n[i + 3];
            const d = s[a + 0],
                u = s[a + 1],
                _ = s[a + 2],
                g = s[a + 3];
            if (o === 0) {
                e[t + 0] = c, e[t + 1] = l, e[t + 2] = f, e[t + 3] = h;
                return
            }
            if (o === 1) {
                e[t + 0] = d, e[t + 1] = u, e[t + 2] = _, e[t + 3] = g;
                return
            }
            if (h !== g || c !== d || l !== u || f !== _) {
                let m = 1 - o;
                const p = c * d + l * u + f * _ + h * g,
                    v = p >= 0 ? 1 : -1,
                    x = 1 - p * p;
                if (x > Number.EPSILON) {
                    const S = Math.sqrt(x),
                        E = Math.atan2(S, p * v);
                    m = Math.sin(m * E) / S, o = Math.sin(o * E) / S
                }
                const b = o * v;
                if (c = c * m + d * b, l = l * m + u * b, f = f * m + _ * b, h = h * m + g * b, m === 1 - o) {
                    const S = 1 / Math.sqrt(c * c + l * l + f * f + h * h);
                    c *= S, l *= S, f *= S, h *= S
                }
            }
            e[t] = c, e[t + 1] = l, e[t + 2] = f, e[t + 3] = h
        }
        static multiplyQuaternionsFlat(e, t, n, i, s, a) {
            const o = n[i],
                c = n[i + 1],
                l = n[i + 2],
                f = n[i + 3],
                h = s[a],
                d = s[a + 1],
                u = s[a + 2],
                _ = s[a + 3];
            return e[t] = o * _ + f * h + c * u - l * d, e[t + 1] = c * _ + f * d + l * h - o * u, e[t + 2] = l * _ + f * u + o * d - c * h, e[t + 3] = f * _ - o * h - c * d - l * u, e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e, this._onChangeCallback()
        }
        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        }
        setFromEuler(e, t = !0) {
            const n = e._x,
                i = e._y,
                s = e._z,
                a = e._order,
                o = Math.cos,
                c = Math.sin,
                l = o(n / 2),
                f = o(i / 2),
                h = o(s / 2),
                d = c(n / 2),
                u = c(i / 2),
                _ = c(s / 2);
            switch (a) {
                case "XYZ":
                    this._x = d * f * h + l * u * _, this._y = l * u * h - d * f * _, this._z = l * f * _ + d * u * h, this._w = l * f * h - d * u * _;
                    break;
                case "YXZ":
                    this._x = d * f * h + l * u * _, this._y = l * u * h - d * f * _, this._z = l * f * _ - d * u * h, this._w = l * f * h + d * u * _;
                    break;
                case "ZXY":
                    this._x = d * f * h - l * u * _, this._y = l * u * h + d * f * _, this._z = l * f * _ + d * u * h, this._w = l * f * h - d * u * _;
                    break;
                case "ZYX":
                    this._x = d * f * h - l * u * _, this._y = l * u * h + d * f * _, this._z = l * f * _ - d * u * h, this._w = l * f * h + d * u * _;
                    break;
                case "YZX":
                    this._x = d * f * h + l * u * _, this._y = l * u * h + d * f * _, this._z = l * f * _ - d * u * h, this._w = l * f * h - d * u * _;
                    break;
                case "XZY":
                    this._x = d * f * h - l * u * _, this._y = l * u * h - d * f * _, this._z = l * f * _ + d * u * h, this._w = l * f * h + d * u * _;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return t === !0 && this._onChangeCallback(), this
        }
        setFromAxisAngle(e, t) {
            const n = t / 2,
                i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(e) {
            const t = e.elements,
                n = t[0],
                i = t[4],
                s = t[8],
                a = t[1],
                o = t[5],
                c = t[9],
                l = t[2],
                f = t[6],
                h = t[10],
                d = n + o + h;
            if (d > 0) {
                const u = .5 / Math.sqrt(d + 1);
                this._w = .25 / u, this._x = (f - c) * u, this._y = (s - l) * u, this._z = (a - i) * u
            } else if (n > o && n > h) {
                const u = 2 * Math.sqrt(1 + n - o - h);
                this._w = (f - c) / u, this._x = .25 * u, this._y = (i + a) / u, this._z = (s + l) / u
            } else if (o > h) {
                const u = 2 * Math.sqrt(1 + o - n - h);
                this._w = (s - l) / u, this._x = (i + a) / u, this._y = .25 * u, this._z = (c + f) / u
            } else {
                const u = 2 * Math.sqrt(1 + h - n - o);
                this._w = (a - i) / u, this._x = (s + l) / u, this._y = (c + f) / u, this._z = .25 * u
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(ht(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (n === 0) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            const n = e._x,
                i = e._y,
                s = e._z,
                a = e._w,
                o = t._x,
                c = t._y,
                l = t._z,
                f = t._w;
            return this._x = n * f + a * o + i * l - s * c, this._y = i * f + a * c + s * o - n * l, this._z = s * f + a * l + n * c - i * o, this._w = a * f - n * o - i * c - s * l, this._onChangeCallback(), this
        }
        slerp(e, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(e);
            const n = this._x,
                i = this._y,
                s = this._z,
                a = this._w;
            let o = a * e._w + n * e._x + i * e._y + s * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = s, this;
            const c = 1 - o * o;
            if (c <= Number.EPSILON) {
                const u = 1 - t;
                return this._w = u * a + t * this._w, this._x = u * n + t * this._x, this._y = u * i + t * this._y, this._z = u * s + t * this._z, this.normalize(), this
            }
            const l = Math.sqrt(c),
                f = Math.atan2(l, o),
                h = Math.sin((1 - t) * f) / l,
                d = Math.sin(t * f) / l;
            return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n)
        }
        random() {
            const e = 2 * Math.PI * Math.random(),
                t = 2 * Math.PI * Math.random(),
                n = Math.random(),
                i = Math.sqrt(1 - n),
                s = Math.sqrt(n);
            return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    }
    class B {
        constructor(e = 0, t = 0, n = 0) {
            B.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }
        applyEuler(e) {
            return this.applyQuaternion(Pg.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(Pg.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements;
            return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements,
                a = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
            return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * a, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * a, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * a, this
        }
        applyQuaternion(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.x,
                a = e.y,
                o = e.z,
                c = e.w,
                l = 2 * (a * i - o * n),
                f = 2 * (o * t - s * i),
                h = 2 * (s * n - a * t);
            return this.x = t + c * l + a * h - o * f, this.y = n + c * f + o * l - s * h, this.z = i + c * h + s * f - a * l, this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = e.elements;
            return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize()
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }
        clamp(e, t) {
            return this.x = ht(this.x, e.x, t.x), this.y = ht(this.y, e.y, t.y), this.z = ht(this.z, e.z, t.z), this
        }
        clampScalar(e, t) {
            return this.x = ht(this.x, e, t), this.y = ht(this.y, e, t), this.z = ht(this.z, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(ht(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
        }
        cross(e) {
            return this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            const n = e.x,
                i = e.y,
                s = e.z,
                a = t.x,
                o = t.y,
                c = t.z;
            return this.x = i * c - s * o, this.y = s * a - n * c, this.z = n * o - i * a, this
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (t === 0) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return vh.copy(this).projectOnVector(e), this.sub(vh)
        }
        reflect(e) {
            return this.sub(vh.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(ht(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y,
                i = this.z - e.z;
            return t * t + n * n + i * i
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3)
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2,
                t = Math.random() * 2 - 1,
                n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    const vh = new B,
        Pg = new as;
    class ct {
        constructor(e, t, n, i, s, a, o, c, l) {
            ct.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, a, o, c, l)
        }
        set(e, t, n, i, s, a, o, c, l) {
            const f = this.elements;
            return f[0] = e, f[1] = i, f[2] = o, f[3] = t, f[4] = s, f[5] = c, f[6] = n, f[7] = a, f[8] = l, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                s = this.elements,
                a = n[0],
                o = n[3],
                c = n[6],
                l = n[1],
                f = n[4],
                h = n[7],
                d = n[2],
                u = n[5],
                _ = n[8],
                g = i[0],
                m = i[3],
                p = i[6],
                v = i[1],
                x = i[4],
                b = i[7],
                S = i[2],
                E = i[5],
                T = i[8];
            return s[0] = a * g + o * v + c * S, s[3] = a * m + o * x + c * E, s[6] = a * p + o * b + c * T, s[1] = l * g + f * v + h * S, s[4] = l * m + f * x + h * E, s[7] = l * p + f * b + h * T, s[2] = d * g + u * v + _ * S, s[5] = d * m + u * x + _ * E, s[8] = d * p + u * b + _ * T, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                c = e[6],
                l = e[7],
                f = e[8];
            return t * a * f - t * o * l - n * s * f + n * o * c + i * s * l - i * a * c
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                c = e[6],
                l = e[7],
                f = e[8],
                h = f * a - o * l,
                d = o * c - f * s,
                u = l * s - a * c,
                _ = t * h + n * d + i * u;
            if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const g = 1 / _;
            return e[0] = h * g, e[1] = (i * l - f * n) * g, e[2] = (o * n - i * a) * g, e[3] = d * g, e[4] = (f * t - i * c) * g, e[5] = (i * s - o * t) * g, e[6] = u * g, e[7] = (n * c - l * t) * g, e[8] = (a * t - n * s) * g, this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }
        setUvTransform(e, t, n, i, s, a, o) {
            const c = Math.cos(s),
                l = Math.sin(s);
            return this.set(n * c, n * l, -n * (c * a + l * o) + a + e, -i * l, i * c, -i * (-l * a + c * o) + o + t, 0, 0, 1), this
        }
        scale(e, t) {
            return this.premultiply(yh.makeScale(e, t)), this
        }
        rotate(e) {
            return this.premultiply(yh.makeRotation(-e)), this
        }
        translate(e, t) {
            return this.premultiply(yh.makeTranslation(e, t)), this
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
        }
        makeRotation(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let i = 0; i < 9; i++)
                if (t[i] !== n[i]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
        clone() {
            return new this.constructor().fromArray(this.elements)
        }
    }
    const yh = new ct;

    function Fg(r) {
        for (let e = r.length - 1; e >= 0; --e)
            if (r[e] >= 65535) return !0;
        return !1
    }

    function hc(r) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", r)
    }

    function Zy() {
        const r = hc("canvas");
        return r.style.display = "block", r
    }
    const Ig = {};

    function ka(r) {
        r in Ig || (Ig[r] = !0, console.warn(r))
    }

    function Qy(r, e, t) {
        return new Promise(function(n, i) {
            function s() {
                switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                    case r.WAIT_FAILED:
                        i();
                        break;
                    case r.TIMEOUT_EXPIRED:
                        setTimeout(s, t);
                        break;
                    default:
                        n()
                }
            }
            setTimeout(s, t)
        })
    }

    function eS(r) {
        const e = r.elements;
        e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15]
    }

    function tS(r) {
        const e = r.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1)
    }
    const Lg = new ct().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
        Ng = new ct().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);

    function nS() {
        const r = {
                enabled: !0,
                workingColorSpace: Dn,
                spaces: {},
                convert: function(i, s, a) {
                    return this.enabled === !1 || s === a || !s || !a || (this.spaces[s].transfer === Rt && (i.r = Ar(i.r), i.g = Ar(i.g), i.b = Ar(i.b)), this.spaces[s].primaries !== this.spaces[a].primaries && (i.applyMatrix3(this.spaces[s].toXYZ), i.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === Rt && (i.r = za(i.r), i.g = za(i.g), i.b = za(i.b))), i
                },
                workingToColorSpace: function(i, s) {
                    return this.convert(i, this.workingColorSpace, s)
                },
                colorSpaceToWorking: function(i, s) {
                    return this.convert(i, s, this.workingColorSpace)
                },
                getPrimaries: function(i) {
                    return this.spaces[i].primaries
                },
                getTransfer: function(i) {
                    return i === ss ? Zl : this.spaces[i].transfer
                },
                getLuminanceCoefficients: function(i, s = this.workingColorSpace) {
                    return i.fromArray(this.spaces[s].luminanceCoefficients)
                },
                define: function(i) {
                    Object.assign(this.spaces, i)
                },
                _getMatrix: function(i, s, a) {
                    return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ)
                },
                _getDrawingBufferColorSpace: function(i) {
                    return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace
                },
                _getUnpackColorSpace: function(i = this.workingColorSpace) {
                    return this.spaces[i].workingColorSpaceConfig.unpackColorSpace
                },
                fromWorkingColorSpace: function(i, s) {
                    return ka("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), r.workingToColorSpace(i, s)
                },
                toWorkingColorSpace: function(i, s) {
                    return ka("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), r.colorSpaceToWorking(i, s)
                }
            },
            e = [.64, .33, .3, .6, .15, .06],
            t = [.2126, .7152, .0722],
            n = [.3127, .329];
        return r.define({
            [Dn]: {
                primaries: e,
                whitePoint: n,
                transfer: Zl,
                toXYZ: Lg,
                fromXYZ: Ng,
                luminanceCoefficients: t,
                workingColorSpaceConfig: {
                    unpackColorSpace: Jt
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Jt
                }
            },
            [Jt]: {
                primaries: e,
                whitePoint: n,
                transfer: Rt,
                toXYZ: Lg,
                fromXYZ: Ng,
                luminanceCoefficients: t,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Jt
                }
            }
        }), r
    }
    const bt = nS();

    function Ar(r) {
        return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
    }

    function za(r) {
        return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
    }
    let Ga;
    class iS {
        static getDataURL(e, t = "image/png") {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
            let n;
            if (e instanceof HTMLCanvasElement) n = e;
            else {
                Ga === void 0 && (Ga = hc("canvas")), Ga.width = e.width, Ga.height = e.height;
                const i = Ga.getContext("2d");
                e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = Ga
            }
            return n.toDataURL(t)
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                const t = hc("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const i = n.getImageData(0, 0, e.width, e.height),
                    s = i.data;
                for (let a = 0; a < s.length; a++) s[a] = Ar(s[a] / 255) * 255;
                return n.putImageData(i, 0, 0), t
            } else if (e.data) {
                const t = e.data.slice(0);
                for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Ar(t[n] / 255) * 255) : t[n] = Ar(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                }
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
        }
    }
    let rS = 0;
    class Sh {
        constructor(e = null) {
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: rS++
            }), this.uuid = Wi(), this.data = e, this.dataReady = !0, this.version = 0
        }
        getSize(e) {
            const t = this.data;
            return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
            const n = {
                    uuid: this.uuid,
                    url: ""
                },
                i = this.data;
            if (i !== null) {
                let s;
                if (Array.isArray(i)) {
                    s = [];
                    for (let a = 0, o = i.length; a < o; a++) i[a].isDataTexture ? s.push(Mh(i[a].image)) : s.push(Mh(i[a]))
                } else s = Mh(i);
                n.url = s
            }
            return t || (e.images[this.uuid] = n), n
        }
    }

    function Mh(r) {
        return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? iS.getDataURL(r) : r.data ? {
            data: Array.from(r.data),
            width: r.width,
            height: r.height,
            type: r.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    let sS = 0;
    const Th = new B;
    class on extends Oa {
        constructor(e = on.DEFAULT_IMAGE, t = on.DEFAULT_MAPPING, n = 1001, i = 1001, s = 1006, a = 1008, o = 1023, c = 1009, l = on.DEFAULT_ANISOTROPY, f = ss) {
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: sS++
            }), this.uuid = Wi(), this.name = "", this.source = new Sh(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new at(0, 0), this.repeat = new at(1, 1), this.center = new at(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ct, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = f, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0
        }
        get width() {
            return this.source.getSize(Th).x
        }
        get height() {
            return this.source.getSize(Th).y
        }
        get depth() {
            return this.source.getSize(Th).z
        }
        get image() {
            return this.source.data
        }
        set image(e = null) {
            this.source.data = e
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
        }
        setValues(e) {
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
                    continue
                }
                i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (this.mapping !== 300) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case 1e3:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case 1001:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case 1e3:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case 1001:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
        set needsUpdate(e) {
            e === !0 && (this.version++, this.source.needsUpdate = !0)
        }
        set needsPMREMUpdate(e) {
            e === !0 && this.pmremVersion++
        }
    }
    on.DEFAULT_IMAGE = null, on.DEFAULT_MAPPING = 300, on.DEFAULT_ANISOTROPY = 1;
    class Tt {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            Tt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setZ(e) {
            return this.z = e, this
        }
        setW(e) {
            return this.w = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }
        applyMatrix4(e) {
            const t = this.x,
                n = this.y,
                i = this.z,
                s = this.w,
                a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * s, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * s, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * s, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * s, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, s;
            const c = e.elements,
                l = c[0],
                f = c[4],
                h = c[8],
                d = c[1],
                u = c[5],
                _ = c[9],
                g = c[2],
                m = c[6],
                p = c[10];
            if (Math.abs(f - d) < .01 && Math.abs(h - g) < .01 && Math.abs(_ - m) < .01) {
                if (Math.abs(f + d) < .1 && Math.abs(h + g) < .1 && Math.abs(_ + m) < .1 && Math.abs(l + u + p - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const x = (l + 1) / 2,
                    b = (u + 1) / 2,
                    S = (p + 1) / 2,
                    E = (f + d) / 4,
                    T = (h + g) / 4,
                    w = (_ + m) / 4;
                return x > b && x > S ? x < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(x), i = E / n, s = T / n) : b > S ? b < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(b), n = E / i, s = w / i) : S < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(S), n = T / s, i = w / s), this.set(n, i, s, t), this
            }
            let v = Math.sqrt((m - _) * (m - _) + (h - g) * (h - g) + (d - f) * (d - f));
            return Math.abs(v) < .001 && (v = 1), this.x = (m - _) / v, this.y = (h - g) / v, this.z = (d - f) / v, this.w = Math.acos((l + u + p - 1) / 2), this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }
        clamp(e, t) {
            return this.x = ht(this.x, e.x, t.x), this.y = ht(this.y, e.y, t.y), this.z = ht(this.z, e.z, t.z), this.w = ht(this.w, e.w, t.w), this
        }
        clampScalar(e, t) {
            return this.x = ht(this.x, e, t), this.y = ht(this.y, e, t), this.z = ht(this.z, e, t), this.w = ht(this.w, e, t), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(ht(n, e, t))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }
    class aS extends Oa {
        constructor(e = 1, t = 1, n = {}) {
            super(), n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: 1006,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
                depth: 1,
                multiview: !1
            }, n), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = n.depth, this.scissor = new Tt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Tt(0, 0, e, t);
            const i = {
                    width: e,
                    height: t,
                    depth: n.depth
                },
                s = new on(i);
            this.textures = [];
            const a = n.count;
            for (let o = 0; o < a; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
            this._setTextureOptions(n), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples, this.multiview = n.multiview
        }
        _setTextureOptions(e = {}) {
            const t = {
                minFilter: 1006,
                generateMipmaps: !1,
                flipY: !1,
                internalFormat: null
            };
            e.mapping !== void 0 && (t.mapping = e.mapping), e.wrapS !== void 0 && (t.wrapS = e.wrapS), e.wrapT !== void 0 && (t.wrapT = e.wrapT), e.wrapR !== void 0 && (t.wrapR = e.wrapR), e.magFilter !== void 0 && (t.magFilter = e.magFilter), e.minFilter !== void 0 && (t.minFilter = e.minFilter), e.format !== void 0 && (t.format = e.format), e.type !== void 0 && (t.type = e.type), e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace), e.flipY !== void 0 && (t.flipY = e.flipY), e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
            for (let n = 0; n < this.textures.length; n++) this.textures[n].setValues(t)
        }
        get texture() {
            return this.textures[0]
        }
        set texture(e) {
            this.textures[0] = e
        }
        set depthTexture(e) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e
        }
        get depthTexture() {
            return this._depthTexture
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for (let i = 0, s = this.textures.length; i < s; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                this.dispose()
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for (let t = 0, n = e.textures.length; t < n; t++) {
                this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                const i = Object.assign({}, e.textures[t].image);
                this.textures[t].source = new Sh(i)
            }
            return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    class Dr extends aS {
        constructor(e = 1, t = 1, n = {}) {
            super(e, t, n), this.isWebGLRenderTarget = !0
        }
    }
    class Ug extends on {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e)
        }
        clearLayerUpdates() {
            this.layerUpdates.clear()
        }
    }
    class oS extends on {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.isData3DTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    class Gt {
        constructor(e = new B(1 / 0, 1 / 0, 1 / 0), t = new B(-1 / 0, -1 / 0, -1 / 0)) {
            this.isBox3 = !0, this.min = e, this.max = t
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }
        setFromArray(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(ji.fromArray(e, t));
            return this
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(ji.fromBufferAttribute(e, t));
            return this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = ji.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (n !== void 0) {
                const s = n.getAttribute("position");
                if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                    for (let a = 0, o = s.count; a < o; a++) e.isMesh === !0 ? e.getVertexPosition(a, ji) : ji.fromBufferAttribute(s, a), ji.applyMatrix4(e.matrixWorld), this.expandByPoint(ji);
                else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Ql.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Ql.copy(n.boundingBox)), Ql.applyMatrix4(e.matrixWorld), this.union(Ql)
            }
            const i = e.children;
            for (let s = 0, a = i.length; s < a; s++) this.expandByObject(i[s], t);
            return this
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, ji), ji.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(dc), eu.subVectors(this.max, dc), Ha.subVectors(e.a, dc), Va.subVectors(e.b, dc), Wa.subVectors(e.c, dc), os.subVectors(Va, Ha), cs.subVectors(Wa, Va), Xs.subVectors(Ha, Wa);
            let t = [0, -os.z, os.y, 0, -cs.z, cs.y, 0, -Xs.z, Xs.y, os.z, 0, -os.x, cs.z, 0, -cs.x, Xs.z, 0, -Xs.x, -os.y, os.x, 0, -cs.y, cs.x, 0, -Xs.y, Xs.x, 0];
            return !Eh(t, Ha, Va, Wa, eu) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Eh(t, Ha, Va, Wa, eu)) ? !1 : (tu.crossVectors(os, cs), t = [tu.x, tu.y, tu.z], Eh(t, Ha, Va, Wa, eu))
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return this.clampPoint(e, ji).distanceTo(e)
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ji).length() * .5), e
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (Cr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Cr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Cr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Cr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Cr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Cr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Cr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Cr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Cr), this)
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
        toJSON() {
            return {
                min: this.min.toArray(),
                max: this.max.toArray()
            }
        }
        fromJSON(e) {
            return this.min.fromArray(e.min), this.max.fromArray(e.max), this
        }
    }
    const Cr = [new B, new B, new B, new B, new B, new B, new B, new B],
        ji = new B,
        Ql = new Gt,
        Ha = new B,
        Va = new B,
        Wa = new B,
        os = new B,
        cs = new B,
        Xs = new B,
        dc = new B,
        eu = new B,
        tu = new B,
        js = new B;

    function Eh(r, e, t, n, i) {
        for (let s = 0, a = r.length - 3; s <= a; s += 3) {
            js.fromArray(r, s);
            const o = i.x * Math.abs(js.x) + i.y * Math.abs(js.y) + i.z * Math.abs(js.z),
                c = e.dot(js),
                l = t.dot(js),
                f = n.dot(js);
            if (Math.max(-Math.max(c, l, f), Math.min(c, l, f)) > o) return !1
        }
        return !0
    }
    const cS = new Gt,
        pc = new B,
        wh = new B;
    class Rn {
        constructor(e = new B, t = -1) {
            this.isSphere = !0, this.center = e, this.radius = t
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this
        }
        setFromPoints(e, t) {
            const n = this.center;
            t !== void 0 ? n.copy(t) : cS.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let s = 0, a = e.length; s < a; s++) i = Math.max(i, n.distanceToSquared(e[s]));
            return this.radius = Math.sqrt(i), this
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }
        translate(e) {
            return this.center.add(e), this
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            pc.subVectors(e, this.center);
            const t = pc.lengthSq();
            if (t > this.radius * this.radius) {
                const n = Math.sqrt(t),
                    i = (n - this.radius) * .5;
                this.center.addScaledVector(pc, i / n), this.radius += i
            }
            return this
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (wh.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(pc.copy(e.center).add(wh)), this.expandByPoint(pc.copy(e.center).sub(wh))), this)
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return new this.constructor().copy(this)
        }
        toJSON() {
            return {
                radius: this.radius,
                center: this.center.toArray()
            }
        }
        fromJSON(e) {
            return this.radius = e.radius, this.center.fromArray(e.center), this
        }
    }
    const Rr = new B,
        Ah = new B,
        nu = new B,
        ls = new B,
        Dh = new B,
        iu = new B,
        Ch = new B;
    class Xa {
        constructor(e = new B, t = new B(0, 0, -1)) {
            this.origin = e, this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }
        recast(e) {
            return this.origin.copy(this.at(e, Rr)), this
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            const t = Rr.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (Rr.copy(this.origin).addScaledVector(this.direction, t), Rr.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, i) {
            Ah.copy(e).add(t).multiplyScalar(.5), nu.copy(t).sub(e).normalize(), ls.copy(this.origin).sub(Ah);
            const s = e.distanceTo(t) * .5,
                a = -this.direction.dot(nu),
                o = ls.dot(this.direction),
                c = -ls.dot(nu),
                l = ls.lengthSq(),
                f = Math.abs(1 - a * a);
            let h, d, u, _;
            if (f > 0)
                if (h = a * c - o, d = a * o - c, _ = s * f, h >= 0)
                    if (d >= -_)
                        if (d <= _) {
                            const g = 1 / f;
                            h *= g, d *= g, u = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * c) + l
                        } else d = s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * c) + l;
            else d = -s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * c) + l;
            else d <= -_ ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -c), s), u = -h * h + d * (d + 2 * c) + l) : d <= _ ? (h = 0, d = Math.min(Math.max(-s, -c), s), u = d * (d + 2 * c) + l) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -c), s), u = -h * h + d * (d + 2 * c) + l);
            else d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), u = -h * h + d * (d + 2 * c) + l;
            return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(Ah).addScaledVector(nu, d), u
        }
        intersectSphere(e, t) {
            Rr.subVectors(e.center, this.origin);
            const n = Rr.dot(this.direction),
                i = Rr.dot(Rr) - n * n,
                s = e.radius * e.radius;
            if (i > s) return null;
            const a = Math.sqrt(s - i),
                o = n - a,
                c = n + a;
            return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t)
        }
        intersectsSphere(e) {
            return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, i, s, a, o, c;
            const l = 1 / this.direction.x,
                f = 1 / this.direction.y,
                h = 1 / this.direction.z,
                d = this.origin;
            return l >= 0 ? (n = (e.min.x - d.x) * l, i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, i = (e.min.x - d.x) * l), f >= 0 ? (s = (e.min.y - d.y) * f, a = (e.max.y - d.y) * f) : (s = (e.max.y - d.y) * f, a = (e.min.y - d.y) * f), n > a || s > i || ((s > n || isNaN(n)) && (n = s), (a < i || isNaN(i)) && (i = a), h >= 0 ? (o = (e.min.z - d.z) * h, c = (e.max.z - d.z) * h) : (o = (e.max.z - d.z) * h, c = (e.min.z - d.z) * h), n > c || o > i) || ((o > n || n !== n) && (n = o), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, t)
        }
        intersectsBox(e) {
            return this.intersectBox(e, Rr) !== null
        }
        intersectTriangle(e, t, n, i, s) {
            Dh.subVectors(t, e), iu.subVectors(n, e), Ch.crossVectors(Dh, iu);
            let a = this.direction.dot(Ch),
                o;
            if (a > 0) {
                if (i) return null;
                o = 1
            } else if (a < 0) o = -1, a = -a;
            else return null;
            ls.subVectors(this.origin, e);
            const c = o * this.direction.dot(iu.crossVectors(ls, iu));
            if (c < 0) return null;
            const l = o * this.direction.dot(Dh.cross(ls));
            if (l < 0 || c + l > a) return null;
            const f = -o * ls.dot(Ch);
            return f < 0 ? null : this.at(f / a, s)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    class Ke {
        constructor(e, t, n, i, s, a, o, c, l, f, h, d, u, _, g, m) {
            Ke.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, a, o, c, l, f, h, d, u, _, g, m)
        }
        set(e, t, n, i, s, a, o, c, l, f, h, d, u, _, g, m) {
            const p = this.elements;
            return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = s, p[5] = a, p[9] = o, p[13] = c, p[2] = l, p[6] = f, p[10] = h, p[14] = d, p[3] = u, p[7] = _, p[11] = g, p[15] = m, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return new Ke().fromArray(this.elements)
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        }
        copyPosition(e) {
            const t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(e) {
            const t = this.elements,
                n = e.elements,
                i = 1 / ja.setFromMatrixColumn(e, 0).length(),
                s = 1 / ja.setFromMatrixColumn(e, 1).length(),
                a = 1 / ja.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromEuler(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z,
                a = Math.cos(n),
                o = Math.sin(n),
                c = Math.cos(i),
                l = Math.sin(i),
                f = Math.cos(s),
                h = Math.sin(s);
            if (e.order === "XYZ") {
                const d = a * f,
                    u = a * h,
                    _ = o * f,
                    g = o * h;
                t[0] = c * f, t[4] = -c * h, t[8] = l, t[1] = u + _ * l, t[5] = d - g * l, t[9] = -o * c, t[2] = g - d * l, t[6] = _ + u * l, t[10] = a * c
            } else if (e.order === "YXZ") {
                const d = c * f,
                    u = c * h,
                    _ = l * f,
                    g = l * h;
                t[0] = d + g * o, t[4] = _ * o - u, t[8] = a * l, t[1] = a * h, t[5] = a * f, t[9] = -o, t[2] = u * o - _, t[6] = g + d * o, t[10] = a * c
            } else if (e.order === "ZXY") {
                const d = c * f,
                    u = c * h,
                    _ = l * f,
                    g = l * h;
                t[0] = d - g * o, t[4] = -a * h, t[8] = _ + u * o, t[1] = u + _ * o, t[5] = a * f, t[9] = g - d * o, t[2] = -a * l, t[6] = o, t[10] = a * c
            } else if (e.order === "ZYX") {
                const d = a * f,
                    u = a * h,
                    _ = o * f,
                    g = o * h;
                t[0] = c * f, t[4] = _ * l - u, t[8] = d * l + g, t[1] = c * h, t[5] = g * l + d, t[9] = u * l - _, t[2] = -l, t[6] = o * c, t[10] = a * c
            } else if (e.order === "YZX") {
                const d = a * c,
                    u = a * l,
                    _ = o * c,
                    g = o * l;
                t[0] = c * f, t[4] = g - d * h, t[8] = _ * h + u, t[1] = h, t[5] = a * f, t[9] = -o * f, t[2] = -l * f, t[6] = u * h + _, t[10] = d - g * h
            } else if (e.order === "XZY") {
                const d = a * c,
                    u = a * l,
                    _ = o * c,
                    g = o * l;
                t[0] = c * f, t[4] = -h, t[8] = l * f, t[1] = d * h + g, t[5] = a * f, t[9] = u * h - _, t[2] = _ * h - u, t[6] = o * f, t[10] = g * h + d
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(lS, e, uS)
        }
        lookAt(e, t, n) {
            const i = this.elements;
            return hi.subVectors(e, t), hi.lengthSq() === 0 && (hi.z = 1), hi.normalize(), us.crossVectors(n, hi), us.lengthSq() === 0 && (Math.abs(n.z) === 1 ? hi.x += 1e-4 : hi.z += 1e-4, hi.normalize(), us.crossVectors(n, hi)), us.normalize(), ru.crossVectors(hi, us), i[0] = us.x, i[4] = ru.x, i[8] = hi.x, i[1] = us.y, i[5] = ru.y, i[9] = hi.y, i[2] = us.z, i[6] = ru.z, i[10] = hi.z, this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                i = t.elements,
                s = this.elements,
                a = n[0],
                o = n[4],
                c = n[8],
                l = n[12],
                f = n[1],
                h = n[5],
                d = n[9],
                u = n[13],
                _ = n[2],
                g = n[6],
                m = n[10],
                p = n[14],
                v = n[3],
                x = n[7],
                b = n[11],
                S = n[15],
                E = i[0],
                T = i[4],
                w = i[8],
                M = i[12],
                y = i[1],
                D = i[5],
                R = i[9],
                P = i[13],
                O = i[2],
                z = i[6],
                k = i[10],
                X = i[14],
                V = i[3],
                H = i[7],
                L = i[11],
                se = i[15];
            return s[0] = a * E + o * y + c * O + l * V, s[4] = a * T + o * D + c * z + l * H, s[8] = a * w + o * R + c * k + l * L, s[12] = a * M + o * P + c * X + l * se, s[1] = f * E + h * y + d * O + u * V, s[5] = f * T + h * D + d * z + u * H, s[9] = f * w + h * R + d * k + u * L, s[13] = f * M + h * P + d * X + u * se, s[2] = _ * E + g * y + m * O + p * V, s[6] = _ * T + g * D + m * z + p * H, s[10] = _ * w + g * R + m * k + p * L, s[14] = _ * M + g * P + m * X + p * se, s[3] = v * E + x * y + b * O + S * V, s[7] = v * T + x * D + b * z + S * H, s[11] = v * w + x * R + b * k + S * L, s[15] = v * M + x * P + b * X + S * se, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[4],
                i = e[8],
                s = e[12],
                a = e[1],
                o = e[5],
                c = e[9],
                l = e[13],
                f = e[2],
                h = e[6],
                d = e[10],
                u = e[14],
                _ = e[3],
                g = e[7],
                m = e[11],
                p = e[15];
            return _ * (+s * c * h - i * l * h - s * o * d + n * l * d + i * o * u - n * c * u) + g * (+t * c * u - t * l * d + s * a * d - i * a * u + i * l * f - s * c * f) + m * (+t * l * h - t * o * u - s * a * h + n * a * u + s * o * f - n * l * f) + p * (-i * o * f - t * c * h + t * o * d + i * a * h - n * a * d + n * c * f)
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        }
        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                c = e[6],
                l = e[7],
                f = e[8],
                h = e[9],
                d = e[10],
                u = e[11],
                _ = e[12],
                g = e[13],
                m = e[14],
                p = e[15],
                v = h * m * l - g * d * l + g * c * u - o * m * u - h * c * p + o * d * p,
                x = _ * d * l - f * m * l - _ * c * u + a * m * u + f * c * p - a * d * p,
                b = f * g * l - _ * h * l + _ * o * u - a * g * u - f * o * p + a * h * p,
                S = _ * h * c - f * g * c - _ * o * d + a * g * d + f * o * m - a * h * m,
                E = t * v + n * x + i * b + s * S;
            if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const T = 1 / E;
            return e[0] = v * T, e[1] = (g * d * s - h * m * s - g * i * u + n * m * u + h * i * p - n * d * p) * T, e[2] = (o * m * s - g * c * s + g * i * l - n * m * l - o * i * p + n * c * p) * T, e[3] = (h * c * s - o * d * s - h * i * l + n * d * l + o * i * u - n * c * u) * T, e[4] = x * T, e[5] = (f * m * s - _ * d * s + _ * i * u - t * m * u - f * i * p + t * d * p) * T, e[6] = (_ * c * s - a * m * s - _ * i * l + t * m * l + a * i * p - t * c * p) * T, e[7] = (a * d * s - f * c * s + f * i * l - t * d * l - a * i * u + t * c * u) * T, e[8] = b * T, e[9] = (_ * h * s - f * g * s - _ * n * u + t * g * u + f * n * p - t * h * p) * T, e[10] = (a * g * s - _ * o * s + _ * n * l - t * g * l - a * n * p + t * o * p) * T, e[11] = (f * o * s - a * h * s - f * n * l + t * h * l + a * n * u - t * o * u) * T, e[12] = S * T, e[13] = (f * g * i - _ * h * i + _ * n * d - t * g * d - f * n * m + t * h * m) * T, e[14] = (_ * o * i - a * g * i - _ * n * c + t * g * c + a * n * m - t * o * m) * T, e[15] = (a * h * i - f * o * i + f * n * c - t * h * c - a * n * d + t * o * d) * T, this
        }
        scale(e) {
            const t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this
        }
        getMaxScaleOnAxis() {
            const e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        }
        makeRotationY(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(e) {
            const t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t),
                i = Math.sin(t),
                s = 1 - n,
                a = e.x,
                o = e.y,
                c = e.z,
                l = s * a,
                f = s * o;
            return this.set(l * a + n, l * o - i * c, l * c + i * o, 0, l * o + i * c, f * o + n, f * c - i * a, 0, l * c - i * o, f * c + i * a, s * c * c + n, 0, 0, 0, 0, 1), this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(e, t, n, i, s, a) {
            return this.set(1, n, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(e, t, n) {
            const i = this.elements,
                s = t._x,
                a = t._y,
                o = t._z,
                c = t._w,
                l = s + s,
                f = a + a,
                h = o + o,
                d = s * l,
                u = s * f,
                _ = s * h,
                g = a * f,
                m = a * h,
                p = o * h,
                v = c * l,
                x = c * f,
                b = c * h,
                S = n.x,
                E = n.y,
                T = n.z;
            return i[0] = (1 - (g + p)) * S, i[1] = (u + b) * S, i[2] = (_ - x) * S, i[3] = 0, i[4] = (u - b) * E, i[5] = (1 - (d + p)) * E, i[6] = (m + v) * E, i[7] = 0, i[8] = (_ + x) * T, i[9] = (m - v) * T, i[10] = (1 - (d + g)) * T, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
        }
        decompose(e, t, n) {
            const i = this.elements;
            let s = ja.set(i[0], i[1], i[2]).length();
            const a = ja.set(i[4], i[5], i[6]).length(),
                o = ja.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], qi.copy(this);
            const l = 1 / s,
                f = 1 / a,
                h = 1 / o;
            return qi.elements[0] *= l, qi.elements[1] *= l, qi.elements[2] *= l, qi.elements[4] *= f, qi.elements[5] *= f, qi.elements[6] *= f, qi.elements[8] *= h, qi.elements[9] *= h, qi.elements[10] *= h, t.setFromRotationMatrix(qi), n.x = s, n.y = a, n.z = o, this
        }
        makePerspective(e, t, n, i, s, a, o = 2e3) {
            const c = this.elements,
                l = 2 * s / (t - e),
                f = 2 * s / (n - i),
                h = (t + e) / (t - e),
                d = (n + i) / (n - i);
            let u, _;
            if (o === 2e3) u = -(a + s) / (a - s), _ = -2 * a * s / (a - s);
            else if (o === 2001) u = -a / (a - s), _ = -a * s / (a - s);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            return c[0] = l, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = f, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = u, c[14] = _, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this
        }
        makeOrthographic(e, t, n, i, s, a, o = 2e3) {
            const c = this.elements,
                l = 1 / (t - e),
                f = 1 / (n - i),
                h = 1 / (a - s),
                d = (t + e) * l,
                u = (n + i) * f;
            let _, g;
            if (o === 2e3) _ = (a + s) * h, g = -2 * h;
            else if (o === 2001) _ = s * h, g = -1 * h;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * f, c[9] = 0, c[13] = -u, c[2] = 0, c[6] = 0, c[10] = g, c[14] = -_, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let i = 0; i < 16; i++)
                if (t[i] !== n[i]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }
    const ja = new B,
        qi = new Ke,
        lS = new B(0, 0, 0),
        uS = new B(1, 1, 1),
        us = new B,
        ru = new B,
        hi = new B,
        Og = new Ke,
        Bg = new as;
    class lr {
        constructor(e = 0, t = 0, n = 0, i = lr.DEFAULT_ORDER) {
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e, this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._onChangeCallback()
        }
        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements,
                s = i[0],
                a = i[4],
                o = i[8],
                c = i[1],
                l = i[5],
                f = i[9],
                h = i[2],
                d = i[6],
                u = i[10];
            switch (t) {
                case "XYZ":
                    this._y = Math.asin(ht(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-f, u), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-ht(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(o, u), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(ht(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, s));
                    break;
                case "ZYX":
                    this._y = Math.asin(-ht(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(ht(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-f, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, u));
                    break;
                case "XZY":
                    this._z = Math.asin(-ht(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-f, u), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t, n === !0 && this._onChangeCallback(), this
        }
        setFromQuaternion(e, t, n) {
            return Og.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Og, t, n)
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t)
        }
        reorder(e) {
            return Bg.setFromEuler(this), this.setFromQuaternion(Bg, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }
        _onChange(e) {
            return this._onChangeCallback = e, this
        }
        _onChangeCallback() {}*[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order
        }
    }
    lr.DEFAULT_ORDER = "XYZ";
    class Rh {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return (this.mask & e.mask) !== 0
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0
        }
    }
    let fS = 0;
    const kg = new B,
        qa = new as,
        Pr = new Ke,
        su = new B,
        mc = new B,
        hS = new B,
        dS = new as,
        zg = new B(1, 0, 0),
        Gg = new B(0, 1, 0),
        Hg = new B(0, 0, 1),
        Vg = {
            type: "added"
        },
        pS = {
            type: "removed"
        },
        Ya = {
            type: "childadded",
            child: null
        },
        Ph = {
            type: "childremoved",
            child: null
        };
    class Ht extends Oa {
        constructor() {
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: fS++
            }), this.uuid = Wi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ht.DEFAULT_UP.clone();
            const e = new B,
                t = new lr,
                n = new as,
                i = new B(1, 1, 1);

            function s() {
                n.setFromEuler(t, !1)
            }

            function a() {
                t.setFromQuaternion(n, void 0, !1)
            }
            t._onChange(s), n._onChange(a), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new Ke
                },
                normalMatrix: {
                    value: new ct
                }
            }), this.matrix = new Ke, this.matrixWorld = new Ke, this.matrixAutoUpdate = Ht.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Rh, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }
        rotateOnAxis(e, t) {
            return qa.setFromAxisAngle(e, t), this.quaternion.multiply(qa), this
        }
        rotateOnWorldAxis(e, t) {
            return qa.setFromAxisAngle(e, t), this.quaternion.premultiply(qa), this
        }
        rotateX(e) {
            return this.rotateOnAxis(zg, e)
        }
        rotateY(e) {
            return this.rotateOnAxis(Gg, e)
        }
        rotateZ(e) {
            return this.rotateOnAxis(Hg, e)
        }
        translateOnAxis(e, t) {
            return kg.copy(e).applyQuaternion(this.quaternion), this.position.add(kg.multiplyScalar(t)), this
        }
        translateX(e) {
            return this.translateOnAxis(zg, e)
        }
        translateY(e) {
            return this.translateOnAxis(Gg, e)
        }
        translateZ(e) {
            return this.translateOnAxis(Hg, e)
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Pr.copy(this.matrixWorld).invert())
        }
        lookAt(e, t, n) {
            e.isVector3 ? su.copy(e) : su.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), mc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Pr.lookAt(mc, su, this.up) : Pr.lookAt(su, mc, this.up), this.quaternion.setFromRotationMatrix(Pr), i && (Pr.extractRotation(i.matrixWorld), qa.setFromRotationMatrix(Pr), this.quaternion.premultiply(qa.invert()))
        }
        add(e) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Vg), Ya.child = e, this.dispatchEvent(Ya), Ya.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
                return this
            }
            const t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(pS), Ph.child = e, this.dispatchEvent(Ph), Ph.child = null), this
        }
        removeFromParent() {
            const e = this.parent;
            return e !== null && e.remove(this), this
        }
        clear() {
            return this.remove(...this.children)
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), Pr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Pr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Pr), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Vg), Ya.child = e, this.dispatchEvent(Ya), Ya.child = null, this
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const a = this.children[n].getObjectByProperty(e, t);
                if (a !== void 0) return a
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const i = this.children;
            for (let s = 0, a = i.length; s < a; s++) i[s].getObjectsByProperty(e, t, n);
            return n
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mc, e, hS), e
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mc, dS, e), e
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
        }
        traverseAncestors(e) {
            const t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
                const i = this.children;
                for (let s = 0, a = i.length; s < a; s++) i[s].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string",
                n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.7,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};
            i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map(o => ({ ...o,
                boundingBox: o.boundingBox ? o.boundingBox.toJSON() : void 0,
                boundingSphere: o.boundingSphere ? o.boundingSphere.toJSON() : void 0
            })), i.instanceInfo = this._instanceInfo.map(o => ({ ...o
            })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(e), i.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));

            function s(o, c) {
                return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid
            }
            if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = s(e.geometries, this.geometry);
                const o = this.geometry.parameters;
                if (o !== void 0 && o.shapes !== void 0) {
                    const c = o.shapes;
                    if (Array.isArray(c))
                        for (let l = 0, f = c.length; l < f; l++) {
                            const h = c[l];
                            s(e.shapes, h)
                        } else s(e.shapes, c)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
                if (Array.isArray(this.material)) {
                    const o = [];
                    for (let c = 0, l = this.material.length; c < l; c++) o.push(s(e.materials, this.material[c]));
                    i.material = o
                } else i.material = s(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let o = 0; o < this.animations.length; o++) {
                    const c = this.animations[o];
                    i.animations.push(s(e.animations, c))
                }
            }
            if (t) {
                const o = a(e.geometries),
                    c = a(e.materials),
                    l = a(e.textures),
                    f = a(e.images),
                    h = a(e.shapes),
                    d = a(e.skeletons),
                    u = a(e.animations),
                    _ = a(e.nodes);
                o.length > 0 && (n.geometries = o), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), f.length > 0 && (n.images = f), h.length > 0 && (n.shapes = h), d.length > 0 && (n.skeletons = d), u.length > 0 && (n.animations = u), _.length > 0 && (n.nodes = _)
            }
            return n.object = i, n;

            function a(o) {
                const c = [];
                for (const l in o) {
                    const f = o[l];
                    delete f.metadata, c.push(f)
                }
                return c
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e)
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                for (let n = 0; n < e.children.length; n++) {
                    const i = e.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }
    Ht.DEFAULT_UP = new B(0, 1, 0), Ht.DEFAULT_MATRIX_AUTO_UPDATE = !0, Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const Yi = new B,
        Fr = new B,
        Fh = new B,
        Ir = new B,
        $a = new B,
        Ka = new B,
        Wg = new B,
        Ih = new B,
        Lh = new B,
        Nh = new B,
        Uh = new Tt,
        Oh = new Tt,
        Bh = new Tt;
    class Mn {
        constructor(e = new B, t = new B, n = new B) {
            this.a = e, this.b = t, this.c = n
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), Yi.subVectors(e, t), i.cross(Yi);
            const s = i.lengthSq();
            return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, i, s) {
            Yi.subVectors(i, t), Fr.subVectors(n, t), Fh.subVectors(e, t);
            const a = Yi.dot(Yi),
                o = Yi.dot(Fr),
                c = Yi.dot(Fh),
                l = Fr.dot(Fr),
                f = Fr.dot(Fh),
                h = a * l - o * o;
            if (h === 0) return s.set(0, 0, 0), null;
            const d = 1 / h,
                u = (l * c - o * f) * d,
                _ = (a * f - o * c) * d;
            return s.set(1 - u - _, _, u)
        }
        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, Ir) === null ? !1 : Ir.x >= 0 && Ir.y >= 0 && Ir.x + Ir.y <= 1
        }
        static getInterpolation(e, t, n, i, s, a, o, c) {
            return this.getBarycoord(e, t, n, i, Ir) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(s, Ir.x), c.addScaledVector(a, Ir.y), c.addScaledVector(o, Ir.z), c)
        }
        static getInterpolatedAttribute(e, t, n, i, s, a) {
            return Uh.setScalar(0), Oh.setScalar(0), Bh.setScalar(0), Uh.fromBufferAttribute(e, t), Oh.fromBufferAttribute(e, n), Bh.fromBufferAttribute(e, i), a.setScalar(0), a.addScaledVector(Uh, s.x), a.addScaledVector(Oh, s.y), a.addScaledVector(Bh, s.z), a
        }
        static isFrontFacing(e, t, n, i) {
            return Yi.subVectors(n, t), Fr.subVectors(e, t), Yi.cross(Fr).dot(i) < 0
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        }
        getArea() {
            return Yi.subVectors(this.c, this.b), Fr.subVectors(this.a, this.b), Yi.cross(Fr).length() * .5
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return Mn.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return Mn.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getInterpolation(e, t, n, i, s) {
            return Mn.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
        }
        containsPoint(e) {
            return Mn.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return Mn.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            const n = this.a,
                i = this.b,
                s = this.c;
            let a, o;
            $a.subVectors(i, n), Ka.subVectors(s, n), Ih.subVectors(e, n);
            const c = $a.dot(Ih),
                l = Ka.dot(Ih);
            if (c <= 0 && l <= 0) return t.copy(n);
            Lh.subVectors(e, i);
            const f = $a.dot(Lh),
                h = Ka.dot(Lh);
            if (f >= 0 && h <= f) return t.copy(i);
            const d = c * h - f * l;
            if (d <= 0 && c >= 0 && f <= 0) return a = c / (c - f), t.copy(n).addScaledVector($a, a);
            Nh.subVectors(e, s);
            const u = $a.dot(Nh),
                _ = Ka.dot(Nh);
            if (_ >= 0 && u <= _) return t.copy(s);
            const g = u * l - c * _;
            if (g <= 0 && l >= 0 && _ <= 0) return o = l / (l - _), t.copy(n).addScaledVector(Ka, o);
            const m = f * _ - u * h;
            if (m <= 0 && h - f >= 0 && u - _ >= 0) return Wg.subVectors(s, i), o = (h - f) / (h - f + (u - _)), t.copy(i).addScaledVector(Wg, o);
            const p = 1 / (m + g + d);
            return a = g * p, o = d * p, t.copy(n).addScaledVector($a, a).addScaledVector(Ka, o)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
    const Xg = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        fs = {
            h: 0,
            s: 0,
            l: 0
        },
        au = {
            h: 0,
            s: 0,
            l: 0
        };

    function kh(r, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
    }
    class rt {
        constructor(e, t, n) {
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
        }
        set(e, t, n) {
            if (t === void 0 && n === void 0) {
                const i = e;
                i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
            } else this.setRGB(e, t, n);
            return this
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }
        setHex(e, t = Jt) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, bt.colorSpaceToWorking(this, t), this
        }
        setRGB(e, t, n, i = bt.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, bt.colorSpaceToWorking(this, i), this
        }
        setHSL(e, t, n, i = bt.workingColorSpace) {
            if (e = xh(e, 1), t = ht(t, 0, 1), n = ht(n, 0, 1), t === 0) this.r = this.g = this.b = n;
            else {
                const s = n <= .5 ? n * (1 + t) : n + t - n * t,
                    a = 2 * n - s;
                this.r = kh(a, s, e + 1 / 3), this.g = kh(a, s, e), this.b = kh(a, s, e - 1 / 3)
            }
            return bt.colorSpaceToWorking(this, i), this
        }
        setStyle(e, t = Jt) {
            function n(s) {
                s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let s;
                const a = i[1],
                    o = i[2];
                switch (a) {
                    case "rgb":
                    case "rgba":
                        if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                        if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const s = i[1],
                    a = s.length;
                if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
                if (a === 6) return this.setHex(parseInt(s, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e)
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this
        }
        setColorName(e, t = Jt) {
            const n = Xg[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }
        copySRGBToLinear(e) {
            return this.r = Ar(e.r), this.g = Ar(e.g), this.b = Ar(e.b), this
        }
        copyLinearToSRGB(e) {
            return this.r = za(e.r), this.g = za(e.g), this.b = za(e.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex(e = Jt) {
            return bt.workingToColorSpace(Pn.copy(this), e), Math.round(ht(Pn.r * 255, 0, 255)) * 65536 + Math.round(ht(Pn.g * 255, 0, 255)) * 256 + Math.round(ht(Pn.b * 255, 0, 255))
        }
        getHexString(e = Jt) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
        getHSL(e, t = bt.workingColorSpace) {
            bt.workingToColorSpace(Pn.copy(this), t);
            const n = Pn.r,
                i = Pn.g,
                s = Pn.b,
                a = Math.max(n, i, s),
                o = Math.min(n, i, s);
            let c, l;
            const f = (o + a) / 2;
            if (o === a) c = 0, l = 0;
            else {
                const h = a - o;
                switch (l = f <= .5 ? h / (a + o) : h / (2 - a - o), a) {
                    case n:
                        c = (i - s) / h + (i < s ? 6 : 0);
                        break;
                    case i:
                        c = (s - n) / h + 2;
                        break;
                    case s:
                        c = (n - i) / h + 4;
                        break
                }
                c /= 6
            }
            return e.h = c, e.s = l, e.l = f, e
        }
        getRGB(e, t = bt.workingColorSpace) {
            return bt.workingToColorSpace(Pn.copy(this), t), e.r = Pn.r, e.g = Pn.g, e.b = Pn.b, e
        }
        getStyle(e = Jt) {
            bt.workingToColorSpace(Pn.copy(this), e);
            const t = Pn.r,
                n = Pn.g,
                i = Pn.b;
            return e !== Jt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`
        }
        offsetHSL(e, t, n) {
            return this.getHSL(fs), this.setHSL(fs.h + e, fs.s + t, fs.l + n)
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }
        lerpHSL(e, t) {
            this.getHSL(fs), e.getHSL(au);
            const n = fc(fs.h, au.h, t),
                i = fc(fs.s, au.s, t),
                s = fc(fs.l, au.l, t);
            return this.setHSL(n, i, s), this
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this
        }
        applyMatrix3(e) {
            const t = this.r,
                n = this.g,
                i = this.b,
                s = e.elements;
            return this.r = s[0] * t + s[3] * n + s[6] * i, this.g = s[1] * t + s[4] * n + s[7] * i, this.b = s[2] * t + s[5] * n + s[8] * i, this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
        }
        toJSON() {
            return this.getHex()
        }*[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b
        }
    }
    const Pn = new rt;
    rt.NAMES = Xg;
    let mS = 0;
    class Ei extends Oa {
        constructor() {
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: mS++
            }), this.uuid = Wi(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new rt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(e) {
            if (e !== void 0)
                for (const t in e) {
                    const n = e[t];
                    if (n === void 0) {
                        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                        continue
                    }
                    const i = this[t];
                    if (i === void 0) {
                        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                        continue
                    }
                    i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== 0 && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== 204 && (n.blendSrc = this.blendSrc), this.blendDst !== 205 && (n.blendDst = this.blendDst), this.blendEquation !== 100 && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== 3 && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== 519 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== 7680 && (n.stencilFail = this.stencilFail), this.stencilZFail !== 7680 && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== 7680 && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

            function i(s) {
                const a = [];
                for (const o in s) {
                    const c = s[o];
                    delete c.metadata, a.push(c)
                }
                return a
            }
            if (t) {
                const s = i(e.textures),
                    a = i(e.images);
                s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a)
            }
            return n
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (t !== null) {
                const i = t.length;
                n = new Array(i);
                for (let s = 0; s !== i; ++s) n[s] = t[s].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
    }
    class hs extends Ei {
        constructor(e) {
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new lr, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
        }
    }
    const tn = new B,
        ou = new at;
    let gS = 0;
    class Zt {
        constructor(e, t, n = !1) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: gS++
            }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = 35044, this.updateRanges = [], this.gpuType = 1015, this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        copyArray(e) {
            return this.array.set(e), this
        }
        applyMatrix3(e) {
            if (this.itemSize === 2)
                for (let t = 0, n = this.count; t < n; t++) ou.fromBufferAttribute(this, t), ou.applyMatrix3(e), this.setXY(t, ou.x, ou.y);
            else if (this.itemSize === 3)
                for (let t = 0, n = this.count; t < n; t++) tn.fromBufferAttribute(this, t), tn.applyMatrix3(e), this.setXYZ(t, tn.x, tn.y, tn.z);
            return this
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++) tn.fromBufferAttribute(this, t), tn.applyMatrix4(e), this.setXYZ(t, tn.x, tn.y, tn.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) tn.fromBufferAttribute(this, t), tn.applyNormalMatrix(e), this.setXYZ(t, tn.x, tn.y, tn.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) tn.fromBufferAttribute(this, t), tn.transformDirection(e), this.setXYZ(t, tn.x, tn.y, tn.z);
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = Xi(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + t] = n, this
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        setX(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize] = t, this
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        setY(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 1] = t, this
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        setZ(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 2] = t, this
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        setW(e, t) {
            return this.normalized && (t = At(t, this.array)), this.array[e * this.itemSize + 3] = t, this
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, s) {
            return e *= this.itemSize, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array), s = At(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name), this.usage !== 35044 && (e.usage = this.usage), e
        }
    }
    class jg extends Zt {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }
    class qg extends Zt {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }
    class Lr extends Zt {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }
    let _S = 0;
    const wi = new Ke,
        zh = new Ht,
        Ja = new B,
        di = new Gt,
        gc = new Gt,
        _n = new B;
    class Fn extends Oa {
        constructor() {
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: _S++
            }), this.uuid = Wi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new(Fg(e) ? qg : jg)(e, 1) : this.index = e, this
        }
        setIndirect(e) {
            return this.indirect = e, this
        }
        getIndirect() {
            return this.indirect
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const s = new ct().getNormalMatrix(e);
                n.applyNormalMatrix(s), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
        }
        applyQuaternion(e) {
            return wi.makeRotationFromQuaternion(e), this.applyMatrix4(wi), this
        }
        rotateX(e) {
            return wi.makeRotationX(e), this.applyMatrix4(wi), this
        }
        rotateY(e) {
            return wi.makeRotationY(e), this.applyMatrix4(wi), this
        }
        rotateZ(e) {
            return wi.makeRotationZ(e), this.applyMatrix4(wi), this
        }
        translate(e, t, n) {
            return wi.makeTranslation(e, t, n), this.applyMatrix4(wi), this
        }
        scale(e, t, n) {
            return wi.makeScale(e, t, n), this.applyMatrix4(wi), this
        }
        lookAt(e) {
            return zh.lookAt(e), zh.updateMatrix(), this.applyMatrix4(zh.matrix), this
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Ja).negate(), this.translate(Ja.x, Ja.y, Ja.z), this
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (t === void 0) {
                const n = [];
                for (let i = 0, s = e.length; i < s; i++) {
                    const a = e[i];
                    n.push(a.x, a.y, a.z || 0)
                }
                this.setAttribute("position", new Lr(n, 3))
            } else {
                const n = Math.min(e.length, t.count);
                for (let i = 0; i < n; i++) {
                    const s = e[i];
                    t.setXYZ(i, s.x, s.y, s.z || 0)
                }
                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0
            }
            return this
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Gt);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new B(-1 / 0, -1 / 0, -1 / 0), new B(1 / 0, 1 / 0, 1 / 0));
                return
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (let n = 0, i = t.length; n < i; n++) {
                        const s = t[n];
                        di.setFromBufferAttribute(s), this.morphTargetsRelative ? (_n.addVectors(this.boundingBox.min, di.min), this.boundingBox.expandByPoint(_n), _n.addVectors(this.boundingBox.max, di.max), this.boundingBox.expandByPoint(_n)) : (this.boundingBox.expandByPoint(di.min), this.boundingBox.expandByPoint(di.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Rn);
            const e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new B, 1 / 0);
                return
            }
            if (e) {
                const n = this.boundingSphere.center;
                if (di.setFromBufferAttribute(e), t)
                    for (let s = 0, a = t.length; s < a; s++) {
                        const o = t[s];
                        gc.setFromBufferAttribute(o), this.morphTargetsRelative ? (_n.addVectors(di.min, gc.min), di.expandByPoint(_n), _n.addVectors(di.max, gc.max), di.expandByPoint(_n)) : (di.expandByPoint(gc.min), di.expandByPoint(gc.max))
                    }
                di.getCenter(n);
                let i = 0;
                for (let s = 0, a = e.count; s < a; s++) _n.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(_n));
                if (t)
                    for (let s = 0, a = t.length; s < a; s++) {
                        const o = t[s],
                            c = this.morphTargetsRelative;
                        for (let l = 0, f = o.count; l < f; l++) _n.fromBufferAttribute(o, l), c && (Ja.fromBufferAttribute(e, l), _n.add(Ja)), i = Math.max(i, n.distanceToSquared(_n))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            const e = this.index,
                t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return
            }
            const n = t.position,
                i = t.normal,
                s = t.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Zt(new Float32Array(4 * n.count), 4));
            const a = this.getAttribute("tangent"),
                o = [],
                c = [];
            for (let w = 0; w < n.count; w++) o[w] = new B, c[w] = new B;
            const l = new B,
                f = new B,
                h = new B,
                d = new at,
                u = new at,
                _ = new at,
                g = new B,
                m = new B;

            function p(w, M, y) {
                l.fromBufferAttribute(n, w), f.fromBufferAttribute(n, M), h.fromBufferAttribute(n, y), d.fromBufferAttribute(s, w), u.fromBufferAttribute(s, M), _.fromBufferAttribute(s, y), f.sub(l), h.sub(l), u.sub(d), _.sub(d);
                const D = 1 / (u.x * _.y - _.x * u.y);
                isFinite(D) && (g.copy(f).multiplyScalar(_.y).addScaledVector(h, -u.y).multiplyScalar(D), m.copy(h).multiplyScalar(u.x).addScaledVector(f, -_.x).multiplyScalar(D), o[w].add(g), o[M].add(g), o[y].add(g), c[w].add(m), c[M].add(m), c[y].add(m))
            }
            let v = this.groups;
            v.length === 0 && (v = [{
                start: 0,
                count: e.count
            }]);
            for (let w = 0, M = v.length; w < M; ++w) {
                const y = v[w],
                    D = y.start,
                    R = y.count;
                for (let P = D, O = D + R; P < O; P += 3) p(e.getX(P + 0), e.getX(P + 1), e.getX(P + 2))
            }
            const x = new B,
                b = new B,
                S = new B,
                E = new B;

            function T(w) {
                S.fromBufferAttribute(i, w), E.copy(S);
                const M = o[w];
                x.copy(M), x.sub(S.multiplyScalar(S.dot(M))).normalize(), b.crossVectors(E, M);
                const D = b.dot(c[w]) < 0 ? -1 : 1;
                a.setXYZW(w, x.x, x.y, x.z, D)
            }
            for (let w = 0, M = v.length; w < M; ++w) {
                const y = v[w],
                    D = y.start,
                    R = y.count;
                for (let P = D, O = D + R; P < O; P += 3) T(e.getX(P + 0)), T(e.getX(P + 1)), T(e.getX(P + 2))
            }
        }
        computeVertexNormals() {
            const e = this.index,
                t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new Zt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                else
                    for (let d = 0, u = n.count; d < u; d++) n.setXYZ(d, 0, 0, 0);
                const i = new B,
                    s = new B,
                    a = new B,
                    o = new B,
                    c = new B,
                    l = new B,
                    f = new B,
                    h = new B;
                if (e)
                    for (let d = 0, u = e.count; d < u; d += 3) {
                        const _ = e.getX(d + 0),
                            g = e.getX(d + 1),
                            m = e.getX(d + 2);
                        i.fromBufferAttribute(t, _), s.fromBufferAttribute(t, g), a.fromBufferAttribute(t, m), f.subVectors(a, s), h.subVectors(i, s), f.cross(h), o.fromBufferAttribute(n, _), c.fromBufferAttribute(n, g), l.fromBufferAttribute(n, m), o.add(f), c.add(f), l.add(f), n.setXYZ(_, o.x, o.y, o.z), n.setXYZ(g, c.x, c.y, c.z), n.setXYZ(m, l.x, l.y, l.z)
                    } else
                        for (let d = 0, u = t.count; d < u; d += 3) i.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), f.subVectors(a, s), h.subVectors(i, s), f.cross(h), n.setXYZ(d + 0, f.x, f.y, f.z), n.setXYZ(d + 1, f.x, f.y, f.z), n.setXYZ(d + 2, f.x, f.y, f.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++) _n.fromBufferAttribute(e, t), _n.normalize(), e.setXYZ(t, _n.x, _n.y, _n.z)
        }
        toNonIndexed() {
            function e(o, c) {
                const l = o.array,
                    f = o.itemSize,
                    h = o.normalized,
                    d = new l.constructor(c.length * f);
                let u = 0,
                    _ = 0;
                for (let g = 0, m = c.length; g < m; g++) {
                    o.isInterleavedBufferAttribute ? u = c[g] * o.data.stride + o.offset : u = c[g] * f;
                    for (let p = 0; p < f; p++) d[_++] = l[u++]
                }
                return new Zt(d, f, h)
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new Fn,
                n = this.index.array,
                i = this.attributes;
            for (const o in i) {
                const c = i[o],
                    l = e(c, n);
                t.setAttribute(o, l)
            }
            const s = this.morphAttributes;
            for (const o in s) {
                const c = [],
                    l = s[o];
                for (let f = 0, h = l.length; f < h; f++) {
                    const d = l[f],
                        u = e(d, n);
                    c.push(u)
                }
                t.morphAttributes[o] = c
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for (let o = 0, c = a.length; o < c; o++) {
                const l = a[o];
                t.addGroup(l.start, l.count, l.materialIndex)
            }
            return t
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                const c = this.parameters;
                for (const l in c) c[l] !== void 0 && (e[l] = c[l]);
                return e
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for (const c in n) {
                const l = n[c];
                e.data.attributes[c] = l.toJSON(e.data)
            }
            const i = {};
            let s = !1;
            for (const c in this.morphAttributes) {
                const l = this.morphAttributes[c],
                    f = [];
                for (let h = 0, d = l.length; h < d; h++) {
                    const u = l[h];
                    f.push(u.toJSON(e.data))
                }
                f.length > 0 && (i[c] = f, s = !0)
            }
            s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const a = this.groups;
            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return o !== null && (e.data.boundingSphere = o.toJSON()), e
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            n !== null && this.setIndex(n.clone());
            const i = e.attributes;
            for (const l in i) {
                const f = i[l];
                this.setAttribute(l, f.clone(t))
            }
            const s = e.morphAttributes;
            for (const l in s) {
                const f = [],
                    h = s[l];
                for (let d = 0, u = h.length; d < u; d++) f.push(h[d].clone(t));
                this.morphAttributes[l] = f
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const a = e.groups;
            for (let l = 0, f = a.length; l < f; l++) {
                const h = a[l];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            const o = e.boundingBox;
            o !== null && (this.boundingBox = o.clone());
            const c = e.boundingSphere;
            return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    const Yg = new Ke,
        qs = new Xa,
        cu = new Rn,
        $g = new B,
        lu = new B,
        uu = new B,
        fu = new B,
        Gh = new B,
        hu = new B,
        Kg = new B,
        du = new B;
    class bn extends Ht {
        constructor(e = new Fn, t = new hs) {
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry,
                i = n.attributes.position,
                s = n.morphAttributes.position,
                a = n.morphTargetsRelative;
            t.fromBufferAttribute(i, e);
            const o = this.morphTargetInfluences;
            if (s && o) {
                hu.set(0, 0, 0);
                for (let c = 0, l = s.length; c < l; c++) {
                    const f = o[c],
                        h = s[c];
                    f !== 0 && (Gh.fromBufferAttribute(h, e), a ? hu.addScaledVector(Gh, f) : hu.addScaledVector(Gh.sub(t), f))
                }
                t.add(hu)
            }
            return t
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.material,
                s = this.matrixWorld;
            i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), cu.copy(n.boundingSphere), cu.applyMatrix4(s), qs.copy(e.ray).recast(e.near), !(cu.containsPoint(qs.origin) === !1 && (qs.intersectSphere(cu, $g) === null || qs.origin.distanceToSquared($g) > (e.far - e.near) ** 2)) && (Yg.copy(s).invert(), qs.copy(e.ray).applyMatrix4(Yg), !(n.boundingBox !== null && qs.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, qs)))
        }
        _computeIntersections(e, t, n) {
            let i;
            const s = this.geometry,
                a = this.material,
                o = s.index,
                c = s.attributes.position,
                l = s.attributes.uv,
                f = s.attributes.uv1,
                h = s.attributes.normal,
                d = s.groups,
                u = s.drawRange;
            if (o !== null)
                if (Array.isArray(a))
                    for (let _ = 0, g = d.length; _ < g; _++) {
                        const m = d[_],
                            p = a[m.materialIndex],
                            v = Math.max(m.start, u.start),
                            x = Math.min(o.count, Math.min(m.start + m.count, u.start + u.count));
                        for (let b = v, S = x; b < S; b += 3) {
                            const E = o.getX(b),
                                T = o.getX(b + 1),
                                w = o.getX(b + 2);
                            i = pu(this, p, e, n, l, f, h, E, T, w), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = m.materialIndex, t.push(i))
                        }
                    } else {
                        const _ = Math.max(0, u.start),
                            g = Math.min(o.count, u.start + u.count);
                        for (let m = _, p = g; m < p; m += 3) {
                            const v = o.getX(m),
                                x = o.getX(m + 1),
                                b = o.getX(m + 2);
                            i = pu(this, a, e, n, l, f, h, v, x, b), i && (i.faceIndex = Math.floor(m / 3), t.push(i))
                        }
                    } else if (c !== void 0)
                        if (Array.isArray(a))
                            for (let _ = 0, g = d.length; _ < g; _++) {
                                const m = d[_],
                                    p = a[m.materialIndex],
                                    v = Math.max(m.start, u.start),
                                    x = Math.min(c.count, Math.min(m.start + m.count, u.start + u.count));
                                for (let b = v, S = x; b < S; b += 3) {
                                    const E = b,
                                        T = b + 1,
                                        w = b + 2;
                                    i = pu(this, p, e, n, l, f, h, E, T, w), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = m.materialIndex, t.push(i))
                                }
                            } else {
                                const _ = Math.max(0, u.start),
                                    g = Math.min(c.count, u.start + u.count);
                                for (let m = _, p = g; m < p; m += 3) {
                                    const v = m,
                                        x = m + 1,
                                        b = m + 2;
                                    i = pu(this, a, e, n, l, f, h, v, x, b), i && (i.faceIndex = Math.floor(m / 3), t.push(i))
                                }
                            }
        }
    }

    function bS(r, e, t, n, i, s, a, o) {
        let c;
        if (e.side === 1 ? c = n.intersectTriangle(a, s, i, !0, o) : c = n.intersectTriangle(i, s, a, e.side === 0, o), c === null) return null;
        du.copy(o), du.applyMatrix4(r.matrixWorld);
        const l = t.ray.origin.distanceTo(du);
        return l < t.near || l > t.far ? null : {
            distance: l,
            point: du.clone(),
            object: r
        }
    }

    function pu(r, e, t, n, i, s, a, o, c, l) {
        r.getVertexPosition(o, lu), r.getVertexPosition(c, uu), r.getVertexPosition(l, fu);
        const f = bS(r, e, t, n, lu, uu, fu, Kg);
        if (f) {
            const h = new B;
            Mn.getBarycoord(Kg, lu, uu, fu, h), i && (f.uv = Mn.getInterpolatedAttribute(i, o, c, l, h, new at)), s && (f.uv1 = Mn.getInterpolatedAttribute(s, o, c, l, h, new at)), a && (f.normal = Mn.getInterpolatedAttribute(a, o, c, l, h, new B), f.normal.dot(n.direction) > 0 && f.normal.multiplyScalar(-1));
            const d = {
                a: o,
                b: c,
                c: l,
                normal: new B,
                materialIndex: 0
            };
            Mn.getNormal(lu, uu, fu, d.normal), f.face = d, f.barycoord = h
        }
        return f
    }
    class _c extends Fn {
        constructor(e = 1, t = 1, n = 1, i = 1, s = 1, a = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: s,
                depthSegments: a
            };
            const o = this;
            i = Math.floor(i), s = Math.floor(s), a = Math.floor(a);
            const c = [],
                l = [],
                f = [],
                h = [];
            let d = 0,
                u = 0;
            _("z", "y", "x", -1, -1, n, t, e, a, s, 0), _("z", "y", "x", 1, -1, n, t, -e, a, s, 1), _("x", "z", "y", 1, 1, e, n, t, i, a, 2), _("x", "z", "y", 1, -1, e, n, -t, i, a, 3), _("x", "y", "z", 1, -1, e, t, n, i, s, 4), _("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(c), this.setAttribute("position", new Lr(l, 3)), this.setAttribute("normal", new Lr(f, 3)), this.setAttribute("uv", new Lr(h, 2));

            function _(g, m, p, v, x, b, S, E, T, w, M) {
                const y = b / T,
                    D = S / w,
                    R = b / 2,
                    P = S / 2,
                    O = E / 2,
                    z = T + 1,
                    k = w + 1;
                let X = 0,
                    V = 0;
                const H = new B;
                for (let L = 0; L < k; L++) {
                    const se = L * D - P;
                    for (let de = 0; de < z; de++) {
                        const ke = de * y - R;
                        H[g] = ke * v, H[m] = se * x, H[p] = O, l.push(H.x, H.y, H.z), H[g] = 0, H[m] = 0, H[p] = E > 0 ? 1 : -1, f.push(H.x, H.y, H.z), h.push(de / T), h.push(1 - L / w), X += 1
                    }
                }
                for (let L = 0; L < w; L++)
                    for (let se = 0; se < T; se++) {
                        const de = d + se + z * L,
                            ke = d + se + z * (L + 1),
                            Y = d + (se + 1) + z * (L + 1),
                            ee = d + (se + 1) + z * L;
                        c.push(de, ke, ee), c.push(ke, Y, ee), V += 6
                    }
                o.addGroup(u, V, M), u += V, d += X
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new _c(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
        }
    }

    function Za(r) {
        const e = {};
        for (const t in r) {
            e[t] = {};
            for (const n in r[t]) {
                const i = r[t][n];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
            }
        }
        return e
    }

    function Gn(r) {
        const e = {};
        for (let t = 0; t < r.length; t++) {
            const n = Za(r[t]);
            for (const i in n) e[i] = n[i]
        }
        return e
    }

    function xS(r) {
        const e = [];
        for (let t = 0; t < r.length; t++) e.push(r[t].clone());
        return e
    }

    function Jg(r) {
        const e = r.getRenderTarget();
        return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : bt.workingColorSpace
    }
    const vS = {
        clone: Za,
        merge: Gn
    };
    var yS = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        SS = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class Nr extends Ei {
        constructor(e) {
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = yS, this.fragmentShader = SS, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Za(e.uniforms), this.uniformsGroups = xS(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for (const i in this.uniforms) {
                const a = this.uniforms[i].value;
                a && a.isTexture ? t.uniforms[i] = {
                    type: "t",
                    value: a.toJSON(e).uuid
                } : a && a.isColor ? t.uniforms[i] = {
                    type: "c",
                    value: a.getHex()
                } : a && a.isVector2 ? t.uniforms[i] = {
                    type: "v2",
                    value: a.toArray()
                } : a && a.isVector3 ? t.uniforms[i] = {
                    type: "v3",
                    value: a.toArray()
                } : a && a.isVector4 ? t.uniforms[i] = {
                    type: "v4",
                    value: a.toArray()
                } : a && a.isMatrix3 ? t.uniforms[i] = {
                    type: "m3",
                    value: a.toArray()
                } : a && a.isMatrix4 ? t.uniforms[i] = {
                    type: "m4",
                    value: a.toArray()
                } : t.uniforms[i] = {
                    value: a
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t
        }
    }
    class Zg extends Ht {
        constructor() {
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ke, this.projectionMatrix = new Ke, this.projectionMatrixInverse = new Ke, this.coordinateSystem = 2e3
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate()
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    const ds = new B,
        Qg = new at,
        e_ = new at;
    class Hn extends Zg {
        constructor(e = 50, t = 1, n = .1, i = 2e3) {
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = Ba * 2 * Math.atan(t), this.updateProjectionMatrix()
        }
        getFocalLength() {
            const e = Math.tan(uc * .5 * this.fov);
            return .5 * this.getFilmHeight() / e
        }
        getEffectiveFOV() {
            return Ba * 2 * Math.atan(Math.tan(uc * .5 * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        getViewBounds(e, t, n) {
            ds.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(ds.x, ds.y).multiplyScalar(-e / ds.z), ds.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(ds.x, ds.y).multiplyScalar(-e / ds.z)
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, Qg, e_), t.subVectors(e_, Qg)
        }
        setViewOffset(e, t, n, i, s, a) {
            this.aspect = e / t, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(uc * .5 * this.fov) / this.zoom,
                n = 2 * t,
                i = this.aspect * n,
                s = -.5 * i;
            const a = this.view;
            if (this.view !== null && this.view.enabled) {
                const c = a.fullWidth,
                    l = a.fullHeight;
                s += a.offsetX * i / c, t -= a.offsetY * n / l, i *= a.width / c, n *= a.height / l
            }
            const o = this.filmOffset;
            o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }
    const Qa = -90,
        eo = 1;
    class MS extends Ht {
        constructor(e, t, n) {
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const i = new Hn(Qa, eo, e, t);
            i.layers = this.layers, this.add(i);
            const s = new Hn(Qa, eo, e, t);
            s.layers = this.layers, this.add(s);
            const a = new Hn(Qa, eo, e, t);
            a.layers = this.layers, this.add(a);
            const o = new Hn(Qa, eo, e, t);
            o.layers = this.layers, this.add(o);
            const c = new Hn(Qa, eo, e, t);
            c.layers = this.layers, this.add(c);
            const l = new Hn(Qa, eo, e, t);
            l.layers = this.layers, this.add(l)
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem,
                t = this.children.concat(),
                [n, i, s, a, o, c] = t;
            for (const l of t) this.remove(l);
            if (e === 2e3) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
            else if (e === 2001) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            for (const l of t) this.add(l), l.updateMatrixWorld()
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            const {
                renderTarget: n,
                activeMipmapLevel: i
            } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [s, a, o, c, l, f] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), _ = e.xr.enabled;
            e.xr.enabled = !1;
            const g = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, s), e.setRenderTarget(n, 1, i), e.render(t, a), e.setRenderTarget(n, 2, i), e.render(t, o), e.setRenderTarget(n, 3, i), e.render(t, c), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, i), e.render(t, f), e.setRenderTarget(h, d, u), e.xr.enabled = _, n.texture.needsPMREMUpdate = !0
        }
    }
    class t_ extends on {
        constructor(e = [], t = 301, n, i, s, a, o, c, l, f) {
            super(e, t, n, i, s, a, o, c, l, f), this.isCubeTexture = !0, this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
    class TS extends Dr {
        constructor(e = 1, t = {}) {
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                    width: e,
                    height: e,
                    depth: 1
                },
                i = [n, n, n, n, n, n];
            this.texture = new t_(i), this._setTextureOptions(t), this.texture.isRenderTargetTexture = !0
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                    fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                },
                i = new _c(5, 5, 5),
                s = new Nr({
                    name: "CubemapFromEquirect",
                    uniforms: Za(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
            s.uniforms.tEquirect.value = t;
            const a = new bn(i, s),
                o = t.minFilter;
            return t.minFilter === 1008 && (t.minFilter = 1006), new MS(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this
        }
        clear(e, t = !0, n = !0, i = !0) {
            const s = e.getRenderTarget();
            for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
            e.setRenderTarget(s)
        }
    }
    class ps extends Ht {
        constructor() {
            super(), this.isGroup = !0, this.type = "Group"
        }
    }
    const ES = {
        type: "move"
    };
    class Hh {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new ps, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new ps, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new B, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new B), this._targetRay
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new ps, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new B, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new B), this._grip
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t)
                    for (const n of e.hand.values()) this._getHandJoint(t, n)
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
        }
        update(e, t, n) {
            let i = null,
                s = null,
                a = null;
            const o = this._targetRay,
                c = this._grip,
                l = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (l && e.hand) {
                    a = !0;
                    for (const g of e.hand.values()) {
                        const m = t.getJointPose(g, n),
                            p = this._getHandJoint(l, g);
                        m !== null && (p.matrix.fromArray(m.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = m.radius), p.visible = m !== null
                    }
                    const f = l.joints["index-finger-tip"],
                        h = l.joints["thumb-tip"],
                        d = f.position.distanceTo(h.position),
                        u = .02,
                        _ = .005;
                    l.inputState.pinching && d > u + _ ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && d <= u - _ && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1, s.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
                o !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(ES)))
            }
            return o !== null && (o.visible = i !== null), c !== null && (c.visible = s !== null), l !== null && (l.visible = a !== null), this
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                const n = new ps;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
            }
            return e.joints[t.jointName]
        }
    }
    class n_ extends Ht {
        constructor() {
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new lr, this.environmentIntensity = 1, this.environmentRotation = new lr, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
        }
    }
    class wS {
        constructor(e, t) {
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = 35044, this.updateRanges = [], this.version = 0, this.uuid = Wi()
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        setUsage(e) {
            return this.usage = e, this
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            })
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = t.array[n + i];
            return this
        }
        set(e, t = 0) {
            return this.array.set(e, t), this
        }
        clone(e) {
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Wi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n
        }
        onUpload(e) {
            return this.onUploadCallback = e, this
        }
        toJSON(e) {
            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Wi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    const Vn = new B;
    class Vh {
        constructor(e, t, n, i = !1) {
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++) Vn.fromBufferAttribute(this, t), Vn.applyMatrix4(e), this.setXYZ(t, Vn.x, Vn.y, Vn.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Vn.fromBufferAttribute(this, t), Vn.applyNormalMatrix(e), this.setXYZ(t, Vn.x, Vn.y, Vn.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Vn.fromBufferAttribute(this, t), Vn.transformDirection(e), this.setXYZ(t, Vn.x, Vn.y, Vn.z);
            return this
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = Xi(n, this.array)), n
        }
        setComponent(e, t, n) {
            return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
        }
        setX(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
        }
        setY(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }
        setZ(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }
        setW(e, t) {
            return this.normalized && (t = At(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = Xi(t, this.array)), t
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        }
        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
        }
        setXYZW(e, t, n, i, s) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = At(t, this.array), n = At(n, this.array), i = At(i, this.array), s = At(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this
        }
        clone(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let n = 0; n < this.count; n++) {
                    const i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
                }
                return new Zt(new this.array.constructor(t), this.itemSize, this.normalized)
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Vh(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }
        toJSON(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let n = 0; n < this.count; n++) {
                    const i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    const i_ = new B,
        r_ = new Tt,
        s_ = new Tt,
        AS = new B,
        a_ = new Ke,
        mu = new B,
        Wh = new Rn,
        o_ = new Ke,
        Xh = new Xa;
    class DS extends bn {
        constructor(e, t) {
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Dg, this.bindMatrix = new Ke, this.bindMatrixInverse = new Ke, this.boundingBox = null, this.boundingSphere = null
        }
        computeBoundingBox() {
            const e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new Gt), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++) this.getVertexPosition(n, mu), this.boundingBox.expandByPoint(mu)
        }
        computeBoundingSphere() {
            const e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new Rn), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++) this.getVertexPosition(n, mu), this.boundingSphere.expandByPoint(mu)
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        raycast(e, t) {
            const n = this.material,
                i = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Wh.copy(this.boundingSphere), Wh.applyMatrix4(i), e.ray.intersectsSphere(Wh) !== !1 && (o_.copy(i).invert(), Xh.copy(e.ray).applyMatrix4(o_), !(this.boundingBox !== null && Xh.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Xh)))
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
        }
        bind(e, t) {
            this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            const e = new Tt,
                t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                e.fromBufferAttribute(t, n);
                const s = 1 / e.manhattanLength();
                s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === Dg ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Ly ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton,
                i = this.geometry;
            r_.fromBufferAttribute(i.attributes.skinIndex, e), s_.fromBufferAttribute(i.attributes.skinWeight, e), i_.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for (let s = 0; s < 4; s++) {
                const a = s_.getComponent(s);
                if (a !== 0) {
                    const o = r_.getComponent(s);
                    a_.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(AS.copy(i_).applyMatrix4(a_), a)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }
    class c_ extends Ht {
        constructor() {
            super(), this.isBone = !0, this.type = "Bone"
        }
    }
    class bc extends on {
        constructor(e = null, t = 1, n = 1, i, s, a, o, c, l = 1003, f = 1003, h, d) {
            super(null, a, o, c, l, f, i, s, h, d), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    const l_ = new Ke,
        CS = new Ke;
    class jh {
        constructor(e = [], t = []) {
            this.uuid = Wi(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
        }
        init() {
            const e = this.bones,
                t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ke)
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = new Ke;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
            }
        }
        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
            }
        }
        update() {
            const e = this.bones,
                t = this.boneInverses,
                n = this.boneMatrices,
                i = this.boneTexture;
            for (let s = 0, a = e.length; s < a; s++) {
                const o = e[s] ? e[s].matrixWorld : CS;
                l_.multiplyMatrices(o, t[s]), l_.toArray(n, s * 16)
            }
            i !== null && (i.needsUpdate = !0)
        }
        clone() {
            return new jh(this.bones, this.boneInverses)
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new bc(t, e, e, 1023, 1015);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
        }
        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                const i = this.bones[t];
                if (i.name === e) return i
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                const s = e.bones[n];
                let a = t[s];
                a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new c_), this.bones.push(a), this.boneInverses.push(new Ke().fromArray(e.boneInverses[n]))
            }
            return this.init(), this
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones,
                n = this.boneInverses;
            for (let i = 0, s = t.length; i < s; i++) {
                const a = t[i];
                e.bones.push(a.uuid);
                const o = n[i];
                e.boneInverses.push(o.toArray())
            }
            return e
        }
    }
    class qh extends Zt {
        constructor(e, t, n, i = 1) {
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }
    const to = new Ke,
        u_ = new Ke,
        gu = [],
        f_ = new Gt,
        RS = new Ke,
        xc = new bn,
        vc = new Rn;
    class PS extends bn {
        constructor(e, t, n) {
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new qh(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for (let i = 0; i < n; i++) this.setMatrixAt(i, RS)
        }
        computeBoundingBox() {
            const e = this.geometry,
                t = this.count;
            this.boundingBox === null && (this.boundingBox = new Gt), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, to), f_.copy(e.boundingBox).applyMatrix4(to), this.boundingBox.union(f_)
        }
        computeBoundingSphere() {
            const e = this.geometry,
                t = this.count;
            this.boundingSphere === null && (this.boundingSphere = new Rn), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for (let n = 0; n < t; n++) this.getMatrixAt(n, to), vc.copy(e.boundingSphere).applyMatrix4(to), this.boundingSphere.union(vc)
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3)
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16)
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = this.morphTexture.source.data.data,
                s = n.length + 1,
                a = e * s + 1;
            for (let o = 0; o < n.length; o++) n[o] = i[a + o]
        }
        raycast(e, t) {
            const n = this.matrixWorld,
                i = this.count;
            if (xc.geometry = this.geometry, xc.material = this.material, xc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), vc.copy(this.boundingSphere), vc.applyMatrix4(n), e.ray.intersectsSphere(vc) !== !1))
                for (let s = 0; s < i; s++) {
                    this.getMatrixAt(s, to), u_.multiplyMatrices(n, to), xc.matrixWorld = u_, xc.raycast(e, gu);
                    for (let a = 0, o = gu.length; a < o; a++) {
                        const c = gu[a];
                        c.instanceId = s, c.object = this, t.push(c)
                    }
                    gu.length = 0
                }
        }
        setColorAt(e, t) {
            this.instanceColor === null && (this.instanceColor = new qh(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3)
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16)
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences,
                i = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new bc(new Float32Array(i * this.count), i, this.count, 1028, 1015));
            const s = this.morphTexture.source.data.data;
            let a = 0;
            for (let l = 0; l < n.length; l++) a += n[l];
            const o = this.geometry.morphTargetsRelative ? 1 : 1 - a,
                c = i * e;
            s[c] = o, s.set(n, c + 1)
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null)
        }
    }
    const Yh = new B,
        FS = new B,
        IS = new ct;
    class Ur {
        constructor(e = new B(1, 0, 0), t = 0) {
            this.isPlane = !0, this.normal = e, this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }
        setFromCoplanarPoints(e, t, n) {
            const i = Yh.subVectors(n, t).cross(FS.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
        }
        intersectLine(e, t) {
            const n = e.delta(Yh),
                i = this.normal.dot(n);
            if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            const s = -(e.start.dot(this.normal) + this.constant) / i;
            return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            const n = t || IS.getNormalMatrix(e),
                i = this.coplanarPoint(Yh).applyMatrix4(e),
                s = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(s), this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    const Ys = new Rn,
        _u = new B;
    class yc {
        constructor(e = new Ur, t = new Ur, n = new Ur, i = new Ur, s = new Ur, a = new Ur) {
            this.planes = [e, t, n, i, s, a]
        }
        set(e, t, n, i, s, a) {
            const o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(s), o[5].copy(a), this
        }
        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e, t = 2e3) {
            const n = this.planes,
                i = e.elements,
                s = i[0],
                a = i[1],
                o = i[2],
                c = i[3],
                l = i[4],
                f = i[5],
                h = i[6],
                d = i[7],
                u = i[8],
                _ = i[9],
                g = i[10],
                m = i[11],
                p = i[12],
                v = i[13],
                x = i[14],
                b = i[15];
            if (n[0].setComponents(c - s, d - l, m - u, b - p).normalize(), n[1].setComponents(c + s, d + l, m + u, b + p).normalize(), n[2].setComponents(c + a, d + f, m + _, b + v).normalize(), n[3].setComponents(c - a, d - f, m - _, b - v).normalize(), n[4].setComponents(c - o, d - h, m - g, b - x).normalize(), t === 2e3) n[5].setComponents(c + o, d + h, m + g, b + x).normalize();
            else if (t === 2001) n[5].setComponents(o, h, g, x).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            return this
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ys.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(), Ys.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
            }
            return this.intersectsSphere(Ys)
        }
        intersectsSprite(e) {
            return Ys.center.set(0, 0, 0), Ys.radius = .7071067811865476, Ys.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ys)
        }
        intersectsSphere(e) {
            const t = this.planes,
                n = e.center,
                i = -e.radius;
            for (let s = 0; s < 6; s++)
                if (t[s].distanceToPoint(n) < i) return !1;
            return !0
        }
        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = t[n];
                if (_u.x = i.normal.x > 0 ? e.max.x : e.min.x, _u.y = i.normal.y > 0 ? e.max.y : e.min.y, _u.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(_u) < 0) return !1
            }
            return !0
        }
        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    const ur = new Ke,
        fr = new yc;
    class $h {
        constructor() {
            this.coordinateSystem = 2e3
        }
        intersectsObject(e, t) {
            if (!t.isArrayCamera || t.cameras.length === 0) return !1;
            for (let n = 0; n < t.cameras.length; n++) {
                const i = t.cameras[n];
                if (ur.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), fr.setFromProjectionMatrix(ur, this.coordinateSystem), fr.intersectsObject(e)) return !0
            }
            return !1
        }
        intersectsSprite(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for (let n = 0; n < t.cameras.length; n++) {
                const i = t.cameras[n];
                if (ur.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), fr.setFromProjectionMatrix(ur, this.coordinateSystem), fr.intersectsSprite(e)) return !0
            }
            return !1
        }
        intersectsSphere(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for (let n = 0; n < t.cameras.length; n++) {
                const i = t.cameras[n];
                if (ur.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), fr.setFromProjectionMatrix(ur, this.coordinateSystem), fr.intersectsSphere(e)) return !0
            }
            return !1
        }
        intersectsBox(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for (let n = 0; n < t.cameras.length; n++) {
                const i = t.cameras[n];
                if (ur.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), fr.setFromProjectionMatrix(ur, this.coordinateSystem), fr.intersectsBox(e)) return !0
            }
            return !1
        }
        containsPoint(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for (let n = 0; n < t.cameras.length; n++) {
                const i = t.cameras[n];
                if (ur.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), fr.setFromProjectionMatrix(ur, this.coordinateSystem), fr.containsPoint(e)) return !0
            }
            return !1
        }
        clone() {
            return new $h
        }
    }

    function Kh(r, e) {
        return r - e
    }

    function LS(r, e) {
        return r.z - e.z
    }

    function NS(r, e) {
        return e.z - r.z
    }
    class US {
        constructor() {
            this.index = 0, this.pool = [], this.list = []
        }
        push(e, t, n, i) {
            const s = this.pool,
                a = this.list;
            this.index >= s.length && s.push({
                start: -1,
                count: -1,
                z: -1,
                index: -1
            });
            const o = s[this.index];
            a.push(o), this.index++, o.start = e, o.count = t, o.z = n, o.index = i
        }
        reset() {
            this.list.length = 0, this.index = 0
        }
    }
    const ti = new Ke,
        OS = new rt(1, 1, 1),
        h_ = new yc,
        BS = new $h,
        bu = new Gt,
        $s = new Rn,
        Sc = new B,
        d_ = new B,
        kS = new B,
        Jh = new US,
        In = new bn,
        xu = [];

    function zS(r, e, t = 0) {
        const n = e.itemSize;
        if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
            const i = r.count;
            for (let s = 0; s < i; s++)
                for (let a = 0; a < n; a++) e.setComponent(s + t, a, r.getComponent(s, a))
        } else e.array.set(r.array, t * n);
        e.needsUpdate = !0
    }

    function Ks(r, e) {
        if (r.constructor !== e.constructor) {
            const t = Math.min(r.length, e.length);
            for (let n = 0; n < t; n++) e[n] = r[n]
        } else {
            const t = Math.min(r.length, e.length);
            e.set(new r.constructor(r.buffer, 0, t))
        }
    }
    class GS extends bn {
        constructor(e, t, n = t * 2, i) {
            super(new Fn, i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture()
        }
        get maxInstanceCount() {
            return this._maxInstanceCount
        }
        get instanceCount() {
            return this._instanceInfo.length - this._availableInstanceIds.length
        }
        get unusedVertexCount() {
            return this._maxVertexCount - this._nextVertexStart
        }
        get unusedIndexCount() {
            return this._maxIndexCount - this._nextIndexStart
        }
        _initMatricesTexture() {
            let e = Math.sqrt(this._maxInstanceCount * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4),
                n = new bc(t, e, e, 1023, 1015);
            this._matricesTexture = n
        }
        _initIndirectTexture() {
            let e = Math.sqrt(this._maxInstanceCount);
            e = Math.ceil(e);
            const t = new Uint32Array(e * e),
                n = new bc(t, e, e, 1029, 1014);
            this._indirectTexture = n
        }
        _initColorsTexture() {
            let e = Math.sqrt(this._maxInstanceCount);
            e = Math.ceil(e);
            const t = new Float32Array(e * e * 4).fill(1),
                n = new bc(t, e, e, 1023, 1015);
            n.colorSpace = bt.workingColorSpace, this._colorsTexture = n
        }
        _initializeGeometry(e) {
            const t = this.geometry,
                n = this._maxVertexCount,
                i = this._maxIndexCount;
            if (this._geometryInitialized === !1) {
                for (const s in e.attributes) {
                    const a = e.getAttribute(s),
                        {
                            array: o,
                            itemSize: c,
                            normalized: l
                        } = a,
                        f = new o.constructor(n * c),
                        h = new Zt(f, c, l);
                    t.setAttribute(s, h)
                }
                if (e.getIndex() !== null) {
                    const s = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                    t.setIndex(new Zt(s, 1))
                }
                this._geometryInitialized = !0
            }
        }
        _validateGeometry(e) {
            const t = this.geometry;
            if (!!e.getIndex() != !!t.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
            for (const n in t.attributes) {
                if (!e.hasAttribute(n)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                const i = e.getAttribute(n),
                    s = t.getAttribute(n);
                if (i.itemSize !== s.itemSize || i.normalized !== s.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
            }
        }
        validateInstanceId(e) {
            const t = this._instanceInfo;
            if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
        }
        validateGeometryId(e) {
            const t = this._geometryInfo;
            if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
        }
        setCustomSort(e) {
            return this.customSort = e, this
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Gt);
            const e = this.boundingBox,
                t = this._instanceInfo;
            e.makeEmpty();
            for (let n = 0, i = t.length; n < i; n++) {
                if (t[n].active === !1) continue;
                const s = t[n].geometryIndex;
                this.getMatrixAt(n, ti), this.getBoundingBoxAt(s, bu).applyMatrix4(ti), e.union(bu)
            }
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Rn);
            const e = this.boundingSphere,
                t = this._instanceInfo;
            e.makeEmpty();
            for (let n = 0, i = t.length; n < i; n++) {
                if (t[n].active === !1) continue;
                const s = t[n].geometryIndex;
                this.getMatrixAt(n, ti), this.getBoundingSphereAt(s, $s).applyMatrix4(ti), e.union($s)
            }
        }
        addInstance(e) {
            if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached.");
            const n = {
                visible: !0,
                active: !0,
                geometryIndex: e
            };
            let i = null;
            this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(Kh), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = n) : (i = this._instanceInfo.length, this._instanceInfo.push(n));
            const s = this._matricesTexture;
            ti.identity().toArray(s.image.data, i * 16), s.needsUpdate = !0;
            const a = this._colorsTexture;
            return a && (OS.toArray(a.image.data, i * 4), a.needsUpdate = !0), this._visibilityChanged = !0, i
        }
        addGeometry(e, t = -1, n = -1) {
            this._initializeGeometry(e), this._validateGeometry(e);
            const i = {
                    vertexStart: -1,
                    vertexCount: -1,
                    reservedVertexCount: -1,
                    indexStart: -1,
                    indexCount: -1,
                    reservedIndexCount: -1,
                    start: -1,
                    count: -1,
                    boundingBox: null,
                    boundingSphere: null,
                    active: !0
                },
                s = this._geometryInfo;
            i.vertexStart = this._nextVertexStart, i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
            const a = e.getIndex();
            if (a !== null && (i.indexStart = this._nextIndexStart, i.reservedIndexCount = n === -1 ? a.count : n), i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
            let c;
            return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(Kh), c = this._availableGeometryIds.shift(), s[c] = i) : (c = this._geometryCount, this._geometryCount++, s.push(i)), this.setGeometryAt(c, e), this._nextIndexStart = i.indexStart + i.reservedIndexCount, this._nextVertexStart = i.vertexStart + i.reservedVertexCount, c
        }
        setGeometryAt(e, t) {
            if (e >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
            this._validateGeometry(t);
            const n = this.geometry,
                i = n.getIndex() !== null,
                s = n.getIndex(),
                a = t.getIndex(),
                o = this._geometryInfo[e];
            if (i && a.count > o.reservedIndexCount || t.attributes.position.count > o.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
            const c = o.vertexStart,
                l = o.reservedVertexCount;
            o.vertexCount = t.getAttribute("position").count;
            for (const f in n.attributes) {
                const h = t.getAttribute(f),
                    d = n.getAttribute(f);
                zS(h, d, c);
                const u = h.itemSize;
                for (let _ = h.count, g = l; _ < g; _++) {
                    const m = c + _;
                    for (let p = 0; p < u; p++) d.setComponent(m, p, 0)
                }
                d.needsUpdate = !0, d.addUpdateRange(c * u, l * u)
            }
            if (i) {
                const f = o.indexStart,
                    h = o.reservedIndexCount;
                o.indexCount = t.getIndex().count;
                for (let d = 0; d < a.count; d++) s.setX(f + d, c + a.getX(d));
                for (let d = a.count, u = h; d < u; d++) s.setX(f + d, c);
                s.needsUpdate = !0, s.addUpdateRange(f, o.reservedIndexCount)
            }
            return o.start = i ? o.indexStart : o.vertexStart, o.count = i ? o.indexCount : o.vertexCount, o.boundingBox = null, t.boundingBox !== null && (o.boundingBox = t.boundingBox.clone()), o.boundingSphere = null, t.boundingSphere !== null && (o.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e
        }
        deleteGeometry(e) {
            const t = this._geometryInfo;
            if (e >= t.length || t[e].active === !1) return this;
            const n = this._instanceInfo;
            for (let i = 0, s = n.length; i < s; i++) n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
            return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this
        }
        deleteInstance(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this
        }
        optimize() {
            let e = 0,
                t = 0;
            const n = this._geometryInfo,
                i = n.map((a, o) => o).sort((a, o) => n[a].vertexStart - n[o].vertexStart),
                s = this.geometry;
            for (let a = 0, o = n.length; a < o; a++) {
                const c = i[a],
                    l = n[c];
                if (l.active !== !1) {
                    if (s.index !== null) {
                        if (l.indexStart !== t) {
                            const {
                                indexStart: f,
                                vertexStart: h,
                                reservedIndexCount: d
                            } = l, u = s.index, _ = u.array, g = e - h;
                            for (let m = f; m < f + d; m++) _[m] = _[m] + g;
                            u.array.copyWithin(t, f, f + d), u.addUpdateRange(t, d), l.indexStart = t
                        }
                        t += l.reservedIndexCount
                    }
                    if (l.vertexStart !== e) {
                        const {
                            vertexStart: f,
                            reservedVertexCount: h
                        } = l, d = s.attributes;
                        for (const u in d) {
                            const _ = d[u],
                                {
                                    array: g,
                                    itemSize: m
                                } = _;
                            g.copyWithin(e * m, f * m, (f + h) * m), _.addUpdateRange(e * m, h * m)
                        }
                        l.vertexStart = e
                    }
                    e += l.reservedVertexCount, l.start = s.index ? l.indexStart : l.vertexStart, this._nextIndexStart = s.index ? l.indexStart + l.reservedIndexCount : 0, this._nextVertexStart = l.vertexStart + l.reservedVertexCount
                }
            }
            return this
        }
        getBoundingBoxAt(e, t) {
            if (e >= this._geometryCount) return null;
            const n = this.geometry,
                i = this._geometryInfo[e];
            if (i.boundingBox === null) {
                const s = new Gt,
                    a = n.index,
                    o = n.attributes.position;
                for (let c = i.start, l = i.start + i.count; c < l; c++) {
                    let f = c;
                    a && (f = a.getX(f)), s.expandByPoint(Sc.fromBufferAttribute(o, f))
                }
                i.boundingBox = s
            }
            return t.copy(i.boundingBox), t
        }
        getBoundingSphereAt(e, t) {
            if (e >= this._geometryCount) return null;
            const n = this.geometry,
                i = this._geometryInfo[e];
            if (i.boundingSphere === null) {
                const s = new Rn;
                this.getBoundingBoxAt(e, bu), bu.getCenter(s.center);
                const a = n.index,
                    o = n.attributes.position;
                let c = 0;
                for (let l = i.start, f = i.start + i.count; l < f; l++) {
                    let h = l;
                    a && (h = a.getX(h)), Sc.fromBufferAttribute(o, h), c = Math.max(c, s.center.distanceToSquared(Sc))
                }
                s.radius = Math.sqrt(c), i.boundingSphere = s
            }
            return t.copy(i.boundingSphere), t
        }
        setMatrixAt(e, t) {
            this.validateInstanceId(e);
            const n = this._matricesTexture,
                i = this._matricesTexture.image.data;
            return t.toArray(i, e * 16), n.needsUpdate = !0, this
        }
        getMatrixAt(e, t) {
            return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16)
        }
        setColorAt(e, t) {
            return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this
        }
        getColorAt(e, t) {
            return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4)
        }
        setVisibleAt(e, t) {
            return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this)
        }
        getVisibleAt(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].visible
        }
        setGeometryIdAt(e, t) {
            return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this
        }
        getGeometryIdAt(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex
        }
        getGeometryRangeAt(e, t = {}) {
            this.validateGeometryId(e);
            const n = this._geometryInfo[e];
            return t.vertexStart = n.vertexStart, t.vertexCount = n.vertexCount, t.reservedVertexCount = n.reservedVertexCount, t.indexStart = n.indexStart, t.indexCount = n.indexCount, t.reservedIndexCount = n.reservedIndexCount, t.start = n.start, t.count = n.count, t
        }
        setInstanceCount(e) {
            const t = this._availableInstanceIds,
                n = this._instanceInfo;
            for (t.sort(Kh); t[t.length - 1] === n.length;) n.pop(), t.pop();
            if (e < n.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
            const i = new Int32Array(e),
                s = new Int32Array(e);
            Ks(this._multiDrawCounts, i), Ks(this._multiDrawStarts, s), this._multiDrawCounts = i, this._multiDrawStarts = s, this._maxInstanceCount = e;
            const a = this._indirectTexture,
                o = this._matricesTexture,
                c = this._colorsTexture;
            a.dispose(), this._initIndirectTexture(), Ks(a.image.data, this._indirectTexture.image.data), o.dispose(), this._initMatricesTexture(), Ks(o.image.data, this._matricesTexture.image.data), c && (c.dispose(), this._initColorsTexture(), Ks(c.image.data, this._colorsTexture.image.data))
        }
        setGeometrySize(e, t) {
            const n = [...this._geometryInfo].filter(o => o.active);
            if (Math.max(...n.map(o => o.vertexStart + o.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
            if (this.geometry.index && Math.max(...n.map(c => c.indexStart + c.reservedIndexCount)) > t) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
            const s = this.geometry;
            s.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Fn, this._initializeGeometry(s));
            const a = this.geometry;
            s.index && Ks(s.index.array, a.index.array);
            for (const o in s.attributes) Ks(s.attributes[o].array, a.attributes[o].array)
        }
        raycast(e, t) {
            const n = this._instanceInfo,
                i = this._geometryInfo,
                s = this.matrixWorld,
                a = this.geometry;
            In.material = this.material, In.geometry.index = a.index, In.geometry.attributes = a.attributes, In.geometry.boundingBox === null && (In.geometry.boundingBox = new Gt), In.geometry.boundingSphere === null && (In.geometry.boundingSphere = new Rn);
            for (let o = 0, c = n.length; o < c; o++) {
                if (!n[o].visible || !n[o].active) continue;
                const l = n[o].geometryIndex,
                    f = i[l];
                In.geometry.setDrawRange(f.start, f.count), this.getMatrixAt(o, In.matrixWorld).premultiply(s), this.getBoundingBoxAt(l, In.geometry.boundingBox), this.getBoundingSphereAt(l, In.geometry.boundingSphere), In.raycast(e, xu);
                for (let h = 0, d = xu.length; h < d; h++) {
                    const u = xu[h];
                    u.object = this, u.batchId = o, t.push(u)
                }
                xu.length = 0
            }
            In.material = null, In.geometry.index = null, In.geometry.attributes = {}, In.geometry.setDrawRange(0, 1 / 0)
        }
        copy(e) {
            return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(t => ({ ...t,
                boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
                boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
            })), this._instanceInfo = e._instanceInfo.map(t => ({ ...t
            })), this._availableInstanceIds = e._availableInstanceIds.slice(), this._availableGeometryIds = e._availableGeometryIds.slice(), this._nextIndexStart = e._nextIndexStart, this._nextVertexStart = e._nextVertexStart, this._geometryCount = e._geometryCount, this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._indirectTexture = e._indirectTexture.clone(), this._indirectTexture.image.data = this._indirectTexture.image.data.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this
        }
        dispose() {
            this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null)
        }
        onBeforeRender(e, t, n, i, s) {
            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
            const a = i.getIndex(),
                o = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
                c = this._instanceInfo,
                l = this._multiDrawStarts,
                f = this._multiDrawCounts,
                h = this._geometryInfo,
                d = this.perObjectFrustumCulled,
                u = this._indirectTexture,
                _ = u.image.data,
                g = n.isArrayCamera ? BS : h_;
            d && !n.isArrayCamera && (ti.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), h_.setFromProjectionMatrix(ti, e.coordinateSystem));
            let m = 0;
            if (this.sortObjects) {
                ti.copy(this.matrixWorld).invert(), Sc.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ti), d_.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(ti);
                for (let x = 0, b = c.length; x < b; x++)
                    if (c[x].visible && c[x].active) {
                        const S = c[x].geometryIndex;
                        this.getMatrixAt(x, ti), this.getBoundingSphereAt(S, $s).applyMatrix4(ti);
                        let E = !1;
                        if (d && (E = !g.intersectsSphere($s, n)), !E) {
                            const T = h[S],
                                w = kS.subVectors($s.center, Sc).dot(d_);
                            Jh.push(T.start, T.count, w, x)
                        }
                    }
                const p = Jh.list,
                    v = this.customSort;
                v === null ? p.sort(s.transparent ? NS : LS) : v.call(this, p, n);
                for (let x = 0, b = p.length; x < b; x++) {
                    const S = p[x];
                    l[m] = S.start * o, f[m] = S.count, _[m] = S.index, m++
                }
                Jh.reset()
            } else
                for (let p = 0, v = c.length; p < v; p++)
                    if (c[p].visible && c[p].active) {
                        const x = c[p].geometryIndex;
                        let b = !1;
                        if (d && (this.getMatrixAt(p, ti), this.getBoundingSphereAt(x, $s).applyMatrix4(ti), b = !g.intersectsSphere($s, n)), !b) {
                            const S = h[x];
                            l[m] = S.start * o, f[m] = S.count, _[m] = p, m++
                        }
                    }
            u.needsUpdate = !0, this._multiDrawCount = m, this._visibilityChanged = !1
        }
        onBeforeShadow(e, t, n, i, s, a) {
            this.onBeforeRender(e, null, i, s, a)
        }
    }
    class p_ extends Ei {
        constructor(e) {
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new rt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
        }
    }
    const vu = new B,
        yu = new B,
        m_ = new Ke,
        Mc = new Xa,
        Su = new Rn,
        Zh = new B,
        g_ = new B;
    class Qh extends Ht {
        constructor(e = new Fn, t = new p_) {
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position,
                    n = [0];
                for (let i = 1, s = t.count; i < s; i++) vu.fromBufferAttribute(t, i - 1), yu.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += vu.distanceTo(yu);
                e.setAttribute("lineDistance", new Lr(n, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Line.threshold,
                a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), Su.copy(n.boundingSphere), Su.applyMatrix4(i), Su.radius += s, e.ray.intersectsSphere(Su) === !1) return;
            m_.copy(i).invert(), Mc.copy(e.ray).applyMatrix4(m_);
            const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                c = o * o,
                l = this.isLineSegments ? 2 : 1,
                f = n.index,
                d = n.attributes.position;
            if (f !== null) {
                const u = Math.max(0, a.start),
                    _ = Math.min(f.count, a.start + a.count);
                for (let g = u, m = _ - 1; g < m; g += l) {
                    const p = f.getX(g),
                        v = f.getX(g + 1),
                        x = Mu(this, e, Mc, c, p, v, g);
                    x && t.push(x)
                }
                if (this.isLineLoop) {
                    const g = f.getX(_ - 1),
                        m = f.getX(u),
                        p = Mu(this, e, Mc, c, g, m, _ - 1);
                    p && t.push(p)
                }
            } else {
                const u = Math.max(0, a.start),
                    _ = Math.min(d.count, a.start + a.count);
                for (let g = u, m = _ - 1; g < m; g += l) {
                    const p = Mu(this, e, Mc, c, g, g + 1, g);
                    p && t.push(p)
                }
                if (this.isLineLoop) {
                    const g = Mu(this, e, Mc, c, _ - 1, u, _ - 1);
                    g && t.push(g)
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
    }

    function Mu(r, e, t, n, i, s, a) {
        const o = r.geometry.attributes.position;
        if (vu.fromBufferAttribute(o, i), yu.fromBufferAttribute(o, s), t.distanceSqToSegment(vu, yu, Zh, g_) > n) return;
        Zh.applyMatrix4(r.matrixWorld);
        const l = e.ray.origin.distanceTo(Zh);
        if (!(l < e.near || l > e.far)) return {
            distance: l,
            point: g_.clone().applyMatrix4(r.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: r
        }
    }
    const __ = new B,
        b_ = new B;
    class HS extends Qh {
        constructor(e, t) {
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position,
                    n = [];
                for (let i = 0, s = t.count; i < s; i += 2) __.fromBufferAttribute(t, i), b_.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + __.distanceTo(b_);
                e.setAttribute("lineDistance", new Lr(n, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
    }
    class VS extends Qh {
        constructor(e, t) {
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
        }
    }
    class x_ extends Ei {
        constructor(e) {
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
        }
    }
    const v_ = new Ke,
        ed = new Xa,
        Tu = new Rn,
        Eu = new B;
    class WS extends Ht {
        constructor(e = new Fn, t = new x_) {
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
        }
        raycast(e, t) {
            const n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Points.threshold,
                a = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), Tu.copy(n.boundingSphere), Tu.applyMatrix4(i), Tu.radius += s, e.ray.intersectsSphere(Tu) === !1) return;
            v_.copy(i).invert(), ed.copy(e.ray).applyMatrix4(v_);
            const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                c = o * o,
                l = n.index,
                h = n.attributes.position;
            if (l !== null) {
                const d = Math.max(0, a.start),
                    u = Math.min(l.count, a.start + a.count);
                for (let _ = d, g = u; _ < g; _++) {
                    const m = l.getX(_);
                    Eu.fromBufferAttribute(h, m), y_(Eu, m, c, i, e, t, this)
                }
            } else {
                const d = Math.max(0, a.start),
                    u = Math.min(h.count, a.start + a.count);
                for (let _ = d, g = u; _ < g; _++) Eu.fromBufferAttribute(h, _), y_(Eu, _, c, i, e, t, this)
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let s = 0, a = i.length; s < a; s++) {
                        const o = i[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
                    }
                }
            }
        }
    }

    function y_(r, e, t, n, i, s, a) {
        const o = ed.distanceSqToPoint(r);
        if (o < t) {
            const c = new B;
            ed.closestPointToPoint(r, c), c.applyMatrix4(n);
            const l = i.ray.origin.distanceTo(c);
            if (l < i.near || l > i.far) return;
            s.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: c,
                index: e,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: a
            })
        }
    }
    class S_ extends on {
        constructor(e, t, n = 1014, i, s, a, o = 1003, c = 1003, l, f = 1026, h = 1) {
            if (f !== 1026 && f !== 1027) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            const d = {
                width: e,
                height: t,
                depth: h
            };
            super(d, i, s, a, o, c, f, n, l), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
        }
        copy(e) {
            return super.copy(e), this.source = new Sh(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
        }
    }
    class Tc extends Fn {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const s = e / 2,
                a = t / 2,
                o = Math.floor(n),
                c = Math.floor(i),
                l = o + 1,
                f = c + 1,
                h = e / o,
                d = t / c,
                u = [],
                _ = [],
                g = [],
                m = [];
            for (let p = 0; p < f; p++) {
                const v = p * d - a;
                for (let x = 0; x < l; x++) {
                    const b = x * h - s;
                    _.push(b, -v, 0), g.push(0, 0, 1), m.push(x / o), m.push(1 - p / c)
                }
            }
            for (let p = 0; p < c; p++)
                for (let v = 0; v < o; v++) {
                    const x = v + l * p,
                        b = v + l * (p + 1),
                        S = v + 1 + l * (p + 1),
                        E = v + 1 + l * p;
                    u.push(x, b, E), u.push(b, S, E)
                }
            this.setIndex(u), this.setAttribute("position", new Lr(_, 3)), this.setAttribute("normal", new Lr(g, 3)), this.setAttribute("uv", new Lr(m, 2))
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
        }
        static fromJSON(e) {
            return new Tc(e.width, e.height, e.widthSegments, e.heightSegments)
        }
    }
    class td extends Ei {
        constructor(e) {
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new lr, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
        }
    }
    class hr extends td {
        constructor(e) {
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new at(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return ht(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t)
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new rt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new rt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new rt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
        }
        get anisotropy() {
            return this._anisotropy
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
        }
        get clearcoat() {
            return this._clearcoat
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
        }
        get iridescence() {
            return this._iridescence
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
        }
        get dispersion() {
            return this._dispersion
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
        }
        get sheen() {
            return this._sheen
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
        }
        get transmission() {
            return this._transmission
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
        }
    }
    class XS extends Ei {
        constructor(e) {
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }
    }
    class jS extends Ei {
        constructor(e) {
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        }
    }
    class qS extends Ei {
        constructor(e) {
            super(), this.isMeshMatcapMaterial = !0, this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.defines = {
                MATCAP: ""
            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
        }
    }

    function wu(r, e) {
        return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
    }

    function YS(r) {
        return ArrayBuffer.isView(r) && !(r instanceof DataView)
    }

    function $S(r) {
        function e(i, s) {
            return r[i] - r[s]
        }
        const t = r.length,
            n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = i;
        return n.sort(e), n
    }

    function M_(r, e, t) {
        const n = r.length,
            i = new r.constructor(n);
        for (let s = 0, a = 0; a !== n; ++s) {
            const o = t[s] * e;
            for (let c = 0; c !== e; ++c) i[a++] = r[o + c]
        }
        return i
    }

    function T_(r, e, t, n) {
        let i = 1,
            s = r[0];
        for (; s !== void 0 && s[n] === void 0;) s = r[i++];
        if (s === void 0) return;
        let a = s[n];
        if (a !== void 0)
            if (Array.isArray(a))
                do a = s[n], a !== void 0 && (e.push(s.time), t.push(...a)), s = r[i++]; while (s !== void 0);
            else if (a.toArray !== void 0)
            do a = s[n], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = r[i++]; while (s !== void 0);
        else
            do a = s[n], a !== void 0 && (e.push(s.time), t.push(a)), s = r[i++]; while (s !== void 0)
    }
    class Ec {
        constructor(e, t, n, i) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex,
                i = t[n],
                s = t[n - 1];
            n: {
                e: {
                    let a;t: {
                        i: if (!(e < i)) {
                            for (let o = n + 2;;) {
                                if (i === void 0) {
                                    if (e < s) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                }
                                if (n === o) break;
                                if (s = i, i = t[++n], e < i) break e
                            }
                            a = t.length;
                            break t
                        }if (!(e >= s)) {
                            const o = t[1];
                            e < o && (n = 2, s = o);
                            for (let c = n - 2;;) {
                                if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === c) break;
                                if (i = s, s = t[--n - 1], e >= s) break e
                            }
                            a = n, n = 0;
                            break t
                        }
                        break n
                    }
                    for (; n < a;) {
                        const o = n + a >>> 1;
                        e < t[o] ? a = o : n = o + 1
                    }
                    if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, s, i)
            }
            return this.interpolate_(n, s, e, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                s = e * i;
            for (let a = 0; a !== i; ++a) t[a] = n[s + a];
            return t
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
    class KS extends Ec {
        constructor(e, t, n, i) {
            super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: 2400,
                endingEnd: 2400
            }
        }
        intervalChanged_(e, t, n) {
            const i = this.parameterPositions;
            let s = e - 2,
                a = e + 1,
                o = i[s],
                c = i[a];
            if (o === void 0) switch (this.getSettings_().endingStart) {
                case 2401:
                    s = e, o = 2 * t - n;
                    break;
                case 2402:
                    s = i.length - 2, o = t + i[s] - i[s + 1];
                    break;
                default:
                    s = e, o = n
            }
            if (c === void 0) switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e, c = 2 * n - t;
                    break;
                case 2402:
                    a = 1, c = n + i[1] - i[0];
                    break;
                default:
                    a = e - 1, c = t
            }
            const l = (n - t) * .5,
                f = this.valueSize;
            this._weightPrev = l / (t - o), this._weightNext = l / (c - n), this._offsetPrev = s * f, this._offsetNext = a * f
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                c = e * o,
                l = c - o,
                f = this._offsetPrev,
                h = this._offsetNext,
                d = this._weightPrev,
                u = this._weightNext,
                _ = (n - t) / (i - t),
                g = _ * _,
                m = g * _,
                p = -d * m + 2 * d * g - d * _,
                v = (1 + d) * m + (-1.5 - 2 * d) * g + (-.5 + d) * _ + 1,
                x = (-1 - u) * m + (1.5 + u) * g + .5 * _,
                b = u * m - u * g;
            for (let S = 0; S !== o; ++S) s[S] = p * a[f + S] + v * a[l + S] + x * a[c + S] + b * a[h + S];
            return s
        }
    }
    class JS extends Ec {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                c = e * o,
                l = c - o,
                f = (n - t) / (i - t),
                h = 1 - f;
            for (let d = 0; d !== o; ++d) s[d] = a[l + d] * h + a[c + d] * f;
            return s
        }
    }
    class ZS extends Ec {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1)
        }
    }
    class $i {
        constructor(e, t, n, i) {
            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = wu(t, this.TimeBufferType), this.values = wu(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: wu(e.times, Array),
                    values: wu(e.values, Array)
                };
                const i = e.getInterpolation();
                i !== e.DefaultInterpolation && (n.interpolation = i)
            }
            return n.type = e.ValueTypeName, n
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new ZS(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodLinear(e) {
            return new JS(this.times, this.values, this.getValueSize(), e)
        }
        InterpolantFactoryMethodSmooth(e) {
            return new KS(this.times, this.values, this.getValueSize(), e)
        }
        setInterpolation(e) {
            let t;
            switch (e) {
                case 2300:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth;
                    break
            }
            if (t === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0)
                    if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                    else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this
            }
            return this.createInterpolant = t, this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(e) {
            if (e !== 0) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
            }
            return this
        }
        scale(e) {
            if (e !== 1) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
            }
            return this
        }
        trim(e, t) {
            const n = this.times,
                i = n.length;
            let s = 0,
                a = i - 1;
            for (; s !== i && n[s] < e;) ++s;
            for (; a !== -1 && n[a] > t;) --a;
            if (++a, s !== 0 || a !== i) {
                s >= a && (a = Math.max(a, 1), s = a - 1);
                const o = this.getValueSize();
                this.times = n.slice(s, a), this.values = this.values.slice(s * o, a * o)
            }
            return this
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times,
                i = this.values,
                s = n.length;
            s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let a = null;
            for (let o = 0; o !== s; o++) {
                const c = n[o];
                if (typeof c == "number" && isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), e = !1;
                    break
                }
                if (a !== null && a > c) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), e = !1;
                    break
                }
                a = c
            }
            if (i !== void 0 && YS(i))
                for (let o = 0, c = i.length; o !== c; ++o) {
                    const l = i[o];
                    if (isNaN(l)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), e = !1;
                        break
                    }
                }
            return e
        }
        optimize() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = this.getValueSize(),
                i = this.getInterpolation() === 2302,
                s = e.length - 1;
            let a = 1;
            for (let o = 1; o < s; ++o) {
                let c = !1;
                const l = e[o],
                    f = e[o + 1];
                if (l !== f && (o !== 1 || l !== e[0]))
                    if (i) c = !0;
                    else {
                        const h = o * n,
                            d = h - n,
                            u = h + n;
                        for (let _ = 0; _ !== n; ++_) {
                            const g = t[h + _];
                            if (g !== t[d + _] || g !== t[u + _]) {
                                c = !0;
                                break
                            }
                        }
                    }
                if (c) {
                    if (o !== a) {
                        e[a] = e[o];
                        const h = o * n,
                            d = a * n;
                        for (let u = 0; u !== n; ++u) t[d + u] = t[h + u]
                    }++a
                }
            }
            if (s > 0) {
                e[a] = e[s];
                for (let o = s * n, c = a * n, l = 0; l !== n; ++l) t[c + l] = t[o + l];
                ++a
            }
            return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this
        }
        clone() {
            const e = this.times.slice(),
                t = this.values.slice(),
                n = this.constructor,
                i = new n(this.name, e, t);
            return i.createInterpolant = this.createInterpolant, i
        }
    }
    $i.prototype.ValueTypeName = "", $i.prototype.TimeBufferType = Float32Array, $i.prototype.ValueBufferType = Float32Array, $i.prototype.DefaultInterpolation = 2301;
    class no extends $i {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    no.prototype.ValueTypeName = "bool", no.prototype.ValueBufferType = Array, no.prototype.DefaultInterpolation = 2300, no.prototype.InterpolantFactoryMethodLinear = void 0, no.prototype.InterpolantFactoryMethodSmooth = void 0;
    class E_ extends $i {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    E_.prototype.ValueTypeName = "color";
    class io extends $i {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    io.prototype.ValueTypeName = "number";
    class QS extends Ec {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                c = (n - t) / (i - t);
            let l = e * o;
            for (let f = l + o; l !== f; l += 4) as.slerpFlat(s, 0, a, l - o, a, l, c);
            return s
        }
    }
    class ro extends $i {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        InterpolantFactoryMethodLinear(e) {
            return new QS(this.times, this.values, this.getValueSize(), e)
        }
    }
    ro.prototype.ValueTypeName = "quaternion", ro.prototype.InterpolantFactoryMethodSmooth = void 0;
    class so extends $i {
        constructor(e, t, n) {
            super(e, t, n)
        }
    }
    so.prototype.ValueTypeName = "string", so.prototype.ValueBufferType = Array, so.prototype.DefaultInterpolation = 2300, so.prototype.InterpolantFactoryMethodLinear = void 0, so.prototype.InterpolantFactoryMethodSmooth = void 0;
    class ao extends $i {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
    }
    ao.prototype.ValueTypeName = "vector";
    class eM {
        constructor(e = "", t = -1, n = [], i = 2500) {
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Wi(), this.duration < 0 && this.resetDuration()
        }
        static parse(e) {
            const t = [],
                n = e.tracks,
                i = 1 / (e.fps || 1);
            for (let a = 0, o = n.length; a !== o; ++a) t.push(nM(n[a]).scale(i));
            const s = new this(e.name, e.duration, t, e.blendMode);
            return s.uuid = e.uuid, s
        }
        static toJSON(e) {
            const t = [],
                n = e.tracks,
                i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
            for (let s = 0, a = n.length; s !== a; ++s) t.push($i.toJSON(n[s]));
            return i
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
            const s = t.length,
                a = [];
            for (let o = 0; o < s; o++) {
                let c = [],
                    l = [];
                c.push((o + s - 1) % s, o, (o + 1) % s), l.push(0, 1, 0);
                const f = $S(c);
                c = M_(c, 1, f), l = M_(l, 1, f), !i && c[0] === 0 && (c.push(s), l.push(l[0])), a.push(new io(".morphTargetInfluences[" + t[o].name + "]", c, l).scale(1 / n))
            }
            return new this(e, -1, a)
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const i = e;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (let i = 0; i < n.length; i++)
                if (n[i].name === t) return n[i];
            return null
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const i = {},
                s = /^([\w-]*?)([\d]+)$/;
            for (let o = 0, c = e.length; o < c; o++) {
                const l = e[o],
                    f = l.name.match(s);
                if (f && f.length > 1) {
                    const h = f[1];
                    let d = i[h];
                    d || (i[h] = d = []), d.push(l)
                }
            }
            const a = [];
            for (const o in i) a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
            return a
        }
        static parseAnimation(e, t) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(h, d, u, _, g) {
                    if (u.length !== 0) {
                        const m = [],
                            p = [];
                        T_(u, m, p, _), m.length !== 0 && g.push(new h(d, m, p))
                    }
                },
                i = [],
                s = e.name || "default",
                a = e.fps || 30,
                o = e.blendMode;
            let c = e.length || -1;
            const l = e.hierarchy || [];
            for (let h = 0; h < l.length; h++) {
                const d = l[h].keys;
                if (!(!d || d.length === 0))
                    if (d[0].morphTargets) {
                        const u = {};
                        let _;
                        for (_ = 0; _ < d.length; _++)
                            if (d[_].morphTargets)
                                for (let g = 0; g < d[_].morphTargets.length; g++) u[d[_].morphTargets[g]] = -1;
                        for (const g in u) {
                            const m = [],
                                p = [];
                            for (let v = 0; v !== d[_].morphTargets.length; ++v) {
                                const x = d[_];
                                m.push(x.time), p.push(x.morphTarget === g ? 1 : 0)
                            }
                            i.push(new io(".morphTargetInfluence[" + g + "]", m, p))
                        }
                        c = u.length * a
                    } else {
                        const u = ".bones[" + t[h].name + "]";
                        n(ao, u + ".position", d, "pos", i), n(ro, u + ".quaternion", d, "rot", i), n(ao, u + ".scale", d, "scl", i)
                    }
            }
            return i.length === 0 ? null : new this(s, c, i, o)
        }
        resetDuration() {
            const e = this.tracks;
            let t = 0;
            for (let n = 0, i = e.length; n !== i; ++n) {
                const s = this.tracks[n];
                t = Math.max(t, s.times[s.times.length - 1])
            }
            return this.duration = t, this
        }
        trim() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        }
        validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        }
        optimize() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
        clone() {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }

    function tM(r) {
        switch (r.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return io;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return ao;
            case "color":
                return E_;
            case "quaternion":
                return ro;
            case "bool":
            case "boolean":
                return no;
            case "string":
                return so
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
    }

    function nM(r) {
        if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = tM(r.type);
        if (r.times === void 0) {
            const t = [],
                n = [];
            T_(r.keys, t, n, "value"), r.times = t, r.values = n
        }
        return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation)
    }
    const ms = {
        enabled: !1,
        files: {},
        add: function(r, e) {
            this.enabled !== !1 && (this.files[r] = e)
        },
        get: function(r) {
            if (this.enabled !== !1) return this.files[r]
        },
        remove: function(r) {
            delete this.files[r]
        },
        clear: function() {
            this.files = {}
        }
    };
    class w_ {
        constructor(e, t, n) {
            const i = this;
            let s = !1,
                a = 0,
                o = 0,
                c;
            const l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(f) {
                o++, s === !1 && i.onStart !== void 0 && i.onStart(f, a, o), s = !0
            }, this.itemEnd = function(f) {
                a++, i.onProgress !== void 0 && i.onProgress(f, a, o), a === o && (s = !1, i.onLoad !== void 0 && i.onLoad())
            }, this.itemError = function(f) {
                i.onError !== void 0 && i.onError(f)
            }, this.resolveURL = function(f) {
                return c ? c(f) : f
            }, this.setURLModifier = function(f) {
                return c = f, this
            }, this.addHandler = function(f, h) {
                return l.push(f, h), this
            }, this.removeHandler = function(f) {
                const h = l.indexOf(f);
                return h !== -1 && l.splice(h, 2), this
            }, this.getHandler = function(f) {
                for (let h = 0, d = l.length; h < d; h += 2) {
                    const u = l[h],
                        _ = l[h + 1];
                    if (u.global && (u.lastIndex = 0), u.test(f)) return _
                }
                return null
            }
        }
    }
    const iM = new w_;
    class Js {
        constructor(e) {
            this.manager = e !== void 0 ? e : iM, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise(function(i, s) {
                n.load(e, i, t, s)
            })
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this
        }
        setPath(e) {
            return this.path = e, this
        }
        setResourcePath(e) {
            return this.resourcePath = e, this
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this
        }
    }
    Js.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Or = {};
    class rM extends Error {
        constructor(e, t) {
            super(e), this.response = t
        }
    }
    class Au extends Js {
        constructor(e) {
            super(e), this.mimeType = "", this.responseType = ""
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = ms.get(e);
            if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
                t && t(s), this.manager.itemEnd(e)
            }, 0), s;
            if (Or[e] !== void 0) {
                Or[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                return
            }
            Or[e] = [], Or[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            const a = new Request(e, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                }),
                o = this.mimeType,
                c = this.responseType;
            fetch(a).then(l => {
                if (l.status === 200 || l.status === 0) {
                    if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
                    const f = Or[e],
                        h = l.body.getReader(),
                        d = l.headers.get("X-File-Size") || l.headers.get("Content-Length"),
                        u = d ? parseInt(d) : 0,
                        _ = u !== 0;
                    let g = 0;
                    const m = new ReadableStream({
                        start(p) {
                            v();

                            function v() {
                                h.read().then(({
                                    done: x,
                                    value: b
                                }) => {
                                    if (x) p.close();
                                    else {
                                        g += b.byteLength;
                                        const S = new ProgressEvent("progress", {
                                            lengthComputable: _,
                                            loaded: g,
                                            total: u
                                        });
                                        for (let E = 0, T = f.length; E < T; E++) {
                                            const w = f[E];
                                            w.onProgress && w.onProgress(S)
                                        }
                                        p.enqueue(b), v()
                                    }
                                }, x => {
                                    p.error(x)
                                })
                            }
                        }
                    });
                    return new Response(m)
                } else throw new rM(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l)
            }).then(l => {
                switch (c) {
                    case "arraybuffer":
                        return l.arrayBuffer();
                    case "blob":
                        return l.blob();
                    case "document":
                        return l.text().then(f => new DOMParser().parseFromString(f, o));
                    case "json":
                        return l.json();
                    default:
                        if (o === "") return l.text(); {
                            const h = /charset="?([^;"\s]*)"?/i.exec(o),
                                d = h && h[1] ? h[1].toLowerCase() : void 0,
                                u = new TextDecoder(d);
                            return l.arrayBuffer().then(_ => u.decode(_))
                        }
                }
            }).then(l => {
                ms.add(e, l);
                const f = Or[e];
                delete Or[e];
                for (let h = 0, d = f.length; h < d; h++) {
                    const u = f[h];
                    u.onLoad && u.onLoad(l)
                }
            }).catch(l => {
                const f = Or[e];
                if (f === void 0) throw this.manager.itemError(e), l;
                delete Or[e];
                for (let h = 0, d = f.length; h < d; h++) {
                    const u = f[h];
                    u.onError && u.onError(l)
                }
                this.manager.itemError(e)
            }).finally(() => {
                this.manager.itemEnd(e)
            }), this.manager.itemStart(e)
        }
        setResponseType(e) {
            return this.responseType = e, this
        }
        setMimeType(e) {
            return this.mimeType = e, this
        }
    }
    class sM extends Js {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = this,
                a = ms.get(e);
            if (a !== void 0) return s.manager.itemStart(e), setTimeout(function() {
                t && t(a), s.manager.itemEnd(e)
            }, 0), a;
            const o = hc("img");

            function c() {
                f(), ms.add(e, this), t && t(this), s.manager.itemEnd(e)
            }

            function l(h) {
                f(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e)
            }

            function f() {
                o.removeEventListener("load", c, !1), o.removeEventListener("error", l, !1)
            }
            return o.addEventListener("load", c, !1), o.addEventListener("error", l, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o
        }
    }
    let A_ = class extends Js {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const s = new on,
                a = new sM(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
                s.image = o, s.needsUpdate = !0, t !== void 0 && t(s)
            }, n, i), s
        }
    };
    class nd extends Ht {
        constructor(e, t = 1) {
            super(), this.isLight = !0, this.type = "Light", this.color = new rt(e), this.intensity = t
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t
        }
    }
    const id = new Ke,
        D_ = new B,
        C_ = new B;
    class rd {
        constructor(e) {
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new at(512, 512), this.mapType = 1009, this.map = null, this.mapPass = null, this.matrix = new Ke, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new yc, this._frameExtents = new at(1, 1), this._viewportCount = 1, this._viewports = [new Tt(0, 0, 1, 1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            const t = this.camera,
                n = this.matrix;
            D_.setFromMatrixPosition(e.matrixWorld), t.position.copy(D_), C_.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(C_), t.updateMatrixWorld(), id.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(id), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(id)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        toJSON() {
            const e = {};
            return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }
    class aM extends rd {
        constructor() {
            super(new Hn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1
        }
        updateMatrices(e) {
            const t = this.camera,
                n = Ba * 2 * e.angle * this.focus,
                i = this.mapSize.width / this.mapSize.height * this.aspect,
                s = e.distance || t.far;
            (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this
        }
    }
    class oM extends nd {
        constructor(e, t, n = 0, i = Math.PI / 3, s = 0, a = 2) {
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ht.DEFAULT_UP), this.updateMatrix(), this.target = new Ht, this.distance = n, this.angle = i, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new aM
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(e) {
            this.intensity = e / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    const R_ = new Ke,
        wc = new B,
        sd = new B;
    class cM extends rd {
        constructor() {
            super(new Hn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new at(4, 2), this._viewportCount = 6, this._viewports = [new Tt(2, 1, 1, 1), new Tt(0, 1, 1, 1), new Tt(3, 1, 1, 1), new Tt(1, 1, 1, 1), new Tt(3, 0, 1, 1), new Tt(1, 0, 1, 1)], this._cubeDirections = [new B(1, 0, 0), new B(-1, 0, 0), new B(0, 0, 1), new B(0, 0, -1), new B(0, 1, 0), new B(0, -1, 0)], this._cubeUps = [new B(0, 1, 0), new B(0, 1, 0), new B(0, 1, 0), new B(0, 1, 0), new B(0, 0, 1), new B(0, 0, -1)]
        }
        updateMatrices(e, t = 0) {
            const n = this.camera,
                i = this.matrix,
                s = e.distance || n.far;
            s !== n.far && (n.far = s, n.updateProjectionMatrix()), wc.setFromMatrixPosition(e.matrixWorld), n.position.copy(wc), sd.copy(n.position), sd.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(sd), n.updateMatrixWorld(), i.makeTranslation(-wc.x, -wc.y, -wc.z), R_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(R_)
        }
    }
    class lM extends nd {
        constructor(e, t, n = 0, i = 2) {
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new cM
        }
        get power() {
            return this.intensity * 4 * Math.PI
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }
    class Du extends Zg {
        constructor(e = -1, t = 1, n = 1, i = -1, s = .1, a = 2e3) {
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = a, this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
        }
        setViewOffset(e, t, n, i, s, a) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let s = n - e,
                a = n + e,
                o = i + t,
                c = i - t;
            if (this.view !== null && this.view.enabled) {
                const l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                s += l * this.view.offsetX, a = s + l * this.view.width, o -= f * this.view.offsetY, c = o - f * this.view.height
            }
            this.projectionMatrix.makeOrthographic(s, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
        }
    }
    class uM extends rd {
        constructor() {
            super(new Du(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
        }
    }
    class fM extends nd {
        constructor(e, t) {
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ht.DEFAULT_UP), this.updateMatrix(), this.target = new Ht, this.shadow = new uM
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }
    class Ac {
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1)
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }
    const ad = new WeakMap;
    class hM extends Js {
        constructor(e) {
            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(e) {
            return this.options = e, this
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const s = this,
                a = ms.get(e);
            if (a !== void 0) {
                if (s.manager.itemStart(e), a.then) {
                    a.then(l => {
                        if (ad.has(a) === !0) i && i(ad.get(a)), s.manager.itemError(e), s.manager.itemEnd(e);
                        else return t && t(l), s.manager.itemEnd(e), l
                    });
                    return
                }
                return setTimeout(function() {
                    t && t(a), s.manager.itemEnd(e)
                }, 0), a
            }
            const o = {};
            o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
            const c = fetch(e, o).then(function(l) {
                return l.blob()
            }).then(function(l) {
                return createImageBitmap(l, Object.assign(s.options, {
                    colorSpaceConversion: "none"
                }))
            }).then(function(l) {
                return ms.add(e, l), t && t(l), s.manager.itemEnd(e), l
            }).catch(function(l) {
                i && i(l), ad.set(c, l), ms.remove(e), s.manager.itemError(e), s.manager.itemEnd(e)
            });
            ms.add(e, c), s.manager.itemStart(e)
        }
    }
    class dM extends Hn {
        constructor(e = []) {
            super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e
        }
    }
    const od = "\\[\\]\\.:\\/",
        pM = new RegExp("[" + od + "]", "g"),
        cd = "[^" + od + "]",
        mM = "[^" + od.replace("\\.", "") + "]",
        gM = /((?:WC+[\/:])*)/.source.replace("WC", cd),
        _M = /(WCOD+)?/.source.replace("WCOD", mM),
        bM = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", cd),
        xM = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", cd),
        vM = new RegExp("^" + gM + _M + bM + xM + "$"),
        yM = ["material", "materials", "bones", "map"];
    class SM {
        constructor(e, t, n) {
            const i = n || Dt.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            i !== void 0 && i.getValue(e, t)
        }
        setValue(e, t) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t)
        }
        bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        }
        unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }
    class Dt {
        constructor(e, t, n) {
            this.path = t, this.parsedPath = n || Dt.parseTrackName(t), this.node = Dt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new Dt.Composite(e, t, n) : new Dt(e, t, n)
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(pM, "")
        }
        static parseTrackName(e) {
            const t = vM.exec(e);
            if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (i !== void 0 && i !== -1) {
                const s = n.nodeName.substring(i + 1);
                yM.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n
            }
            if (e.children) {
                const n = function(s) {
                        for (let a = 0; a < s.length; a++) {
                            const o = s[a];
                            if (o.name === t || o.uuid === t) return o;
                            const c = n(o.children);
                            if (c) return c
                        }
                        return null
                    },
                    i = n(e.children);
                if (i) return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i]
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++]
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t)
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t)
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath,
                n = t.objectName,
                i = t.propertyName;
            let s = t.propertyIndex;
            if (e || (e = Dt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return
            }
            if (n) {
                let l = t.objectIndex;
                switch (n) {
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return
                        }
                        e = e.skeleton.bones;
                        for (let f = 0; f < e.length; f++)
                            if (e[f].name === l) {
                                l = f;
                                break
                            }
                        break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return
                        }
                        e = e[n]
                }
                if (l !== void 0) {
                    if (e[l] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return
                    }
                    e = e[l]
                }
            }
            const a = e[i];
            if (a === void 0) {
                const l = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e);
                return
            }
            let o = this.Versioning.None;
            this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let c = this.BindingType.Direct;
            if (s !== void 0) {
                if (i === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return
                    }
                    e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
                }
                c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s
            } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o]
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }
    Dt.Composite = SM, Dt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, Dt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, Dt.prototype.GetterByBindingType = [Dt.prototype._getValue_direct, Dt.prototype._getValue_array, Dt.prototype._getValue_arrayElement, Dt.prototype._getValue_toArray], Dt.prototype.SetterByBindingTypeAndVersioning = [
        [Dt.prototype._setValue_direct, Dt.prototype._setValue_direct_setNeedsUpdate, Dt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [Dt.prototype._setValue_array, Dt.prototype._setValue_array_setNeedsUpdate, Dt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [Dt.prototype._setValue_arrayElement, Dt.prototype._setValue_arrayElement_setNeedsUpdate, Dt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
        [Dt.prototype._setValue_fromArray, Dt.prototype._setValue_fromArray_setNeedsUpdate, Dt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ];
    const P_ = new Ke;
    class MM {
        constructor(e, t, n = 0, i = 1 / 0) {
            this.ray = new Xa(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Rh, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(e, t) {
            this.ray.set(e, t)
        }
        setFromCamera(e, t) {
            t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        }
        setFromXRController(e) {
            return P_.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(P_), this
        }
        intersectObject(e, t = !0, n = []) {
            return ld(e, this, n, t), n.sort(F_), n
        }
        intersectObjects(e, t = !0, n = []) {
            for (let i = 0, s = e.length; i < s; i++) ld(e[i], this, n, t);
            return n.sort(F_), n
        }
    }

    function F_(r, e) {
        return r.distance - e.distance
    }

    function ld(r, e, t, n) {
        let i = !0;
        if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
            const s = r.children;
            for (let a = 0, o = s.length; a < o; a++) ld(s[a], e, t, !0)
        }
    }
    const I_ = new B,
        Cu = new B;
    class Br {
        constructor(e = new B, t = new B) {
            this.start = e, this.end = t
        }
        set(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        }
        copy(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        }
        getCenter(e) {
            return e.addVectors(this.start, this.end).multiplyScalar(.5)
        }
        delta(e) {
            return e.subVectors(this.end, this.start)
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end)
        }
        distance() {
            return this.start.distanceTo(this.end)
        }
        at(e, t) {
            return this.delta(t).multiplyScalar(e).add(this.start)
        }
        closestPointToPointParameter(e, t) {
            I_.subVectors(e, this.start), Cu.subVectors(this.end, this.start);
            const n = Cu.dot(Cu);
            let s = Cu.dot(I_) / n;
            return t && (s = ht(s, 0, 1)), s
        }
        closestPointToPoint(e, t, n) {
            const i = this.closestPointToPointParameter(e, t);
            return this.delta(n).multiplyScalar(i).add(this.start)
        }
        applyMatrix4(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        }
        equals(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }

    function L_(r, e, t, n) {
        const i = TM(n);
        switch (t) {
            case 1021:
                return r * e;
            case 1028:
                return r * e / i.components * i.byteLength;
            case 1029:
                return r * e / i.components * i.byteLength;
            case 1030:
                return r * e * 2 / i.components * i.byteLength;
            case 1031:
                return r * e * 2 / i.components * i.byteLength;
            case 1022:
                return r * e * 3 / i.components * i.byteLength;
            case 1023:
                return r * e * 4 / i.components * i.byteLength;
            case 1033:
                return r * e * 4 / i.components * i.byteLength;
            case 33776:
            case 33777:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case 33778:
            case 33779:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 35841:
            case 35843:
                return Math.max(r, 16) * Math.max(e, 8) / 4;
            case 35840:
            case 35842:
                return Math.max(r, 8) * Math.max(e, 8) / 2;
            case 36196:
            case 37492:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case 37496:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 37808:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case 37809:
                return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
            case 37810:
                return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
            case 37811:
                return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
            case 37812:
                return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
            case 37813:
                return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
            case 37814:
                return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
            case 37815:
                return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
            case 37816:
                return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
            case 37817:
                return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
            case 37818:
                return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
            case 37819:
                return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
            case 37820:
                return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
            case 37821:
                return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
            case 36492:
            case 36494:
            case 36495:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
            case 36283:
            case 36284:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
            case 36285:
            case 36286:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`)
    }

    function TM(r) {
        switch (r) {
            case 1009:
            case 1010:
                return {
                    byteLength: 1,
                    components: 1
                };
            case 1012:
            case 1011:
            case 1016:
                return {
                    byteLength: 2,
                    components: 1
                };
            case 1017:
            case 1018:
                return {
                    byteLength: 2,
                    components: 4
                };
            case 1014:
            case 1013:
            case 1015:
                return {
                    byteLength: 4,
                    components: 1
                };
            case 35902:
                return {
                    byteLength: 4,
                    components: 3
                }
        }
        throw new Error(`Unknown texture type ${r}.`)
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: Jl
        }
    })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Jl);
    /**
     * @license
     * Copyright 2010-2025 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    function N_() {
        let r = null,
            e = !1,
            t = null,
            n = null;

        function i(s, a) {
            t(s, a), n = r.requestAnimationFrame(i)
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0)
            },
            stop: function() {
                r.cancelAnimationFrame(n), e = !1
            },
            setAnimationLoop: function(s) {
                t = s
            },
            setContext: function(s) {
                r = s
            }
        }
    }

    function EM(r) {
        const e = new WeakMap;

        function t(o, c) {
            const l = o.array,
                f = o.usage,
                h = l.byteLength,
                d = r.createBuffer();
            r.bindBuffer(c, d), r.bufferData(c, l, f), o.onUploadCallback();
            let u;
            if (l instanceof Float32Array) u = r.FLOAT;
            else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? u = r.HALF_FLOAT : u = r.UNSIGNED_SHORT;
            else if (l instanceof Int16Array) u = r.SHORT;
            else if (l instanceof Uint32Array) u = r.UNSIGNED_INT;
            else if (l instanceof Int32Array) u = r.INT;
            else if (l instanceof Int8Array) u = r.BYTE;
            else if (l instanceof Uint8Array) u = r.UNSIGNED_BYTE;
            else if (l instanceof Uint8ClampedArray) u = r.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
            return {
                buffer: d,
                type: u,
                bytesPerElement: l.BYTES_PER_ELEMENT,
                version: o.version,
                size: h
            }
        }

        function n(o, c, l) {
            const f = c.array,
                h = c.updateRanges;
            if (r.bindBuffer(l, o), h.length === 0) r.bufferSubData(l, 0, f);
            else {
                h.sort((u, _) => u.start - _.start);
                let d = 0;
                for (let u = 1; u < h.length; u++) {
                    const _ = h[d],
                        g = h[u];
                    g.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, g.start + g.count - _.start) : (++d, h[d] = g)
                }
                h.length = d + 1;
                for (let u = 0, _ = h.length; u < _; u++) {
                    const g = h[u];
                    r.bufferSubData(l, g.start * f.BYTES_PER_ELEMENT, f, g.start, g.count)
                }
                c.clearUpdateRanges()
            }
            c.onUploadCallback()
        }

        function i(o) {
            return o.isInterleavedBufferAttribute && (o = o.data), e.get(o)
        }

        function s(o) {
            o.isInterleavedBufferAttribute && (o = o.data);
            const c = e.get(o);
            c && (r.deleteBuffer(c.buffer), e.delete(o))
        }

        function a(o, c) {
            if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
                const f = e.get(o);
                (!f || f.version < o.version) && e.set(o, {
                    buffer: o.buffer,
                    type: o.type,
                    bytesPerElement: o.elementSize,
                    version: o.version
                });
                return
            }
            const l = e.get(o);
            if (l === void 0) e.set(o, t(o, c));
            else if (l.version < o.version) {
                if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(l.buffer, o, c), l.version = o.version
            }
        }
        return {
            get: i,
            remove: s,
            update: a
        }
    }
    var wM = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
        AM = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
        DM = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
        CM = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        RM = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
        PM = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        FM = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        IM = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        LM = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
        NM = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
        UM = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
        OM = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        BM = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
        kM = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
        zM = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        GM = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
        HM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        VM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        WM = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        XM = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        jM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        qM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
        YM = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
        $M = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
        KM = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        JM = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        ZM = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        QM = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
        eT = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        tT = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        nT = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        iT = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        rT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        sT = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        aT = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        oT = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        cT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        lT = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        uT = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        fT = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        hT = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        dT = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
        pT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        mT = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
        gT = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
        _T = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        bT = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
        xT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        vT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
        yT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        ST = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
        MT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
        TT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        ET = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        wT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        AT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
        DT = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        CT = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        RT = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        PT = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
        FT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        IT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        LT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        NT = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        UT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        OT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        BT = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
        kT = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        zT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        GT = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
        HT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        VT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
        WT = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        XT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        jT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        qT = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        YT = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
        $T = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
        KT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
        JT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
        ZT = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
        QT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        eE = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
        tE = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        nE = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        iE = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        rE = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        sE = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        aE = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        oE = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
        cE = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        lE = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
        uE = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        fE = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        hE = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
        dE = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        pE = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        mE = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        gE = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        _E = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        bE = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        xE = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
        vE = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
        yE = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        SE = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        ME = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
        TE = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const ot = {
            alphahash_fragment: wM,
            alphahash_pars_fragment: AM,
            alphamap_fragment: DM,
            alphamap_pars_fragment: CM,
            alphatest_fragment: RM,
            alphatest_pars_fragment: PM,
            aomap_fragment: FM,
            aomap_pars_fragment: IM,
            batching_pars_vertex: LM,
            batching_vertex: NM,
            begin_vertex: UM,
            beginnormal_vertex: OM,
            bsdfs: BM,
            iridescence_fragment: kM,
            bumpmap_pars_fragment: zM,
            clipping_planes_fragment: GM,
            clipping_planes_pars_fragment: HM,
            clipping_planes_pars_vertex: VM,
            clipping_planes_vertex: WM,
            color_fragment: XM,
            color_pars_fragment: jM,
            color_pars_vertex: qM,
            color_vertex: YM,
            common: $M,
            cube_uv_reflection_fragment: KM,
            defaultnormal_vertex: JM,
            displacementmap_pars_vertex: ZM,
            displacementmap_vertex: QM,
            emissivemap_fragment: eT,
            emissivemap_pars_fragment: tT,
            colorspace_fragment: nT,
            colorspace_pars_fragment: iT,
            envmap_fragment: rT,
            envmap_common_pars_fragment: sT,
            envmap_pars_fragment: aT,
            envmap_pars_vertex: oT,
            envmap_physical_pars_fragment: bT,
            envmap_vertex: cT,
            fog_vertex: lT,
            fog_pars_vertex: uT,
            fog_fragment: fT,
            fog_pars_fragment: hT,
            gradientmap_pars_fragment: dT,
            lightmap_pars_fragment: pT,
            lights_lambert_fragment: mT,
            lights_lambert_pars_fragment: gT,
            lights_pars_begin: _T,
            lights_toon_fragment: xT,
            lights_toon_pars_fragment: vT,
            lights_phong_fragment: yT,
            lights_phong_pars_fragment: ST,
            lights_physical_fragment: MT,
            lights_physical_pars_fragment: TT,
            lights_fragment_begin: ET,
            lights_fragment_maps: wT,
            lights_fragment_end: AT,
            logdepthbuf_fragment: DT,
            logdepthbuf_pars_fragment: CT,
            logdepthbuf_pars_vertex: RT,
            logdepthbuf_vertex: PT,
            map_fragment: FT,
            map_pars_fragment: IT,
            map_particle_fragment: LT,
            map_particle_pars_fragment: NT,
            metalnessmap_fragment: UT,
            metalnessmap_pars_fragment: OT,
            morphinstance_vertex: BT,
            morphcolor_vertex: kT,
            morphnormal_vertex: zT,
            morphtarget_pars_vertex: GT,
            morphtarget_vertex: HT,
            normal_fragment_begin: VT,
            normal_fragment_maps: WT,
            normal_pars_fragment: XT,
            normal_pars_vertex: jT,
            normal_vertex: qT,
            normalmap_pars_fragment: YT,
            clearcoat_normal_fragment_begin: $T,
            clearcoat_normal_fragment_maps: KT,
            clearcoat_pars_fragment: JT,
            iridescence_pars_fragment: ZT,
            opaque_fragment: QT,
            packing: eE,
            premultiplied_alpha_fragment: tE,
            project_vertex: nE,
            dithering_fragment: iE,
            dithering_pars_fragment: rE,
            roughnessmap_fragment: sE,
            roughnessmap_pars_fragment: aE,
            shadowmap_pars_fragment: oE,
            shadowmap_pars_vertex: cE,
            shadowmap_vertex: lE,
            shadowmask_pars_fragment: uE,
            skinbase_vertex: fE,
            skinning_pars_vertex: hE,
            skinning_vertex: dE,
            skinnormal_vertex: pE,
            specularmap_fragment: mE,
            specularmap_pars_fragment: gE,
            tonemapping_fragment: _E,
            tonemapping_pars_fragment: bE,
            transmission_fragment: xE,
            transmission_pars_fragment: vE,
            uv_pars_fragment: yE,
            uv_pars_vertex: SE,
            uv_vertex: ME,
            worldpos_vertex: TE,
            background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
            background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
            depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
            distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
            distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
            equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
            equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
            meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
            meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
            meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
            meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
            meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
            points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
            sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
        },
        Re = {
            common: {
                diffuse: {
                    value: new rt(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new ct
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ct
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new ct
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new ct
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new ct
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new ct
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new ct
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new ct
                },
                normalScale: {
                    value: new at(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new ct
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new ct
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new ct
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new ct
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new rt(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new rt(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ct
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new ct
                }
            },
            sprite: {
                diffuse: {
                    value: new rt(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new at(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new ct
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new ct
                },
                alphaTest: {
                    value: 0
                }
            }
        },
        dr = {
            basic: {
                uniforms: Gn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]),
                vertexShader: ot.meshbasic_vert,
                fragmentShader: ot.meshbasic_frag
            },
            lambert: {
                uniforms: Gn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new rt(0)
                    }
                }]),
                vertexShader: ot.meshlambert_vert,
                fragmentShader: ot.meshlambert_frag
            },
            phong: {
                uniforms: Gn([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new rt(0)
                    },
                    specular: {
                        value: new rt(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ot.meshphong_vert,
                fragmentShader: ot.meshphong_frag
            },
            standard: {
                uniforms: Gn([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new rt(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ot.meshphysical_vert,
                fragmentShader: ot.meshphysical_frag
            },
            toon: {
                uniforms: Gn([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, {
                    emissive: {
                        value: new rt(0)
                    }
                }]),
                vertexShader: ot.meshtoon_vert,
                fragmentShader: ot.meshtoon_frag
            },
            matcap: {
                uniforms: Gn([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ot.meshmatcap_vert,
                fragmentShader: ot.meshmatcap_frag
            },
            points: {
                uniforms: Gn([Re.points, Re.fog]),
                vertexShader: ot.points_vert,
                fragmentShader: ot.points_frag
            },
            dashed: {
                uniforms: Gn([Re.common, Re.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ot.linedashed_vert,
                fragmentShader: ot.linedashed_frag
            },
            depth: {
                uniforms: Gn([Re.common, Re.displacementmap]),
                vertexShader: ot.depth_vert,
                fragmentShader: ot.depth_frag
            },
            normal: {
                uniforms: Gn([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ot.meshnormal_vert,
                fragmentShader: ot.meshnormal_frag
            },
            sprite: {
                uniforms: Gn([Re.sprite, Re.fog]),
                vertexShader: ot.sprite_vert,
                fragmentShader: ot.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new ct
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: ot.background_vert,
                fragmentShader: ot.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new ct
                    }
                },
                vertexShader: ot.backgroundCube_vert,
                fragmentShader: ot.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ot.cube_vert,
                fragmentShader: ot.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ot.equirect_vert,
                fragmentShader: ot.equirect_frag
            },
            distanceRGBA: {
                uniforms: Gn([Re.common, Re.displacementmap, {
                    referencePosition: {
                        value: new B
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ot.distanceRGBA_vert,
                fragmentShader: ot.distanceRGBA_frag
            },
            shadow: {
                uniforms: Gn([Re.lights, Re.fog, {
                    color: {
                        value: new rt(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ot.shadow_vert,
                fragmentShader: ot.shadow_frag
            }
        };
    dr.physical = {
        uniforms: Gn([dr.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatMapTransform: {
                value: new ct
            },
            clearcoatNormalMap: {
                value: null
            },
            clearcoatNormalMapTransform: {
                value: new ct
            },
            clearcoatNormalScale: {
                value: new at(1, 1)
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatRoughnessMapTransform: {
                value: new ct
            },
            dispersion: {
                value: 0
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceMapTransform: {
                value: new ct
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            iridescenceThicknessMapTransform: {
                value: new ct
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new rt(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenColorMapTransform: {
                value: new ct
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            sheenRoughnessMapTransform: {
                value: new ct
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionMapTransform: {
                value: new ct
            },
            transmissionSamplerSize: {
                value: new at
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            thicknessMapTransform: {
                value: new ct
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new rt(0)
            },
            specularColor: {
                value: new rt(1, 1, 1)
            },
            specularColorMap: {
                value: null
            },
            specularColorMapTransform: {
                value: new ct
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularIntensityMapTransform: {
                value: new ct
            },
            anisotropyVector: {
                value: new at
            },
            anisotropyMap: {
                value: null
            },
            anisotropyMapTransform: {
                value: new ct
            }
        }]),
        vertexShader: ot.meshphysical_vert,
        fragmentShader: ot.meshphysical_frag
    };
    const Ru = {
            r: 0,
            b: 0,
            g: 0
        },
        Zs = new lr,
        EE = new Ke;

    function wE(r, e, t, n, i, s, a) {
        const o = new rt(0);
        let c = s === !0 ? 0 : 1,
            l, f, h = null,
            d = 0,
            u = null;

        function _(x) {
            let b = x.isScene === !0 ? x.background : null;
            return b && b.isTexture && (b = (x.backgroundBlurriness > 0 ? t : e).get(b)), b
        }

        function g(x) {
            let b = !1;
            const S = _(x);
            S === null ? p(o, c) : S && S.isColor && (p(S, 1), b = !0);
            const E = r.xr.getEnvironmentBlendMode();
            E === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : E === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (r.autoClear || b) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
        }

        function m(x, b) {
            const S = _(b);
            S && (S.isCubeTexture || S.mapping === 306) ? (f === void 0 && (f = new bn(new _c(1, 1, 1), new Nr({
                name: "BackgroundCubeMaterial",
                uniforms: Za(dr.backgroundCube.uniforms),
                vertexShader: dr.backgroundCube.vertexShader,
                fragmentShader: dr.backgroundCube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(E, T, w) {
                this.matrixWorld.copyPosition(w.matrixWorld)
            }, Object.defineProperty(f.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }), i.update(f)), Zs.copy(b.backgroundRotation), Zs.x *= -1, Zs.y *= -1, Zs.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (Zs.y *= -1, Zs.z *= -1), f.material.uniforms.envMap.value = S, f.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(EE.makeRotationFromEuler(Zs)), f.material.toneMapped = bt.getTransfer(S.colorSpace) !== Rt, (h !== S || d !== S.version || u !== r.toneMapping) && (f.material.needsUpdate = !0, h = S, d = S.version, u = r.toneMapping), f.layers.enableAll(), x.unshift(f, f.geometry, f.material, 0, 0, null)) : S && S.isTexture && (l === void 0 && (l = new bn(new Tc(2, 2), new Nr({
                name: "BackgroundMaterial",
                uniforms: Za(dr.background.uniforms),
                vertexShader: dr.background.vertexShader,
                fragmentShader: dr.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }), i.update(l)), l.material.uniforms.t2D.value = S, l.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, l.material.toneMapped = bt.getTransfer(S.colorSpace) !== Rt, S.matrixAutoUpdate === !0 && S.updateMatrix(), l.material.uniforms.uvTransform.value.copy(S.matrix), (h !== S || d !== S.version || u !== r.toneMapping) && (l.material.needsUpdate = !0, h = S, d = S.version, u = r.toneMapping), l.layers.enableAll(), x.unshift(l, l.geometry, l.material, 0, 0, null))
        }

        function p(x, b) {
            x.getRGB(Ru, Jg(r)), n.buffers.color.setClear(Ru.r, Ru.g, Ru.b, b, a)
        }

        function v() {
            f !== void 0 && (f.geometry.dispose(), f.material.dispose(), f = void 0), l !== void 0 && (l.geometry.dispose(), l.material.dispose(), l = void 0)
        }
        return {
            getClearColor: function() {
                return o
            },
            setClearColor: function(x, b = 1) {
                o.set(x), c = b, p(o, c)
            },
            getClearAlpha: function() {
                return c
            },
            setClearAlpha: function(x) {
                c = x, p(o, c)
            },
            render: g,
            addToRenderList: m,
            dispose: v
        }
    }

    function AE(r, e) {
        const t = r.getParameter(r.MAX_VERTEX_ATTRIBS),
            n = {},
            i = d(null);
        let s = i,
            a = !1;

        function o(y, D, R, P, O) {
            let z = !1;
            const k = h(P, R, D);
            s !== k && (s = k, l(s.object)), z = u(y, P, R, O), z && _(y, P, R, O), O !== null && e.update(O, r.ELEMENT_ARRAY_BUFFER), (z || a) && (a = !1, b(y, D, R, P), O !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(O).buffer))
        }

        function c() {
            return r.createVertexArray()
        }

        function l(y) {
            return r.bindVertexArray(y)
        }

        function f(y) {
            return r.deleteVertexArray(y)
        }

        function h(y, D, R) {
            const P = R.wireframe === !0;
            let O = n[y.id];
            O === void 0 && (O = {}, n[y.id] = O);
            let z = O[D.id];
            z === void 0 && (z = {}, O[D.id] = z);
            let k = z[P];
            return k === void 0 && (k = d(c()), z[P] = k), k
        }

        function d(y) {
            const D = [],
                R = [],
                P = [];
            for (let O = 0; O < t; O++) D[O] = 0, R[O] = 0, P[O] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: D,
                enabledAttributes: R,
                attributeDivisors: P,
                object: y,
                attributes: {},
                index: null
            }
        }

        function u(y, D, R, P) {
            const O = s.attributes,
                z = D.attributes;
            let k = 0;
            const X = R.getAttributes();
            for (const V in X)
                if (X[V].location >= 0) {
                    const L = O[V];
                    let se = z[V];
                    if (se === void 0 && (V === "instanceMatrix" && y.instanceMatrix && (se = y.instanceMatrix), V === "instanceColor" && y.instanceColor && (se = y.instanceColor)), L === void 0 || L.attribute !== se || se && L.data !== se.data) return !0;
                    k++
                }
            return s.attributesNum !== k || s.index !== P
        }

        function _(y, D, R, P) {
            const O = {},
                z = D.attributes;
            let k = 0;
            const X = R.getAttributes();
            for (const V in X)
                if (X[V].location >= 0) {
                    let L = z[V];
                    L === void 0 && (V === "instanceMatrix" && y.instanceMatrix && (L = y.instanceMatrix), V === "instanceColor" && y.instanceColor && (L = y.instanceColor));
                    const se = {};
                    se.attribute = L, L && L.data && (se.data = L.data), O[V] = se, k++
                }
            s.attributes = O, s.attributesNum = k, s.index = P
        }

        function g() {
            const y = s.newAttributes;
            for (let D = 0, R = y.length; D < R; D++) y[D] = 0
        }

        function m(y) {
            p(y, 0)
        }

        function p(y, D) {
            const R = s.newAttributes,
                P = s.enabledAttributes,
                O = s.attributeDivisors;
            R[y] = 1, P[y] === 0 && (r.enableVertexAttribArray(y), P[y] = 1), O[y] !== D && (r.vertexAttribDivisor(y, D), O[y] = D)
        }

        function v() {
            const y = s.newAttributes,
                D = s.enabledAttributes;
            for (let R = 0, P = D.length; R < P; R++) D[R] !== y[R] && (r.disableVertexAttribArray(R), D[R] = 0)
        }

        function x(y, D, R, P, O, z, k) {
            k === !0 ? r.vertexAttribIPointer(y, D, R, O, z) : r.vertexAttribPointer(y, D, R, P, O, z)
        }

        function b(y, D, R, P) {
            g();
            const O = P.attributes,
                z = R.getAttributes(),
                k = D.defaultAttributeValues;
            for (const X in z) {
                const V = z[X];
                if (V.location >= 0) {
                    let H = O[X];
                    if (H === void 0 && (X === "instanceMatrix" && y.instanceMatrix && (H = y.instanceMatrix), X === "instanceColor" && y.instanceColor && (H = y.instanceColor)), H !== void 0) {
                        const L = H.normalized,
                            se = H.itemSize,
                            de = e.get(H);
                        if (de === void 0) continue;
                        const ke = de.buffer,
                            Y = de.type,
                            ee = de.bytesPerElement,
                            he = Y === r.INT || Y === r.UNSIGNED_INT || H.gpuType === 1013;
                        if (H.isInterleavedBufferAttribute) {
                            const fe = H.data,
                                be = fe.stride,
                                Ye = H.offset;
                            if (fe.isInstancedInterleavedBuffer) {
                                for (let Pe = 0; Pe < V.locationSize; Pe++) p(V.location + Pe, fe.meshPerAttribute);
                                y.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = fe.meshPerAttribute * fe.count)
                            } else
                                for (let Pe = 0; Pe < V.locationSize; Pe++) m(V.location + Pe);
                            r.bindBuffer(r.ARRAY_BUFFER, ke);
                            for (let Pe = 0; Pe < V.locationSize; Pe++) x(V.location + Pe, se / V.locationSize, Y, L, be * ee, (Ye + se / V.locationSize * Pe) * ee, he)
                        } else {
                            if (H.isInstancedBufferAttribute) {
                                for (let fe = 0; fe < V.locationSize; fe++) p(V.location + fe, H.meshPerAttribute);
                                y.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = H.meshPerAttribute * H.count)
                            } else
                                for (let fe = 0; fe < V.locationSize; fe++) m(V.location + fe);
                            r.bindBuffer(r.ARRAY_BUFFER, ke);
                            for (let fe = 0; fe < V.locationSize; fe++) x(V.location + fe, se / V.locationSize, Y, L, se * ee, se / V.locationSize * fe * ee, he)
                        }
                    } else if (k !== void 0) {
                        const L = k[X];
                        if (L !== void 0) switch (L.length) {
                            case 2:
                                r.vertexAttrib2fv(V.location, L);
                                break;
                            case 3:
                                r.vertexAttrib3fv(V.location, L);
                                break;
                            case 4:
                                r.vertexAttrib4fv(V.location, L);
                                break;
                            default:
                                r.vertexAttrib1fv(V.location, L)
                        }
                    }
                }
            }
            v()
        }

        function S() {
            w();
            for (const y in n) {
                const D = n[y];
                for (const R in D) {
                    const P = D[R];
                    for (const O in P) f(P[O].object), delete P[O];
                    delete D[R]
                }
                delete n[y]
            }
        }

        function E(y) {
            if (n[y.id] === void 0) return;
            const D = n[y.id];
            for (const R in D) {
                const P = D[R];
                for (const O in P) f(P[O].object), delete P[O];
                delete D[R]
            }
            delete n[y.id]
        }

        function T(y) {
            for (const D in n) {
                const R = n[D];
                if (R[y.id] === void 0) continue;
                const P = R[y.id];
                for (const O in P) f(P[O].object), delete P[O];
                delete R[y.id]
            }
        }

        function w() {
            M(), a = !0, s !== i && (s = i, l(s.object))
        }

        function M() {
            i.geometry = null, i.program = null, i.wireframe = !1
        }
        return {
            setup: o,
            reset: w,
            resetDefaultState: M,
            dispose: S,
            releaseStatesOfGeometry: E,
            releaseStatesOfProgram: T,
            initAttributes: g,
            enableAttribute: m,
            disableUnusedAttributes: v
        }
    }

    function DE(r, e, t) {
        let n;

        function i(l) {
            n = l
        }

        function s(l, f) {
            r.drawArrays(n, l, f), t.update(f, n, 1)
        }

        function a(l, f, h) {
            h !== 0 && (r.drawArraysInstanced(n, l, f, h), t.update(f, n, h))
        }

        function o(l, f, h) {
            if (h === 0) return;
            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, l, 0, f, 0, h);
            let u = 0;
            for (let _ = 0; _ < h; _++) u += f[_];
            t.update(u, n, 1)
        }

        function c(l, f, h, d) {
            if (h === 0) return;
            const u = e.get("WEBGL_multi_draw");
            if (u === null)
                for (let _ = 0; _ < l.length; _++) a(l[_], f[_], d[_]);
            else {
                u.multiDrawArraysInstancedWEBGL(n, l, 0, f, 0, d, 0, h);
                let _ = 0;
                for (let g = 0; g < h; g++) _ += f[g] * d[g];
                t.update(_, n, 1)
            }
        }
        this.setMode = i, this.render = s, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c
    }

    function CE(r, e, t, n) {
        let i;

        function s() {
            if (i !== void 0) return i;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                const T = e.get("EXT_texture_filter_anisotropic");
                i = r.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else i = 0;
            return i
        }

        function a(T) {
            return !(T !== 1023 && n.convert(T) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
        }

        function o(T) {
            const w = T === 1016 && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(T !== 1009 && n.convert(T) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && T !== 1015 && !w)
        }

        function c(T) {
            if (T === "highp") {
                if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
                T = "mediump"
            }
            return T === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        let l = t.precision !== void 0 ? t.precision : "highp";
        const f = c(l);
        f !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", f, "instead."), l = f);
        const h = t.logarithmicDepthBuffer === !0,
            d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
            u = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
            _ = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            g = r.getParameter(r.MAX_TEXTURE_SIZE),
            m = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = r.getParameter(r.MAX_VERTEX_ATTRIBS),
            v = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
            x = r.getParameter(r.MAX_VARYING_VECTORS),
            b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
            S = _ > 0,
            E = r.getParameter(r.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: s,
            getMaxPrecision: c,
            textureFormatReadable: a,
            textureTypeReadable: o,
            precision: l,
            logarithmicDepthBuffer: h,
            reverseDepthBuffer: d,
            maxTextures: u,
            maxVertexTextures: _,
            maxTextureSize: g,
            maxCubemapSize: m,
            maxAttributes: p,
            maxVertexUniforms: v,
            maxVaryings: x,
            maxFragmentUniforms: b,
            vertexTextures: S,
            maxSamples: E
        }
    }

    function RE(r) {
        const e = this;
        let t = null,
            n = 0,
            i = !1,
            s = !1;
        const a = new Ur,
            o = new ct,
            c = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d) {
            const u = h.length !== 0 || d || n !== 0 || i;
            return i = d, n = h.length, u
        }, this.beginShadows = function() {
            s = !0, f(null)
        }, this.endShadows = function() {
            s = !1
        }, this.setGlobalState = function(h, d) {
            t = f(h, d, 0)
        }, this.setState = function(h, d, u) {
            const _ = h.clippingPlanes,
                g = h.clipIntersection,
                m = h.clipShadows,
                p = r.get(h);
            if (!i || _ === null || _.length === 0 || s && !m) s ? f(null) : l();
            else {
                const v = s ? 0 : n,
                    x = v * 4;
                let b = p.clippingState || null;
                c.value = b, b = f(_, d, x, u);
                for (let S = 0; S !== x; ++S) b[S] = t[S];
                p.clippingState = b, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += v
            }
        };

        function l() {
            c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
        }

        function f(h, d, u, _) {
            const g = h !== null ? h.length : 0;
            let m = null;
            if (g !== 0) {
                if (m = c.value, _ !== !0 || m === null) {
                    const p = u + g * 4,
                        v = d.matrixWorldInverse;
                    o.getNormalMatrix(v), (m === null || m.length < p) && (m = new Float32Array(p));
                    for (let x = 0, b = u; x !== g; ++x, b += 4) a.copy(h[x]).applyMatrix4(v, o), a.normal.toArray(m, b), m[b + 3] = a.constant
                }
                c.value = m, c.needsUpdate = !0
            }
            return e.numPlanes = g, e.numIntersection = 0, m
        }
    }

    function PE(r) {
        let e = new WeakMap;

        function t(a, o) {
            return o === 303 ? a.mapping = 301 : o === 304 && (a.mapping = 302), a
        }

        function n(a) {
            if (a && a.isTexture) {
                const o = a.mapping;
                if (o === 303 || o === 304)
                    if (e.has(a)) {
                        const c = e.get(a).texture;
                        return t(c, a.mapping)
                    } else {
                        const c = a.image;
                        if (c && c.height > 0) {
                            const l = new TS(c.height);
                            return l.fromEquirectangularTexture(r, a), e.set(a, l), a.addEventListener("dispose", i), t(l.texture, a.mapping)
                        } else return null
                    }
            }
            return a
        }

        function i(a) {
            const o = a.target;
            o.removeEventListener("dispose", i);
            const c = e.get(o);
            c !== void 0 && (e.delete(o), c.dispose())
        }

        function s() {
            e = new WeakMap
        }
        return {
            get: n,
            dispose: s
        }
    }
    const oo = 4,
        U_ = [.125, .215, .35, .446, .526, .582],
        Qs = 20,
        ud = new Du,
        O_ = new rt;
    let fd = null,
        hd = 0,
        dd = 0,
        pd = !1;
    const ea = (1 + Math.sqrt(5)) / 2,
        co = 1 / ea,
        B_ = [new B(-ea, co, 0), new B(ea, co, 0), new B(-co, 0, ea), new B(co, 0, ea), new B(0, ea, -co), new B(0, ea, co), new B(-1, 1, -1), new B(1, 1, -1), new B(-1, 1, 1), new B(1, 1, 1)],
        FE = new B;
    class k_ {
        constructor(e) {
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
        }
        fromScene(e, t = 0, n = .1, i = 100, s = {}) {
            const {
                size: a = 256,
                position: o = FE
            } = s;
            fd = this._renderer.getRenderTarget(), hd = this._renderer.getActiveCubeFace(), dd = this._renderer.getActiveMipmapLevel(), pd = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
            const c = this._allocateTargets();
            return c.depthBuffer = !0, this._sceneToCubeUV(e, n, i, c, o), t > 0 && this._blur(c, 0, 0, t), this._applyPMREM(c), this._cleanup(c), c
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t)
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t)
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = H_(), this._compileMaterial(this._cubemapMaterial))
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = G_(), this._compileMaterial(this._equirectMaterial))
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(fd, hd, dd), this._renderer.xr.enabled = pd, e.scissorTest = !1, Pu(e, 0, 0, e.width, e.height)
        }
        _fromTexture(e, t) {
            e.mapping === 301 || e.mapping === 302 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), fd = this._renderer.getRenderTarget(), hd = this._renderer.getActiveCubeFace(), dd = this._renderer.getActiveMipmapLevel(), pd = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112),
                t = 4 * this._cubeSize,
                n = {
                    magFilter: 1006,
                    minFilter: 1006,
                    generateMipmaps: !1,
                    type: 1016,
                    format: 1023,
                    colorSpace: Dn,
                    depthBuffer: !1
                },
                i = z_(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = z_(e, t, n);
                const {
                    _lodMax: s
                } = this;
                ({
                    sizeLods: this._sizeLods,
                    lodPlanes: this._lodPlanes,
                    sigmas: this._sigmas
                } = IE(s)), this._blurMaterial = LE(s, e, t)
            }
            return i
        }
        _compileMaterial(e) {
            const t = new bn(this._lodPlanes[0], e);
            this._renderer.compile(t, ud)
        }
        _sceneToCubeUV(e, t, n, i, s) {
            const c = new Hn(90, 1, t, n),
                l = [1, -1, 1, 1, 1, 1],
                f = [1, 1, 1, -1, -1, -1],
                h = this._renderer,
                d = h.autoClear,
                u = h.toneMapping;
            h.getClearColor(O_), h.toneMapping = 0, h.autoClear = !1;
            const _ = new hs({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                g = new bn(new _c, _);
            let m = !1;
            const p = e.background;
            p ? p.isColor && (_.color.copy(p), e.background = null, m = !0) : (_.color.copy(O_), m = !0);
            for (let v = 0; v < 6; v++) {
                const x = v % 3;
                x === 0 ? (c.up.set(0, l[v], 0), c.position.set(s.x, s.y, s.z), c.lookAt(s.x + f[v], s.y, s.z)) : x === 1 ? (c.up.set(0, 0, l[v]), c.position.set(s.x, s.y, s.z), c.lookAt(s.x, s.y + f[v], s.z)) : (c.up.set(0, l[v], 0), c.position.set(s.x, s.y, s.z), c.lookAt(s.x, s.y, s.z + f[v]));
                const b = this._cubeSize;
                Pu(i, x * b, v > 2 ? b : 0, b, b), h.setRenderTarget(i), m && h.render(g, c), h.render(e, c)
            }
            g.geometry.dispose(), g.material.dispose(), h.toneMapping = u, h.autoClear = d, e.background = p
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer,
                i = e.mapping === 301 || e.mapping === 302;
            i ? (this._cubemapMaterial === null && (this._cubemapMaterial = H_()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = G_());
            const s = i ? this._cubemapMaterial : this._equirectMaterial,
                a = new bn(this._lodPlanes[0], s),
                o = s.uniforms;
            o.envMap.value = e;
            const c = this._cubeSize;
            Pu(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(a, ud)
        }
        _applyPMREM(e) {
            const t = this._renderer,
                n = t.autoClear;
            t.autoClear = !1;
            const i = this._lodPlanes.length;
            for (let s = 1; s < i; s++) {
                const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                    o = B_[(i - s - 1) % B_.length];
                this._blur(e, s - 1, s, a, o)
            }
            t.autoClear = n
        }
        _blur(e, t, n, i, s) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, n, i, "latitudinal", s), this._halfBlur(a, e, n, n, i, "longitudinal", s)
        }
        _halfBlur(e, t, n, i, s, a, o) {
            const c = this._renderer,
                l = this._blurMaterial;
            a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const f = 3,
                h = new bn(this._lodPlanes[i], l),
                d = l.uniforms,
                u = this._sizeLods[n] - 1,
                _ = isFinite(s) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Qs - 1),
                g = s / _,
                m = isFinite(s) ? 1 + Math.floor(f * g) : Qs;
            m > Qs && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Qs}`);
            const p = [];
            let v = 0;
            for (let T = 0; T < Qs; ++T) {
                const w = T / g,
                    M = Math.exp(-w * w / 2);
                p.push(M), T === 0 ? v += M : T < m && (v += 2 * M)
            }
            for (let T = 0; T < p.length; T++) p[T] = p[T] / v;
            d.envMap.value = e.texture, d.samples.value = m, d.weights.value = p, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
            const {
                _lodMax: x
            } = this;
            d.dTheta.value = _, d.mipInt.value = x - n;
            const b = this._sizeLods[i],
                S = 3 * b * (i > x - oo ? i - x + oo : 0),
                E = 4 * (this._cubeSize - b);
            Pu(t, S, E, 3 * b, 2 * b), c.setRenderTarget(t), c.render(h, ud)
        }
    }

    function IE(r) {
        const e = [],
            t = [],
            n = [];
        let i = r;
        const s = r - oo + 1 + U_.length;
        for (let a = 0; a < s; a++) {
            const o = Math.pow(2, i);
            t.push(o);
            let c = 1 / o;
            a > r - oo ? c = U_[a - r + oo - 1] : a === 0 && (c = 0), n.push(c);
            const l = 1 / (o - 2),
                f = -l,
                h = 1 + l,
                d = [f, f, h, f, h, h, f, f, h, h, f, h],
                u = 6,
                _ = 6,
                g = 3,
                m = 2,
                p = 1,
                v = new Float32Array(g * _ * u),
                x = new Float32Array(m * _ * u),
                b = new Float32Array(p * _ * u);
            for (let E = 0; E < u; E++) {
                const T = E % 3 * 2 / 3 - 1,
                    w = E > 2 ? 0 : -1,
                    M = [T, w, 0, T + 2 / 3, w, 0, T + 2 / 3, w + 1, 0, T, w, 0, T + 2 / 3, w + 1, 0, T, w + 1, 0];
                v.set(M, g * _ * E), x.set(d, m * _ * E);
                const y = [E, E, E, E, E, E];
                b.set(y, p * _ * E)
            }
            const S = new Fn;
            S.setAttribute("position", new Zt(v, g)), S.setAttribute("uv", new Zt(x, m)), S.setAttribute("faceIndex", new Zt(b, p)), e.push(S), i > oo && i--
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        }
    }

    function z_(r, e, t) {
        const n = new Dr(r, e, t);
        return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
    }

    function Pu(r, e, t, n, i) {
        r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i)
    }

    function LE(r, e, t) {
        const n = new Float32Array(Qs),
            i = new B(0, 1, 0);
        return new Nr({
            name: "SphericalGaussianBlur",
            defines: {
                n: Qs,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${r}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: i
                }
            },
            vertexShader: md(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function G_() {
        return new Nr({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: md(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function H_() {
        return new Nr({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: md(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function md() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    }

    function NE(r) {
        let e = new WeakMap,
            t = null;

        function n(o) {
            if (o && o.isTexture) {
                const c = o.mapping,
                    l = c === 303 || c === 304,
                    f = c === 301 || c === 302;
                if (l || f) {
                    let h = e.get(o);
                    const d = h !== void 0 ? h.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new k_(r)), h = l ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), h.texture;
                    if (h !== void 0) return h.texture; {
                        const u = o.image;
                        return l && u && u.height > 0 || f && u && i(u) ? (t === null && (t = new k_(r)), h = l ? t.fromEquirectangular(o) : t.fromCubemap(o), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), o.addEventListener("dispose", s), h.texture) : null
                    }
                }
            }
            return o
        }

        function i(o) {
            let c = 0;
            const l = 6;
            for (let f = 0; f < l; f++) o[f] !== void 0 && c++;
            return c === l
        }

        function s(o) {
            const c = o.target;
            c.removeEventListener("dispose", s);
            const l = e.get(c);
            l !== void 0 && (e.delete(c), l.dispose())
        }

        function a() {
            e = new WeakMap, t !== null && (t.dispose(), t = null)
        }
        return {
            get: n,
            dispose: a
        }
    }

    function UE(r) {
        const e = {};

        function t(n) {
            if (e[n] !== void 0) return e[n];
            let i;
            switch (n) {
                case "WEBGL_depth_texture":
                    i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = r.getExtension(n)
            }
            return e[n] = i, i
        }
        return {
            has: function(n) {
                return t(n) !== null
            },
            init: function() {
                t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent")
            },
            get: function(n) {
                const i = t(n);
                return i === null && ka("THREE.WebGLRenderer: " + n + " extension not supported."), i
            }
        }
    }

    function OE(r, e, t, n) {
        const i = {},
            s = new WeakMap;

        function a(h) {
            const d = h.target;
            d.index !== null && e.remove(d.index);
            for (const _ in d.attributes) e.remove(d.attributes[_]);
            d.removeEventListener("dispose", a), delete i[d.id];
            const u = s.get(d);
            u && (e.remove(u), s.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--
        }

        function o(h, d) {
            return i[d.id] === !0 || (d.addEventListener("dispose", a), i[d.id] = !0, t.memory.geometries++), d
        }

        function c(h) {
            const d = h.attributes;
            for (const u in d) e.update(d[u], r.ARRAY_BUFFER)
        }

        function l(h) {
            const d = [],
                u = h.index,
                _ = h.attributes.position;
            let g = 0;
            if (u !== null) {
                const v = u.array;
                g = u.version;
                for (let x = 0, b = v.length; x < b; x += 3) {
                    const S = v[x + 0],
                        E = v[x + 1],
                        T = v[x + 2];
                    d.push(S, E, E, T, T, S)
                }
            } else if (_ !== void 0) {
                const v = _.array;
                g = _.version;
                for (let x = 0, b = v.length / 3 - 1; x < b; x += 3) {
                    const S = x + 0,
                        E = x + 1,
                        T = x + 2;
                    d.push(S, E, E, T, T, S)
                }
            } else return;
            const m = new(Fg(d) ? qg : jg)(d, 1);
            m.version = g;
            const p = s.get(h);
            p && e.remove(p), s.set(h, m)
        }

        function f(h) {
            const d = s.get(h);
            if (d) {
                const u = h.index;
                u !== null && d.version < u.version && l(h)
            } else l(h);
            return s.get(h)
        }
        return {
            get: o,
            update: c,
            getWireframeAttribute: f
        }
    }

    function BE(r, e, t) {
        let n;

        function i(d) {
            n = d
        }
        let s, a;

        function o(d) {
            s = d.type, a = d.bytesPerElement
        }

        function c(d, u) {
            r.drawElements(n, u, s, d * a), t.update(u, n, 1)
        }

        function l(d, u, _) {
            _ !== 0 && (r.drawElementsInstanced(n, u, s, d * a, _), t.update(u, n, _))
        }

        function f(d, u, _) {
            if (_ === 0) return;
            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, u, 0, s, d, 0, _);
            let m = 0;
            for (let p = 0; p < _; p++) m += u[p];
            t.update(m, n, 1)
        }

        function h(d, u, _, g) {
            if (_ === 0) return;
            const m = e.get("WEBGL_multi_draw");
            if (m === null)
                for (let p = 0; p < d.length; p++) l(d[p] / a, u[p], g[p]);
            else {
                m.multiDrawElementsInstancedWEBGL(n, u, 0, s, d, 0, g, 0, _);
                let p = 0;
                for (let v = 0; v < _; v++) p += u[v] * g[v];
                t.update(p, n, 1)
            }
        }
        this.setMode = i, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = f, this.renderMultiDrawInstances = h
    }

    function kE(r) {
        const e = {
                geometries: 0,
                textures: 0
            },
            t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };

        function n(s, a, o) {
            switch (t.calls++, a) {
                case r.TRIANGLES:
                    t.triangles += o * (s / 3);
                    break;
                case r.LINES:
                    t.lines += o * (s / 2);
                    break;
                case r.LINE_STRIP:
                    t.lines += o * (s - 1);
                    break;
                case r.LINE_LOOP:
                    t.lines += o * s;
                    break;
                case r.POINTS:
                    t.points += o * s;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", a);
                    break
            }
        }

        function i() {
            t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: i,
            update: n
        }
    }

    function zE(r, e, t) {
        const n = new WeakMap,
            i = new Tt;

        function s(a, o, c) {
            const l = a.morphTargetInfluences,
                f = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
                h = f !== void 0 ? f.length : 0;
            let d = n.get(o);
            if (d === void 0 || d.count !== h) {
                let M = function() {
                    T.dispose(), n.delete(o), o.removeEventListener("dispose", M)
                };
                d !== void 0 && d.texture.dispose();
                const u = o.morphAttributes.position !== void 0,
                    _ = o.morphAttributes.normal !== void 0,
                    g = o.morphAttributes.color !== void 0,
                    m = o.morphAttributes.position || [],
                    p = o.morphAttributes.normal || [],
                    v = o.morphAttributes.color || [];
                let x = 0;
                u === !0 && (x = 1), _ === !0 && (x = 2), g === !0 && (x = 3);
                let b = o.attributes.position.count * x,
                    S = 1;
                b > e.maxTextureSize && (S = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
                const E = new Float32Array(b * S * 4 * h),
                    T = new Ug(E, b, S, h);
                T.type = 1015, T.needsUpdate = !0;
                const w = x * 4;
                for (let y = 0; y < h; y++) {
                    const D = m[y],
                        R = p[y],
                        P = v[y],
                        O = b * S * 4 * y;
                    for (let z = 0; z < D.count; z++) {
                        const k = z * w;
                        u === !0 && (i.fromBufferAttribute(D, z), E[O + k + 0] = i.x, E[O + k + 1] = i.y, E[O + k + 2] = i.z, E[O + k + 3] = 0), _ === !0 && (i.fromBufferAttribute(R, z), E[O + k + 4] = i.x, E[O + k + 5] = i.y, E[O + k + 6] = i.z, E[O + k + 7] = 0), g === !0 && (i.fromBufferAttribute(P, z), E[O + k + 8] = i.x, E[O + k + 9] = i.y, E[O + k + 10] = i.z, E[O + k + 11] = P.itemSize === 4 ? i.w : 1)
                    }
                }
                d = {
                    count: h,
                    texture: T,
                    size: new at(b, S)
                }, n.set(o, d), o.addEventListener("dispose", M)
            }
            if (a.isInstancedMesh === !0 && a.morphTexture !== null) c.getUniforms().setValue(r, "morphTexture", a.morphTexture, t);
            else {
                let u = 0;
                for (let g = 0; g < l.length; g++) u += l[g];
                const _ = o.morphTargetsRelative ? 1 : 1 - u;
                c.getUniforms().setValue(r, "morphTargetBaseInfluence", _), c.getUniforms().setValue(r, "morphTargetInfluences", l)
            }
            c.getUniforms().setValue(r, "morphTargetsTexture", d.texture, t), c.getUniforms().setValue(r, "morphTargetsTextureSize", d.size)
        }
        return {
            update: s
        }
    }

    function GE(r, e, t, n) {
        let i = new WeakMap;

        function s(c) {
            const l = n.render.frame,
                f = c.geometry,
                h = e.get(c, f);
            if (i.get(h) !== l && (e.update(h), i.set(h, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), i.get(c) !== l && (t.update(c.instanceMatrix, r.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, r.ARRAY_BUFFER), i.set(c, l))), c.isSkinnedMesh) {
                const d = c.skeleton;
                i.get(d) !== l && (d.update(), i.set(d, l))
            }
            return h
        }

        function a() {
            i = new WeakMap
        }

        function o(c) {
            const l = c.target;
            l.removeEventListener("dispose", o), t.remove(l.instanceMatrix), l.instanceColor !== null && t.remove(l.instanceColor)
        }
        return {
            update: s,
            dispose: a
        }
    }
    const V_ = new on,
        W_ = new S_(1, 1),
        X_ = new Ug,
        j_ = new oS,
        q_ = new t_,
        Y_ = [],
        $_ = [],
        K_ = new Float32Array(16),
        J_ = new Float32Array(9),
        Z_ = new Float32Array(4);

    function lo(r, e, t) {
        const n = r[0];
        if (n <= 0 || n > 0) return r;
        const i = e * t;
        let s = Y_[i];
        if (s === void 0 && (s = new Float32Array(i), Y_[i] = s), e !== 0) {
            n.toArray(s, 0);
            for (let a = 1, o = 0; a !== e; ++a) o += t, r[a].toArray(s, o)
        }
        return s
    }

    function cn(r, e) {
        if (r.length !== e.length) return !1;
        for (let t = 0, n = r.length; t < n; t++)
            if (r[t] !== e[t]) return !1;
        return !0
    }

    function ln(r, e) {
        for (let t = 0, n = e.length; t < n; t++) r[t] = e[t]
    }

    function Fu(r, e) {
        let t = $_[e];
        t === void 0 && (t = new Int32Array(e), $_[e] = t);
        for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
        return t
    }

    function HE(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e)
    }

    function VE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (cn(t, e)) return;
            r.uniform2fv(this.addr, e), ln(t, e)
        }
    }

    function WE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
            if (cn(t, e)) return;
            r.uniform3fv(this.addr, e), ln(t, e)
        }
    }

    function XE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (cn(t, e)) return;
            r.uniform4fv(this.addr, e), ln(t, e)
        }
    }

    function jE(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (cn(t, e)) return;
            r.uniformMatrix2fv(this.addr, !1, e), ln(t, e)
        } else {
            if (cn(t, n)) return;
            Z_.set(n), r.uniformMatrix2fv(this.addr, !1, Z_), ln(t, n)
        }
    }

    function qE(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (cn(t, e)) return;
            r.uniformMatrix3fv(this.addr, !1, e), ln(t, e)
        } else {
            if (cn(t, n)) return;
            J_.set(n), r.uniformMatrix3fv(this.addr, !1, J_), ln(t, n)
        }
    }

    function YE(r, e) {
        const t = this.cache,
            n = e.elements;
        if (n === void 0) {
            if (cn(t, e)) return;
            r.uniformMatrix4fv(this.addr, !1, e), ln(t, e)
        } else {
            if (cn(t, n)) return;
            K_.set(n), r.uniformMatrix4fv(this.addr, !1, K_), ln(t, n)
        }
    }

    function $E(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e)
    }

    function KE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (cn(t, e)) return;
            r.uniform2iv(this.addr, e), ln(t, e)
        }
    }

    function JE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (cn(t, e)) return;
            r.uniform3iv(this.addr, e), ln(t, e)
        }
    }

    function ZE(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (cn(t, e)) return;
            r.uniform4iv(this.addr, e), ln(t, e)
        }
    }

    function QE(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e)
    }

    function ew(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (cn(t, e)) return;
            r.uniform2uiv(this.addr, e), ln(t, e)
        }
    }

    function tw(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (cn(t, e)) return;
            r.uniform3uiv(this.addr, e), ln(t, e)
        }
    }

    function nw(r, e) {
        const t = this.cache;
        if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (cn(t, e)) return;
            r.uniform4uiv(this.addr, e), ln(t, e)
        }
    }

    function iw(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
        let s;
        this.type === r.SAMPLER_2D_SHADOW ? (W_.compareFunction = 515, s = W_) : s = V_, t.setTexture2D(e || s, i)
    }

    function rw(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || j_, i)
    }

    function sw(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || q_, i)
    }

    function aw(r, e, t) {
        const n = this.cache,
            i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || X_, i)
    }

    function ow(r) {
        switch (r) {
            case 5126:
                return HE;
            case 35664:
                return VE;
            case 35665:
                return WE;
            case 35666:
                return XE;
            case 35674:
                return jE;
            case 35675:
                return qE;
            case 35676:
                return YE;
            case 5124:
            case 35670:
                return $E;
            case 35667:
            case 35671:
                return KE;
            case 35668:
            case 35672:
                return JE;
            case 35669:
            case 35673:
                return ZE;
            case 5125:
                return QE;
            case 36294:
                return ew;
            case 36295:
                return tw;
            case 36296:
                return nw;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return iw;
            case 35679:
            case 36299:
            case 36307:
                return rw;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return sw;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return aw
        }
    }

    function cw(r, e) {
        r.uniform1fv(this.addr, e)
    }

    function lw(r, e) {
        const t = lo(e, this.size, 2);
        r.uniform2fv(this.addr, t)
    }

    function uw(r, e) {
        const t = lo(e, this.size, 3);
        r.uniform3fv(this.addr, t)
    }

    function fw(r, e) {
        const t = lo(e, this.size, 4);
        r.uniform4fv(this.addr, t)
    }

    function hw(r, e) {
        const t = lo(e, this.size, 4);
        r.uniformMatrix2fv(this.addr, !1, t)
    }

    function dw(r, e) {
        const t = lo(e, this.size, 9);
        r.uniformMatrix3fv(this.addr, !1, t)
    }

    function pw(r, e) {
        const t = lo(e, this.size, 16);
        r.uniformMatrix4fv(this.addr, !1, t)
    }

    function mw(r, e) {
        r.uniform1iv(this.addr, e)
    }

    function gw(r, e) {
        r.uniform2iv(this.addr, e)
    }

    function _w(r, e) {
        r.uniform3iv(this.addr, e)
    }

    function bw(r, e) {
        r.uniform4iv(this.addr, e)
    }

    function xw(r, e) {
        r.uniform1uiv(this.addr, e)
    }

    function vw(r, e) {
        r.uniform2uiv(this.addr, e)
    }

    function yw(r, e) {
        r.uniform3uiv(this.addr, e)
    }

    function Sw(r, e) {
        r.uniform4uiv(this.addr, e)
    }

    function Mw(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Fu(t, i);
        cn(n, s) || (r.uniform1iv(this.addr, s), ln(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || V_, s[a])
    }

    function Tw(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Fu(t, i);
        cn(n, s) || (r.uniform1iv(this.addr, s), ln(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || j_, s[a])
    }

    function Ew(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Fu(t, i);
        cn(n, s) || (r.uniform1iv(this.addr, s), ln(n, s));
        for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || q_, s[a])
    }

    function ww(r, e, t) {
        const n = this.cache,
            i = e.length,
            s = Fu(t, i);
        cn(n, s) || (r.uniform1iv(this.addr, s), ln(n, s));
        for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || X_, s[a])
    }

    function Aw(r) {
        switch (r) {
            case 5126:
                return cw;
            case 35664:
                return lw;
            case 35665:
                return uw;
            case 35666:
                return fw;
            case 35674:
                return hw;
            case 35675:
                return dw;
            case 35676:
                return pw;
            case 5124:
            case 35670:
                return mw;
            case 35667:
            case 35671:
                return gw;
            case 35668:
            case 35672:
                return _w;
            case 35669:
            case 35673:
                return bw;
            case 5125:
                return xw;
            case 36294:
                return vw;
            case 36295:
                return yw;
            case 36296:
                return Sw;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Mw;
            case 35679:
            case 36299:
            case 36307:
                return Tw;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Ew;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return ww
        }
    }
    class Dw {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = ow(t.type)
        }
    }
    class Cw {
        constructor(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Aw(t.type)
        }
    }
    class Rw {
        constructor(e) {
            this.id = e, this.seq = [], this.map = {}
        }
        setValue(e, t, n) {
            const i = this.seq;
            for (let s = 0, a = i.length; s !== a; ++s) {
                const o = i[s];
                o.setValue(e, t[o.id], n)
            }
        }
    }
    const gd = /(\w+)(\])?(\[|\.)?/g;

    function Q_(r, e) {
        r.seq.push(e), r.map[e.id] = e
    }

    function Pw(r, e, t) {
        const n = r.name,
            i = n.length;
        for (gd.lastIndex = 0;;) {
            const s = gd.exec(n),
                a = gd.lastIndex;
            let o = s[1];
            const c = s[2] === "]",
                l = s[3];
            if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === i) {
                Q_(t, l === void 0 ? new Dw(o, r, e) : new Cw(o, r, e));
                break
            } else {
                let h = t.map[o];
                h === void 0 && (h = new Rw(o), Q_(t, h)), t = h
            }
        }
    }
    class Iu {
        constructor(e, t) {
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
                const s = e.getActiveUniform(t, i),
                    a = e.getUniformLocation(t, s.name);
                Pw(s, a, this)
            }
        }
        setValue(e, t, n, i) {
            const s = this.map[t];
            s !== void 0 && s.setValue(e, n, i)
        }
        setOptional(e, t, n) {
            const i = t[n];
            i !== void 0 && this.setValue(e, n, i)
        }
        static upload(e, t, n, i) {
            for (let s = 0, a = t.length; s !== a; ++s) {
                const o = t[s],
                    c = n[o.id];
                c.needsUpdate !== !1 && o.setValue(e, c.value, i)
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for (let i = 0, s = e.length; i !== s; ++i) {
                const a = e[i];
                a.id in t && n.push(a)
            }
            return n
        }
    }

    function eb(r, e, t) {
        const n = r.createShader(e);
        return r.shaderSource(n, t), r.compileShader(n), n
    }
    const Fw = 37297;
    let Iw = 0;

    function Lw(r, e) {
        const t = r.split(`
`),
            n = [],
            i = Math.max(e - 6, 0),
            s = Math.min(e + 6, t.length);
        for (let a = i; a < s; a++) {
            const o = a + 1;
            n.push(`${o===e?">":" "} ${o}: ${t[a]}`)
        }
        return n.join(`
`)
    }
    const tb = new ct;

    function Nw(r) {
        bt._getMatrix(tb, bt.workingColorSpace, r);
        const e = `mat3( ${tb.elements.map(t=>t.toFixed(4))} )`;
        switch (bt.getTransfer(r)) {
            case Zl:
                return [e, "LinearTransferOETF"];
            case Rt:
                return [e, "sRGBTransferOETF"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"]
        }
    }

    function nb(r, e, t) {
        const n = r.getShaderParameter(e, r.COMPILE_STATUS),
            i = r.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(i);
        if (s) {
            const a = parseInt(s[1]);
            return t.toUpperCase() + `

` + i + `

` + Lw(r.getShaderSource(e), a)
        } else return i
    }

    function Uw(r, e) {
        const t = Nw(e);
        return [`vec4 ${r}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
    }

    function Ow(r, e) {
        let t;
        switch (e) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Cineon";
                break;
            case 4:
                t = "ACESFilmic";
                break;
            case 6:
                t = "AgX";
                break;
            case 7:
                t = "Neutral";
                break;
            case 5:
                t = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
        }
        return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }
    const Lu = new B;

    function Bw() {
        bt.getLuminanceCoefficients(Lu);
        const r = Lu.x.toFixed(4),
            e = Lu.y.toFixed(4),
            t = Lu.z.toFixed(4);
        return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
    }

    function kw(r) {
        return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Dc).join(`
`)
    }

    function zw(r) {
        const e = [];
        for (const t in r) {
            const n = r[t];
            n !== !1 && e.push("#define " + t + " " + n)
        }
        return e.join(`
`)
    }

    function Gw(r, e) {
        const t = {},
            n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < n; i++) {
            const s = r.getActiveAttrib(e, i),
                a = s.name;
            let o = 1;
            s.type === r.FLOAT_MAT2 && (o = 2), s.type === r.FLOAT_MAT3 && (o = 3), s.type === r.FLOAT_MAT4 && (o = 4), t[a] = {
                type: s.type,
                location: r.getAttribLocation(e, a),
                locationSize: o
            }
        }
        return t
    }

    function Dc(r) {
        return r !== ""
    }

    function ib(r, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function rb(r, e) {
        return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const Hw = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function _d(r) {
        return r.replace(Hw, Ww)
    }
    const Vw = new Map;

    function Ww(r, e) {
        let t = ot[e];
        if (t === void 0) {
            const n = Vw.get(e);
            if (n !== void 0) t = ot[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
            else throw new Error("Can not resolve #include <" + e + ">")
        }
        return _d(t)
    }
    const Xw = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function sb(r) {
        return r.replace(Xw, jw)
    }

    function jw(r, e, t, n) {
        let i = "";
        for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
        return i
    }

    function ab(r) {
        let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
        return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
    }

    function qw(r) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return r.shadowMapType === 1 ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === 2 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === 3 && (e = "SHADOWMAP_TYPE_VSM"), e
    }

    function Yw(r) {
        let e = "ENVMAP_TYPE_CUBE";
        if (r.envMap) switch (r.envMapMode) {
            case 301:
            case 302:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
                e = "ENVMAP_TYPE_CUBE_UV";
                break
        }
        return e
    }

    function $w(r) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (r.envMap) switch (r.envMapMode) {
            case 302:
                e = "ENVMAP_MODE_REFRACTION";
                break
        }
        return e
    }

    function Kw(r) {
        let e = "ENVMAP_BLENDING_NONE";
        if (r.envMap) switch (r.combine) {
            case 0:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                e = "ENVMAP_BLENDING_ADD";
                break
        }
        return e
    }

    function Jw(r) {
        const e = r.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2,
            n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
            texelHeight: n,
            maxMip: t
        }
    }

    function Zw(r, e, t, n) {
        const i = r.getContext(),
            s = t.defines;
        let a = t.vertexShader,
            o = t.fragmentShader;
        const c = qw(t),
            l = Yw(t),
            f = $w(t),
            h = Kw(t),
            d = Jw(t),
            u = kw(t),
            _ = zw(s),
            g = i.createProgram();
        let m, p, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Dc).join(`
`), m.length > 0 && (m += `
`), p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Dc).join(`
`), p.length > 0 && (p += `
`)) : (m = [ab(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Dc).join(`
`), p = [ab(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + l : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== 0 ? "#define TONE_MAPPING" : "", t.toneMapping !== 0 ? ot.tonemapping_pars_fragment : "", t.toneMapping !== 0 ? Ow("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ot.colorspace_pars_fragment, Uw("linearToOutputTexel", t.outputColorSpace), Bw(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Dc).join(`
`)), a = _d(a), a = ib(a, t), a = rb(a, t), o = _d(o), o = ib(o, t), o = rb(o, t), a = sb(a), o = sb(o), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, m = [u, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, p = ["#define varying in", t.glslVersion === Cg ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Cg ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
        const x = v + m + a,
            b = v + p + o,
            S = eb(i, i.VERTEX_SHADER, x),
            E = eb(i, i.FRAGMENT_SHADER, b);
        i.attachShader(g, S), i.attachShader(g, E), t.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g);

        function T(D) {
            if (r.debug.checkShaderErrors) {
                const R = i.getProgramInfoLog(g).trim(),
                    P = i.getShaderInfoLog(S).trim(),
                    O = i.getShaderInfoLog(E).trim();
                let z = !0,
                    k = !0;
                if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
                    if (z = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, g, S, E);
                    else {
                        const X = nb(i, S, "vertex"),
                            V = nb(i, E, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + R + `
` + X + `
` + V)
                    }
                else R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (P === "" || O === "") && (k = !1);
                k && (D.diagnostics = {
                    runnable: z,
                    programLog: R,
                    vertexShader: {
                        log: P,
                        prefix: m
                    },
                    fragmentShader: {
                        log: O,
                        prefix: p
                    }
                })
            }
            i.deleteShader(S), i.deleteShader(E), w = new Iu(i, g), M = Gw(i, g)
        }
        let w;
        this.getUniforms = function() {
            return w === void 0 && T(this), w
        };
        let M;
        this.getAttributes = function() {
            return M === void 0 && T(this), M
        };
        let y = t.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return y === !1 && (y = i.getProgramParameter(g, Fw)), y
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = Iw++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = E, this
    }
    let Qw = 0;
    class eA {
        constructor() {
            this.shaderCache = new Map, this.materialCache = new Map
        }
        update(e) {
            const t = e.vertexShader,
                n = e.fragmentShader,
                i = this._getShaderStage(t),
                s = this._getShaderStage(n),
                a = this._getShaderCacheForMaterial(e);
            return a.has(i) === !1 && (a.add(i), i.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e), this
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear()
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return n === void 0 && (n = new Set, t.set(e, n)), n
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return n === void 0 && (n = new tA(e), t.set(e, n)), n
        }
    }
    class tA {
        constructor(e) {
            this.id = Qw++, this.code = e, this.usedTimes = 0
        }
    }

    function nA(r, e, t, n, i, s, a) {
        const o = new Rh,
            c = new eA,
            l = new Set,
            f = [],
            h = i.logarithmicDepthBuffer,
            d = i.vertexTextures;
        let u = i.precision;
        const _ = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };

        function g(M) {
            return l.add(M), M === 0 ? "uv" : `uv${M}`
        }

        function m(M, y, D, R, P) {
            const O = R.fog,
                z = P.geometry,
                k = M.isMeshStandardMaterial ? R.environment : null,
                X = (M.isMeshStandardMaterial ? t : e).get(M.envMap || k),
                V = X && X.mapping === 306 ? X.image.height : null,
                H = _[M.type];
            M.precision !== null && (u = i.getMaxPrecision(M.precision), u !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", u, "instead."));
            const L = z.morphAttributes.position || z.morphAttributes.normal || z.morphAttributes.color,
                se = L !== void 0 ? L.length : 0;
            let de = 0;
            z.morphAttributes.position !== void 0 && (de = 1), z.morphAttributes.normal !== void 0 && (de = 2), z.morphAttributes.color !== void 0 && (de = 3);
            let ke, Y, ee, he;
            if (H) {
                const G = dr[H];
                ke = G.vertexShader, Y = G.fragmentShader
            } else ke = M.vertexShader, Y = M.fragmentShader, c.update(M), ee = c.getVertexShaderID(M), he = c.getFragmentShaderID(M);
            const fe = r.getRenderTarget(),
                be = r.state.buffers.depth.getReversed(),
                Ye = P.isInstancedMesh === !0,
                Pe = P.isBatchedMesh === !0,
                Xe = !!M.map,
                nt = !!M.matcap,
                xe = !!X,
                F = !!M.aoMap,
                Ge = !!M.lightMap,
                Je = !!M.bumpMap,
                q = !!M.normalMap,
                ve = !!M.displacementMap,
                et = !!M.emissiveMap,
                Le = !!M.metalnessMap,
                ge = !!M.roughnessMap,
                st = M.anisotropy > 0,
                I = M.clearcoat > 0,
                A = M.dispersion > 0,
                $ = M.iridescence > 0,
                ne = M.sheen > 0,
                ie = M.transmission > 0,
                te = st && !!M.anisotropyMap,
                Fe = I && !!M.clearcoatMap,
                ye = I && !!M.clearcoatNormalMap,
                Ue = I && !!M.clearcoatRoughnessMap,
                we = $ && !!M.iridescenceMap,
                pe = $ && !!M.iridescenceThicknessMap,
                Ae = ne && !!M.sheenColorMap,
                Ve = ne && !!M.sheenRoughnessMap,
                He = !!M.specularMap,
                Se = !!M.specularColorMap,
                je = !!M.specularIntensityMap,
                U = ie && !!M.transmissionMap,
                Me = ie && !!M.thicknessMap,
                oe = !!M.gradientMap,
                Ee = !!M.alphaMap,
                me = M.alphaTest > 0,
                ce = !!M.alphaHash,
                ae = !!M.extensions;
            let N = 0;
            M.toneMapped && (fe === null || fe.isXRRenderTarget === !0) && (N = r.toneMapping);
            const re = {
                shaderID: H,
                shaderType: M.type,
                shaderName: M.name,
                vertexShader: ke,
                fragmentShader: Y,
                defines: M.defines,
                customVertexShaderID: ee,
                customFragmentShaderID: he,
                isRawShaderMaterial: M.isRawShaderMaterial === !0,
                glslVersion: M.glslVersion,
                precision: u,
                batching: Pe,
                batchingColor: Pe && P._colorsTexture !== null,
                instancing: Ye,
                instancingColor: Ye && P.instanceColor !== null,
                instancingMorph: Ye && P.morphTexture !== null,
                supportsVertexTextures: d,
                outputColorSpace: fe === null ? r.outputColorSpace : fe.isXRRenderTarget === !0 ? fe.texture.colorSpace : Dn,
                alphaToCoverage: !!M.alphaToCoverage,
                map: Xe,
                matcap: nt,
                envMap: xe,
                envMapMode: xe && X.mapping,
                envMapCubeUVHeight: V,
                aoMap: F,
                lightMap: Ge,
                bumpMap: Je,
                normalMap: q,
                displacementMap: d && ve,
                emissiveMap: et,
                normalMapObjectSpace: q && M.normalMapType === 1,
                normalMapTangentSpace: q && M.normalMapType === 0,
                metalnessMap: Le,
                roughnessMap: ge,
                anisotropy: st,
                anisotropyMap: te,
                clearcoat: I,
                clearcoatMap: Fe,
                clearcoatNormalMap: ye,
                clearcoatRoughnessMap: Ue,
                dispersion: A,
                iridescence: $,
                iridescenceMap: we,
                iridescenceThicknessMap: pe,
                sheen: ne,
                sheenColorMap: Ae,
                sheenRoughnessMap: Ve,
                specularMap: He,
                specularColorMap: Se,
                specularIntensityMap: je,
                transmission: ie,
                transmissionMap: U,
                thicknessMap: Me,
                gradientMap: oe,
                opaque: M.transparent === !1 && M.blending === 1 && M.alphaToCoverage === !1,
                alphaMap: Ee,
                alphaTest: me,
                alphaHash: ce,
                combine: M.combine,
                mapUv: Xe && g(M.map.channel),
                aoMapUv: F && g(M.aoMap.channel),
                lightMapUv: Ge && g(M.lightMap.channel),
                bumpMapUv: Je && g(M.bumpMap.channel),
                normalMapUv: q && g(M.normalMap.channel),
                displacementMapUv: ve && g(M.displacementMap.channel),
                emissiveMapUv: et && g(M.emissiveMap.channel),
                metalnessMapUv: Le && g(M.metalnessMap.channel),
                roughnessMapUv: ge && g(M.roughnessMap.channel),
                anisotropyMapUv: te && g(M.anisotropyMap.channel),
                clearcoatMapUv: Fe && g(M.clearcoatMap.channel),
                clearcoatNormalMapUv: ye && g(M.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: Ue && g(M.clearcoatRoughnessMap.channel),
                iridescenceMapUv: we && g(M.iridescenceMap.channel),
                iridescenceThicknessMapUv: pe && g(M.iridescenceThicknessMap.channel),
                sheenColorMapUv: Ae && g(M.sheenColorMap.channel),
                sheenRoughnessMapUv: Ve && g(M.sheenRoughnessMap.channel),
                specularMapUv: He && g(M.specularMap.channel),
                specularColorMapUv: Se && g(M.specularColorMap.channel),
                specularIntensityMapUv: je && g(M.specularIntensityMap.channel),
                transmissionMapUv: U && g(M.transmissionMap.channel),
                thicknessMapUv: Me && g(M.thicknessMap.channel),
                alphaMapUv: Ee && g(M.alphaMap.channel),
                vertexTangents: !!z.attributes.tangent && (q || st),
                vertexColors: M.vertexColors,
                vertexAlphas: M.vertexColors === !0 && !!z.attributes.color && z.attributes.color.itemSize === 4,
                pointsUvs: P.isPoints === !0 && !!z.attributes.uv && (Xe || Ee),
                fog: !!O,
                useFog: M.fog === !0,
                fogExp2: !!O && O.isFogExp2,
                flatShading: M.flatShading === !0,
                sizeAttenuation: M.sizeAttenuation === !0,
                logarithmicDepthBuffer: h,
                reverseDepthBuffer: be,
                skinning: P.isSkinnedMesh === !0,
                morphTargets: z.morphAttributes.position !== void 0,
                morphNormals: z.morphAttributes.normal !== void 0,
                morphColors: z.morphAttributes.color !== void 0,
                morphTargetsCount: se,
                morphTextureStride: de,
                numDirLights: y.directional.length,
                numPointLights: y.point.length,
                numSpotLights: y.spot.length,
                numSpotLightMaps: y.spotLightMap.length,
                numRectAreaLights: y.rectArea.length,
                numHemiLights: y.hemi.length,
                numDirLightShadows: y.directionalShadowMap.length,
                numPointLightShadows: y.pointShadowMap.length,
                numSpotLightShadows: y.spotShadowMap.length,
                numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
                numLightProbes: y.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: M.dithering,
                shadowMapEnabled: r.shadowMap.enabled && D.length > 0,
                shadowMapType: r.shadowMap.type,
                toneMapping: N,
                decodeVideoTexture: Xe && M.map.isVideoTexture === !0 && bt.getTransfer(M.map.colorSpace) === Rt,
                decodeVideoTextureEmissive: et && M.emissiveMap.isVideoTexture === !0 && bt.getTransfer(M.emissiveMap.colorSpace) === Rt,
                premultipliedAlpha: M.premultipliedAlpha,
                doubleSided: M.side === 2,
                flipSided: M.side === 1,
                useDepthPacking: M.depthPacking >= 0,
                depthPacking: M.depthPacking || 0,
                index0AttributeName: M.index0AttributeName,
                extensionClipCullDistance: ae && M.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ae && M.extensions.multiDraw === !0 || Pe) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: M.customProgramCacheKey()
            };
            return re.vertexUv1s = l.has(1), re.vertexUv2s = l.has(2), re.vertexUv3s = l.has(3), l.clear(), re
        }

        function p(M) {
            const y = [];
            if (M.shaderID ? y.push(M.shaderID) : (y.push(M.customVertexShaderID), y.push(M.customFragmentShaderID)), M.defines !== void 0)
                for (const D in M.defines) y.push(D), y.push(M.defines[D]);
            return M.isRawShaderMaterial === !1 && (v(y, M), x(y, M), y.push(r.outputColorSpace)), y.push(M.customProgramCacheKey), y.join()
        }

        function v(M, y) {
            M.push(y.precision), M.push(y.outputColorSpace), M.push(y.envMapMode), M.push(y.envMapCubeUVHeight), M.push(y.mapUv), M.push(y.alphaMapUv), M.push(y.lightMapUv), M.push(y.aoMapUv), M.push(y.bumpMapUv), M.push(y.normalMapUv), M.push(y.displacementMapUv), M.push(y.emissiveMapUv), M.push(y.metalnessMapUv), M.push(y.roughnessMapUv), M.push(y.anisotropyMapUv), M.push(y.clearcoatMapUv), M.push(y.clearcoatNormalMapUv), M.push(y.clearcoatRoughnessMapUv), M.push(y.iridescenceMapUv), M.push(y.iridescenceThicknessMapUv), M.push(y.sheenColorMapUv), M.push(y.sheenRoughnessMapUv), M.push(y.specularMapUv), M.push(y.specularColorMapUv), M.push(y.specularIntensityMapUv), M.push(y.transmissionMapUv), M.push(y.thicknessMapUv), M.push(y.combine), M.push(y.fogExp2), M.push(y.sizeAttenuation), M.push(y.morphTargetsCount), M.push(y.morphAttributeCount), M.push(y.numDirLights), M.push(y.numPointLights), M.push(y.numSpotLights), M.push(y.numSpotLightMaps), M.push(y.numHemiLights), M.push(y.numRectAreaLights), M.push(y.numDirLightShadows), M.push(y.numPointLightShadows), M.push(y.numSpotLightShadows), M.push(y.numSpotLightShadowsWithMaps), M.push(y.numLightProbes), M.push(y.shadowMapType), M.push(y.toneMapping), M.push(y.numClippingPlanes), M.push(y.numClipIntersection), M.push(y.depthPacking)
        }

        function x(M, y) {
            o.disableAll(), y.supportsVertexTextures && o.enable(0), y.instancing && o.enable(1), y.instancingColor && o.enable(2), y.instancingMorph && o.enable(3), y.matcap && o.enable(4), y.envMap && o.enable(5), y.normalMapObjectSpace && o.enable(6), y.normalMapTangentSpace && o.enable(7), y.clearcoat && o.enable(8), y.iridescence && o.enable(9), y.alphaTest && o.enable(10), y.vertexColors && o.enable(11), y.vertexAlphas && o.enable(12), y.vertexUv1s && o.enable(13), y.vertexUv2s && o.enable(14), y.vertexUv3s && o.enable(15), y.vertexTangents && o.enable(16), y.anisotropy && o.enable(17), y.alphaHash && o.enable(18), y.batching && o.enable(19), y.dispersion && o.enable(20), y.batchingColor && o.enable(21), M.push(o.mask), o.disableAll(), y.fog && o.enable(0), y.useFog && o.enable(1), y.flatShading && o.enable(2), y.logarithmicDepthBuffer && o.enable(3), y.reverseDepthBuffer && o.enable(4), y.skinning && o.enable(5), y.morphTargets && o.enable(6), y.morphNormals && o.enable(7), y.morphColors && o.enable(8), y.premultipliedAlpha && o.enable(9), y.shadowMapEnabled && o.enable(10), y.doubleSided && o.enable(11), y.flipSided && o.enable(12), y.useDepthPacking && o.enable(13), y.dithering && o.enable(14), y.transmission && o.enable(15), y.sheen && o.enable(16), y.opaque && o.enable(17), y.pointsUvs && o.enable(18), y.decodeVideoTexture && o.enable(19), y.decodeVideoTextureEmissive && o.enable(20), y.alphaToCoverage && o.enable(21), M.push(o.mask)
        }

        function b(M) {
            const y = _[M.type];
            let D;
            if (y) {
                const R = dr[y];
                D = vS.clone(R.uniforms)
            } else D = M.uniforms;
            return D
        }

        function S(M, y) {
            let D;
            for (let R = 0, P = f.length; R < P; R++) {
                const O = f[R];
                if (O.cacheKey === y) {
                    D = O, ++D.usedTimes;
                    break
                }
            }
            return D === void 0 && (D = new Zw(r, y, M, s), f.push(D)), D
        }

        function E(M) {
            if (--M.usedTimes === 0) {
                const y = f.indexOf(M);
                f[y] = f[f.length - 1], f.pop(), M.destroy()
            }
        }

        function T(M) {
            c.remove(M)
        }

        function w() {
            c.dispose()
        }
        return {
            getParameters: m,
            getProgramCacheKey: p,
            getUniforms: b,
            acquireProgram: S,
            releaseProgram: E,
            releaseShaderCache: T,
            programs: f,
            dispose: w
        }
    }

    function iA() {
        let r = new WeakMap;

        function e(a) {
            return r.has(a)
        }

        function t(a) {
            let o = r.get(a);
            return o === void 0 && (o = {}, r.set(a, o)), o
        }

        function n(a) {
            r.delete(a)
        }

        function i(a, o, c) {
            r.get(a)[o] = c
        }

        function s() {
            r = new WeakMap
        }
        return {
            has: e,
            get: t,
            remove: n,
            update: i,
            dispose: s
        }
    }

    function rA(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
    }

    function ob(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
    }

    function cb() {
        const r = [];
        let e = 0;
        const t = [],
            n = [],
            i = [];

        function s() {
            e = 0, t.length = 0, n.length = 0, i.length = 0
        }

        function a(h, d, u, _, g, m) {
            let p = r[e];
            return p === void 0 ? (p = {
                id: h.id,
                object: h,
                geometry: d,
                material: u,
                groupOrder: _,
                renderOrder: h.renderOrder,
                z: g,
                group: m
            }, r[e] = p) : (p.id = h.id, p.object = h, p.geometry = d, p.material = u, p.groupOrder = _, p.renderOrder = h.renderOrder, p.z = g, p.group = m), e++, p
        }

        function o(h, d, u, _, g, m) {
            const p = a(h, d, u, _, g, m);
            u.transmission > 0 ? n.push(p) : u.transparent === !0 ? i.push(p) : t.push(p)
        }

        function c(h, d, u, _, g, m) {
            const p = a(h, d, u, _, g, m);
            u.transmission > 0 ? n.unshift(p) : u.transparent === !0 ? i.unshift(p) : t.unshift(p)
        }

        function l(h, d) {
            t.length > 1 && t.sort(h || rA), n.length > 1 && n.sort(d || ob), i.length > 1 && i.sort(d || ob)
        }

        function f() {
            for (let h = e, d = r.length; h < d; h++) {
                const u = r[h];
                if (u.id === null) break;
                u.id = null, u.object = null, u.geometry = null, u.material = null, u.group = null
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: i,
            init: s,
            push: o,
            unshift: c,
            finish: f,
            sort: l
        }
    }

    function sA() {
        let r = new WeakMap;

        function e(n, i) {
            const s = r.get(n);
            let a;
            return s === void 0 ? (a = new cb, r.set(n, [a])) : i >= s.length ? (a = new cb, s.push(a)) : a = s[i], a
        }

        function t() {
            r = new WeakMap
        }
        return {
            get: e,
            dispose: t
        }
    }

    function aA() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            direction: new B,
                            color: new rt
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new B,
                            direction: new B,
                            color: new rt,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new B,
                            color: new rt,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new B,
                            skyColor: new rt,
                            groundColor: new rt
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new rt,
                            position: new B,
                            halfWidth: new B,
                            halfHeight: new B
                        };
                        break
                }
                return r[e.id] = t, t
            }
        }
    }

    function oA() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new at
                        };
                        break;
                    case "SpotLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new at
                        };
                        break;
                    case "PointLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new at,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break
                }
                return r[e.id] = t, t
            }
        }
    }
    let cA = 0;

    function lA(r, e) {
        return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
    }

    function uA(r) {
        const e = new aA,
            t = oA(),
            n = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
        for (let l = 0; l < 9; l++) n.probe.push(new B);
        const i = new B,
            s = new Ke,
            a = new Ke;

        function o(l) {
            let f = 0,
                h = 0,
                d = 0;
            for (let M = 0; M < 9; M++) n.probe[M].set(0, 0, 0);
            let u = 0,
                _ = 0,
                g = 0,
                m = 0,
                p = 0,
                v = 0,
                x = 0,
                b = 0,
                S = 0,
                E = 0,
                T = 0;
            l.sort(lA);
            for (let M = 0, y = l.length; M < y; M++) {
                const D = l[M],
                    R = D.color,
                    P = D.intensity,
                    O = D.distance,
                    z = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                if (D.isAmbientLight) f += R.r * P, h += R.g * P, d += R.b * P;
                else if (D.isLightProbe) {
                    for (let k = 0; k < 9; k++) n.probe[k].addScaledVector(D.sh.coefficients[k], P);
                    T++
                } else if (D.isDirectionalLight) {
                    const k = e.get(D);
                    if (k.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
                        const X = D.shadow,
                            V = t.get(D);
                        V.shadowIntensity = X.intensity, V.shadowBias = X.bias, V.shadowNormalBias = X.normalBias, V.shadowRadius = X.radius, V.shadowMapSize = X.mapSize, n.directionalShadow[u] = V, n.directionalShadowMap[u] = z, n.directionalShadowMatrix[u] = D.shadow.matrix, v++
                    }
                    n.directional[u] = k, u++
                } else if (D.isSpotLight) {
                    const k = e.get(D);
                    k.position.setFromMatrixPosition(D.matrixWorld), k.color.copy(R).multiplyScalar(P), k.distance = O, k.coneCos = Math.cos(D.angle), k.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), k.decay = D.decay, n.spot[g] = k;
                    const X = D.shadow;
                    if (D.map && (n.spotLightMap[S] = D.map, S++, X.updateMatrices(D), D.castShadow && E++), n.spotLightMatrix[g] = X.matrix, D.castShadow) {
                        const V = t.get(D);
                        V.shadowIntensity = X.intensity, V.shadowBias = X.bias, V.shadowNormalBias = X.normalBias, V.shadowRadius = X.radius, V.shadowMapSize = X.mapSize, n.spotShadow[g] = V, n.spotShadowMap[g] = z, b++
                    }
                    g++
                } else if (D.isRectAreaLight) {
                    const k = e.get(D);
                    k.color.copy(R).multiplyScalar(P), k.halfWidth.set(D.width * .5, 0, 0), k.halfHeight.set(0, D.height * .5, 0), n.rectArea[m] = k, m++
                } else if (D.isPointLight) {
                    const k = e.get(D);
                    if (k.color.copy(D.color).multiplyScalar(D.intensity), k.distance = D.distance, k.decay = D.decay, D.castShadow) {
                        const X = D.shadow,
                            V = t.get(D);
                        V.shadowIntensity = X.intensity, V.shadowBias = X.bias, V.shadowNormalBias = X.normalBias, V.shadowRadius = X.radius, V.shadowMapSize = X.mapSize, V.shadowCameraNear = X.camera.near, V.shadowCameraFar = X.camera.far, n.pointShadow[_] = V, n.pointShadowMap[_] = z, n.pointShadowMatrix[_] = D.shadow.matrix, x++
                    }
                    n.point[_] = k, _++
                } else if (D.isHemisphereLight) {
                    const k = e.get(D);
                    k.skyColor.copy(D.color).multiplyScalar(P), k.groundColor.copy(D.groundColor).multiplyScalar(P), n.hemi[p] = k, p++
                }
            }
            m > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Re.LTC_FLOAT_1, n.rectAreaLTC2 = Re.LTC_FLOAT_2) : (n.rectAreaLTC1 = Re.LTC_HALF_1, n.rectAreaLTC2 = Re.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = h, n.ambient[2] = d;
            const w = n.hash;
            (w.directionalLength !== u || w.pointLength !== _ || w.spotLength !== g || w.rectAreaLength !== m || w.hemiLength !== p || w.numDirectionalShadows !== v || w.numPointShadows !== x || w.numSpotShadows !== b || w.numSpotMaps !== S || w.numLightProbes !== T) && (n.directional.length = u, n.spot.length = g, n.rectArea.length = m, n.point.length = _, n.hemi.length = p, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + S - E, n.spotLightMap.length = S, n.numSpotLightShadowsWithMaps = E, n.numLightProbes = T, w.directionalLength = u, w.pointLength = _, w.spotLength = g, w.rectAreaLength = m, w.hemiLength = p, w.numDirectionalShadows = v, w.numPointShadows = x, w.numSpotShadows = b, w.numSpotMaps = S, w.numLightProbes = T, n.version = cA++)
        }

        function c(l, f) {
            let h = 0,
                d = 0,
                u = 0,
                _ = 0,
                g = 0;
            const m = f.matrixWorldInverse;
            for (let p = 0, v = l.length; p < v; p++) {
                const x = l[p];
                if (x.isDirectionalLight) {
                    const b = n.directional[h];
                    b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(m), h++
                } else if (x.isSpotLight) {
                    const b = n.spot[u];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(m), b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(m), u++
                } else if (x.isRectAreaLight) {
                    const b = n.rectArea[_];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(m), a.identity(), s.copy(x.matrixWorld), s.premultiply(m), a.extractRotation(s), b.halfWidth.set(x.width * .5, 0, 0), b.halfHeight.set(0, x.height * .5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), _++
                } else if (x.isPointLight) {
                    const b = n.point[d];
                    b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(m), d++
                } else if (x.isHemisphereLight) {
                    const b = n.hemi[g];
                    b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(m), g++
                }
            }
        }
        return {
            setup: o,
            setupView: c,
            state: n
        }
    }

    function lb(r) {
        const e = new uA(r),
            t = [],
            n = [];

        function i(f) {
            l.camera = f, t.length = 0, n.length = 0
        }

        function s(f) {
            t.push(f)
        }

        function a(f) {
            n.push(f)
        }

        function o() {
            e.setup(t)
        }

        function c(f) {
            e.setupView(t, f)
        }
        const l = {
            lightsArray: t,
            shadowsArray: n,
            camera: null,
            lights: e,
            transmissionRenderTarget: {}
        };
        return {
            init: i,
            state: l,
            setupLights: o,
            setupLightsView: c,
            pushLight: s,
            pushShadow: a
        }
    }

    function fA(r) {
        let e = new WeakMap;

        function t(i, s = 0) {
            const a = e.get(i);
            let o;
            return a === void 0 ? (o = new lb(r), e.set(i, [o])) : s >= a.length ? (o = new lb(r), a.push(o)) : o = a[s], o
        }

        function n() {
            e = new WeakMap
        }
        return {
            get: t,
            dispose: n
        }
    }
    const hA = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        dA = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

    function pA(r, e, t) {
        let n = new yc;
        const i = new at,
            s = new at,
            a = new Tt,
            o = new XS({
                depthPacking: 3201
            }),
            c = new jS,
            l = {},
            f = t.maxTextureSize,
            h = {
                0: 1,
                1: 0,
                2: 2
            },
            d = new Nr({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new at
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: hA,
                fragmentShader: dA
            }),
            u = d.clone();
        u.defines.HORIZONTAL_PASS = 1;
        const _ = new Fn;
        _.setAttribute("position", new Zt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const g = new bn(_, d),
            m = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
        let p = this.type;
        this.render = function(E, T, w) {
            if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || E.length === 0) return;
            const M = r.getRenderTarget(),
                y = r.getActiveCubeFace(),
                D = r.getActiveMipmapLevel(),
                R = r.state;
            R.setBlending(0), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
            const P = p !== 3 && this.type === 3,
                O = p === 3 && this.type !== 3;
            for (let z = 0, k = E.length; z < k; z++) {
                const X = E[z],
                    V = X.shadow;
                if (V === void 0) {
                    console.warn("THREE.WebGLShadowMap:", X, "has no shadow.");
                    continue
                }
                if (V.autoUpdate === !1 && V.needsUpdate === !1) continue;
                i.copy(V.mapSize);
                const H = V.getFrameExtents();
                if (i.multiply(H), s.copy(V.mapSize), (i.x > f || i.y > f) && (i.x > f && (s.x = Math.floor(f / H.x), i.x = s.x * H.x, V.mapSize.x = s.x), i.y > f && (s.y = Math.floor(f / H.y), i.y = s.y * H.y, V.mapSize.y = s.y)), V.map === null || P === !0 || O === !0) {
                    const se = this.type !== 3 ? {
                        minFilter: 1003,
                        magFilter: 1003
                    } : {};
                    V.map !== null && V.map.dispose(), V.map = new Dr(i.x, i.y, se), V.map.texture.name = X.name + ".shadowMap", V.camera.updateProjectionMatrix()
                }
                r.setRenderTarget(V.map), r.clear();
                const L = V.getViewportCount();
                for (let se = 0; se < L; se++) {
                    const de = V.getViewport(se);
                    a.set(s.x * de.x, s.y * de.y, s.x * de.z, s.y * de.w), R.viewport(a), V.updateMatrices(X, se), n = V.getFrustum(), b(T, w, V.camera, X, this.type)
                }
                V.isPointLightShadow !== !0 && this.type === 3 && v(V, w), V.needsUpdate = !1
            }
            p = this.type, m.needsUpdate = !1, r.setRenderTarget(M, y, D)
        };

        function v(E, T) {
            const w = e.update(g);
            d.defines.VSM_SAMPLES !== E.blurSamples && (d.defines.VSM_SAMPLES = E.blurSamples, u.defines.VSM_SAMPLES = E.blurSamples, d.needsUpdate = !0, u.needsUpdate = !0), E.mapPass === null && (E.mapPass = new Dr(i.x, i.y)), d.uniforms.shadow_pass.value = E.map.texture, d.uniforms.resolution.value = E.mapSize, d.uniforms.radius.value = E.radius, r.setRenderTarget(E.mapPass), r.clear(), r.renderBufferDirect(T, null, w, d, g, null), u.uniforms.shadow_pass.value = E.mapPass.texture, u.uniforms.resolution.value = E.mapSize, u.uniforms.radius.value = E.radius, r.setRenderTarget(E.map), r.clear(), r.renderBufferDirect(T, null, w, u, g, null)
        }

        function x(E, T, w, M) {
            let y = null;
            const D = w.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
            if (D !== void 0) y = D;
            else if (y = w.isPointLight === !0 ? c : o, r.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0 || T.alphaToCoverage === !0) {
                const R = y.uuid,
                    P = T.uuid;
                let O = l[R];
                O === void 0 && (O = {}, l[R] = O);
                let z = O[P];
                z === void 0 && (z = y.clone(), O[P] = z, T.addEventListener("dispose", S)), y = z
            }
            if (y.visible = T.visible, y.wireframe = T.wireframe, M === 3 ? y.side = T.shadowSide !== null ? T.shadowSide : T.side : y.side = T.shadowSide !== null ? T.shadowSide : h[T.side], y.alphaMap = T.alphaMap, y.alphaTest = T.alphaToCoverage === !0 ? .5 : T.alphaTest, y.map = T.map, y.clipShadows = T.clipShadows, y.clippingPlanes = T.clippingPlanes, y.clipIntersection = T.clipIntersection, y.displacementMap = T.displacementMap, y.displacementScale = T.displacementScale, y.displacementBias = T.displacementBias, y.wireframeLinewidth = T.wireframeLinewidth, y.linewidth = T.linewidth, w.isPointLight === !0 && y.isMeshDistanceMaterial === !0) {
                const R = r.properties.get(y);
                R.light = w
            }
            return y
        }

        function b(E, T, w, M, y) {
            if (E.visible === !1) return;
            if (E.layers.test(T.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && y === 3) && (!E.frustumCulled || n.intersectsObject(E))) {
                E.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, E.matrixWorld);
                const P = e.update(E),
                    O = E.material;
                if (Array.isArray(O)) {
                    const z = P.groups;
                    for (let k = 0, X = z.length; k < X; k++) {
                        const V = z[k],
                            H = O[V.materialIndex];
                        if (H && H.visible) {
                            const L = x(E, H, M, y);
                            E.onBeforeShadow(r, E, T, w, P, L, V), r.renderBufferDirect(w, null, P, L, E, V), E.onAfterShadow(r, E, T, w, P, L, V)
                        }
                    }
                } else if (O.visible) {
                    const z = x(E, O, M, y);
                    E.onBeforeShadow(r, E, T, w, P, z, null), r.renderBufferDirect(w, null, P, z, E, null), E.onAfterShadow(r, E, T, w, P, z, null)
                }
            }
            const R = E.children;
            for (let P = 0, O = R.length; P < O; P++) b(R[P], T, w, M, y)
        }

        function S(E) {
            E.target.removeEventListener("dispose", S);
            for (const w in l) {
                const M = l[w],
                    y = E.target.uuid;
                y in M && (M[y].dispose(), delete M[y])
            }
        }
    }
    const mA = {
        0: 1,
        2: 6,
        4: 7,
        3: 5,
        1: 0,
        6: 2,
        7: 4,
        5: 3
    };

    function gA(r, e) {
        function t() {
            let U = !1;
            const Me = new Tt;
            let oe = null;
            const Ee = new Tt(0, 0, 0, 0);
            return {
                setMask: function(me) {
                    oe !== me && !U && (r.colorMask(me, me, me, me), oe = me)
                },
                setLocked: function(me) {
                    U = me
                },
                setClear: function(me, ce, ae, N, re) {
                    re === !0 && (me *= N, ce *= N, ae *= N), Me.set(me, ce, ae, N), Ee.equals(Me) === !1 && (r.clearColor(me, ce, ae, N), Ee.copy(Me))
                },
                reset: function() {
                    U = !1, oe = null, Ee.set(-1, 0, 0, 0)
                }
            }
        }

        function n() {
            let U = !1,
                Me = !1,
                oe = null,
                Ee = null,
                me = null;
            return {
                setReversed: function(ce) {
                    if (Me !== ce) {
                        const ae = e.get("EXT_clip_control");
                        ce ? ae.clipControlEXT(ae.LOWER_LEFT_EXT, ae.ZERO_TO_ONE_EXT) : ae.clipControlEXT(ae.LOWER_LEFT_EXT, ae.NEGATIVE_ONE_TO_ONE_EXT), Me = ce;
                        const N = me;
                        me = null, this.setClear(N)
                    }
                },
                getReversed: function() {
                    return Me
                },
                setTest: function(ce) {
                    ce ? fe(r.DEPTH_TEST) : be(r.DEPTH_TEST)
                },
                setMask: function(ce) {
                    oe !== ce && !U && (r.depthMask(ce), oe = ce)
                },
                setFunc: function(ce) {
                    if (Me && (ce = mA[ce]), Ee !== ce) {
                        switch (ce) {
                            case 0:
                                r.depthFunc(r.NEVER);
                                break;
                            case 1:
                                r.depthFunc(r.ALWAYS);
                                break;
                            case 2:
                                r.depthFunc(r.LESS);
                                break;
                            case 3:
                                r.depthFunc(r.LEQUAL);
                                break;
                            case 4:
                                r.depthFunc(r.EQUAL);
                                break;
                            case 5:
                                r.depthFunc(r.GEQUAL);
                                break;
                            case 6:
                                r.depthFunc(r.GREATER);
                                break;
                            case 7:
                                r.depthFunc(r.NOTEQUAL);
                                break;
                            default:
                                r.depthFunc(r.LEQUAL)
                        }
                        Ee = ce
                    }
                },
                setLocked: function(ce) {
                    U = ce
                },
                setClear: function(ce) {
                    me !== ce && (Me && (ce = 1 - ce), r.clearDepth(ce), me = ce)
                },
                reset: function() {
                    U = !1, oe = null, Ee = null, me = null, Me = !1
                }
            }
        }

        function i() {
            let U = !1,
                Me = null,
                oe = null,
                Ee = null,
                me = null,
                ce = null,
                ae = null,
                N = null,
                re = null;
            return {
                setTest: function(G) {
                    U || (G ? fe(r.STENCIL_TEST) : be(r.STENCIL_TEST))
                },
                setMask: function(G) {
                    Me !== G && !U && (r.stencilMask(G), Me = G)
                },
                setFunc: function(G, J, le) {
                    (oe !== G || Ee !== J || me !== le) && (r.stencilFunc(G, J, le), oe = G, Ee = J, me = le)
                },
                setOp: function(G, J, le) {
                    (ce !== G || ae !== J || N !== le) && (r.stencilOp(G, J, le), ce = G, ae = J, N = le)
                },
                setLocked: function(G) {
                    U = G
                },
                setClear: function(G) {
                    re !== G && (r.clearStencil(G), re = G)
                },
                reset: function() {
                    U = !1, Me = null, oe = null, Ee = null, me = null, ce = null, ae = null, N = null, re = null
                }
            }
        }
        const s = new t,
            a = new n,
            o = new i,
            c = new WeakMap,
            l = new WeakMap;
        let f = {},
            h = {},
            d = new WeakMap,
            u = [],
            _ = null,
            g = !1,
            m = null,
            p = null,
            v = null,
            x = null,
            b = null,
            S = null,
            E = null,
            T = new rt(0, 0, 0),
            w = 0,
            M = !1,
            y = null,
            D = null,
            R = null,
            P = null,
            O = null;
        const z = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let k = !1,
            X = 0;
        const V = r.getParameter(r.VERSION);
        V.indexOf("WebGL") !== -1 ? (X = parseFloat(/^WebGL (\d)/.exec(V)[1]), k = X >= 1) : V.indexOf("OpenGL ES") !== -1 && (X = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), k = X >= 2);
        let H = null,
            L = {};
        const se = r.getParameter(r.SCISSOR_BOX),
            de = r.getParameter(r.VIEWPORT),
            ke = new Tt().fromArray(se),
            Y = new Tt().fromArray(de);

        function ee(U, Me, oe, Ee) {
            const me = new Uint8Array(4),
                ce = r.createTexture();
            r.bindTexture(U, ce), r.texParameteri(U, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(U, r.TEXTURE_MAG_FILTER, r.NEAREST);
            for (let ae = 0; ae < oe; ae++) U === r.TEXTURE_3D || U === r.TEXTURE_2D_ARRAY ? r.texImage3D(Me, 0, r.RGBA, 1, 1, Ee, 0, r.RGBA, r.UNSIGNED_BYTE, me) : r.texImage2D(Me + ae, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, me);
            return ce
        }
        const he = {};
        he[r.TEXTURE_2D] = ee(r.TEXTURE_2D, r.TEXTURE_2D, 1), he[r.TEXTURE_CUBE_MAP] = ee(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), he[r.TEXTURE_2D_ARRAY] = ee(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), he[r.TEXTURE_3D] = ee(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), fe(r.DEPTH_TEST), a.setFunc(3), Je(!1), q(1), fe(r.CULL_FACE), F(0);

        function fe(U) {
            f[U] !== !0 && (r.enable(U), f[U] = !0)
        }

        function be(U) {
            f[U] !== !1 && (r.disable(U), f[U] = !1)
        }

        function Ye(U, Me) {
            return h[U] !== Me ? (r.bindFramebuffer(U, Me), h[U] = Me, U === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = Me), U === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = Me), !0) : !1
        }

        function Pe(U, Me) {
            let oe = u,
                Ee = !1;
            if (U) {
                oe = d.get(Me), oe === void 0 && (oe = [], d.set(Me, oe));
                const me = U.textures;
                if (oe.length !== me.length || oe[0] !== r.COLOR_ATTACHMENT0) {
                    for (let ce = 0, ae = me.length; ce < ae; ce++) oe[ce] = r.COLOR_ATTACHMENT0 + ce;
                    oe.length = me.length, Ee = !0
                }
            } else oe[0] !== r.BACK && (oe[0] = r.BACK, Ee = !0);
            Ee && r.drawBuffers(oe)
        }

        function Xe(U) {
            return _ !== U ? (r.useProgram(U), _ = U, !0) : !1
        }
        const nt = {
            100: r.FUNC_ADD,
            101: r.FUNC_SUBTRACT,
            102: r.FUNC_REVERSE_SUBTRACT
        };
        nt[103] = r.MIN, nt[104] = r.MAX;
        const xe = {
            200: r.ZERO,
            201: r.ONE,
            202: r.SRC_COLOR,
            204: r.SRC_ALPHA,
            210: r.SRC_ALPHA_SATURATE,
            208: r.DST_COLOR,
            206: r.DST_ALPHA,
            203: r.ONE_MINUS_SRC_COLOR,
            205: r.ONE_MINUS_SRC_ALPHA,
            209: r.ONE_MINUS_DST_COLOR,
            207: r.ONE_MINUS_DST_ALPHA,
            211: r.CONSTANT_COLOR,
            212: r.ONE_MINUS_CONSTANT_COLOR,
            213: r.CONSTANT_ALPHA,
            214: r.ONE_MINUS_CONSTANT_ALPHA
        };

        function F(U, Me, oe, Ee, me, ce, ae, N, re, G) {
            if (U === 0) {
                g === !0 && (be(r.BLEND), g = !1);
                return
            }
            if (g === !1 && (fe(r.BLEND), g = !0), U !== 5) {
                if (U !== m || G !== M) {
                    if ((p !== 100 || b !== 100) && (r.blendEquation(r.FUNC_ADD), p = 100, b = 100), G) switch (U) {
                        case 1:
                            r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            r.blendFunc(r.ONE, r.ONE);
                            break;
                        case 3:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case 4:
                            r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", U);
                            break
                    } else switch (U) {
                        case 1:
                            r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            r.blendFunc(r.SRC_ALPHA, r.ONE);
                            break;
                        case 3:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case 4:
                            r.blendFunc(r.ZERO, r.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", U);
                            break
                    }
                    v = null, x = null, S = null, E = null, T.set(0, 0, 0), w = 0, m = U, M = G
                }
                return
            }
            me = me || Me, ce = ce || oe, ae = ae || Ee, (Me !== p || me !== b) && (r.blendEquationSeparate(nt[Me], nt[me]), p = Me, b = me), (oe !== v || Ee !== x || ce !== S || ae !== E) && (r.blendFuncSeparate(xe[oe], xe[Ee], xe[ce], xe[ae]), v = oe, x = Ee, S = ce, E = ae), (N.equals(T) === !1 || re !== w) && (r.blendColor(N.r, N.g, N.b, re), T.copy(N), w = re), m = U, M = !1
        }

        function Ge(U, Me) {
            U.side === 2 ? be(r.CULL_FACE) : fe(r.CULL_FACE);
            let oe = U.side === 1;
            Me && (oe = !oe), Je(oe), U.blending === 1 && U.transparent === !1 ? F(0) : F(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.blendColor, U.blendAlpha, U.premultipliedAlpha), a.setFunc(U.depthFunc), a.setTest(U.depthTest), a.setMask(U.depthWrite), s.setMask(U.colorWrite);
            const Ee = U.stencilWrite;
            o.setTest(Ee), Ee && (o.setMask(U.stencilWriteMask), o.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), o.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), et(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === !0 ? fe(r.SAMPLE_ALPHA_TO_COVERAGE) : be(r.SAMPLE_ALPHA_TO_COVERAGE)
        }

        function Je(U) {
            y !== U && (U ? r.frontFace(r.CW) : r.frontFace(r.CCW), y = U)
        }

        function q(U) {
            U !== 0 ? (fe(r.CULL_FACE), U !== D && (U === 1 ? r.cullFace(r.BACK) : U === 2 ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : be(r.CULL_FACE), D = U
        }

        function ve(U) {
            U !== R && (k && r.lineWidth(U), R = U)
        }

        function et(U, Me, oe) {
            U ? (fe(r.POLYGON_OFFSET_FILL), (P !== Me || O !== oe) && (r.polygonOffset(Me, oe), P = Me, O = oe)) : be(r.POLYGON_OFFSET_FILL)
        }

        function Le(U) {
            U ? fe(r.SCISSOR_TEST) : be(r.SCISSOR_TEST)
        }

        function ge(U) {
            U === void 0 && (U = r.TEXTURE0 + z - 1), H !== U && (r.activeTexture(U), H = U)
        }

        function st(U, Me, oe) {
            oe === void 0 && (H === null ? oe = r.TEXTURE0 + z - 1 : oe = H);
            let Ee = L[oe];
            Ee === void 0 && (Ee = {
                type: void 0,
                texture: void 0
            }, L[oe] = Ee), (Ee.type !== U || Ee.texture !== Me) && (H !== oe && (r.activeTexture(oe), H = oe), r.bindTexture(U, Me || he[U]), Ee.type = U, Ee.texture = Me)
        }

        function I() {
            const U = L[H];
            U !== void 0 && U.type !== void 0 && (r.bindTexture(U.type, null), U.type = void 0, U.texture = void 0)
        }

        function A() {
            try {
                r.compressedTexImage2D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function $() {
            try {
                r.compressedTexImage3D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function ne() {
            try {
                r.texSubImage2D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function ie() {
            try {
                r.texSubImage3D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function te() {
            try {
                r.compressedTexSubImage2D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function Fe() {
            try {
                r.compressedTexSubImage3D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function ye() {
            try {
                r.texStorage2D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function Ue() {
            try {
                r.texStorage3D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function we() {
            try {
                r.texImage2D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function pe() {
            try {
                r.texImage3D(...arguments)
            } catch (U) {
                console.error("THREE.WebGLState:", U)
            }
        }

        function Ae(U) {
            ke.equals(U) === !1 && (r.scissor(U.x, U.y, U.z, U.w), ke.copy(U))
        }

        function Ve(U) {
            Y.equals(U) === !1 && (r.viewport(U.x, U.y, U.z, U.w), Y.copy(U))
        }

        function He(U, Me) {
            let oe = l.get(Me);
            oe === void 0 && (oe = new WeakMap, l.set(Me, oe));
            let Ee = oe.get(U);
            Ee === void 0 && (Ee = r.getUniformBlockIndex(Me, U.name), oe.set(U, Ee))
        }

        function Se(U, Me) {
            const Ee = l.get(Me).get(U);
            c.get(Me) !== Ee && (r.uniformBlockBinding(Me, Ee, U.__bindingPointIndex), c.set(Me, Ee))
        }

        function je() {
            r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), a.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), f = {}, H = null, L = {}, h = {}, d = new WeakMap, u = [], _ = null, g = !1, m = null, p = null, v = null, x = null, b = null, S = null, E = null, T = new rt(0, 0, 0), w = 0, M = !1, y = null, D = null, R = null, P = null, O = null, ke.set(0, 0, r.canvas.width, r.canvas.height), Y.set(0, 0, r.canvas.width, r.canvas.height), s.reset(), a.reset(), o.reset()
        }
        return {
            buffers: {
                color: s,
                depth: a,
                stencil: o
            },
            enable: fe,
            disable: be,
            bindFramebuffer: Ye,
            drawBuffers: Pe,
            useProgram: Xe,
            setBlending: F,
            setMaterial: Ge,
            setFlipSided: Je,
            setCullFace: q,
            setLineWidth: ve,
            setPolygonOffset: et,
            setScissorTest: Le,
            activeTexture: ge,
            bindTexture: st,
            unbindTexture: I,
            compressedTexImage2D: A,
            compressedTexImage3D: $,
            texImage2D: we,
            texImage3D: pe,
            updateUBOMapping: He,
            uniformBlockBinding: Se,
            texStorage2D: ye,
            texStorage3D: Ue,
            texSubImage2D: ne,
            texSubImage3D: ie,
            compressedTexSubImage2D: te,
            compressedTexSubImage3D: Fe,
            scissor: Ae,
            viewport: Ve,
            reset: je
        }
    }

    function _A(r, e, t, n, i, s, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
            c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
            l = new at,
            f = new WeakMap;
        let h;
        const d = new WeakMap;
        let u = !1;
        try {
            u = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
        } catch {}

        function _(I, A) {
            return u ? new OffscreenCanvas(I, A) : hc("canvas")
        }

        function g(I, A, $) {
            let ne = 1;
            const ie = st(I);
            if ((ie.width > $ || ie.height > $) && (ne = $ / Math.max(ie.width, ie.height)), ne < 1)
                if (typeof HTMLImageElement < "u" && I instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && I instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && I instanceof ImageBitmap || typeof VideoFrame < "u" && I instanceof VideoFrame) {
                    const te = Math.floor(ne * ie.width),
                        Fe = Math.floor(ne * ie.height);
                    h === void 0 && (h = _(te, Fe));
                    const ye = A ? _(te, Fe) : h;
                    return ye.width = te, ye.height = Fe, ye.getContext("2d").drawImage(I, 0, 0, te, Fe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + te + "x" + Fe + ")."), ye
                } else return "data" in I && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), I;
            return I
        }

        function m(I) {
            return I.generateMipmaps
        }

        function p(I) {
            r.generateMipmap(I)
        }

        function v(I) {
            return I.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : I.isWebGL3DRenderTarget ? r.TEXTURE_3D : I.isWebGLArrayRenderTarget || I.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D
        }

        function x(I, A, $, ne, ie = !1) {
            if (I !== null) {
                if (r[I] !== void 0) return r[I];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + I + "'")
            }
            let te = A;
            if (A === r.RED && ($ === r.FLOAT && (te = r.R32F), $ === r.HALF_FLOAT && (te = r.R16F), $ === r.UNSIGNED_BYTE && (te = r.R8)), A === r.RED_INTEGER && ($ === r.UNSIGNED_BYTE && (te = r.R8UI), $ === r.UNSIGNED_SHORT && (te = r.R16UI), $ === r.UNSIGNED_INT && (te = r.R32UI), $ === r.BYTE && (te = r.R8I), $ === r.SHORT && (te = r.R16I), $ === r.INT && (te = r.R32I)), A === r.RG && ($ === r.FLOAT && (te = r.RG32F), $ === r.HALF_FLOAT && (te = r.RG16F), $ === r.UNSIGNED_BYTE && (te = r.RG8)), A === r.RG_INTEGER && ($ === r.UNSIGNED_BYTE && (te = r.RG8UI), $ === r.UNSIGNED_SHORT && (te = r.RG16UI), $ === r.UNSIGNED_INT && (te = r.RG32UI), $ === r.BYTE && (te = r.RG8I), $ === r.SHORT && (te = r.RG16I), $ === r.INT && (te = r.RG32I)), A === r.RGB_INTEGER && ($ === r.UNSIGNED_BYTE && (te = r.RGB8UI), $ === r.UNSIGNED_SHORT && (te = r.RGB16UI), $ === r.UNSIGNED_INT && (te = r.RGB32UI), $ === r.BYTE && (te = r.RGB8I), $ === r.SHORT && (te = r.RGB16I), $ === r.INT && (te = r.RGB32I)), A === r.RGBA_INTEGER && ($ === r.UNSIGNED_BYTE && (te = r.RGBA8UI), $ === r.UNSIGNED_SHORT && (te = r.RGBA16UI), $ === r.UNSIGNED_INT && (te = r.RGBA32UI), $ === r.BYTE && (te = r.RGBA8I), $ === r.SHORT && (te = r.RGBA16I), $ === r.INT && (te = r.RGBA32I)), A === r.RGB && $ === r.UNSIGNED_INT_5_9_9_9_REV && (te = r.RGB9_E5), A === r.RGBA) {
                const Fe = ie ? Zl : bt.getTransfer(ne);
                $ === r.FLOAT && (te = r.RGBA32F), $ === r.HALF_FLOAT && (te = r.RGBA16F), $ === r.UNSIGNED_BYTE && (te = Fe === Rt ? r.SRGB8_ALPHA8 : r.RGBA8), $ === r.UNSIGNED_SHORT_4_4_4_4 && (te = r.RGBA4), $ === r.UNSIGNED_SHORT_5_5_5_1 && (te = r.RGB5_A1)
            }
            return (te === r.R16F || te === r.R32F || te === r.RG16F || te === r.RG32F || te === r.RGBA16F || te === r.RGBA32F) && e.get("EXT_color_buffer_float"), te
        }

        function b(I, A) {
            let $;
            return I ? A === null || A === 1014 || A === 1020 ? $ = r.DEPTH24_STENCIL8 : A === 1015 ? $ = r.DEPTH32F_STENCIL8 : A === 1012 && ($ = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : A === null || A === 1014 || A === 1020 ? $ = r.DEPTH_COMPONENT24 : A === 1015 ? $ = r.DEPTH_COMPONENT32F : A === 1012 && ($ = r.DEPTH_COMPONENT16), $
        }

        function S(I, A) {
            return m(I) === !0 || I.isFramebufferTexture && I.minFilter !== 1003 && I.minFilter !== 1006 ? Math.log2(Math.max(A.width, A.height)) + 1 : I.mipmaps !== void 0 && I.mipmaps.length > 0 ? I.mipmaps.length : I.isCompressedTexture && Array.isArray(I.image) ? A.mipmaps.length : 1
        }

        function E(I) {
            const A = I.target;
            A.removeEventListener("dispose", E), w(A), A.isVideoTexture && f.delete(A)
        }

        function T(I) {
            const A = I.target;
            A.removeEventListener("dispose", T), y(A)
        }

        function w(I) {
            const A = n.get(I);
            if (A.__webglInit === void 0) return;
            const $ = I.source,
                ne = d.get($);
            if (ne) {
                const ie = ne[A.__cacheKey];
                ie.usedTimes--, ie.usedTimes === 0 && M(I), Object.keys(ne).length === 0 && d.delete($)
            }
            n.remove(I)
        }

        function M(I) {
            const A = n.get(I);
            r.deleteTexture(A.__webglTexture);
            const $ = I.source,
                ne = d.get($);
            delete ne[A.__cacheKey], a.memory.textures--
        }

        function y(I) {
            const A = n.get(I);
            if (I.depthTexture && (I.depthTexture.dispose(), n.remove(I.depthTexture)), I.isWebGLCubeRenderTarget)
                for (let ne = 0; ne < 6; ne++) {
                    if (Array.isArray(A.__webglFramebuffer[ne]))
                        for (let ie = 0; ie < A.__webglFramebuffer[ne].length; ie++) r.deleteFramebuffer(A.__webglFramebuffer[ne][ie]);
                    else r.deleteFramebuffer(A.__webglFramebuffer[ne]);
                    A.__webglDepthbuffer && r.deleteRenderbuffer(A.__webglDepthbuffer[ne])
                } else {
                    if (Array.isArray(A.__webglFramebuffer))
                        for (let ne = 0; ne < A.__webglFramebuffer.length; ne++) r.deleteFramebuffer(A.__webglFramebuffer[ne]);
                    else r.deleteFramebuffer(A.__webglFramebuffer);
                    if (A.__webglDepthbuffer && r.deleteRenderbuffer(A.__webglDepthbuffer), A.__webglMultisampledFramebuffer && r.deleteFramebuffer(A.__webglMultisampledFramebuffer), A.__webglColorRenderbuffer)
                        for (let ne = 0; ne < A.__webglColorRenderbuffer.length; ne++) A.__webglColorRenderbuffer[ne] && r.deleteRenderbuffer(A.__webglColorRenderbuffer[ne]);
                    A.__webglDepthRenderbuffer && r.deleteRenderbuffer(A.__webglDepthRenderbuffer)
                }
            const $ = I.textures;
            for (let ne = 0, ie = $.length; ne < ie; ne++) {
                const te = n.get($[ne]);
                te.__webglTexture && (r.deleteTexture(te.__webglTexture), a.memory.textures--), n.remove($[ne])
            }
            n.remove(I)
        }
        let D = 0;

        function R() {
            D = 0
        }

        function P() {
            const I = D;
            return I >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + I + " texture units while this GPU supports only " + i.maxTextures), D += 1, I
        }

        function O(I) {
            const A = [];
            return A.push(I.wrapS), A.push(I.wrapT), A.push(I.wrapR || 0), A.push(I.magFilter), A.push(I.minFilter), A.push(I.anisotropy), A.push(I.internalFormat), A.push(I.format), A.push(I.type), A.push(I.generateMipmaps), A.push(I.premultiplyAlpha), A.push(I.flipY), A.push(I.unpackAlignment), A.push(I.colorSpace), A.join()
        }

        function z(I, A) {
            const $ = n.get(I);
            if (I.isVideoTexture && Le(I), I.isRenderTargetTexture === !1 && I.version > 0 && $.__version !== I.version) {
                const ne = I.image;
                if (ne === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (ne.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    he($, I, A);
                    return
                }
            }
            t.bindTexture(r.TEXTURE_2D, $.__webglTexture, r.TEXTURE0 + A)
        }

        function k(I, A) {
            const $ = n.get(I);
            if (I.version > 0 && $.__version !== I.version) {
                he($, I, A);
                return
            }
            t.bindTexture(r.TEXTURE_2D_ARRAY, $.__webglTexture, r.TEXTURE0 + A)
        }

        function X(I, A) {
            const $ = n.get(I);
            if (I.version > 0 && $.__version !== I.version) {
                he($, I, A);
                return
            }
            t.bindTexture(r.TEXTURE_3D, $.__webglTexture, r.TEXTURE0 + A)
        }

        function V(I, A) {
            const $ = n.get(I);
            if (I.version > 0 && $.__version !== I.version) {
                fe($, I, A);
                return
            }
            t.bindTexture(r.TEXTURE_CUBE_MAP, $.__webglTexture, r.TEXTURE0 + A)
        }
        const H = {
                1e3: r.REPEAT,
                1001: r.CLAMP_TO_EDGE,
                1002: r.MIRRORED_REPEAT
            },
            L = {
                1003: r.NEAREST,
                1004: r.NEAREST_MIPMAP_NEAREST,
                1005: r.NEAREST_MIPMAP_LINEAR,
                1006: r.LINEAR,
                1007: r.LINEAR_MIPMAP_NEAREST,
                1008: r.LINEAR_MIPMAP_LINEAR
            },
            se = {
                512: r.NEVER,
                519: r.ALWAYS,
                513: r.LESS,
                515: r.LEQUAL,
                514: r.EQUAL,
                518: r.GEQUAL,
                516: r.GREATER,
                517: r.NOTEQUAL
            };

        function de(I, A) {
            if (A.type === 1015 && e.has("OES_texture_float_linear") === !1 && (A.magFilter === 1006 || A.magFilter === 1007 || A.magFilter === 1005 || A.magFilter === 1008 || A.minFilter === 1006 || A.minFilter === 1007 || A.minFilter === 1005 || A.minFilter === 1008) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(I, r.TEXTURE_WRAP_S, H[A.wrapS]), r.texParameteri(I, r.TEXTURE_WRAP_T, H[A.wrapT]), (I === r.TEXTURE_3D || I === r.TEXTURE_2D_ARRAY) && r.texParameteri(I, r.TEXTURE_WRAP_R, H[A.wrapR]), r.texParameteri(I, r.TEXTURE_MAG_FILTER, L[A.magFilter]), r.texParameteri(I, r.TEXTURE_MIN_FILTER, L[A.minFilter]), A.compareFunction && (r.texParameteri(I, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(I, r.TEXTURE_COMPARE_FUNC, se[A.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                if (A.magFilter === 1003 || A.minFilter !== 1005 && A.minFilter !== 1008 || A.type === 1015 && e.has("OES_texture_float_linear") === !1) return;
                if (A.anisotropy > 1 || n.get(A).__currentAnisotropy) {
                    const $ = e.get("EXT_texture_filter_anisotropic");
                    r.texParameterf(I, $.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(A.anisotropy, i.getMaxAnisotropy())), n.get(A).__currentAnisotropy = A.anisotropy
                }
            }
        }

        function ke(I, A) {
            let $ = !1;
            I.__webglInit === void 0 && (I.__webglInit = !0, A.addEventListener("dispose", E));
            const ne = A.source;
            let ie = d.get(ne);
            ie === void 0 && (ie = {}, d.set(ne, ie));
            const te = O(A);
            if (te !== I.__cacheKey) {
                ie[te] === void 0 && (ie[te] = {
                    texture: r.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, $ = !0), ie[te].usedTimes++;
                const Fe = ie[I.__cacheKey];
                Fe !== void 0 && (ie[I.__cacheKey].usedTimes--, Fe.usedTimes === 0 && M(A)), I.__cacheKey = te, I.__webglTexture = ie[te].texture
            }
            return $
        }

        function Y(I, A, $) {
            return Math.floor(Math.floor(I / $) / A)
        }

        function ee(I, A, $, ne) {
            const te = I.updateRanges;
            if (te.length === 0) t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, A.width, A.height, $, ne, A.data);
            else {
                te.sort((pe, Ae) => pe.start - Ae.start);
                let Fe = 0;
                for (let pe = 1; pe < te.length; pe++) {
                    const Ae = te[Fe],
                        Ve = te[pe],
                        He = Ae.start + Ae.count,
                        Se = Y(Ve.start, A.width, 4),
                        je = Y(Ae.start, A.width, 4);
                    Ve.start <= He + 1 && Se === je && Y(Ve.start + Ve.count - 1, A.width, 4) === Se ? Ae.count = Math.max(Ae.count, Ve.start + Ve.count - Ae.start) : (++Fe, te[Fe] = Ve)
                }
                te.length = Fe + 1;
                const ye = r.getParameter(r.UNPACK_ROW_LENGTH),
                    Ue = r.getParameter(r.UNPACK_SKIP_PIXELS),
                    we = r.getParameter(r.UNPACK_SKIP_ROWS);
                r.pixelStorei(r.UNPACK_ROW_LENGTH, A.width);
                for (let pe = 0, Ae = te.length; pe < Ae; pe++) {
                    const Ve = te[pe],
                        He = Math.floor(Ve.start / 4),
                        Se = Math.ceil(Ve.count / 4),
                        je = He % A.width,
                        U = Math.floor(He / A.width),
                        Me = Se,
                        oe = 1;
                    r.pixelStorei(r.UNPACK_SKIP_PIXELS, je), r.pixelStorei(r.UNPACK_SKIP_ROWS, U), t.texSubImage2D(r.TEXTURE_2D, 0, je, U, Me, oe, $, ne, A.data)
                }
                I.clearUpdateRanges(), r.pixelStorei(r.UNPACK_ROW_LENGTH, ye), r.pixelStorei(r.UNPACK_SKIP_PIXELS, Ue), r.pixelStorei(r.UNPACK_SKIP_ROWS, we)
            }
        }

        function he(I, A, $) {
            let ne = r.TEXTURE_2D;
            (A.isDataArrayTexture || A.isCompressedArrayTexture) && (ne = r.TEXTURE_2D_ARRAY), A.isData3DTexture && (ne = r.TEXTURE_3D);
            const ie = ke(I, A),
                te = A.source;
            t.bindTexture(ne, I.__webglTexture, r.TEXTURE0 + $);
            const Fe = n.get(te);
            if (te.version !== Fe.__version || ie === !0) {
                t.activeTexture(r.TEXTURE0 + $);
                const ye = bt.getPrimaries(bt.workingColorSpace),
                    Ue = A.colorSpace === ss ? null : bt.getPrimaries(A.colorSpace),
                    we = A.colorSpace === ss || ye === Ue ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, A.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, A.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
                let pe = g(A.image, !1, i.maxTextureSize);
                pe = ge(A, pe);
                const Ae = s.convert(A.format, A.colorSpace),
                    Ve = s.convert(A.type);
                let He = x(A.internalFormat, Ae, Ve, A.colorSpace, A.isVideoTexture);
                de(ne, A);
                let Se;
                const je = A.mipmaps,
                    U = A.isVideoTexture !== !0,
                    Me = Fe.__version === void 0 || ie === !0,
                    oe = te.dataReady,
                    Ee = S(A, pe);
                if (A.isDepthTexture) He = b(A.format === 1027, A.type), Me && (U ? t.texStorage2D(r.TEXTURE_2D, 1, He, pe.width, pe.height) : t.texImage2D(r.TEXTURE_2D, 0, He, pe.width, pe.height, 0, Ae, Ve, null));
                else if (A.isDataTexture)
                    if (je.length > 0) {
                        U && Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, je[0].width, je[0].height);
                        for (let me = 0, ce = je.length; me < ce; me++) Se = je[me], U ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Ve, Se.data) : t.texImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Ae, Ve, Se.data);
                        A.generateMipmaps = !1
                    } else U ? (Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, pe.width, pe.height), oe && ee(A, pe, Ae, Ve)) : t.texImage2D(r.TEXTURE_2D, 0, He, pe.width, pe.height, 0, Ae, Ve, pe.data);
                else if (A.isCompressedTexture)
                    if (A.isCompressedArrayTexture) {
                        U && Me && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ee, He, je[0].width, je[0].height, pe.depth);
                        for (let me = 0, ce = je.length; me < ce; me++)
                            if (Se = je[me], A.format !== 1023)
                                if (Ae !== null)
                                    if (U) {
                                        if (oe)
                                            if (A.layerUpdates.size > 0) {
                                                const ae = L_(Se.width, Se.height, A.format, A.type);
                                                for (const N of A.layerUpdates) {
                                                    const re = Se.data.subarray(N * ae / Se.data.BYTES_PER_ELEMENT, (N + 1) * ae / Se.data.BYTES_PER_ELEMENT);
                                                    t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, N, Se.width, Se.height, 1, Ae, re)
                                                }
                                                A.clearLayerUpdates()
                                            } else t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, 0, Se.width, Se.height, pe.depth, Ae, Se.data)
                                    } else t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, me, He, Se.width, Se.height, pe.depth, 0, Se.data, 0, 0);
                        else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else U ? oe && t.texSubImage3D(r.TEXTURE_2D_ARRAY, me, 0, 0, 0, Se.width, Se.height, pe.depth, Ae, Ve, Se.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, me, He, Se.width, Se.height, pe.depth, 0, Ae, Ve, Se.data)
                    } else {
                        U && Me && t.texStorage2D(r.TEXTURE_2D, Ee, He, je[0].width, je[0].height);
                        for (let me = 0, ce = je.length; me < ce; me++) Se = je[me], A.format !== 1023 ? Ae !== null ? U ? oe && t.compressedTexSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Se.data) : t.compressedTexImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : U ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Se.width, Se.height, Ae, Ve, Se.data) : t.texImage2D(r.TEXTURE_2D, me, He, Se.width, Se.height, 0, Ae, Ve, Se.data)
                    }
                else if (A.isDataArrayTexture)
                    if (U) {
                        if (Me && t.texStorage3D(r.TEXTURE_2D_ARRAY, Ee, He, pe.width, pe.height, pe.depth), oe)
                            if (A.layerUpdates.size > 0) {
                                const me = L_(pe.width, pe.height, A.format, A.type);
                                for (const ce of A.layerUpdates) {
                                    const ae = pe.data.subarray(ce * me / pe.data.BYTES_PER_ELEMENT, (ce + 1) * me / pe.data.BYTES_PER_ELEMENT);
                                    t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, ce, pe.width, pe.height, 1, Ae, Ve, ae)
                                }
                                A.clearLayerUpdates()
                            } else t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Ae, Ve, pe.data)
                    } else t.texImage3D(r.TEXTURE_2D_ARRAY, 0, He, pe.width, pe.height, pe.depth, 0, Ae, Ve, pe.data);
                else if (A.isData3DTexture) U ? (Me && t.texStorage3D(r.TEXTURE_3D, Ee, He, pe.width, pe.height, pe.depth), oe && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Ae, Ve, pe.data)) : t.texImage3D(r.TEXTURE_3D, 0, He, pe.width, pe.height, pe.depth, 0, Ae, Ve, pe.data);
                else if (A.isFramebufferTexture) {
                    if (Me)
                        if (U) t.texStorage2D(r.TEXTURE_2D, Ee, He, pe.width, pe.height);
                        else {
                            let me = pe.width,
                                ce = pe.height;
                            for (let ae = 0; ae < Ee; ae++) t.texImage2D(r.TEXTURE_2D, ae, He, me, ce, 0, Ae, Ve, null), me >>= 1, ce >>= 1
                        }
                } else if (je.length > 0) {
                    if (U && Me) {
                        const me = st(je[0]);
                        t.texStorage2D(r.TEXTURE_2D, Ee, He, me.width, me.height)
                    }
                    for (let me = 0, ce = je.length; me < ce; me++) Se = je[me], U ? oe && t.texSubImage2D(r.TEXTURE_2D, me, 0, 0, Ae, Ve, Se) : t.texImage2D(r.TEXTURE_2D, me, He, Ae, Ve, Se);
                    A.generateMipmaps = !1
                } else if (U) {
                    if (Me) {
                        const me = st(pe);
                        t.texStorage2D(r.TEXTURE_2D, Ee, He, me.width, me.height)
                    }
                    oe && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ae, Ve, pe)
                } else t.texImage2D(r.TEXTURE_2D, 0, He, Ae, Ve, pe);
                m(A) && p(ne), Fe.__version = te.version, A.onUpdate && A.onUpdate(A)
            }
            I.__version = A.version
        }

        function fe(I, A, $) {
            if (A.image.length !== 6) return;
            const ne = ke(I, A),
                ie = A.source;
            t.bindTexture(r.TEXTURE_CUBE_MAP, I.__webglTexture, r.TEXTURE0 + $);
            const te = n.get(ie);
            if (ie.version !== te.__version || ne === !0) {
                t.activeTexture(r.TEXTURE0 + $);
                const Fe = bt.getPrimaries(bt.workingColorSpace),
                    ye = A.colorSpace === ss ? null : bt.getPrimaries(A.colorSpace),
                    Ue = A.colorSpace === ss || Fe === ye ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, A.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, A.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ue);
                const we = A.isCompressedTexture || A.image[0].isCompressedTexture,
                    pe = A.image[0] && A.image[0].isDataTexture,
                    Ae = [];
                for (let ce = 0; ce < 6; ce++) !we && !pe ? Ae[ce] = g(A.image[ce], !0, i.maxCubemapSize) : Ae[ce] = pe ? A.image[ce].image : A.image[ce], Ae[ce] = ge(A, Ae[ce]);
                const Ve = Ae[0],
                    He = s.convert(A.format, A.colorSpace),
                    Se = s.convert(A.type),
                    je = x(A.internalFormat, He, Se, A.colorSpace),
                    U = A.isVideoTexture !== !0,
                    Me = te.__version === void 0 || ne === !0,
                    oe = ie.dataReady;
                let Ee = S(A, Ve);
                de(r.TEXTURE_CUBE_MAP, A);
                let me;
                if (we) {
                    U && Me && t.texStorage2D(r.TEXTURE_CUBE_MAP, Ee, je, Ve.width, Ve.height);
                    for (let ce = 0; ce < 6; ce++) {
                        me = Ae[ce].mipmaps;
                        for (let ae = 0; ae < me.length; ae++) {
                            const N = me[ae];
                            A.format !== 1023 ? He !== null ? U ? oe && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae, 0, 0, N.width, N.height, He, N.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae, je, N.width, N.height, 0, N.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : U ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae, 0, 0, N.width, N.height, He, Se, N.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae, je, N.width, N.height, 0, He, Se, N.data)
                        }
                    }
                } else {
                    if (me = A.mipmaps, U && Me) {
                        me.length > 0 && Ee++;
                        const ce = st(Ae[0]);
                        t.texStorage2D(r.TEXTURE_CUBE_MAP, Ee, je, ce.width, ce.height)
                    }
                    for (let ce = 0; ce < 6; ce++)
                        if (pe) {
                            U ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, 0, 0, 0, Ae[ce].width, Ae[ce].height, He, Se, Ae[ce].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, 0, je, Ae[ce].width, Ae[ce].height, 0, He, Se, Ae[ce].data);
                            for (let ae = 0; ae < me.length; ae++) {
                                const re = me[ae].image[ce].image;
                                U ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae + 1, 0, 0, re.width, re.height, He, Se, re.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae + 1, je, re.width, re.height, 0, He, Se, re.data)
                            }
                        } else {
                            U ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, 0, 0, 0, He, Se, Ae[ce]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, 0, je, He, Se, Ae[ce]);
                            for (let ae = 0; ae < me.length; ae++) {
                                const N = me[ae];
                                U ? oe && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae + 1, 0, 0, He, Se, N.image[ce]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ce, ae + 1, je, He, Se, N.image[ce])
                            }
                        }
                }
                m(A) && p(r.TEXTURE_CUBE_MAP), te.__version = ie.version, A.onUpdate && A.onUpdate(A)
            }
            I.__version = A.version
        }

        function be(I, A, $, ne, ie, te) {
            const Fe = s.convert($.format, $.colorSpace),
                ye = s.convert($.type),
                Ue = x($.internalFormat, Fe, ye, $.colorSpace),
                we = n.get(A),
                pe = n.get($);
            if (pe.__renderTarget = A, !we.__hasExternalTextures) {
                const Ae = Math.max(1, A.width >> te),
                    Ve = Math.max(1, A.height >> te);
                ie === r.TEXTURE_3D || ie === r.TEXTURE_2D_ARRAY ? t.texImage3D(ie, te, Ue, Ae, Ve, A.depth, 0, Fe, ye, null) : t.texImage2D(ie, te, Ue, Ae, Ve, 0, Fe, ye, null)
            }
            t.bindFramebuffer(r.FRAMEBUFFER, I), et(A) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ne, ie, pe.__webglTexture, 0, ve(A)) : (ie === r.TEXTURE_2D || ie >= r.TEXTURE_CUBE_MAP_POSITIVE_X && ie <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ne, ie, pe.__webglTexture, te), t.bindFramebuffer(r.FRAMEBUFFER, null)
        }

        function Ye(I, A, $) {
            if (r.bindRenderbuffer(r.RENDERBUFFER, I), A.depthBuffer) {
                const ne = A.depthTexture,
                    ie = ne && ne.isDepthTexture ? ne.type : null,
                    te = b(A.stencilBuffer, ie),
                    Fe = A.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                    ye = ve(A);
                et(A) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ye, te, A.width, A.height) : $ ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ye, te, A.width, A.height) : r.renderbufferStorage(r.RENDERBUFFER, te, A.width, A.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Fe, r.RENDERBUFFER, I)
            } else {
                const ne = A.textures;
                for (let ie = 0; ie < ne.length; ie++) {
                    const te = ne[ie],
                        Fe = s.convert(te.format, te.colorSpace),
                        ye = s.convert(te.type),
                        Ue = x(te.internalFormat, Fe, ye, te.colorSpace),
                        we = ve(A);
                    $ && et(A) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, we, Ue, A.width, A.height) : et(A) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, we, Ue, A.width, A.height) : r.renderbufferStorage(r.RENDERBUFFER, Ue, A.width, A.height)
                }
            }
            r.bindRenderbuffer(r.RENDERBUFFER, null)
        }

        function Pe(I, A) {
            if (A && A.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(r.FRAMEBUFFER, I), !(A.depthTexture && A.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const ne = n.get(A.depthTexture);
            ne.__renderTarget = A, (!ne.__webglTexture || A.depthTexture.image.width !== A.width || A.depthTexture.image.height !== A.height) && (A.depthTexture.image.width = A.width, A.depthTexture.image.height = A.height, A.depthTexture.needsUpdate = !0), z(A.depthTexture, 0);
            const ie = ne.__webglTexture,
                te = ve(A);
            if (A.depthTexture.format === 1026) et(A) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ie, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ie, 0);
            else if (A.depthTexture.format === 1027) et(A) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ie, 0, te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ie, 0);
            else throw new Error("Unknown depthTexture format")
        }

        function Xe(I) {
            const A = n.get(I),
                $ = I.isWebGLCubeRenderTarget === !0;
            if (A.__boundDepthTexture !== I.depthTexture) {
                const ne = I.depthTexture;
                if (A.__depthDisposeCallback && A.__depthDisposeCallback(), ne) {
                    const ie = () => {
                        delete A.__boundDepthTexture, delete A.__depthDisposeCallback, ne.removeEventListener("dispose", ie)
                    };
                    ne.addEventListener("dispose", ie), A.__depthDisposeCallback = ie
                }
                A.__boundDepthTexture = ne
            }
            if (I.depthTexture && !A.__autoAllocateDepthBuffer) {
                if ($) throw new Error("target.depthTexture not supported in Cube render targets");
                const ne = I.texture.mipmaps;
                ne && ne.length > 0 ? Pe(A.__webglFramebuffer[0], I) : Pe(A.__webglFramebuffer, I)
            } else if ($) {
                A.__webglDepthbuffer = [];
                for (let ne = 0; ne < 6; ne++)
                    if (t.bindFramebuffer(r.FRAMEBUFFER, A.__webglFramebuffer[ne]), A.__webglDepthbuffer[ne] === void 0) A.__webglDepthbuffer[ne] = r.createRenderbuffer(), Ye(A.__webglDepthbuffer[ne], I, !1);
                    else {
                        const ie = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                            te = A.__webglDepthbuffer[ne];
                        r.bindRenderbuffer(r.RENDERBUFFER, te), r.framebufferRenderbuffer(r.FRAMEBUFFER, ie, r.RENDERBUFFER, te)
                    }
            } else {
                const ne = I.texture.mipmaps;
                if (ne && ne.length > 0 ? t.bindFramebuffer(r.FRAMEBUFFER, A.__webglFramebuffer[0]) : t.bindFramebuffer(r.FRAMEBUFFER, A.__webglFramebuffer), A.__webglDepthbuffer === void 0) A.__webglDepthbuffer = r.createRenderbuffer(), Ye(A.__webglDepthbuffer, I, !1);
                else {
                    const ie = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                        te = A.__webglDepthbuffer;
                    r.bindRenderbuffer(r.RENDERBUFFER, te), r.framebufferRenderbuffer(r.FRAMEBUFFER, ie, r.RENDERBUFFER, te)
                }
            }
            t.bindFramebuffer(r.FRAMEBUFFER, null)
        }

        function nt(I, A, $) {
            const ne = n.get(I);
            A !== void 0 && be(ne.__webglFramebuffer, I, I.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), $ !== void 0 && Xe(I)
        }

        function xe(I) {
            const A = I.texture,
                $ = n.get(I),
                ne = n.get(A);
            I.addEventListener("dispose", T);
            const ie = I.textures,
                te = I.isWebGLCubeRenderTarget === !0,
                Fe = ie.length > 1;
            if (Fe || (ne.__webglTexture === void 0 && (ne.__webglTexture = r.createTexture()), ne.__version = A.version, a.memory.textures++), te) {
                $.__webglFramebuffer = [];
                for (let ye = 0; ye < 6; ye++)
                    if (A.mipmaps && A.mipmaps.length > 0) {
                        $.__webglFramebuffer[ye] = [];
                        for (let Ue = 0; Ue < A.mipmaps.length; Ue++) $.__webglFramebuffer[ye][Ue] = r.createFramebuffer()
                    } else $.__webglFramebuffer[ye] = r.createFramebuffer()
            } else {
                if (A.mipmaps && A.mipmaps.length > 0) {
                    $.__webglFramebuffer = [];
                    for (let ye = 0; ye < A.mipmaps.length; ye++) $.__webglFramebuffer[ye] = r.createFramebuffer()
                } else $.__webglFramebuffer = r.createFramebuffer();
                if (Fe)
                    for (let ye = 0, Ue = ie.length; ye < Ue; ye++) {
                        const we = n.get(ie[ye]);
                        we.__webglTexture === void 0 && (we.__webglTexture = r.createTexture(), a.memory.textures++)
                    }
                if (I.samples > 0 && et(I) === !1) {
                    $.__webglMultisampledFramebuffer = r.createFramebuffer(), $.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
                    for (let ye = 0; ye < ie.length; ye++) {
                        const Ue = ie[ye];
                        $.__webglColorRenderbuffer[ye] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, $.__webglColorRenderbuffer[ye]);
                        const we = s.convert(Ue.format, Ue.colorSpace),
                            pe = s.convert(Ue.type),
                            Ae = x(Ue.internalFormat, we, pe, Ue.colorSpace, I.isXRRenderTarget === !0),
                            Ve = ve(I);
                        r.renderbufferStorageMultisample(r.RENDERBUFFER, Ve, Ae, I.width, I.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.RENDERBUFFER, $.__webglColorRenderbuffer[ye])
                    }
                    r.bindRenderbuffer(r.RENDERBUFFER, null), I.depthBuffer && ($.__webglDepthRenderbuffer = r.createRenderbuffer(), Ye($.__webglDepthRenderbuffer, I, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null)
                }
            }
            if (te) {
                t.bindTexture(r.TEXTURE_CUBE_MAP, ne.__webglTexture), de(r.TEXTURE_CUBE_MAP, A);
                for (let ye = 0; ye < 6; ye++)
                    if (A.mipmaps && A.mipmaps.length > 0)
                        for (let Ue = 0; Ue < A.mipmaps.length; Ue++) be($.__webglFramebuffer[ye][Ue], I, A, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ye, Ue);
                    else be($.__webglFramebuffer[ye], I, A, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0);
                m(A) && p(r.TEXTURE_CUBE_MAP), t.unbindTexture()
            } else if (Fe) {
                for (let ye = 0, Ue = ie.length; ye < Ue; ye++) {
                    const we = ie[ye],
                        pe = n.get(we);
                    t.bindTexture(r.TEXTURE_2D, pe.__webglTexture), de(r.TEXTURE_2D, we), be($.__webglFramebuffer, I, we, r.COLOR_ATTACHMENT0 + ye, r.TEXTURE_2D, 0), m(we) && p(r.TEXTURE_2D)
                }
                t.unbindTexture()
            } else {
                let ye = r.TEXTURE_2D;
                if ((I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) && (ye = I.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(ye, ne.__webglTexture), de(ye, A), A.mipmaps && A.mipmaps.length > 0)
                    for (let Ue = 0; Ue < A.mipmaps.length; Ue++) be($.__webglFramebuffer[Ue], I, A, r.COLOR_ATTACHMENT0, ye, Ue);
                else be($.__webglFramebuffer, I, A, r.COLOR_ATTACHMENT0, ye, 0);
                m(A) && p(ye), t.unbindTexture()
            }
            I.depthBuffer && Xe(I)
        }

        function F(I) {
            const A = I.textures;
            for (let $ = 0, ne = A.length; $ < ne; $++) {
                const ie = A[$];
                if (m(ie)) {
                    const te = v(I),
                        Fe = n.get(ie).__webglTexture;
                    t.bindTexture(te, Fe), p(te), t.unbindTexture()
                }
            }
        }
        const Ge = [],
            Je = [];

        function q(I) {
            if (I.samples > 0) {
                if (et(I) === !1) {
                    const A = I.textures,
                        $ = I.width,
                        ne = I.height;
                    let ie = r.COLOR_BUFFER_BIT;
                    const te = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                        Fe = n.get(I),
                        ye = A.length > 1;
                    if (ye)
                        for (let we = 0; we < A.length; we++) t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + we, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + we, r.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(r.READ_FRAMEBUFFER, Fe.__webglMultisampledFramebuffer);
                    const Ue = I.texture.mipmaps;
                    Ue && Ue.length > 0 ? t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglFramebuffer[0]) : t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglFramebuffer);
                    for (let we = 0; we < A.length; we++) {
                        if (I.resolveDepthBuffer && (I.depthBuffer && (ie |= r.DEPTH_BUFFER_BIT), I.stencilBuffer && I.resolveStencilBuffer && (ie |= r.STENCIL_BUFFER_BIT)), ye) {
                            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Fe.__webglColorRenderbuffer[we]);
                            const pe = n.get(A[we]).__webglTexture;
                            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, pe, 0)
                        }
                        r.blitFramebuffer(0, 0, $, ne, 0, 0, $, ne, ie, r.NEAREST), c === !0 && (Ge.length = 0, Je.length = 0, Ge.push(r.COLOR_ATTACHMENT0 + we), I.depthBuffer && I.resolveDepthBuffer === !1 && (Ge.push(te), Je.push(te), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Je)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Ge))
                    }
                    if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ye)
                        for (let we = 0; we < A.length; we++) {
                            t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + we, r.RENDERBUFFER, Fe.__webglColorRenderbuffer[we]);
                            const pe = n.get(A[we]).__webglTexture;
                            t.bindFramebuffer(r.FRAMEBUFFER, Fe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + we, r.TEXTURE_2D, pe, 0)
                        }
                    t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Fe.__webglMultisampledFramebuffer)
                } else if (I.depthBuffer && I.resolveDepthBuffer === !1 && c) {
                    const A = I.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [A])
                }
            }
        }

        function ve(I) {
            return Math.min(i.maxSamples, I.samples)
        }

        function et(I) {
            const A = n.get(I);
            return I.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && A.__useRenderToTexture !== !1
        }

        function Le(I) {
            const A = a.render.frame;
            f.get(I) !== A && (f.set(I, A), I.update())
        }

        function ge(I, A) {
            const $ = I.colorSpace,
                ne = I.format,
                ie = I.type;
            return I.isCompressedTexture === !0 || I.isVideoTexture === !0 || $ !== Dn && $ !== ss && (bt.getTransfer($) === Rt ? (ne !== 1023 || ie !== 1009) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $)), A
        }

        function st(I) {
            return typeof HTMLImageElement < "u" && I instanceof HTMLImageElement ? (l.width = I.naturalWidth || I.width, l.height = I.naturalHeight || I.height) : typeof VideoFrame < "u" && I instanceof VideoFrame ? (l.width = I.displayWidth, l.height = I.displayHeight) : (l.width = I.width, l.height = I.height), l
        }
        this.allocateTextureUnit = P, this.resetTextureUnits = R, this.setTexture2D = z, this.setTexture2DArray = k, this.setTexture3D = X, this.setTextureCube = V, this.rebindTextures = nt, this.setupRenderTarget = xe, this.updateRenderTargetMipmap = F, this.updateMultisampleRenderTarget = q, this.setupDepthRenderbuffer = Xe, this.setupFrameBufferTexture = be, this.useMultisampledRTT = et
    }

    function bA(r, e) {
        function t(n, i = ss) {
            let s;
            const a = bt.getTransfer(i);
            if (n === 1009) return r.UNSIGNED_BYTE;
            if (n === 1017) return r.UNSIGNED_SHORT_4_4_4_4;
            if (n === 1018) return r.UNSIGNED_SHORT_5_5_5_1;
            if (n === 35902) return r.UNSIGNED_INT_5_9_9_9_REV;
            if (n === 1010) return r.BYTE;
            if (n === 1011) return r.SHORT;
            if (n === 1012) return r.UNSIGNED_SHORT;
            if (n === 1013) return r.INT;
            if (n === 1014) return r.UNSIGNED_INT;
            if (n === 1015) return r.FLOAT;
            if (n === 1016) return r.HALF_FLOAT;
            if (n === 1021) return r.ALPHA;
            if (n === 1022) return r.RGB;
            if (n === 1023) return r.RGBA;
            if (n === 1026) return r.DEPTH_COMPONENT;
            if (n === 1027) return r.DEPTH_STENCIL;
            if (n === 1028) return r.RED;
            if (n === 1029) return r.RED_INTEGER;
            if (n === 1030) return r.RG;
            if (n === 1031) return r.RG_INTEGER;
            if (n === 1033) return r.RGBA_INTEGER;
            if (n === 33776 || n === 33777 || n === 33778 || n === 33779)
                if (a === Rt)
                    if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
                        if (n === 33776) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === 33777) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === 33778) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === 33779) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
                if (n === 33776) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === 33777) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === 33778) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === 33779) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else return null;
            if (n === 35840 || n === 35841 || n === 35842 || n === 35843)
                if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
                    if (n === 35840) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === 35841) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === 35842) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === 35843) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                } else return null;
            if (n === 36196 || n === 37492 || n === 37496)
                if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
                    if (n === 36196 || n === 37492) return a === Rt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                    if (n === 37496) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                } else return null;
            if (n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821)
                if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
                    if (n === 37808) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (n === 37809) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (n === 37810) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (n === 37811) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (n === 37812) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (n === 37813) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (n === 37814) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (n === 37815) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (n === 37816) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (n === 37817) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (n === 37818) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (n === 37819) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (n === 37820) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (n === 37821) return a === Rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                } else return null;
            if (n === 36492 || n === 36494 || n === 36495)
                if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
                    if (n === 36492) return a === Rt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                    if (n === 36494) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                    if (n === 36495) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                } else return null;
            if (n === 36283 || n === 36284 || n === 36285 || n === 36286)
                if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
                    if (n === 36492) return s.COMPRESSED_RED_RGTC1_EXT;
                    if (n === 36284) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (n === 36285) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (n === 36286) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                } else return null;
            return n === 1020 ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
        }
        return {
            convert: t
        }
    }
    const xA = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
        vA = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class yA {
        constructor() {
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
        }
        init(e, t, n) {
            if (this.texture === null) {
                const i = new on,
                    s = e.properties.get(i);
                s.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
            }
        }
        getMesh(e) {
            if (this.texture !== null && this.mesh === null) {
                const t = e.cameras[0].viewport,
                    n = new Nr({
                        vertexShader: xA,
                        fragmentShader: vA,
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                this.mesh = new bn(new Tc(20, 20), n)
            }
            return this.mesh
        }
        reset() {
            this.texture = null, this.mesh = null
        }
        getDepthTexture() {
            return this.texture
        }
    }
    class SA extends Oa {
        constructor(e, t) {
            super();
            const n = this;
            let i = null,
                s = 1,
                a = null,
                o = "local-floor",
                c = 1,
                l = null,
                f = null,
                h = null,
                d = null,
                u = null,
                _ = null;
            const g = new yA,
                m = t.getContextAttributes();
            let p = null,
                v = null;
            const x = [],
                b = [],
                S = new at;
            let E = null;
            const T = new Hn;
            T.viewport = new Tt;
            const w = new Hn;
            w.viewport = new Tt;
            const M = [T, w],
                y = new dM;
            let D = null,
                R = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Y) {
                let ee = x[Y];
                return ee === void 0 && (ee = new Hh, x[Y] = ee), ee.getTargetRaySpace()
            }, this.getControllerGrip = function(Y) {
                let ee = x[Y];
                return ee === void 0 && (ee = new Hh, x[Y] = ee), ee.getGripSpace()
            }, this.getHand = function(Y) {
                let ee = x[Y];
                return ee === void 0 && (ee = new Hh, x[Y] = ee), ee.getHandSpace()
            };

            function P(Y) {
                const ee = b.indexOf(Y.inputSource);
                if (ee === -1) return;
                const he = x[ee];
                he !== void 0 && (he.update(Y.inputSource, Y.frame, l || a), he.dispatchEvent({
                    type: Y.type,
                    data: Y.inputSource
                }))
            }

            function O() {
                i.removeEventListener("select", P), i.removeEventListener("selectstart", P), i.removeEventListener("selectend", P), i.removeEventListener("squeeze", P), i.removeEventListener("squeezestart", P), i.removeEventListener("squeezeend", P), i.removeEventListener("end", O), i.removeEventListener("inputsourceschange", z);
                for (let Y = 0; Y < x.length; Y++) {
                    const ee = b[Y];
                    ee !== null && (b[Y] = null, x[Y].disconnect(ee))
                }
                D = null, R = null, g.reset(), e.setRenderTarget(p), u = null, d = null, h = null, i = null, v = null, ke.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(S.width, S.height, !1), n.dispatchEvent({
                    type: "sessionend"
                })
            }
            this.setFramebufferScaleFactor = function(Y) {
                s = Y, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function(Y) {
                o = Y, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function() {
                return l || a
            }, this.setReferenceSpace = function(Y) {
                l = Y
            }, this.getBaseLayer = function() {
                return d !== null ? d : u
            }, this.getBinding = function() {
                return h
            }, this.getFrame = function() {
                return _
            }, this.getSession = function() {
                return i
            }, this.setSession = async function(Y) {
                if (i = Y, i !== null) {
                    if (p = e.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", O), i.addEventListener("inputsourceschange", z), m.xrCompatible !== !0 && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(S), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let he = null,
                            fe = null,
                            be = null;
                        m.depth && (be = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, he = m.stencil ? 1027 : 1026, fe = m.stencil ? 1020 : 1014);
                        const Ye = {
                            colorFormat: t.RGBA8,
                            depthFormat: be,
                            scaleFactor: s
                        };
                        h = new XRWebGLBinding(i, t), d = h.createProjectionLayer(Ye), i.updateRenderState({
                            layers: [d]
                        }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new Dr(d.textureWidth, d.textureHeight, {
                            format: 1023,
                            type: 1009,
                            depthTexture: new S_(d.textureWidth, d.textureHeight, fe, void 0, void 0, void 0, void 0, void 0, void 0, he),
                            stencilBuffer: m.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: m.antialias ? 4 : 0,
                            resolveDepthBuffer: d.ignoreDepthValues === !1,
                            resolveStencilBuffer: d.ignoreDepthValues === !1
                        })
                    } else {
                        const he = {
                            antialias: m.antialias,
                            alpha: !0,
                            depth: m.depth,
                            stencil: m.stencil,
                            framebufferScaleFactor: s
                        };
                        u = new XRWebGLLayer(i, t, he), i.updateRenderState({
                            baseLayer: u
                        }), e.setPixelRatio(1), e.setSize(u.framebufferWidth, u.framebufferHeight, !1), v = new Dr(u.framebufferWidth, u.framebufferHeight, {
                            format: 1023,
                            type: 1009,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: m.stencil,
                            resolveDepthBuffer: u.ignoreDepthValues === !1,
                            resolveStencilBuffer: u.ignoreDepthValues === !1
                        })
                    }
                    v.isXRRenderTarget = !0, this.setFoveation(c), l = null, a = await i.requestReferenceSpace(o), ke.setContext(i), ke.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }, this.getEnvironmentBlendMode = function() {
                if (i !== null) return i.environmentBlendMode
            }, this.getDepthTexture = function() {
                return g.getDepthTexture()
            };

            function z(Y) {
                for (let ee = 0; ee < Y.removed.length; ee++) {
                    const he = Y.removed[ee],
                        fe = b.indexOf(he);
                    fe >= 0 && (b[fe] = null, x[fe].disconnect(he))
                }
                for (let ee = 0; ee < Y.added.length; ee++) {
                    const he = Y.added[ee];
                    let fe = b.indexOf(he);
                    if (fe === -1) {
                        for (let Ye = 0; Ye < x.length; Ye++)
                            if (Ye >= b.length) {
                                b.push(he), fe = Ye;
                                break
                            } else if (b[Ye] === null) {
                            b[Ye] = he, fe = Ye;
                            break
                        }
                        if (fe === -1) break
                    }
                    const be = x[fe];
                    be && be.connect(he)
                }
            }
            const k = new B,
                X = new B;

            function V(Y, ee, he) {
                k.setFromMatrixPosition(ee.matrixWorld), X.setFromMatrixPosition(he.matrixWorld);
                const fe = k.distanceTo(X),
                    be = ee.projectionMatrix.elements,
                    Ye = he.projectionMatrix.elements,
                    Pe = be[14] / (be[10] - 1),
                    Xe = be[14] / (be[10] + 1),
                    nt = (be[9] + 1) / be[5],
                    xe = (be[9] - 1) / be[5],
                    F = (be[8] - 1) / be[0],
                    Ge = (Ye[8] + 1) / Ye[0],
                    Je = Pe * F,
                    q = Pe * Ge,
                    ve = fe / (-F + Ge),
                    et = ve * -F;
                if (ee.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale), Y.translateX(et), Y.translateZ(ve), Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldInverse.copy(Y.matrixWorld).invert(), be[10] === -1) Y.projectionMatrix.copy(ee.projectionMatrix), Y.projectionMatrixInverse.copy(ee.projectionMatrixInverse);
                else {
                    const Le = Pe + ve,
                        ge = Xe + ve,
                        st = Je - et,
                        I = q + (fe - et),
                        A = nt * Xe / ge * Le,
                        $ = xe * Xe / ge * Le;
                    Y.projectionMatrix.makePerspective(st, I, A, $, Le, ge), Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert()
                }
            }

            function H(Y, ee) {
                ee === null ? Y.matrixWorld.copy(Y.matrix) : Y.matrixWorld.multiplyMatrices(ee.matrixWorld, Y.matrix), Y.matrixWorldInverse.copy(Y.matrixWorld).invert()
            }
            this.updateCamera = function(Y) {
                if (i === null) return;
                let ee = Y.near,
                    he = Y.far;
                g.texture !== null && (g.depthNear > 0 && (ee = g.depthNear), g.depthFar > 0 && (he = g.depthFar)), y.near = w.near = T.near = ee, y.far = w.far = T.far = he, (D !== y.near || R !== y.far) && (i.updateRenderState({
                    depthNear: y.near,
                    depthFar: y.far
                }), D = y.near, R = y.far), T.layers.mask = Y.layers.mask | 2, w.layers.mask = Y.layers.mask | 4, y.layers.mask = T.layers.mask | w.layers.mask;
                const fe = Y.parent,
                    be = y.cameras;
                H(y, fe);
                for (let Ye = 0; Ye < be.length; Ye++) H(be[Ye], fe);
                be.length === 2 ? V(y, T, w) : y.projectionMatrix.copy(T.projectionMatrix), L(Y, y, fe)
            };

            function L(Y, ee, he) {
                he === null ? Y.matrix.copy(ee.matrixWorld) : (Y.matrix.copy(he.matrixWorld), Y.matrix.invert(), Y.matrix.multiply(ee.matrixWorld)), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.updateMatrixWorld(!0), Y.projectionMatrix.copy(ee.projectionMatrix), Y.projectionMatrixInverse.copy(ee.projectionMatrixInverse), Y.isPerspectiveCamera && (Y.fov = Ba * 2 * Math.atan(1 / Y.projectionMatrix.elements[5]), Y.zoom = 1)
            }
            this.getCamera = function() {
                return y
            }, this.getFoveation = function() {
                if (!(d === null && u === null)) return c
            }, this.setFoveation = function(Y) {
                c = Y, d !== null && (d.fixedFoveation = Y), u !== null && u.fixedFoveation !== void 0 && (u.fixedFoveation = Y)
            }, this.hasDepthSensing = function() {
                return g.texture !== null
            }, this.getDepthSensingMesh = function() {
                return g.getMesh(y)
            };
            let se = null;

            function de(Y, ee) {
                if (f = ee.getViewerPose(l || a), _ = ee, f !== null) {
                    const he = f.views;
                    u !== null && (e.setRenderTargetFramebuffer(v, u.framebuffer), e.setRenderTarget(v));
                    let fe = !1;
                    he.length !== y.cameras.length && (y.cameras.length = 0, fe = !0);
                    for (let Pe = 0; Pe < he.length; Pe++) {
                        const Xe = he[Pe];
                        let nt = null;
                        if (u !== null) nt = u.getViewport(Xe);
                        else {
                            const F = h.getViewSubImage(d, Xe);
                            nt = F.viewport, Pe === 0 && (e.setRenderTargetTextures(v, F.colorTexture, F.depthStencilTexture), e.setRenderTarget(v))
                        }
                        let xe = M[Pe];
                        xe === void 0 && (xe = new Hn, xe.layers.enable(Pe), xe.viewport = new Tt, M[Pe] = xe), xe.matrix.fromArray(Xe.transform.matrix), xe.matrix.decompose(xe.position, xe.quaternion, xe.scale), xe.projectionMatrix.fromArray(Xe.projectionMatrix), xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(), xe.viewport.set(nt.x, nt.y, nt.width, nt.height), Pe === 0 && (y.matrix.copy(xe.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), fe === !0 && y.cameras.push(xe)
                    }
                    const be = i.enabledFeatures;
                    if (be && be.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && h) {
                        const Pe = h.getDepthInformation(he[0]);
                        Pe && Pe.isValid && Pe.texture && g.init(e, Pe, i.renderState)
                    }
                }
                for (let he = 0; he < x.length; he++) {
                    const fe = b[he],
                        be = x[he];
                    fe !== null && be !== void 0 && be.update(fe, ee, l || a)
                }
                se && se(Y, ee), ee.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: ee
                }), _ = null
            }
            const ke = new N_;
            ke.setAnimationLoop(de), this.setAnimationLoop = function(Y) {
                se = Y
            }, this.dispose = function() {}
        }
    }
    const ta = new lr,
        MA = new Ke;

    function TA(r, e) {
        function t(m, p) {
            m.matrixAutoUpdate === !0 && m.updateMatrix(), p.value.copy(m.matrix)
        }

        function n(m, p) {
            p.color.getRGB(m.fogColor.value, Jg(r)), p.isFog ? (m.fogNear.value = p.near, m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density)
        }

        function i(m, p, v, x, b) {
            p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(m, p) : p.isMeshToonMaterial ? (s(m, p), h(m, p)) : p.isMeshPhongMaterial ? (s(m, p), f(m, p)) : p.isMeshStandardMaterial ? (s(m, p), d(m, p), p.isMeshPhysicalMaterial && u(m, p, b)) : p.isMeshMatcapMaterial ? (s(m, p), _(m, p)) : p.isMeshDepthMaterial ? s(m, p) : p.isMeshDistanceMaterial ? (s(m, p), g(m, p)) : p.isMeshNormalMaterial ? s(m, p) : p.isLineBasicMaterial ? (a(m, p), p.isLineDashedMaterial && o(m, p)) : p.isPointsMaterial ? c(m, p, v, x) : p.isSpriteMaterial ? l(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color), m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
        }

        function s(m, p) {
            m.opacity.value = p.opacity, p.color && m.diffuse.value.copy(p.color), p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.bumpMap && (m.bumpMap.value = p.bumpMap, t(p.bumpMap, m.bumpMapTransform), m.bumpScale.value = p.bumpScale, p.side === 1 && (m.bumpScale.value *= -1)), p.normalMap && (m.normalMap.value = p.normalMap, t(p.normalMap, m.normalMapTransform), m.normalScale.value.copy(p.normalScale), p.side === 1 && m.normalScale.value.negate()), p.displacementMap && (m.displacementMap.value = p.displacementMap, t(p.displacementMap, m.displacementMapTransform), m.displacementScale.value = p.displacementScale, m.displacementBias.value = p.displacementBias), p.emissiveMap && (m.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, m.emissiveMapTransform)), p.specularMap && (m.specularMap.value = p.specularMap, t(p.specularMap, m.specularMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
            const v = e.get(p),
                x = v.envMap,
                b = v.envMapRotation;
            x && (m.envMap.value = x, ta.copy(b), ta.x *= -1, ta.y *= -1, ta.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (ta.y *= -1, ta.z *= -1), m.envMapRotation.value.setFromMatrix4(MA.makeRotationFromEuler(ta)), m.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = p.reflectivity, m.ior.value = p.ior, m.refractionRatio.value = p.refractionRatio), p.lightMap && (m.lightMap.value = p.lightMap, m.lightMapIntensity.value = p.lightMapIntensity, t(p.lightMap, m.lightMapTransform)), p.aoMap && (m.aoMap.value = p.aoMap, m.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, m.aoMapTransform))
        }

        function a(m, p) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, p.map && (m.map.value = p.map, t(p.map, m.mapTransform))
        }

        function o(m, p) {
            m.dashSize.value = p.dashSize, m.totalSize.value = p.dashSize + p.gapSize, m.scale.value = p.scale
        }

        function c(m, p, v, x) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.size.value = p.size * v, m.scale.value = x * .5, p.map && (m.map.value = p.map, t(p.map, m.uvTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
        }

        function l(m, p) {
            m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.rotation.value = p.rotation, p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
        }

        function f(m, p) {
            m.specular.value.copy(p.specular), m.shininess.value = Math.max(p.shininess, 1e-4)
        }

        function h(m, p) {
            p.gradientMap && (m.gradientMap.value = p.gradientMap)
        }

        function d(m, p) {
            m.metalness.value = p.metalness, p.metalnessMap && (m.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, m.metalnessMapTransform)), m.roughness.value = p.roughness, p.roughnessMap && (m.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, m.roughnessMapTransform)), p.envMap && (m.envMapIntensity.value = p.envMapIntensity)
        }

        function u(m, p, v) {
            m.ior.value = p.ior, p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), m.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, m.sheenColorMapTransform)), p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))), p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat, m.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, m.clearcoatMapTransform)), p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === 1 && m.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (m.dispersion.value = p.dispersion), p.iridescence > 0 && (m.iridescence.value = p.iridescence, m.iridescenceIOR.value = p.iridescenceIOR, m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, m.iridescenceMapTransform)), p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), p.transmission > 0 && (m.transmission.value = p.transmission, m.transmissionSamplerMap.value = v.texture, m.transmissionSamplerSize.value.set(v.width, v.height), p.transmissionMap && (m.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, m.transmissionMapTransform)), m.thickness.value = p.thickness, p.thicknessMap && (m.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = p.attenuationDistance, m.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = p.specularIntensity, m.specularColor.value.copy(p.specularColor), p.specularColorMap && (m.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, m.specularColorMapTransform)), p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, m.specularIntensityMapTransform))
        }

        function _(m, p) {
            p.matcap && (m.matcap.value = p.matcap)
        }

        function g(m, p) {
            const v = e.get(p).light;
            m.referencePosition.value.setFromMatrixPosition(v.matrixWorld), m.nearDistance.value = v.shadow.camera.near, m.farDistance.value = v.shadow.camera.far
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: i
        }
    }

    function EA(r, e, t, n) {
        let i = {},
            s = {},
            a = [];
        const o = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);

        function c(v, x) {
            const b = x.program;
            n.uniformBlockBinding(v, b)
        }

        function l(v, x) {
            let b = i[v.id];
            b === void 0 && (_(v), b = f(v), i[v.id] = b, v.addEventListener("dispose", m));
            const S = x.program;
            n.updateUBOMapping(v, S);
            const E = e.render.frame;
            s[v.id] !== E && (d(v), s[v.id] = E)
        }

        function f(v) {
            const x = h();
            v.__bindingPointIndex = x;
            const b = r.createBuffer(),
                S = v.__size,
                E = v.usage;
            return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, S, E), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b
        }

        function h() {
            for (let v = 0; v < o; v++)
                if (a.indexOf(v) === -1) return a.push(v), v;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
        }

        function d(v) {
            const x = i[v.id],
                b = v.uniforms,
                S = v.__cache;
            r.bindBuffer(r.UNIFORM_BUFFER, x);
            for (let E = 0, T = b.length; E < T; E++) {
                const w = Array.isArray(b[E]) ? b[E] : [b[E]];
                for (let M = 0, y = w.length; M < y; M++) {
                    const D = w[M];
                    if (u(D, E, M, S) === !0) {
                        const R = D.__offset,
                            P = Array.isArray(D.value) ? D.value : [D.value];
                        let O = 0;
                        for (let z = 0; z < P.length; z++) {
                            const k = P[z],
                                X = g(k);
                            typeof k == "number" || typeof k == "boolean" ? (D.__data[0] = k, r.bufferSubData(r.UNIFORM_BUFFER, R + O, D.__data)) : k.isMatrix3 ? (D.__data[0] = k.elements[0], D.__data[1] = k.elements[1], D.__data[2] = k.elements[2], D.__data[3] = 0, D.__data[4] = k.elements[3], D.__data[5] = k.elements[4], D.__data[6] = k.elements[5], D.__data[7] = 0, D.__data[8] = k.elements[6], D.__data[9] = k.elements[7], D.__data[10] = k.elements[8], D.__data[11] = 0) : (k.toArray(D.__data, O), O += X.storage / Float32Array.BYTES_PER_ELEMENT)
                        }
                        r.bufferSubData(r.UNIFORM_BUFFER, R, D.__data)
                    }
                }
            }
            r.bindBuffer(r.UNIFORM_BUFFER, null)
        }

        function u(v, x, b, S) {
            const E = v.value,
                T = x + "_" + b;
            if (S[T] === void 0) return typeof E == "number" || typeof E == "boolean" ? S[T] = E : S[T] = E.clone(), !0; {
                const w = S[T];
                if (typeof E == "number" || typeof E == "boolean") {
                    if (w !== E) return S[T] = E, !0
                } else if (w.equals(E) === !1) return w.copy(E), !0
            }
            return !1
        }

        function _(v) {
            const x = v.uniforms;
            let b = 0;
            const S = 16;
            for (let T = 0, w = x.length; T < w; T++) {
                const M = Array.isArray(x[T]) ? x[T] : [x[T]];
                for (let y = 0, D = M.length; y < D; y++) {
                    const R = M[y],
                        P = Array.isArray(R.value) ? R.value : [R.value];
                    for (let O = 0, z = P.length; O < z; O++) {
                        const k = P[O],
                            X = g(k),
                            V = b % S,
                            H = V % X.boundary,
                            L = V + H;
                        b += H, L !== 0 && S - L < X.storage && (b += S - L), R.__data = new Float32Array(X.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = b, b += X.storage
                    }
                }
            }
            const E = b % S;
            return E > 0 && (b += S - E), v.__size = b, v.__cache = {}, this
        }

        function g(v) {
            const x = {
                boundary: 0,
                storage: 0
            };
            return typeof v == "number" || typeof v == "boolean" ? (x.boundary = 4, x.storage = 4) : v.isVector2 ? (x.boundary = 8, x.storage = 8) : v.isVector3 || v.isColor ? (x.boundary = 16, x.storage = 12) : v.isVector4 ? (x.boundary = 16, x.storage = 16) : v.isMatrix3 ? (x.boundary = 48, x.storage = 48) : v.isMatrix4 ? (x.boundary = 64, x.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), x
        }

        function m(v) {
            const x = v.target;
            x.removeEventListener("dispose", m);
            const b = a.indexOf(x.__bindingPointIndex);
            a.splice(b, 1), r.deleteBuffer(i[x.id]), delete i[x.id], delete s[x.id]
        }

        function p() {
            for (const v in i) r.deleteBuffer(i[v]);
            a = [], i = {}, s = {}
        }
        return {
            bind: c,
            update: l,
            dispose: p
        }
    }
    class wA {
        constructor(e = {}) {
            const {
                canvas: t = Zy(),
                context: n = null,
                depth: i = !0,
                stencil: s = !1,
                alpha: a = !1,
                antialias: o = !1,
                premultipliedAlpha: c = !0,
                preserveDrawingBuffer: l = !1,
                powerPreference: f = "default",
                failIfMajorPerformanceCaveat: h = !1,
                reverseDepthBuffer: d = !1
            } = e;
            this.isWebGLRenderer = !0;
            let u;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                u = n.getContextAttributes().alpha
            } else u = a;
            const _ = new Uint32Array(4),
                g = new Int32Array(4);
            let m = null,
                p = null;
            const v = [],
                x = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const b = this;
            let S = !1;
            this._outputColorSpace = Jt;
            let E = 0,
                T = 0,
                w = null,
                M = -1,
                y = null;
            const D = new Tt,
                R = new Tt;
            let P = null;
            const O = new rt(0);
            let z = 0,
                k = t.width,
                X = t.height,
                V = 1,
                H = null,
                L = null;
            const se = new Tt(0, 0, k, X),
                de = new Tt(0, 0, k, X);
            let ke = !1;
            const Y = new yc;
            let ee = !1,
                he = !1;
            const fe = new Ke,
                be = new Ke,
                Ye = new B,
                Pe = new Tt,
                Xe = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
            let nt = !1;

            function xe() {
                return w === null ? V : 1
            }
            let F = n;

            function Ge(C, j) {
                return t.getContext(C, j)
            }
            try {
                const C = {
                    alpha: !0,
                    depth: i,
                    stencil: s,
                    antialias: o,
                    premultipliedAlpha: c,
                    preserveDrawingBuffer: l,
                    powerPreference: f,
                    failIfMajorPerformanceCaveat: h
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Jl}`), t.addEventListener("webglcontextlost", Ee, !1), t.addEventListener("webglcontextrestored", me, !1), t.addEventListener("webglcontextcreationerror", ce, !1), F === null) {
                    const j = "webgl2";
                    if (F = Ge(j, C), F === null) throw Ge(j) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
            } catch (C) {
                throw console.error("THREE.WebGLRenderer: " + C.message), C
            }
            let Je, q, ve, et, Le, ge, st, I, A, $, ne, ie, te, Fe, ye, Ue, we, pe, Ae, Ve, He, Se, je, U;

            function Me() {
                Je = new UE(F), Je.init(), Se = new bA(F, Je), q = new CE(F, Je, e, Se), ve = new gA(F, Je), q.reverseDepthBuffer && d && ve.buffers.depth.setReversed(!0), et = new kE(F), Le = new iA, ge = new _A(F, Je, ve, Le, q, Se, et), st = new PE(b), I = new NE(b), A = new EM(F), je = new AE(F, A), $ = new OE(F, A, et, je), ne = new GE(F, $, A, et), Ae = new zE(F, q, ge), Ue = new RE(Le), ie = new nA(b, st, I, Je, q, je, Ue), te = new TA(b, Le), Fe = new sA, ye = new fA(Je), pe = new wE(b, st, I, ve, ne, u, c), we = new pA(b, ne, q), U = new EA(F, et, q, ve), Ve = new DE(F, Je, et), He = new BE(F, Je, et), et.programs = ie.programs, b.capabilities = q, b.extensions = Je, b.properties = Le, b.renderLists = Fe, b.shadowMap = we, b.state = ve, b.info = et
            }
            Me();
            const oe = new SA(b, F);
            this.xr = oe, this.getContext = function() {
                return F
            }, this.getContextAttributes = function() {
                return F.getContextAttributes()
            }, this.forceContextLoss = function() {
                const C = Je.get("WEBGL_lose_context");
                C && C.loseContext()
            }, this.forceContextRestore = function() {
                const C = Je.get("WEBGL_lose_context");
                C && C.restoreContext()
            }, this.getPixelRatio = function() {
                return V
            }, this.setPixelRatio = function(C) {
                C !== void 0 && (V = C, this.setSize(k, X, !1))
            }, this.getSize = function(C) {
                return C.set(k, X)
            }, this.setSize = function(C, j, Z = !0) {
                if (oe.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return
                }
                k = C, X = j, t.width = Math.floor(C * V), t.height = Math.floor(j * V), Z === !0 && (t.style.width = C + "px", t.style.height = j + "px"), this.setViewport(0, 0, C, j)
            }, this.getDrawingBufferSize = function(C) {
                return C.set(k * V, X * V).floor()
            }, this.setDrawingBufferSize = function(C, j, Z) {
                k = C, X = j, V = Z, t.width = Math.floor(C * Z), t.height = Math.floor(j * Z), this.setViewport(0, 0, C, j)
            }, this.getCurrentViewport = function(C) {
                return C.copy(D)
            }, this.getViewport = function(C) {
                return C.copy(se)
            }, this.setViewport = function(C, j, Z, K) {
                C.isVector4 ? se.set(C.x, C.y, C.z, C.w) : se.set(C, j, Z, K), ve.viewport(D.copy(se).multiplyScalar(V).round())
            }, this.getScissor = function(C) {
                return C.copy(de)
            }, this.setScissor = function(C, j, Z, K) {
                C.isVector4 ? de.set(C.x, C.y, C.z, C.w) : de.set(C, j, Z, K), ve.scissor(R.copy(de).multiplyScalar(V).round())
            }, this.getScissorTest = function() {
                return ke
            }, this.setScissorTest = function(C) {
                ve.setScissorTest(ke = C)
            }, this.setOpaqueSort = function(C) {
                H = C
            }, this.setTransparentSort = function(C) {
                L = C
            }, this.getClearColor = function(C) {
                return C.copy(pe.getClearColor())
            }, this.setClearColor = function() {
                pe.setClearColor(...arguments)
            }, this.getClearAlpha = function() {
                return pe.getClearAlpha()
            }, this.setClearAlpha = function() {
                pe.setClearAlpha(...arguments)
            }, this.clear = function(C = !0, j = !0, Z = !0) {
                let K = 0;
                if (C) {
                    let W = !1;
                    if (w !== null) {
                        const _e = w.texture.format;
                        W = _e === 1033 || _e === 1031 || _e === 1029
                    }
                    if (W) {
                        const _e = w.texture.type,
                            Ce = _e === 1009 || _e === 1014 || _e === 1012 || _e === 1020 || _e === 1017 || _e === 1018,
                            ze = pe.getClearColor(),
                            Ie = pe.getClearAlpha(),
                            qe = ze.r,
                            Ze = ze.g,
                            We = ze.b;
                        Ce ? (_[0] = qe, _[1] = Ze, _[2] = We, _[3] = Ie, F.clearBufferuiv(F.COLOR, 0, _)) : (g[0] = qe, g[1] = Ze, g[2] = We, g[3] = Ie, F.clearBufferiv(F.COLOR, 0, g))
                    } else K |= F.COLOR_BUFFER_BIT
                }
                j && (K |= F.DEPTH_BUFFER_BIT), Z && (K |= F.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), F.clear(K)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", Ee, !1), t.removeEventListener("webglcontextrestored", me, !1), t.removeEventListener("webglcontextcreationerror", ce, !1), pe.dispose(), Fe.dispose(), ye.dispose(), Le.dispose(), st.dispose(), I.dispose(), ne.dispose(), je.dispose(), U.dispose(), ie.dispose(), oe.dispose(), oe.removeEventListener("sessionstart", Q), oe.removeEventListener("sessionend", Te), ue.stop()
            };

            function Ee(C) {
                C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0
            }

            function me() {
                console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
                const C = et.autoReset,
                    j = we.enabled,
                    Z = we.autoUpdate,
                    K = we.needsUpdate,
                    W = we.type;
                Me(), et.autoReset = C, we.enabled = j, we.autoUpdate = Z, we.needsUpdate = K, we.type = W
            }

            function ce(C) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage)
            }

            function ae(C) {
                const j = C.target;
                j.removeEventListener("dispose", ae), N(j)
            }

            function N(C) {
                re(C), Le.remove(C)
            }

            function re(C) {
                const j = Le.get(C).programs;
                j !== void 0 && (j.forEach(function(Z) {
                    ie.releaseProgram(Z)
                }), C.isShaderMaterial && ie.releaseShaderCache(C))
            }
            this.renderBufferDirect = function(C, j, Z, K, W, _e) {
                j === null && (j = Xe);
                const Ce = W.isMesh && W.matrixWorld.determinant() < 0,
                    ze = Et(C, j, Z, K, W);
                ve.setMaterial(K, Ce);
                let Ie = Z.index,
                    qe = 1;
                if (K.wireframe === !0) {
                    if (Ie = $.getWireframeAttribute(Z), Ie === void 0) return;
                    qe = 2
                }
                const Ze = Z.drawRange,
                    We = Z.attributes.position;
                let lt = Ze.start * qe,
                    Ct = (Ze.start + Ze.count) * qe;
                _e !== null && (lt = Math.max(lt, _e.start * qe), Ct = Math.min(Ct, (_e.start + _e.count) * qe)), Ie !== null ? (lt = Math.max(lt, 0), Ct = Math.min(Ct, Ie.count)) : We != null && (lt = Math.max(lt, 0), Ct = Math.min(Ct, We.count));
                const qt = Ct - lt;
                if (qt < 0 || qt === 1 / 0) return;
                je.setup(W, K, ze, Z, Ie);
                let Kt, Mt = Ve;
                if (Ie !== null && (Kt = A.get(Ie), Mt = He, Mt.setIndex(Kt)), W.isMesh) K.wireframe === !0 ? (ve.setLineWidth(K.wireframeLinewidth * xe()), Mt.setMode(F.LINES)) : Mt.setMode(F.TRIANGLES);
                else if (W.isLine) {
                    let Qe = K.linewidth;
                    Qe === void 0 && (Qe = 1), ve.setLineWidth(Qe * xe()), W.isLineSegments ? Mt.setMode(F.LINES) : W.isLineLoop ? Mt.setMode(F.LINE_LOOP) : Mt.setMode(F.LINE_STRIP)
                } else W.isPoints ? Mt.setMode(F.POINTS) : W.isSprite && Mt.setMode(F.TRIANGLES);
                if (W.isBatchedMesh)
                    if (W._multiDrawInstances !== null) ka("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Mt.renderMultiDrawInstances(W._multiDrawStarts, W._multiDrawCounts, W._multiDrawCount, W._multiDrawInstances);
                    else if (Je.get("WEBGL_multi_draw")) Mt.renderMultiDraw(W._multiDrawStarts, W._multiDrawCounts, W._multiDrawCount);
                else {
                    const Qe = W._multiDrawStarts,
                        An = W._multiDrawCounts,
                        wt = W._multiDrawCount,
                        cr = Ie ? A.get(Ie).bytesPerElement : 1,
                        lc = Le.get(K).currentProgram.getUniforms();
                    for (let Ti = 0; Ti < wt; Ti++) lc.setValue(F, "_gl_DrawID", Ti), Mt.render(Qe[Ti] / cr, An[Ti])
                } else if (W.isInstancedMesh) Mt.renderInstances(lt, qt, W.count);
                else if (Z.isInstancedBufferGeometry) {
                    const Qe = Z._maxInstanceCount !== void 0 ? Z._maxInstanceCount : 1 / 0,
                        An = Math.min(Z.instanceCount, Qe);
                    Mt.renderInstances(lt, qt, An)
                } else Mt.render(lt, qt)
            };

            function G(C, j, Z) {
                C.transparent === !0 && C.side === 2 && C.forceSinglePass === !1 ? (C.side = 1, C.needsUpdate = !0, _t(C, j, Z), C.side = 0, C.needsUpdate = !0, _t(C, j, Z), C.side = 2) : _t(C, j, Z)
            }
            this.compile = function(C, j, Z = null) {
                Z === null && (Z = C), p = ye.get(Z), p.init(j), x.push(p), Z.traverseVisible(function(W) {
                    W.isLight && W.layers.test(j.layers) && (p.pushLight(W), W.castShadow && p.pushShadow(W))
                }), C !== Z && C.traverseVisible(function(W) {
                    W.isLight && W.layers.test(j.layers) && (p.pushLight(W), W.castShadow && p.pushShadow(W))
                }), p.setupLights();
                const K = new Set;
                return C.traverse(function(W) {
                    if (!(W.isMesh || W.isPoints || W.isLine || W.isSprite)) return;
                    const _e = W.material;
                    if (_e)
                        if (Array.isArray(_e))
                            for (let Ce = 0; Ce < _e.length; Ce++) {
                                const ze = _e[Ce];
                                G(ze, Z, W), K.add(ze)
                            } else G(_e, Z, W), K.add(_e)
                }), p = x.pop(), K
            }, this.compileAsync = function(C, j, Z = null) {
                const K = this.compile(C, j, Z);
                return new Promise(W => {
                    function _e() {
                        if (K.forEach(function(Ce) {
                                Le.get(Ce).currentProgram.isReady() && K.delete(Ce)
                            }), K.size === 0) {
                            W(C);
                            return
                        }
                        setTimeout(_e, 10)
                    }
                    Je.get("KHR_parallel_shader_compile") !== null ? _e() : setTimeout(_e, 10)
                })
            };
            let J = null;

            function le(C) {
                J && J(C)
            }

            function Q() {
                ue.stop()
            }

            function Te() {
                ue.start()
            }
            const ue = new N_;
            ue.setAnimationLoop(le), typeof self < "u" && ue.setContext(self), this.setAnimationLoop = function(C) {
                J = C, oe.setAnimationLoop(C), C === null ? ue.stop() : ue.start()
            }, oe.addEventListener("sessionstart", Q), oe.addEventListener("sessionend", Te), this.render = function(C, j) {
                if (j !== void 0 && j.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return
                }
                if (S === !0) return;
                if (C.matrixWorldAutoUpdate === !0 && C.updateMatrixWorld(), j.parent === null && j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(), oe.enabled === !0 && oe.isPresenting === !0 && (oe.cameraAutoUpdate === !0 && oe.updateCamera(j), j = oe.getCamera()), C.isScene === !0 && C.onBeforeRender(b, C, j, w), p = ye.get(C, x.length), p.init(j), x.push(p), be.multiplyMatrices(j.projectionMatrix, j.matrixWorldInverse), Y.setFromProjectionMatrix(be), he = this.localClippingEnabled, ee = Ue.init(this.clippingPlanes, he), m = Fe.get(C, v.length), m.init(), v.push(m), oe.enabled === !0 && oe.isPresenting === !0) {
                    const _e = b.xr.getDepthSensingMesh();
                    _e !== null && De(_e, j, -1 / 0, b.sortObjects)
                }
                De(C, j, 0, b.sortObjects), m.finish(), b.sortObjects === !0 && m.sort(H, L), nt = oe.enabled === !1 || oe.isPresenting === !1 || oe.hasDepthSensing() === !1, nt && pe.addToRenderList(m, C), this.info.render.frame++, ee === !0 && Ue.beginShadows();
                const Z = p.state.shadowsArray;
                we.render(Z, C, j), ee === !0 && Ue.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const K = m.opaque,
                    W = m.transmissive;
                if (p.setupLights(), j.isArrayCamera) {
                    const _e = j.cameras;
                    if (W.length > 0)
                        for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) {
                            const Ie = _e[Ce];
                            Oe(K, W, C, Ie)
                        }
                    nt && pe.render(C);
                    for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) {
                        const Ie = _e[Ce];
                        $e(m, C, Ie, Ie.viewport)
                    }
                } else W.length > 0 && Oe(K, W, C, j), nt && pe.render(C), $e(m, C, j);
                w !== null && T === 0 && (ge.updateMultisampleRenderTarget(w), ge.updateRenderTargetMipmap(w)), C.isScene === !0 && C.onAfterRender(b, C, j), je.resetDefaultState(), M = -1, y = null, x.pop(), x.length > 0 ? (p = x[x.length - 1], ee === !0 && Ue.setGlobalState(b.clippingPlanes, p.state.camera)) : p = null, v.pop(), v.length > 0 ? m = v[v.length - 1] : m = null
            };

            function De(C, j, Z, K) {
                if (C.visible === !1) return;
                if (C.layers.test(j.layers)) {
                    if (C.isGroup) Z = C.renderOrder;
                    else if (C.isLOD) C.autoUpdate === !0 && C.update(j);
                    else if (C.isLight) p.pushLight(C), C.castShadow && p.pushShadow(C);
                    else if (C.isSprite) {
                        if (!C.frustumCulled || Y.intersectsSprite(C)) {
                            K && Pe.setFromMatrixPosition(C.matrixWorld).applyMatrix4(be);
                            const Ce = ne.update(C),
                                ze = C.material;
                            ze.visible && m.push(C, Ce, ze, Z, Pe.z, null)
                        }
                    } else if ((C.isMesh || C.isLine || C.isPoints) && (!C.frustumCulled || Y.intersectsObject(C))) {
                        const Ce = ne.update(C),
                            ze = C.material;
                        if (K && (C.boundingSphere !== void 0 ? (C.boundingSphere === null && C.computeBoundingSphere(), Pe.copy(C.boundingSphere.center)) : (Ce.boundingSphere === null && Ce.computeBoundingSphere(), Pe.copy(Ce.boundingSphere.center)), Pe.applyMatrix4(C.matrixWorld).applyMatrix4(be)), Array.isArray(ze)) {
                            const Ie = Ce.groups;
                            for (let qe = 0, Ze = Ie.length; qe < Ze; qe++) {
                                const We = Ie[qe],
                                    lt = ze[We.materialIndex];
                                lt && lt.visible && m.push(C, Ce, lt, Z, Pe.z, We)
                            }
                        } else ze.visible && m.push(C, Ce, ze, Z, Pe.z, null)
                    }
                }
                const _e = C.children;
                for (let Ce = 0, ze = _e.length; Ce < ze; Ce++) De(_e[Ce], j, Z, K)
            }

            function $e(C, j, Z, K) {
                const W = C.opaque,
                    _e = C.transmissive,
                    Ce = C.transparent;
                p.setupLightsView(Z), ee === !0 && Ue.setGlobalState(b.clippingPlanes, Z), K && ve.viewport(D.copy(K)), W.length > 0 && tt(W, j, Z), _e.length > 0 && tt(_e, j, Z), Ce.length > 0 && tt(Ce, j, Z), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1)
            }

            function Oe(C, j, Z, K) {
                if ((Z.isScene === !0 ? Z.overrideMaterial : null) !== null) return;
                p.state.transmissionRenderTarget[K.id] === void 0 && (p.state.transmissionRenderTarget[K.id] = new Dr(1, 1, {
                    generateMipmaps: !0,
                    type: Je.has("EXT_color_buffer_half_float") || Je.has("EXT_color_buffer_float") ? 1016 : 1009,
                    minFilter: 1008,
                    samples: 4,
                    stencilBuffer: s,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: bt.workingColorSpace
                }));
                const _e = p.state.transmissionRenderTarget[K.id],
                    Ce = K.viewport || D;
                _e.setSize(Ce.z * b.transmissionResolutionScale, Ce.w * b.transmissionResolutionScale);
                const ze = b.getRenderTarget();
                b.setRenderTarget(_e), b.getClearColor(O), z = b.getClearAlpha(), z < 1 && b.setClearColor(16777215, .5), b.clear(), nt && pe.render(Z);
                const Ie = b.toneMapping;
                b.toneMapping = 0;
                const qe = K.viewport;
                if (K.viewport !== void 0 && (K.viewport = void 0), p.setupLightsView(K), ee === !0 && Ue.setGlobalState(b.clippingPlanes, K), tt(C, Z, K), ge.updateMultisampleRenderTarget(_e), ge.updateRenderTargetMipmap(_e), Je.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let Ze = !1;
                    for (let We = 0, lt = j.length; We < lt; We++) {
                        const Ct = j[We],
                            qt = Ct.object,
                            Kt = Ct.geometry,
                            Mt = Ct.material,
                            Qe = Ct.group;
                        if (Mt.side === 2 && qt.layers.test(K.layers)) {
                            const An = Mt.side;
                            Mt.side = 1, Mt.needsUpdate = !0, xt(qt, Z, K, Kt, Mt, Qe), Mt.side = An, Mt.needsUpdate = !0, Ze = !0
                        }
                    }
                    Ze === !0 && (ge.updateMultisampleRenderTarget(_e), ge.updateRenderTargetMipmap(_e))
                }
                b.setRenderTarget(ze), b.setClearColor(O, z), qe !== void 0 && (K.viewport = qe), b.toneMapping = Ie
            }

            function tt(C, j, Z) {
                const K = j.isScene === !0 ? j.overrideMaterial : null;
                for (let W = 0, _e = C.length; W < _e; W++) {
                    const Ce = C[W],
                        ze = Ce.object,
                        Ie = Ce.geometry,
                        qe = Ce.group;
                    let Ze = Ce.material;
                    Ze.allowOverride === !0 && K !== null && (Ze = K), ze.layers.test(Z.layers) && xt(ze, j, Z, Ie, Ze, qe)
                }
            }

            function xt(C, j, Z, K, W, _e) {
                C.onBeforeRender(b, j, Z, K, W, _e), C.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), W.onBeforeRender(b, j, Z, K, C, _e), W.transparent === !0 && W.side === 2 && W.forceSinglePass === !1 ? (W.side = 1, W.needsUpdate = !0, b.renderBufferDirect(Z, j, K, W, C, _e), W.side = 0, W.needsUpdate = !0, b.renderBufferDirect(Z, j, K, W, C, _e), W.side = 2) : b.renderBufferDirect(Z, j, K, W, C, _e), C.onAfterRender(b, j, Z, K, W, _e)
            }

            function _t(C, j, Z) {
                j.isScene !== !0 && (j = Xe);
                const K = Le.get(C),
                    W = p.state.lights,
                    _e = p.state.shadowsArray,
                    Ce = W.state.version,
                    ze = ie.getParameters(C, W.state, _e, j, Z),
                    Ie = ie.getProgramCacheKey(ze);
                let qe = K.programs;
                K.environment = C.isMeshStandardMaterial ? j.environment : null, K.fog = j.fog, K.envMap = (C.isMeshStandardMaterial ? I : st).get(C.envMap || K.environment), K.envMapRotation = K.environment !== null && C.envMap === null ? j.environmentRotation : C.envMapRotation, qe === void 0 && (C.addEventListener("dispose", ae), qe = new Map, K.programs = qe);
                let Ze = qe.get(Ie);
                if (Ze !== void 0) {
                    if (K.currentProgram === Ze && K.lightsStateVersion === Ce) return ft(C, ze), Ze
                } else ze.uniforms = ie.getUniforms(C), C.onBeforeCompile(ze, b), Ze = ie.acquireProgram(ze, Ie), qe.set(Ie, Ze), K.uniforms = ze.uniforms;
                const We = K.uniforms;
                return (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === !0) && (We.clippingPlanes = Ue.uniform), ft(C, ze), K.needsLights = pn(C), K.lightsStateVersion = Ce, K.needsLights && (We.ambientLightColor.value = W.state.ambient, We.lightProbe.value = W.state.probe, We.directionalLights.value = W.state.directional, We.directionalLightShadows.value = W.state.directionalShadow, We.spotLights.value = W.state.spot, We.spotLightShadows.value = W.state.spotShadow, We.rectAreaLights.value = W.state.rectArea, We.ltc_1.value = W.state.rectAreaLTC1, We.ltc_2.value = W.state.rectAreaLTC2, We.pointLights.value = W.state.point, We.pointLightShadows.value = W.state.pointShadow, We.hemisphereLights.value = W.state.hemi, We.directionalShadowMap.value = W.state.directionalShadowMap, We.directionalShadowMatrix.value = W.state.directionalShadowMatrix, We.spotShadowMap.value = W.state.spotShadowMap, We.spotLightMatrix.value = W.state.spotLightMatrix, We.spotLightMap.value = W.state.spotLightMap, We.pointShadowMap.value = W.state.pointShadowMap, We.pointShadowMatrix.value = W.state.pointShadowMatrix), K.currentProgram = Ze, K.uniformsList = null, Ze
            }

            function ut(C) {
                if (C.uniformsList === null) {
                    const j = C.currentProgram.getUniforms();
                    C.uniformsList = Iu.seqWithValue(j.seq, C.uniforms)
                }
                return C.uniformsList
            }

            function ft(C, j) {
                const Z = Le.get(C);
                Z.outputColorSpace = j.outputColorSpace, Z.batching = j.batching, Z.batchingColor = j.batchingColor, Z.instancing = j.instancing, Z.instancingColor = j.instancingColor, Z.instancingMorph = j.instancingMorph, Z.skinning = j.skinning, Z.morphTargets = j.morphTargets, Z.morphNormals = j.morphNormals, Z.morphColors = j.morphColors, Z.morphTargetsCount = j.morphTargetsCount, Z.numClippingPlanes = j.numClippingPlanes, Z.numIntersection = j.numClipIntersection, Z.vertexAlphas = j.vertexAlphas, Z.vertexTangents = j.vertexTangents, Z.toneMapping = j.toneMapping
            }

            function Et(C, j, Z, K, W) {
                j.isScene !== !0 && (j = Xe), ge.resetTextureUnits();
                const _e = j.fog,
                    Ce = K.isMeshStandardMaterial ? j.environment : null,
                    ze = w === null ? b.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : Dn,
                    Ie = (K.isMeshStandardMaterial ? I : st).get(K.envMap || Ce),
                    qe = K.vertexColors === !0 && !!Z.attributes.color && Z.attributes.color.itemSize === 4,
                    Ze = !!Z.attributes.tangent && (!!K.normalMap || K.anisotropy > 0),
                    We = !!Z.morphAttributes.position,
                    lt = !!Z.morphAttributes.normal,
                    Ct = !!Z.morphAttributes.color;
                let qt = 0;
                K.toneMapped && (w === null || w.isXRRenderTarget === !0) && (qt = b.toneMapping);
                const Kt = Z.morphAttributes.position || Z.morphAttributes.normal || Z.morphAttributes.color,
                    Mt = Kt !== void 0 ? Kt.length : 0,
                    Qe = Le.get(K),
                    An = p.state.lights;
                if (ee === !0 && (he === !0 || C !== y)) {
                    const ei = C === y && K.id === M;
                    Ue.setState(K, C, ei)
                }
                let wt = !1;
                K.version === Qe.__version ? (Qe.needsLights && Qe.lightsStateVersion !== An.state.version || Qe.outputColorSpace !== ze || W.isBatchedMesh && Qe.batching === !1 || !W.isBatchedMesh && Qe.batching === !0 || W.isBatchedMesh && Qe.batchingColor === !0 && W.colorTexture === null || W.isBatchedMesh && Qe.batchingColor === !1 && W.colorTexture !== null || W.isInstancedMesh && Qe.instancing === !1 || !W.isInstancedMesh && Qe.instancing === !0 || W.isSkinnedMesh && Qe.skinning === !1 || !W.isSkinnedMesh && Qe.skinning === !0 || W.isInstancedMesh && Qe.instancingColor === !0 && W.instanceColor === null || W.isInstancedMesh && Qe.instancingColor === !1 && W.instanceColor !== null || W.isInstancedMesh && Qe.instancingMorph === !0 && W.morphTexture === null || W.isInstancedMesh && Qe.instancingMorph === !1 && W.morphTexture !== null || Qe.envMap !== Ie || K.fog === !0 && Qe.fog !== _e || Qe.numClippingPlanes !== void 0 && (Qe.numClippingPlanes !== Ue.numPlanes || Qe.numIntersection !== Ue.numIntersection) || Qe.vertexAlphas !== qe || Qe.vertexTangents !== Ze || Qe.morphTargets !== We || Qe.morphNormals !== lt || Qe.morphColors !== Ct || Qe.toneMapping !== qt || Qe.morphTargetsCount !== Mt) && (wt = !0) : (wt = !0, Qe.__version = K.version);
                let cr = Qe.currentProgram;
                wt === !0 && (cr = _t(K, j, W));
                let lc = !1,
                    Ti = !1,
                    Kl = !1;
                const zt = cr.getUniforms(),
                    Hi = Qe.uniforms;
                if (ve.useProgram(cr.program) && (lc = !0, Ti = !0, Kl = !0), K.id !== M && (M = K.id, Ti = !0), lc || y !== C) {
                    ve.buffers.depth.getReversed() ? (fe.copy(C.projectionMatrix), eS(fe), tS(fe), zt.setValue(F, "projectionMatrix", fe)) : zt.setValue(F, "projectionMatrix", C.projectionMatrix), zt.setValue(F, "viewMatrix", C.matrixWorldInverse);
                    const fi = zt.map.cameraPosition;
                    fi !== void 0 && fi.setValue(F, Ye.setFromMatrixPosition(C.matrixWorld)), q.logarithmicDepthBuffer && zt.setValue(F, "logDepthBufFC", 2 / (Math.log(C.far + 1) / Math.LN2)), (K.isMeshPhongMaterial || K.isMeshToonMaterial || K.isMeshLambertMaterial || K.isMeshBasicMaterial || K.isMeshStandardMaterial || K.isShaderMaterial) && zt.setValue(F, "isOrthographic", C.isOrthographicCamera === !0), y !== C && (y = C, Ti = !0, Kl = !0)
                }
                if (W.isSkinnedMesh) {
                    zt.setOptional(F, W, "bindMatrix"), zt.setOptional(F, W, "bindMatrixInverse");
                    const ei = W.skeleton;
                    ei && (ei.boneTexture === null && ei.computeBoneTexture(), zt.setValue(F, "boneTexture", ei.boneTexture, ge))
                }
                W.isBatchedMesh && (zt.setOptional(F, W, "batchingTexture"), zt.setValue(F, "batchingTexture", W._matricesTexture, ge), zt.setOptional(F, W, "batchingIdTexture"), zt.setValue(F, "batchingIdTexture", W._indirectTexture, ge), zt.setOptional(F, W, "batchingColorTexture"), W._colorsTexture !== null && zt.setValue(F, "batchingColorTexture", W._colorsTexture, ge));
                const Vi = Z.morphAttributes;
                if ((Vi.position !== void 0 || Vi.normal !== void 0 || Vi.color !== void 0) && Ae.update(W, Z, cr), (Ti || Qe.receiveShadow !== W.receiveShadow) && (Qe.receiveShadow = W.receiveShadow, zt.setValue(F, "receiveShadow", W.receiveShadow)), K.isMeshGouraudMaterial && K.envMap !== null && (Hi.envMap.value = Ie, Hi.flipEnvMap.value = Ie.isCubeTexture && Ie.isRenderTargetTexture === !1 ? -1 : 1), K.isMeshStandardMaterial && K.envMap === null && j.environment !== null && (Hi.envMapIntensity.value = j.environmentIntensity), Ti && (zt.setValue(F, "toneMappingExposure", b.toneMappingExposure), Qe.needsLights && it(Hi, Kl), _e && K.fog === !0 && te.refreshFogUniforms(Hi, _e), te.refreshMaterialUniforms(Hi, K, V, X, p.state.transmissionRenderTarget[C.id]), Iu.upload(F, ut(Qe), Hi, ge)), K.isShaderMaterial && K.uniformsNeedUpdate === !0 && (Iu.upload(F, ut(Qe), Hi, ge), K.uniformsNeedUpdate = !1), K.isSpriteMaterial && zt.setValue(F, "center", W.center), zt.setValue(F, "modelViewMatrix", W.modelViewMatrix), zt.setValue(F, "normalMatrix", W.normalMatrix), zt.setValue(F, "modelMatrix", W.matrixWorld), K.isShaderMaterial || K.isRawShaderMaterial) {
                    const ei = K.uniformsGroups;
                    for (let fi = 0, Ag = ei.length; fi < Ag; fi++) {
                        const Ua = ei[fi];
                        U.update(Ua, cr), U.bind(Ua, cr)
                    }
                }
                return cr
            }

            function it(C, j) {
                C.ambientLightColor.needsUpdate = j, C.lightProbe.needsUpdate = j, C.directionalLights.needsUpdate = j, C.directionalLightShadows.needsUpdate = j, C.pointLights.needsUpdate = j, C.pointLightShadows.needsUpdate = j, C.spotLights.needsUpdate = j, C.spotLightShadows.needsUpdate = j, C.rectAreaLights.needsUpdate = j, C.hemisphereLights.needsUpdate = j
            }

            function pn(C) {
                return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === !0
            }
            this.getActiveCubeFace = function() {
                return E
            }, this.getActiveMipmapLevel = function() {
                return T
            }, this.getRenderTarget = function() {
                return w
            }, this.setRenderTargetTextures = function(C, j, Z) {
                const K = Le.get(C);
                K.__autoAllocateDepthBuffer = C.resolveDepthBuffer === !1, K.__autoAllocateDepthBuffer === !1 && (K.__useRenderToTexture = !1), Le.get(C.texture).__webglTexture = j, Le.get(C.depthTexture).__webglTexture = K.__autoAllocateDepthBuffer ? void 0 : Z, K.__hasExternalTextures = !0
            }, this.setRenderTargetFramebuffer = function(C, j) {
                const Z = Le.get(C);
                Z.__webglFramebuffer = j, Z.__useDefaultFramebuffer = j === void 0
            };
            const kt = F.createFramebuffer();
            this.setRenderTarget = function(C, j = 0, Z = 0) {
                w = C, E = j, T = Z;
                let K = !0,
                    W = null,
                    _e = !1,
                    Ce = !1;
                if (C) {
                    const Ie = Le.get(C);
                    if (Ie.__useDefaultFramebuffer !== void 0) ve.bindFramebuffer(F.FRAMEBUFFER, null), K = !1;
                    else if (Ie.__webglFramebuffer === void 0) ge.setupRenderTarget(C);
                    else if (Ie.__hasExternalTextures) ge.rebindTextures(C, Le.get(C.texture).__webglTexture, Le.get(C.depthTexture).__webglTexture);
                    else if (C.depthBuffer) {
                        const We = C.depthTexture;
                        if (Ie.__boundDepthTexture !== We) {
                            if (We !== null && Le.has(We) && (C.width !== We.image.width || C.height !== We.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            ge.setupDepthRenderbuffer(C)
                        }
                    }
                    const qe = C.texture;
                    (qe.isData3DTexture || qe.isDataArrayTexture || qe.isCompressedArrayTexture) && (Ce = !0);
                    const Ze = Le.get(C).__webglFramebuffer;
                    C.isWebGLCubeRenderTarget ? (Array.isArray(Ze[j]) ? W = Ze[j][Z] : W = Ze[j], _e = !0) : C.samples > 0 && ge.useMultisampledRTT(C) === !1 ? W = Le.get(C).__webglMultisampledFramebuffer : Array.isArray(Ze) ? W = Ze[Z] : W = Ze, D.copy(C.viewport), R.copy(C.scissor), P = C.scissorTest
                } else D.copy(se).multiplyScalar(V).floor(), R.copy(de).multiplyScalar(V).floor(), P = ke;
                if (Z !== 0 && (W = kt), ve.bindFramebuffer(F.FRAMEBUFFER, W) && K && ve.drawBuffers(C, W), ve.viewport(D), ve.scissor(R), ve.setScissorTest(P), _e) {
                    const Ie = Le.get(C.texture);
                    F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + j, Ie.__webglTexture, Z)
                } else if (Ce) {
                    const Ie = Le.get(C.texture),
                        qe = j;
                    F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ie.__webglTexture, Z, qe)
                } else if (C !== null && Z !== 0) {
                    const Ie = Le.get(C.texture);
                    F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, Ie.__webglTexture, Z)
                }
                M = -1
            }, this.readRenderTargetPixels = function(C, j, Z, K, W, _e, Ce, ze = 0) {
                if (!(C && C.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return
                }
                let Ie = Le.get(C).__webglFramebuffer;
                if (C.isWebGLCubeRenderTarget && Ce !== void 0 && (Ie = Ie[Ce]), Ie) {
                    ve.bindFramebuffer(F.FRAMEBUFFER, Ie);
                    try {
                        const qe = C.textures[ze],
                            Ze = qe.format,
                            We = qe.type;
                        if (!q.textureFormatReadable(Ze)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return
                        }
                        if (!q.textureTypeReadable(We)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return
                        }
                        j >= 0 && j <= C.width - K && Z >= 0 && Z <= C.height - W && (C.textures.length > 1 && F.readBuffer(F.COLOR_ATTACHMENT0 + ze), F.readPixels(j, Z, K, W, Se.convert(Ze), Se.convert(We), _e))
                    } finally {
                        const qe = w !== null ? Le.get(w).__webglFramebuffer : null;
                        ve.bindFramebuffer(F.FRAMEBUFFER, qe)
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(C, j, Z, K, W, _e, Ce, ze = 0) {
                if (!(C && C.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let Ie = Le.get(C).__webglFramebuffer;
                if (C.isWebGLCubeRenderTarget && Ce !== void 0 && (Ie = Ie[Ce]), Ie)
                    if (j >= 0 && j <= C.width - K && Z >= 0 && Z <= C.height - W) {
                        ve.bindFramebuffer(F.FRAMEBUFFER, Ie);
                        const qe = C.textures[ze],
                            Ze = qe.format,
                            We = qe.type;
                        if (!q.textureFormatReadable(Ze)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                        if (!q.textureTypeReadable(We)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                        const lt = F.createBuffer();
                        F.bindBuffer(F.PIXEL_PACK_BUFFER, lt), F.bufferData(F.PIXEL_PACK_BUFFER, _e.byteLength, F.STREAM_READ), C.textures.length > 1 && F.readBuffer(F.COLOR_ATTACHMENT0 + ze), F.readPixels(j, Z, K, W, Se.convert(Ze), Se.convert(We), 0);
                        const Ct = w !== null ? Le.get(w).__webglFramebuffer : null;
                        ve.bindFramebuffer(F.FRAMEBUFFER, Ct);
                        const qt = F.fenceSync(F.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        return F.flush(), await Qy(F, qt, 4), F.bindBuffer(F.PIXEL_PACK_BUFFER, lt), F.getBufferSubData(F.PIXEL_PACK_BUFFER, 0, _e), F.deleteBuffer(lt), F.deleteSync(qt), _e
                    } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
            }, this.copyFramebufferToTexture = function(C, j = null, Z = 0) {
                const K = Math.pow(2, -Z),
                    W = Math.floor(C.image.width * K),
                    _e = Math.floor(C.image.height * K),
                    Ce = j !== null ? j.x : 0,
                    ze = j !== null ? j.y : 0;
                ge.setTexture2D(C, 0), F.copyTexSubImage2D(F.TEXTURE_2D, Z, 0, 0, Ce, ze, W, _e), ve.unbindTexture()
            };
            const mn = F.createFramebuffer(),
                gn = F.createFramebuffer();
            this.copyTextureToTexture = function(C, j, Z = null, K = null, W = 0, _e = null) {
                _e === null && (W !== 0 ? (ka("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), _e = W, W = 0) : _e = 0);
                let Ce, ze, Ie, qe, Ze, We, lt, Ct, qt;
                const Kt = C.isCompressedTexture ? C.mipmaps[_e] : C.image;
                if (Z !== null) Ce = Z.max.x - Z.min.x, ze = Z.max.y - Z.min.y, Ie = Z.isBox3 ? Z.max.z - Z.min.z : 1, qe = Z.min.x, Ze = Z.min.y, We = Z.isBox3 ? Z.min.z : 0;
                else {
                    const Vi = Math.pow(2, -W);
                    Ce = Math.floor(Kt.width * Vi), ze = Math.floor(Kt.height * Vi), C.isDataArrayTexture ? Ie = Kt.depth : C.isData3DTexture ? Ie = Math.floor(Kt.depth * Vi) : Ie = 1, qe = 0, Ze = 0, We = 0
                }
                K !== null ? (lt = K.x, Ct = K.y, qt = K.z) : (lt = 0, Ct = 0, qt = 0);
                const Mt = Se.convert(j.format),
                    Qe = Se.convert(j.type);
                let An;
                j.isData3DTexture ? (ge.setTexture3D(j, 0), An = F.TEXTURE_3D) : j.isDataArrayTexture || j.isCompressedArrayTexture ? (ge.setTexture2DArray(j, 0), An = F.TEXTURE_2D_ARRAY) : (ge.setTexture2D(j, 0), An = F.TEXTURE_2D), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, j.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, j.unpackAlignment);
                const wt = F.getParameter(F.UNPACK_ROW_LENGTH),
                    cr = F.getParameter(F.UNPACK_IMAGE_HEIGHT),
                    lc = F.getParameter(F.UNPACK_SKIP_PIXELS),
                    Ti = F.getParameter(F.UNPACK_SKIP_ROWS),
                    Kl = F.getParameter(F.UNPACK_SKIP_IMAGES);
                F.pixelStorei(F.UNPACK_ROW_LENGTH, Kt.width), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, Kt.height), F.pixelStorei(F.UNPACK_SKIP_PIXELS, qe), F.pixelStorei(F.UNPACK_SKIP_ROWS, Ze), F.pixelStorei(F.UNPACK_SKIP_IMAGES, We);
                const zt = C.isDataArrayTexture || C.isData3DTexture,
                    Hi = j.isDataArrayTexture || j.isData3DTexture;
                if (C.isDepthTexture) {
                    const Vi = Le.get(C),
                        ei = Le.get(j),
                        fi = Le.get(Vi.__renderTarget),
                        Ag = Le.get(ei.__renderTarget);
                    ve.bindFramebuffer(F.READ_FRAMEBUFFER, fi.__webglFramebuffer), ve.bindFramebuffer(F.DRAW_FRAMEBUFFER, Ag.__webglFramebuffer);
                    for (let Ua = 0; Ua < Ie; Ua++) zt && (F.framebufferTextureLayer(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Le.get(C).__webglTexture, W, We + Ua), F.framebufferTextureLayer(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Le.get(j).__webglTexture, _e, qt + Ua)), F.blitFramebuffer(qe, Ze, Ce, ze, lt, Ct, Ce, ze, F.DEPTH_BUFFER_BIT, F.NEAREST);
                    ve.bindFramebuffer(F.READ_FRAMEBUFFER, null), ve.bindFramebuffer(F.DRAW_FRAMEBUFFER, null)
                } else if (W !== 0 || C.isRenderTargetTexture || Le.has(C)) {
                    const Vi = Le.get(C),
                        ei = Le.get(j);
                    ve.bindFramebuffer(F.READ_FRAMEBUFFER, mn), ve.bindFramebuffer(F.DRAW_FRAMEBUFFER, gn);
                    for (let fi = 0; fi < Ie; fi++) zt ? F.framebufferTextureLayer(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Vi.__webglTexture, W, We + fi) : F.framebufferTexture2D(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, Vi.__webglTexture, W), Hi ? F.framebufferTextureLayer(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, ei.__webglTexture, _e, qt + fi) : F.framebufferTexture2D(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, ei.__webglTexture, _e), W !== 0 ? F.blitFramebuffer(qe, Ze, Ce, ze, lt, Ct, Ce, ze, F.COLOR_BUFFER_BIT, F.NEAREST) : Hi ? F.copyTexSubImage3D(An, _e, lt, Ct, qt + fi, qe, Ze, Ce, ze) : F.copyTexSubImage2D(An, _e, lt, Ct, qe, Ze, Ce, ze);
                    ve.bindFramebuffer(F.READ_FRAMEBUFFER, null), ve.bindFramebuffer(F.DRAW_FRAMEBUFFER, null)
                } else Hi ? C.isDataTexture || C.isData3DTexture ? F.texSubImage3D(An, _e, lt, Ct, qt, Ce, ze, Ie, Mt, Qe, Kt.data) : j.isCompressedArrayTexture ? F.compressedTexSubImage3D(An, _e, lt, Ct, qt, Ce, ze, Ie, Mt, Kt.data) : F.texSubImage3D(An, _e, lt, Ct, qt, Ce, ze, Ie, Mt, Qe, Kt) : C.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, _e, lt, Ct, Ce, ze, Mt, Qe, Kt.data) : C.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, _e, lt, Ct, Kt.width, Kt.height, Mt, Kt.data) : F.texSubImage2D(F.TEXTURE_2D, _e, lt, Ct, Ce, ze, Mt, Qe, Kt);
                F.pixelStorei(F.UNPACK_ROW_LENGTH, wt), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, cr), F.pixelStorei(F.UNPACK_SKIP_PIXELS, lc), F.pixelStorei(F.UNPACK_SKIP_ROWS, Ti), F.pixelStorei(F.UNPACK_SKIP_IMAGES, Kl), _e === 0 && j.generateMipmaps && F.generateMipmap(An), ve.unbindTexture()
            }, this.copyTextureToTexture3D = function(C, j, Z = null, K = null, W = 0) {
                return ka('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(C, j, Z, K, W)
            }, this.initRenderTarget = function(C) {
                Le.get(C).__webglFramebuffer === void 0 && ge.setupRenderTarget(C)
            }, this.initTexture = function(C) {
                C.isCubeTexture ? ge.setTextureCube(C, 0) : C.isData3DTexture ? ge.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? ge.setTexture2DArray(C, 0) : ge.setTexture2D(C, 0), ve.unbindTexture()
            }, this.resetState = function() {
                E = 0, T = 0, w = null, ve.reset(), je.reset()
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        get coordinateSystem() {
            return 2e3
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorSpace = bt._getDrawingBufferColorSpace(e), t.unpackColorSpace = bt._getUnpackColorSpace()
        }
    }
    /**
     * @vue/shared v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    /*! #__NO_SIDE_EFFECTS__ */
    function AA(r) {
        const e = Object.create(null);
        for (const t of r.split(",")) e[t] = 1;
        return t => t in e
    }
    const bd = {},
        Nu = () => {},
        ub = Object.assign,
        DA = Object.prototype.hasOwnProperty,
        xd = (r, e) => DA.call(r, e),
        Ki = Array.isArray,
        Cc = r => Uu(r) === "[object Map]",
        CA = r => Uu(r) === "[object Set]",
        na = r => typeof r == "function",
        RA = r => typeof r == "string",
        Rc = r => typeof r == "symbol",
        uo = r => r !== null && typeof r == "object",
        PA = r => (uo(r) || na(r)) && na(r.then) && na(r.catch),
        FA = Object.prototype.toString,
        Uu = r => FA.call(r),
        IA = r => Uu(r).slice(8, -1),
        LA = r => Uu(r) === "[object Object]",
        vd = r => RA(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r,
        gs = (r, e) => !Object.is(r, e);
    let fb;
    const yd = () => fb || (fb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
    /**
     * @vue/reactivity v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    let Lt;
    const Sd = new WeakSet;
    class NA {
        constructor(e) {
            this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0
        }
        pause() {
            this.flags |= 64
        }
        resume() {
            this.flags & 64 && (this.flags &= -65, Sd.has(this) && (Sd.delete(this), this.trigger()))
        }
        notify() {
            this.flags & 2 && !(this.flags & 32) || this.flags & 8 || UA(this)
        }
        run() {
            if (!(this.flags & 1)) return this.fn();
            this.flags |= 2, gb(this), db(this);
            const e = Lt,
                t = Ji;
            Lt = this, Ji = !0;
            try {
                return this.fn()
            } finally {
                pb(this), Lt = e, Ji = t, this.flags &= -3
            }
        }
        stop() {
            if (this.flags & 1) {
                for (let e = this.deps; e; e = e.nextDep) wd(e);
                this.deps = this.depsTail = void 0, gb(this), this.onStop && this.onStop(), this.flags &= -2
            }
        }
        trigger() {
            this.flags & 64 ? Sd.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
        }
        runIfDirty() {
            Ed(this) && this.run()
        }
        get dirty() {
            return Ed(this)
        }
    }
    let hb = 0,
        Pc, Fc;

    function UA(r, e = !1) {
        if (r.flags |= 8, e) {
            r.next = Fc, Fc = r;
            return
        }
        r.next = Pc, Pc = r
    }

    function Md() {
        hb++
    }

    function Td() {
        if (--hb > 0) return;
        if (Fc) {
            let e = Fc;
            for (Fc = void 0; e;) {
                const t = e.next;
                e.next = void 0, e.flags &= -9, e = t
            }
        }
        let r;
        for (; Pc;) {
            let e = Pc;
            for (Pc = void 0; e;) {
                const t = e.next;
                if (e.next = void 0, e.flags &= -9, e.flags & 1) try {
                    e.trigger()
                } catch (n) {
                    r || (r = n)
                }
                e = t
            }
        }
        if (r) throw r
    }

    function db(r) {
        for (let e = r.deps; e; e = e.nextDep) e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e
    }

    function pb(r) {
        let e, t = r.depsTail,
            n = t;
        for (; n;) {
            const i = n.prevDep;
            n.version === -1 ? (n === t && (t = i), wd(n), BA(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i
        }
        r.deps = e, r.depsTail = t
    }

    function Ed(r) {
        for (let e = r.deps; e; e = e.nextDep)
            if (e.dep.version !== e.version || e.dep.computed && (OA(e.dep.computed) || e.dep.version !== e.version)) return !0;
        return !!r._dirty
    }

    function OA(r) {
        if (r.flags & 4 && !(r.flags & 16) || (r.flags &= -17, r.globalVersion === Ou)) return;
        r.globalVersion = Ou;
        const e = r.dep;
        if (r.flags |= 2, e.version > 0 && !r.isSSR && r.deps && !Ed(r)) {
            r.flags &= -3;
            return
        }
        const t = Lt,
            n = Ji;
        Lt = r, Ji = !0;
        try {
            db(r);
            const i = r.fn(r._value);
            (e.version === 0 || gs(i, r._value)) && (r._value = i, e.version++)
        } catch (i) {
            throw e.version++, i
        } finally {
            Lt = t, Ji = n, pb(r), r.flags &= -3
        }
    }

    function wd(r, e = !1) {
        const {
            dep: t,
            prevSub: n,
            nextSub: i
        } = r;
        if (n && (n.nextSub = i, r.prevSub = void 0), i && (i.prevSub = n, r.nextSub = void 0), t.subs === r && (t.subs = n, !n && t.computed)) {
            t.computed.flags &= -5;
            for (let s = t.computed.deps; s; s = s.nextDep) wd(s, !0)
        }!e && !--t.sc && t.map && t.map.delete(t.key)
    }

    function BA(r) {
        const {
            prevDep: e,
            nextDep: t
        } = r;
        e && (e.nextDep = t, r.prevDep = void 0), t && (t.prevDep = e, r.nextDep = void 0)
    }
    let Ji = !0;
    const mb = [];

    function Ad() {
        mb.push(Ji), Ji = !1
    }

    function Dd() {
        const r = mb.pop();
        Ji = r === void 0 ? !0 : r
    }

    function gb(r) {
        const {
            cleanup: e
        } = r;
        if (r.cleanup = void 0, e) {
            const t = Lt;
            Lt = void 0;
            try {
                e()
            } finally {
                Lt = t
            }
        }
    }
    let Ou = 0;
    class kA {
        constructor(e, t) {
            this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
        }
    }
    class _b {
        constructor(e) {
            this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
        }
        track(e) {
            if (!Lt || !Ji || Lt === this.computed) return;
            let t = this.activeLink;
            if (t === void 0 || t.sub !== Lt) t = this.activeLink = new kA(Lt, this), Lt.deps ? (t.prevDep = Lt.depsTail, Lt.depsTail.nextDep = t, Lt.depsTail = t) : Lt.deps = Lt.depsTail = t, bb(t);
            else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
                const n = t.nextDep;
                n.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = n), t.prevDep = Lt.depsTail, t.nextDep = void 0, Lt.depsTail.nextDep = t, Lt.depsTail = t, Lt.deps === t && (Lt.deps = n)
            }
            return t
        }
        trigger(e) {
            this.version++, Ou++, this.notify(e)
        }
        notify(e) {
            Md();
            try {
                for (let t = this.subs; t; t = t.prevSub) t.sub.notify() && t.sub.dep.notify()
            } finally {
                Td()
            }
        }
    }

    function bb(r) {
        if (r.dep.sc++, r.sub.flags & 4) {
            const e = r.dep.computed;
            if (e && !r.dep.subs) {
                e.flags |= 20;
                for (let n = e.deps; n; n = n.nextDep) bb(n)
            }
            const t = r.dep.subs;
            t !== r && (r.prevSub = t, t && (t.nextSub = r)), r.dep.subs = r
        }
    }
    const Cd = new WeakMap,
        ia = Symbol(""),
        Rd = Symbol(""),
        Ic = Symbol("");

    function ni(r, e, t) {
        if (Ji && Lt) {
            let n = Cd.get(r);
            n || Cd.set(r, n = new Map);
            let i = n.get(t);
            i || (n.set(t, i = new _b), i.map = n, i.key = t), i.track()
        }
    }

    function _s(r, e, t, n, i, s) {
        const a = Cd.get(r);
        if (!a) {
            Ou++;
            return
        }
        const o = c => {
            c && c.trigger()
        };
        if (Md(), e === "clear") a.forEach(o);
        else {
            const c = Ki(r),
                l = c && vd(t);
            if (c && t === "length") {
                const f = Number(n);
                a.forEach((h, d) => {
                    (d === "length" || d === Ic || !Rc(d) && d >= f) && o(h)
                })
            } else switch ((t !== void 0 || a.has(void 0)) && o(a.get(t)), l && o(a.get(Ic)), e) {
                case "add":
                    c ? l && o(a.get("length")) : (o(a.get(ia)), Cc(r) && o(a.get(Rd)));
                    break;
                case "delete":
                    c || (o(a.get(ia)), Cc(r) && o(a.get(Rd)));
                    break;
                case "set":
                    Cc(r) && o(a.get(ia));
                    break
            }
        }
        Td()
    }

    function fo(r) {
        const e = Pt(r);
        return e === r ? e : (ni(e, "iterate", Ic), Zi(r) ? e : e.map(Wn))
    }

    function Pd(r) {
        return ni(r = Pt(r), "iterate", Ic), r
    }
    const zA = {
        __proto__: null,
        [Symbol.iterator]() {
            return Fd(this, Symbol.iterator, Wn)
        },
        concat(...r) {
            return fo(this).concat(...r.map(e => Ki(e) ? fo(e) : e))
        },
        entries() {
            return Fd(this, "entries", r => (r[1] = Wn(r[1]), r))
        },
        every(r, e) {
            return kr(this, "every", r, e, void 0, arguments)
        },
        filter(r, e) {
            return kr(this, "filter", r, e, t => t.map(Wn), arguments)
        },
        find(r, e) {
            return kr(this, "find", r, e, Wn, arguments)
        },
        findIndex(r, e) {
            return kr(this, "findIndex", r, e, void 0, arguments)
        },
        findLast(r, e) {
            return kr(this, "findLast", r, e, Wn, arguments)
        },
        findLastIndex(r, e) {
            return kr(this, "findLastIndex", r, e, void 0, arguments)
        },
        forEach(r, e) {
            return kr(this, "forEach", r, e, void 0, arguments)
        },
        includes(...r) {
            return Id(this, "includes", r)
        },
        indexOf(...r) {
            return Id(this, "indexOf", r)
        },
        join(r) {
            return fo(this).join(r)
        },
        lastIndexOf(...r) {
            return Id(this, "lastIndexOf", r)
        },
        map(r, e) {
            return kr(this, "map", r, e, void 0, arguments)
        },
        pop() {
            return Lc(this, "pop")
        },
        push(...r) {
            return Lc(this, "push", r)
        },
        reduce(r, ...e) {
            return xb(this, "reduce", r, e)
        },
        reduceRight(r, ...e) {
            return xb(this, "reduceRight", r, e)
        },
        shift() {
            return Lc(this, "shift")
        },
        some(r, e) {
            return kr(this, "some", r, e, void 0, arguments)
        },
        splice(...r) {
            return Lc(this, "splice", r)
        },
        toReversed() {
            return fo(this).toReversed()
        },
        toSorted(r) {
            return fo(this).toSorted(r)
        },
        toSpliced(...r) {
            return fo(this).toSpliced(...r)
        },
        unshift(...r) {
            return Lc(this, "unshift", r)
        },
        values() {
            return Fd(this, "values", Wn)
        }
    };

    function Fd(r, e, t) {
        const n = Pd(r),
            i = n[e]();
        return n !== r && !Zi(r) && (i._next = i.next, i.next = () => {
            const s = i._next();
            return s.value && (s.value = t(s.value)), s
        }), i
    }
    const GA = Array.prototype;

    function kr(r, e, t, n, i, s) {
        const a = Pd(r),
            o = a !== r && !Zi(r),
            c = a[e];
        if (c !== GA[e]) {
            const h = c.apply(r, s);
            return o ? Wn(h) : h
        }
        let l = t;
        a !== r && (o ? l = function(h, d) {
            return t.call(this, Wn(h), d, r)
        } : t.length > 2 && (l = function(h, d) {
            return t.call(this, h, d, r)
        }));
        const f = c.call(a, l, n);
        return o && i ? i(f) : f
    }

    function xb(r, e, t, n) {
        const i = Pd(r);
        let s = t;
        return i !== r && (Zi(r) ? t.length > 3 && (s = function(a, o, c) {
            return t.call(this, a, o, c, r)
        }) : s = function(a, o, c) {
            return t.call(this, a, Wn(o), c, r)
        }), i[e](s, ...n)
    }

    function Id(r, e, t) {
        const n = Pt(r);
        ni(n, "iterate", Ic);
        const i = n[e](...t);
        return (i === -1 || i === !1) && nD(t[0]) ? (t[0] = Pt(t[0]), n[e](...t)) : i
    }

    function Lc(r, e, t = []) {
        Ad(), Md();
        const n = Pt(r)[e].apply(r, t);
        return Td(), Dd(), n
    }
    const HA = AA("__proto__,__v_isRef,__isVue"),
        vb = new Set(Object.getOwnPropertyNames(Symbol).filter(r => r !== "arguments" && r !== "caller").map(r => Symbol[r]).filter(Rc));

    function VA(r) {
        Rc(r) || (r = String(r));
        const e = Pt(this);
        return ni(e, "has", r), e.hasOwnProperty(r)
    }
    class yb {
        constructor(e = !1, t = !1) {
            this._isReadonly = e, this._isShallow = t
        }
        get(e, t, n) {
            if (t === "__v_skip") return e.__v_skip;
            const i = this._isReadonly,
                s = this._isShallow;
            if (t === "__v_isReactive") return !i;
            if (t === "__v_isReadonly") return i;
            if (t === "__v_isShallow") return s;
            if (t === "__v_raw") return n === (i ? s ? QA : Tb : s ? ZA : Mb).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
            const a = Ki(e);
            if (!i) {
                let c;
                if (a && (c = zA[t])) return c;
                if (t === "hasOwnProperty") return VA
            }
            const o = Reflect.get(e, t, pr(e) ? e : n);
            return (Rc(t) ? vb.has(t) : HA(t)) || (i || ni(e, "get", t), s) ? o : pr(o) ? a && vd(t) ? o : o.value : uo(o) ? i ? wb(o) : Eb(o) : o
        }
    }
    class WA extends yb {
        constructor(e = !1) {
            super(!1, e)
        }
        set(e, t, n, i) {
            let s = e[t];
            if (!this._isShallow) {
                const c = ra(s);
                if (!Zi(n) && !ra(n) && (s = Pt(s), n = Pt(n)), !Ki(e) && pr(s) && !pr(n)) return c ? !1 : (s.value = n, !0)
            }
            const a = Ki(e) && vd(t) ? Number(t) < e.length : xd(e, t),
                o = Reflect.set(e, t, n, pr(e) ? e : i);
            return e === Pt(i) && (a ? gs(n, s) && _s(e, "set", t, n) : _s(e, "add", t, n)), o
        }
        deleteProperty(e, t) {
            const n = xd(e, t);
            e[t];
            const i = Reflect.deleteProperty(e, t);
            return i && n && _s(e, "delete", t, void 0), i
        }
        has(e, t) {
            const n = Reflect.has(e, t);
            return (!Rc(t) || !vb.has(t)) && ni(e, "has", t), n
        }
        ownKeys(e) {
            return ni(e, "iterate", Ki(e) ? "length" : ia), Reflect.ownKeys(e)
        }
    }
    class XA extends yb {
        constructor(e = !1) {
            super(!0, e)
        }
        set(e, t) {
            return !0
        }
        deleteProperty(e, t) {
            return !0
        }
    }
    const jA = new WA,
        qA = new XA,
        Ld = r => r,
        Bu = r => Reflect.getPrototypeOf(r);

    function YA(r, e, t) {
        return function(...n) {
            const i = this.__v_raw,
                s = Pt(i),
                a = Cc(s),
                o = r === "entries" || r === Symbol.iterator && a,
                c = r === "keys" && a,
                l = i[r](...n),
                f = t ? Ld : e ? Nd : Wn;
            return !e && ni(s, "iterate", c ? Rd : ia), {
                next() {
                    const {
                        value: h,
                        done: d
                    } = l.next();
                    return d ? {
                        value: h,
                        done: d
                    } : {
                        value: o ? [f(h[0]), f(h[1])] : f(h),
                        done: d
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
        }
    }

    function ku(r) {
        return function(...e) {
            return r === "delete" ? !1 : r === "clear" ? void 0 : this
        }
    }

    function $A(r, e) {
        const t = {
            get(i) {
                const s = this.__v_raw,
                    a = Pt(s),
                    o = Pt(i);
                r || (gs(i, o) && ni(a, "get", i), ni(a, "get", o));
                const {
                    has: c
                } = Bu(a), l = e ? Ld : r ? Nd : Wn;
                if (c.call(a, i)) return l(s.get(i));
                if (c.call(a, o)) return l(s.get(o));
                s !== a && s.get(i)
            },
            get size() {
                const i = this.__v_raw;
                return !r && ni(Pt(i), "iterate", ia), Reflect.get(i, "size", i)
            },
            has(i) {
                const s = this.__v_raw,
                    a = Pt(s),
                    o = Pt(i);
                return r || (gs(i, o) && ni(a, "has", i), ni(a, "has", o)), i === o ? s.has(i) : s.has(i) || s.has(o)
            },
            forEach(i, s) {
                const a = this,
                    o = a.__v_raw,
                    c = Pt(o),
                    l = e ? Ld : r ? Nd : Wn;
                return !r && ni(c, "iterate", ia), o.forEach((f, h) => i.call(s, l(f), l(h), a))
            }
        };
        return ub(t, r ? {
            add: ku("add"),
            set: ku("set"),
            delete: ku("delete"),
            clear: ku("clear")
        } : {
            add(i) {
                !e && !Zi(i) && !ra(i) && (i = Pt(i));
                const s = Pt(this);
                return Bu(s).has.call(s, i) || (s.add(i), _s(s, "add", i, i)), this
            },
            set(i, s) {
                !e && !Zi(s) && !ra(s) && (s = Pt(s));
                const a = Pt(this),
                    {
                        has: o,
                        get: c
                    } = Bu(a);
                let l = o.call(a, i);
                l || (i = Pt(i), l = o.call(a, i));
                const f = c.call(a, i);
                return a.set(i, s), l ? gs(s, f) && _s(a, "set", i, s) : _s(a, "add", i, s), this
            },
            delete(i) {
                const s = Pt(this),
                    {
                        has: a,
                        get: o
                    } = Bu(s);
                let c = a.call(s, i);
                c || (i = Pt(i), c = a.call(s, i)), o && o.call(s, i);
                const l = s.delete(i);
                return c && _s(s, "delete", i, void 0), l
            },
            clear() {
                const i = Pt(this),
                    s = i.size !== 0,
                    a = i.clear();
                return s && _s(i, "clear", void 0, void 0), a
            }
        }), ["keys", "values", "entries", Symbol.iterator].forEach(i => {
            t[i] = YA(i, r, e)
        }), t
    }

    function Sb(r, e) {
        const t = $A(r, e);
        return (n, i, s) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? n : Reflect.get(xd(t, i) && i in n ? t : n, i, s)
    }
    const KA = {
            get: Sb(!1, !1)
        },
        JA = {
            get: Sb(!0, !1)
        },
        Mb = new WeakMap,
        ZA = new WeakMap,
        Tb = new WeakMap,
        QA = new WeakMap;

    function eD(r) {
        switch (r) {
            case "Object":
            case "Array":
                return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
                return 2;
            default:
                return 0
        }
    }

    function tD(r) {
        return r.__v_skip || !Object.isExtensible(r) ? 0 : eD(IA(r))
    }

    function Eb(r) {
        return ra(r) ? r : Ab(r, !1, jA, KA, Mb)
    }

    function wb(r) {
        return Ab(r, !0, qA, JA, Tb)
    }

    function Ab(r, e, t, n, i) {
        if (!uo(r) || r.__v_raw && !(e && r.__v_isReactive)) return r;
        const s = i.get(r);
        if (s) return s;
        const a = tD(r);
        if (a === 0) return r;
        const o = new Proxy(r, a === 2 ? n : t);
        return i.set(r, o), o
    }

    function zu(r) {
        return ra(r) ? zu(r.__v_raw) : !!(r && r.__v_isReactive)
    }

    function ra(r) {
        return !!(r && r.__v_isReadonly)
    }

    function Zi(r) {
        return !!(r && r.__v_isShallow)
    }

    function nD(r) {
        return r ? !!r.__v_raw : !1
    }

    function Pt(r) {
        const e = r && r.__v_raw;
        return e ? Pt(e) : r
    }
    const Wn = r => uo(r) ? Eb(r) : r,
        Nd = r => uo(r) ? wb(r) : r;

    function pr(r) {
        return r ? r.__v_isRef === !0 : !1
    }

    function Db(r) {
        return iD(r, !0)
    }

    function iD(r, e) {
        return pr(r) ? r : new rD(r, e)
    }
    class rD {
        constructor(e, t) {
            this.dep = new _b, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Pt(e), this._value = t ? e : Wn(e), this.__v_isShallow = t
        }
        get value() {
            return this.dep.track(), this._value
        }
        set value(e) {
            const t = this._rawValue,
                n = this.__v_isShallow || Zi(e) || ra(e);
            e = n ? e : Pt(e), gs(e, t) && (this._rawValue = e, this._value = n ? e : Wn(e), this.dep.trigger())
        }
    }

    function sD(r) {
        return pr(r) ? r.value : r
    }
    const Gu = {},
        Hu = new WeakMap;
    let sa;

    function aD(r, e = !1, t = sa) {
        if (t) {
            let n = Hu.get(t);
            n || Hu.set(t, n = []), n.push(r)
        }
    }

    function oD(r, e, t = bd) {
        const {
            immediate: n,
            deep: i,
            once: s,
            scheduler: a,
            augmentJob: o,
            call: c
        } = t, l = x => i ? x : Zi(x) || i === !1 || i === 0 ? bs(x, 1) : bs(x);
        let f, h, d, u, _ = !1,
            g = !1;
        if (pr(r) ? (h = () => r.value, _ = Zi(r)) : zu(r) ? (h = () => l(r), _ = !0) : Ki(r) ? (g = !0, _ = r.some(x => zu(x) || Zi(x)), h = () => r.map(x => {
                if (pr(x)) return x.value;
                if (zu(x)) return l(x);
                if (na(x)) return c ? c(x, 2) : x()
            })) : na(r) ? e ? h = c ? () => c(r, 2) : r : h = () => {
                if (d) {
                    Ad();
                    try {
                        d()
                    } finally {
                        Dd()
                    }
                }
                const x = sa;
                sa = f;
                try {
                    return c ? c(r, 3, [u]) : r(u)
                } finally {
                    sa = x
                }
            } : h = Nu, e && i) {
            const x = h,
                b = i === !0 ? 1 / 0 : i;
            h = () => bs(x(), b)
        }
        const m = () => {
            f.stop()
        };
        if (s && e) {
            const x = e;
            e = (...b) => {
                x(...b), m()
            }
        }
        let p = g ? new Array(r.length).fill(Gu) : Gu;
        const v = x => {
            if (!(!(f.flags & 1) || !f.dirty && !x))
                if (e) {
                    const b = f.run();
                    if (i || _ || (g ? b.some((S, E) => gs(S, p[E])) : gs(b, p))) {
                        d && d();
                        const S = sa;
                        sa = f;
                        try {
                            const E = [b, p === Gu ? void 0 : g && p[0] === Gu ? [] : p, u];
                            c ? c(e, 3, E) : e(...E), p = b
                        } finally {
                            sa = S
                        }
                    }
                } else f.run()
        };
        return o && o(v), f = new NA(h), f.scheduler = a ? () => a(v, !1) : v, u = x => aD(x, !1, f), d = f.onStop = () => {
            const x = Hu.get(f);
            if (x) {
                if (c) c(x, 4);
                else
                    for (const b of x) b();
                Hu.delete(f)
            }
        }, e ? n ? v(!0) : p = f.run() : a ? a(v.bind(null, !0), !0) : f.run(), m.pause = f.pause.bind(f), m.resume = f.resume.bind(f), m.stop = m, m
    }

    function bs(r, e = 1 / 0, t) {
        if (e <= 0 || !uo(r) || r.__v_skip || (t = t || new Set, t.has(r))) return r;
        if (t.add(r), e--, pr(r)) bs(r.value, e, t);
        else if (Ki(r))
            for (let n = 0; n < r.length; n++) bs(r[n], e, t);
        else if (CA(r) || Cc(r)) r.forEach(n => {
            bs(n, e, t)
        });
        else if (LA(r)) {
            for (const n in r) bs(r[n], e, t);
            for (const n of Object.getOwnPropertySymbols(r)) Object.prototype.propertyIsEnumerable.call(r, n) && bs(r[n], e, t)
        }
        return r
    }
    /**
     * @vue/runtime-core v3.5.13
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    function Ud(r, e, t, n) {
        try {
            return n ? r(...n) : r()
        } catch (i) {
            Rb(i, e, t)
        }
    }

    function Cb(r, e, t, n) {
        if (na(r)) {
            const i = Ud(r, e, t, n);
            return i && PA(i) && i.catch(s => {
                Rb(s, e, t)
            }), i
        }
        if (Ki(r)) {
            const i = [];
            for (let s = 0; s < r.length; s++) i.push(Cb(r[s], e, t, n));
            return i
        }
    }

    function Rb(r, e, t, n = !0) {
        const i = e ? e.vnode : null,
            {
                errorHandler: s,
                throwUnhandledErrorInProduction: a
            } = e && e.appContext.config || bd;
        if (e) {
            let o = e.parent;
            const c = e.proxy,
                l = `https://vuejs.org/error-reference/#runtime-${t}`;
            for (; o;) {
                const f = o.ec;
                if (f) {
                    for (let h = 0; h < f.length; h++)
                        if (f[h](r, c, l) === !1) return
                }
                o = o.parent
            }
            if (s) {
                Ad(), Ud(s, null, 10, [r, c, l]), Dd();
                return
            }
        }
        cD(r, t, i, n, a)
    }

    function cD(r, e, t, n = !0, i = !1) {
        if (i) throw r;
        console.error(r)
    }
    const Ai = [];
    let zr = -1;
    const ho = [];
    let xs = null,
        po = 0;
    const lD = Promise.resolve();
    let Od = null;

    function uD(r) {
        let e = zr + 1,
            t = Ai.length;
        for (; e < t;) {
            const n = e + t >>> 1,
                i = Ai[n],
                s = Nc(i);
            s < r || s === r && i.flags & 2 ? e = n + 1 : t = n
        }
        return e
    }

    function fD(r) {
        if (!(r.flags & 1)) {
            const e = Nc(r),
                t = Ai[Ai.length - 1];
            !t || !(r.flags & 2) && e >= Nc(t) ? Ai.push(r) : Ai.splice(uD(e), 0, r), r.flags |= 1, Pb()
        }
    }

    function Pb() {
        Od || (Od = lD.then(Fb))
    }

    function hD(r) {
        Ki(r) ? ho.push(...r) : xs && r.id === -1 ? xs.splice(po + 1, 0, r) : r.flags & 1 || (ho.push(r), r.flags |= 1), Pb()
    }

    function dD(r) {
        if (ho.length) {
            const e = [...new Set(ho)].sort((t, n) => Nc(t) - Nc(n));
            if (ho.length = 0, xs) {
                xs.push(...e);
                return
            }
            for (xs = e, po = 0; po < xs.length; po++) {
                const t = xs[po];
                t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2
            }
            xs = null, po = 0
        }
    }
    const Nc = r => r.id == null ? r.flags & 2 ? -1 : 1 / 0 : r.id;

    function Fb(r) {
        try {
            for (zr = 0; zr < Ai.length; zr++) {
                const e = Ai[zr];
                e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), Ud(e, e.i, e.i ? 15 : 14), e.flags & 4 || (e.flags &= -2))
            }
        } finally {
            for (; zr < Ai.length; zr++) {
                const e = Ai[zr];
                e && (e.flags &= -2)
            }
            zr = -1, Ai.length = 0, dD(), Od = null, (Ai.length || ho.length) && Fb()
        }
    }
    let pD = null;
    yd().requestIdleCallback, yd().cancelIdleCallback;
    let mD = null;

    function gD(r, e, t = !1) {
        const n = Bd || pD;
        if (n || mD) {
            const i = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
            if (i && r in i) return i[r];
            if (arguments.length > 1) return t && na(e) ? e.call(n && n.proxy) : e
        }
    }
    const _D = SD,
        bD = Symbol.for("v-scx"),
        xD = () => gD(bD);

    function vD(r, e, t) {
        return yD(r, e, t)
    }

    function yD(r, e, t = bd) {
        const {
            immediate: n,
            deep: i,
            flush: s,
            once: a
        } = t, o = ub({}, t), c = e && n || !e && s !== "post";
        let l;
        if (kd) {
            if (s === "sync") {
                const u = xD();
                l = u.__watcherHandles || (u.__watcherHandles = [])
            } else if (!c) {
                const u = () => {};
                return u.stop = Nu, u.resume = Nu, u.pause = Nu, u
            }
        }
        const f = Bd;
        o.call = (u, _, g) => Cb(u, f, _, g);
        let h = !1;
        s === "post" ? o.scheduler = u => {
            _D(u, f && f.suspense)
        } : s !== "sync" && (h = !0, o.scheduler = (u, _) => {
            _ ? u() : fD(u)
        }), o.augmentJob = u => {
            e && (u.flags |= 4), h && (u.flags |= 2, f && (u.id = f.uid, u.i = f))
        };
        const d = oD(r, e, o);
        return kd && (l ? l.push(d) : c && d()), d
    }

    function SD(r, e) {
        e && e.pendingBranch ? Ki(r) ? e.effects.push(...r) : e.effects.push(r) : hD(r)
    }
    let Bd = null; {
        const r = yd(),
            e = (t, n) => {
                let i;
                return (i = r[t]) || (i = r[t] = []), i.push(n), s => {
                    i.length > 1 ? i.forEach(a => a(s)) : i[0](s)
                }
            };
        e("__VUE_INSTANCE_SETTERS__", t => Bd = t), e("__VUE_SSR_SETTERS__", t => kd = t)
    }
    let kd = !1;

    function Vu(r, e) {
        return sD(r)
    }
    typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;

    function MD(...r) {
        if (r.length === 2) {
            const [e, t] = r;
            e.value = t
        }
        if (r.length === 3) {
            const [e, t, n] = r;
            e[t] = n
        }
    }
    const TD = `
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump;
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`,
        ED = `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        csm_Bump = vec3(0.0);
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`,
        wD = `
    varying mat4 csm_internal_vModelViewMatrix;
`,
        AD = `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,
        DD = `
    varying mat4 csm_internal_vModelViewMatrix;
`,
        CD = `
    
`,
        Ne = {
            diffuse: "csm_DiffuseColor",
            roughness: "csm_Roughness",
            metalness: "csm_Metalness",
            emissive: "csm_Emissive",
            ao: "csm_AO",
            bump: "csm_Bump",
            fragNormal: "csm_FragNormal",
            clearcoat: "csm_Clearcoat",
            clearcoatRoughness: "csm_ClearcoatRoughness",
            clearcoatNormal: "csm_ClearcoatNormal",
            transmission: "csm_Transmission",
            thickness: "csm_Thickness",
            iridescence: "csm_Iridescence",
            pointSize: "csm_PointSize",
            fragColor: "csm_FragColor",
            depthAlpha: "csm_DepthAlpha",
            unlitFac: "csm_UnlitFac",
            position: "csm_Position",
            positionRaw: "csm_PositionRaw",
            normal: "csm_Normal"
        },
        RD = {
            [`${Ne.position}`]: "*",
            [`${Ne.positionRaw}`]: "*",
            [`${Ne.normal}`]: "*",
            [`${Ne.depthAlpha}`]: "*",
            [`${Ne.pointSize}`]: ["PointsMaterial"],
            [`${Ne.diffuse}`]: "*",
            [`${Ne.fragColor}`]: "*",
            [`${Ne.fragNormal}`]: "*",
            [`${Ne.unlitFac}`]: "*",
            [`${Ne.emissive}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.roughness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.metalness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.iridescence}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
            [`${Ne.ao}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"],
            [`${Ne.bump}`]: ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"],
            [`${Ne.clearcoat}`]: ["MeshPhysicalMaterial"],
            [`${Ne.clearcoatRoughness}`]: ["MeshPhysicalMaterial"],
            [`${Ne.clearcoatNormal}`]: ["MeshPhysicalMaterial"],
            [`${Ne.transmission}`]: ["MeshPhysicalMaterial"],
            [`${Ne.thickness}`]: ["MeshPhysicalMaterial"]
        },
        PD = {
            "*": {
                "#include <lights_physical_fragment>": ot.lights_physical_fragment,
                "#include <transmission_fragment>": ot.transmission_fragment
            },
            [`${Ne.normal}`]: {
                "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${Ne.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
            },
            [`${Ne.position}`]: {
                "#include <begin_vertex>": `
    vec3 transformed = ${Ne.position};
  `
            },
            [`${Ne.positionRaw}`]: {
                "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = ${Ne.positionRaw};
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `
            },
            [`${Ne.pointSize}`]: {
                "gl_PointSize = size;": `
    gl_PointSize = ${Ne.pointSize};
    `
            },
            [`${Ne.diffuse}`]: {
                "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${Ne.diffuse};
  `
            },
            [`${Ne.fragColor}`]: {
                "#include <opaque_fragment>": `
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${Ne.fragColor}, ${Ne.unlitFac});
  `
            },
            [`${Ne.emissive}`]: {
                "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${Ne.emissive};
    `
            },
            [`${Ne.roughness}`]: {
                "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${Ne.roughness};
    `
            },
            [`${Ne.metalness}`]: {
                "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${Ne.metalness};
    `
            },
            [`${Ne.ao}`]: {
                "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${Ne.ao};
    `
            },
            [`${Ne.bump}`]: {
                "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = ${Ne.bump} - (dot(${Ne.bump}, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `
            },
            [`${Ne.fragNormal}`]: {
                "#include <normal_fragment_maps>": `
      #include <normal_fragment_maps>
      normal = ${Ne.fragNormal};
    `
            },
            [`${Ne.depthAlpha}`]: {
                "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${Ne.depthAlpha} );
    `,
                "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      if(${Ne.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,
                "gl_FragColor = packDepthToRGBA( dist );": `
      if(${Ne.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `
            },
            [`${Ne.clearcoat}`]: {
                "material.clearcoat = clearcoat;": `material.clearcoat = ${Ne.clearcoat};`
            },
            [`${Ne.clearcoatRoughness}`]: {
                "material.clearcoatRoughness = clearcoatRoughness;": `material.clearcoatRoughness = ${Ne.clearcoatRoughness};`
            },
            [`${Ne.clearcoatNormal}`]: {
                "#include <clearcoat_normal_fragment_begin>": `
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `
            },
            [`${Ne.transmission}`]: {
                "material.transmission = transmission;": `
      material.transmission = ${Ne.transmission};
    `
            },
            [`${Ne.thickness}`]: {
                "material.thickness = thickness;": `
      material.thickness = ${Ne.thickness};
    `
            },
            [`${Ne.iridescence}`]: {
                "material.iridescence = iridescence;": `
      material.iridescence = ${Ne.iridescence};
    `
            }
        },
        FD = {
            clearcoat: [Ne.clearcoat, Ne.clearcoatNormal, Ne.clearcoatRoughness],
            transmission: [Ne.transmission],
            iridescence: [Ne.iridescence]
        };

    function ID(r) {
        let e = 0;
        for (let n = 0; n < r.length; n++) e = r.charCodeAt(n) + (e << 6) + (e << 16) - e;
        const t = e >>> 0;
        return String(t)
    }

    function LD(r) {
        try {
            new r
        } catch (e) {
            if (e.message.indexOf("is not a constructor") >= 0) return !1
        }
        return !0
    }

    function Ib(r) {
        return r.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "")
    }
    class ND extends Ei {
        constructor({
            baseMaterial: e,
            vertexShader: t,
            fragmentShader: n,
            uniforms: i,
            patchMap: s,
            cacheKey: a,
            ...o
        }) {
            if (!e) throw new Error("CustomShaderMaterial: baseMaterial is required.");
            let c;
            if (LD(e)) {
                const d = Object.keys(o).length === 0;
                c = new e(d ? void 0 : o)
            } else c = e, Object.assign(c, o);
            if (["ShaderMaterial", "RawShaderMaterial"].includes(c.type)) throw new Error(`CustomShaderMaterial does not support ${c.type} as a base material.`);
            super(), this.uniforms = {}, this.vertexShader = "", this.fragmentShader = "";
            const l = c;
            l.name = `CustomShaderMaterial<${c.name||c.type}>`, l.update = this.update.bind(l), l.__csm = {
                prevOnBeforeCompile: c.onBeforeCompile,
                baseMaterial: c,
                vertexShader: t,
                fragmentShader: n,
                uniforms: i,
                patchMap: s,
                cacheKey: a
            };
            const f = { ...l.uniforms || {},
                ...i || {}
            };
            l.uniforms = this.uniforms = f, l.vertexShader = this.vertexShader = t || "", l.fragmentShader = this.fragmentShader = n || "", l.update({
                fragmentShader: l.fragmentShader,
                vertexShader: l.vertexShader,
                uniforms: l.uniforms,
                patchMap: s,
                cacheKey: a
            }), Object.assign(this, l);
            const h = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(l));
            for (const d in h) {
                const u = h[d];
                (u.get || u.set) && Object.defineProperty(this, d, u)
            }
            return Object.defineProperty(this, "type", {
                get() {
                    return c.type
                },
                set(d) {
                    c.type = d
                }
            }), this
        }
        update({
            fragmentShader: e,
            vertexShader: t,
            uniforms: n,
            cacheKey: i,
            patchMap: s
        }) {
            const a = Ib(t || ""),
                o = Ib(e || ""),
                c = this;
            n && (c.uniforms = n), t && (c.vertexShader = t), e && (c.fragmentShader = e), Object.entries(FD).forEach(([d, u]) => {
                for (const _ in u) {
                    const g = u[_];
                    (o && o.includes(g) || a && a.includes(g)) && (c[d] || (c[d] = 1))
                }
            });
            const l = c.__csm.prevOnBeforeCompile,
                f = (d, u, _) => {
                    let g, m = "";
                    if (u) {
                        const p = u.search(/void\s+main\s*\(\s*\)\s*{/);
                        if (p !== -1) {
                            m = u.slice(0, p);
                            let v = 0,
                                x = -1;
                            for (let b = p; b < u.length; b++)
                                if (u[b] === "{" && v++, u[b] === "}" && (v--, v === 0)) {
                                    x = b;
                                    break
                                }
                            if (x !== -1) {
                                const b = u.slice(p, x + 1);
                                g = b.slice(b.indexOf("{") + 1, -1)
                            }
                        } else m = u
                    }
                    if (_ && u && u.includes(Ne.fragColor) && g && (g = `csm_UnlitFac = 1.0;
` + g), d.includes("//~CSM_DEFAULTS")) {
                        d = d.replace("void main() {", `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${m}
          
          void main() {
          `);
                        const p = d.lastIndexOf("//~CSM_MAIN_END");
                        if (p !== -1) {
                            const v = `
            ${g?`${g}`:""}
            //~CSM_MAIN_END
          `;
                            d = d.slice(0, p) + v + d.slice(p)
                        }
                    } else {
                        const p = /void\s*main\s*\(\s*\)\s*{/gm;
                        d = d.replace(p, `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${_?DD:wD}
          ${TD}
  
          ${m}
          
          void main() {
            {
              ${ED}
            }
            ${_?CD:AD}

            ${g?`${g}`:""}
            //~CSM_MAIN_END
          `)
                    }
                    return d
                };
            c.onBeforeCompile = (d, u) => {
                l ? .(d, u);
                const _ = s || {},
                    g = c.type,
                    m = g ? `#define IS_${g.toUpperCase()};
` : `#define IS_UNKNOWN;
`;
                d.vertexShader = m + `#define IS_VERTEX
` + d.vertexShader, d.fragmentShader = m + `#define IS_FRAGMENT
` + d.fragmentShader;
                const p = v => {
                    for (const x in v) {
                        const b = x === "*" || a && a.includes(x);
                        if (x === "*" || o && o.includes(x) || b) {
                            const S = RD[x];
                            if (S && S !== "*" && (Array.isArray(S) ? !S.includes(g) : S !== g)) {
                                console.error(`CustomShaderMaterial: ${x} is not available in ${g}. Shader cannot compile.`);
                                return
                            }
                            const E = v[x];
                            for (const T in E) {
                                const w = E[T];
                                if (typeof w == "object") {
                                    const M = w.type,
                                        y = w.value;
                                    M === "fs" ? d.fragmentShader = d.fragmentShader.replace(T, y) : M === "vs" && (d.vertexShader = d.vertexShader.replace(T, y))
                                } else w && (d.vertexShader = d.vertexShader.replace(T, w), d.fragmentShader = d.fragmentShader.replace(T, w))
                            }
                        }
                    }
                };
                p(PD), p(_), d.vertexShader = f(d.vertexShader, a, !1), d.fragmentShader = f(d.fragmentShader, o, !0), n && (d.uniforms = { ...d.uniforms,
                    ...c.uniforms
                }), c.uniforms = d.uniforms
            };
            const h = c.customProgramCacheKey;
            c.customProgramCacheKey = () => (i ? .() || ID((a || "") + (o || ""))) + h ? .call(c), c.needsUpdate = !0
        }
        clone() {
            const e = this;
            return new e.constructor({
                baseMaterial: e.__csm.baseMaterial.clone(),
                vertexShader: e.__csm.vertexShader,
                fragmentShader: e.__csm.fragmentShader,
                uniforms: e.__csm.uniforms,
                patchMap: e.__csm.patchMap,
                cacheKey: e.__csm.cacheKey
            })
        }
    }
    const Lb = 0,
        UD = 1,
        OD = 2,
        Nb = 2,
        zd = 1.25,
        Ub = 1,
        Uc = 6 * 4 + 4 + 4,
        Wu = 65535,
        BD = Math.pow(2, -24),
        Gd = Symbol("SKIP_GENERATION");

    function kD(r) {
        return r.index ? r.index.count : r.attributes.position.count
    }

    function mo(r) {
        return kD(r) / 3
    }

    function zD(r, e = ArrayBuffer) {
        return r > 65535 ? new Uint32Array(new e(4 * r)) : new Uint16Array(new e(2 * r))
    }

    function GD(r, e) {
        if (!r.index) {
            const t = r.attributes.position.count,
                n = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
                i = zD(t, n);
            r.setIndex(new Zt(i, 1));
            for (let s = 0; s < t; s++) i[s] = s
        }
    }

    function Ob(r, e) {
        const t = mo(r),
            n = e || r.drawRange,
            i = n.start / 3,
            s = (n.start + n.count) / 3,
            a = Math.max(0, i),
            o = Math.min(t, s) - a;
        return [{
            offset: Math.floor(a),
            count: Math.floor(o)
        }]
    }

    function Bb(r, e) {
        if (!r.groups || !r.groups.length) return Ob(r, e);
        const t = [],
            n = new Set,
            i = e || r.drawRange,
            s = i.start / 3,
            a = (i.start + i.count) / 3;
        for (const c of r.groups) {
            const l = c.start / 3,
                f = (c.start + c.count) / 3;
            n.add(Math.max(s, l)), n.add(Math.min(a, f))
        }
        const o = Array.from(n.values()).sort((c, l) => c - l);
        for (let c = 0; c < o.length - 1; c++) {
            const l = o[c],
                f = o[c + 1];
            t.push({
                offset: Math.floor(l),
                count: Math.floor(f - l)
            })
        }
        return t
    }

    function HD(r, e) {
        const t = mo(r),
            n = Bb(r, e).sort((a, o) => a.offset - o.offset),
            i = n[n.length - 1];
        i.count = Math.min(t - i.offset, i.count);
        let s = 0;
        return n.forEach(({
            count: a
        }) => s += a), t !== s
    }

    function Hd(r, e, t, n, i) {
        let s = 1 / 0,
            a = 1 / 0,
            o = 1 / 0,
            c = -1 / 0,
            l = -1 / 0,
            f = -1 / 0,
            h = 1 / 0,
            d = 1 / 0,
            u = 1 / 0,
            _ = -1 / 0,
            g = -1 / 0,
            m = -1 / 0;
        for (let p = e * 6, v = (e + t) * 6; p < v; p += 6) {
            const x = r[p + 0],
                b = r[p + 1],
                S = x - b,
                E = x + b;
            S < s && (s = S), E > c && (c = E), x < h && (h = x), x > _ && (_ = x);
            const T = r[p + 2],
                w = r[p + 3],
                M = T - w,
                y = T + w;
            M < a && (a = M), y > l && (l = y), T < d && (d = T), T > g && (g = T);
            const D = r[p + 4],
                R = r[p + 5],
                P = D - R,
                O = D + R;
            P < o && (o = P), O > f && (f = O), D < u && (u = D), D > m && (m = D)
        }
        n[0] = s, n[1] = a, n[2] = o, n[3] = c, n[4] = l, n[5] = f, i[0] = h, i[1] = d, i[2] = u, i[3] = _, i[4] = g, i[5] = m
    }

    function VD(r, e = null, t = null, n = null) {
        const i = r.attributes.position,
            s = r.index ? r.index.array : null,
            a = mo(r),
            o = i.normalized;
        let c;
        e === null ? (c = new Float32Array(a * 6), t = 0, n = a) : (c = e, t = t || 0, n = n || a);
        const l = i.array,
            f = i.offset || 0;
        let h = 3;
        i.isInterleavedBufferAttribute && (h = i.data.stride);
        const d = ["getX", "getY", "getZ"];
        for (let u = t; u < t + n; u++) {
            const _ = u * 3,
                g = u * 6;
            let m = _ + 0,
                p = _ + 1,
                v = _ + 2;
            s && (m = s[m], p = s[p], v = s[v]), o || (m = m * h + f, p = p * h + f, v = v * h + f);
            for (let x = 0; x < 3; x++) {
                let b, S, E;
                o ? (b = i[d[x]](m), S = i[d[x]](p), E = i[d[x]](v)) : (b = l[m + x], S = l[p + x], E = l[v + x]);
                let T = b;
                S < T && (T = S), E < T && (T = E);
                let w = b;
                S > w && (w = S), E > w && (w = E);
                const M = (w - T) / 2,
                    y = x * 2;
                c[g + y + 0] = T + M, c[g + y + 1] = M + (Math.abs(T) + M) * BD
            }
        }
        return c
    }

    function Yt(r, e, t) {
        return t.min.x = e[r], t.min.y = e[r + 1], t.min.z = e[r + 2], t.max.x = e[r + 3], t.max.y = e[r + 4], t.max.z = e[r + 5], t
    }

    function kb(r) {
        let e = -1,
            t = -1 / 0;
        for (let n = 0; n < 3; n++) {
            const i = r[n + 3] - r[n];
            i > t && (t = i, e = n)
        }
        return e
    }

    function zb(r, e) {
        e.set(r)
    }

    function Gb(r, e, t) {
        let n, i;
        for (let s = 0; s < 3; s++) {
            const a = s + 3;
            n = r[s], i = e[s], t[s] = n < i ? n : i, n = r[a], i = e[a], t[a] = n > i ? n : i
        }
    }

    function Xu(r, e, t) {
        for (let n = 0; n < 3; n++) {
            const i = e[r + 2 * n],
                s = e[r + 2 * n + 1],
                a = i - s,
                o = i + s;
            a < t[n] && (t[n] = a), o > t[n + 3] && (t[n + 3] = o)
        }
    }

    function Oc(r) {
        const e = r[3] - r[0],
            t = r[4] - r[1],
            n = r[5] - r[2];
        return 2 * (e * t + t * n + n * e)
    }
    const Gr = 32,
        WD = (r, e) => r.candidate - e.candidate,
        vs = new Array(Gr).fill().map(() => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0
        })),
        ju = new Float32Array(6);

    function XD(r, e, t, n, i, s) {
        let a = -1,
            o = 0;
        if (s === Lb) a = kb(e), a !== -1 && (o = (e[a] + e[a + 3]) / 2);
        else if (s === UD) a = kb(r), a !== -1 && (o = jD(t, n, i, a));
        else if (s === OD) {
            const c = Oc(r);
            let l = zd * i;
            const f = n * 6,
                h = (n + i) * 6;
            for (let d = 0; d < 3; d++) {
                const u = e[d],
                    m = (e[d + 3] - u) / Gr;
                if (i < Gr / 4) {
                    const p = [...vs];
                    p.length = i;
                    let v = 0;
                    for (let b = f; b < h; b += 6, v++) {
                        const S = p[v];
                        S.candidate = t[b + 2 * d], S.count = 0;
                        const {
                            bounds: E,
                            leftCacheBounds: T,
                            rightCacheBounds: w
                        } = S;
                        for (let M = 0; M < 3; M++) w[M] = 1 / 0, w[M + 3] = -1 / 0, T[M] = 1 / 0, T[M + 3] = -1 / 0, E[M] = 1 / 0, E[M + 3] = -1 / 0;
                        Xu(b, t, E)
                    }
                    p.sort(WD);
                    let x = i;
                    for (let b = 0; b < x; b++) {
                        const S = p[b];
                        for (; b + 1 < x && p[b + 1].candidate === S.candidate;) p.splice(b + 1, 1), x--
                    }
                    for (let b = f; b < h; b += 6) {
                        const S = t[b + 2 * d];
                        for (let E = 0; E < x; E++) {
                            const T = p[E];
                            S >= T.candidate ? Xu(b, t, T.rightCacheBounds) : (Xu(b, t, T.leftCacheBounds), T.count++)
                        }
                    }
                    for (let b = 0; b < x; b++) {
                        const S = p[b],
                            E = S.count,
                            T = i - S.count,
                            w = S.leftCacheBounds,
                            M = S.rightCacheBounds;
                        let y = 0;
                        E !== 0 && (y = Oc(w) / c);
                        let D = 0;
                        T !== 0 && (D = Oc(M) / c);
                        const R = Ub + zd * (y * E + D * T);
                        R < l && (a = d, l = R, o = S.candidate)
                    }
                } else {
                    for (let x = 0; x < Gr; x++) {
                        const b = vs[x];
                        b.count = 0, b.candidate = u + m + x * m;
                        const S = b.bounds;
                        for (let E = 0; E < 3; E++) S[E] = 1 / 0, S[E + 3] = -1 / 0
                    }
                    for (let x = f; x < h; x += 6) {
                        let E = ~~((t[x + 2 * d] - u) / m);
                        E >= Gr && (E = Gr - 1);
                        const T = vs[E];
                        T.count++, Xu(x, t, T.bounds)
                    }
                    const p = vs[Gr - 1];
                    zb(p.bounds, p.rightCacheBounds);
                    for (let x = Gr - 2; x >= 0; x--) {
                        const b = vs[x],
                            S = vs[x + 1];
                        Gb(b.bounds, S.rightCacheBounds, b.rightCacheBounds)
                    }
                    let v = 0;
                    for (let x = 0; x < Gr - 1; x++) {
                        const b = vs[x],
                            S = b.count,
                            E = b.bounds,
                            w = vs[x + 1].rightCacheBounds;
                        S !== 0 && (v === 0 ? zb(E, ju) : Gb(E, ju, ju)), v += S;
                        let M = 0,
                            y = 0;
                        v !== 0 && (M = Oc(ju) / c);
                        const D = i - v;
                        D !== 0 && (y = Oc(w) / c);
                        const R = Ub + zd * (M * v + y * D);
                        R < l && (a = d, l = R, o = b.candidate)
                    }
                }
            }
        } else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);
        return {
            axis: a,
            pos: o
        }
    }

    function jD(r, e, t, n) {
        let i = 0;
        for (let s = e, a = e + t; s < a; s++) i += r[s * 6 + n * 2];
        return i / t
    }
    class Vd {
        constructor() {
            this.boundingData = new Float32Array(6)
        }
    }

    function qD(r, e, t, n, i, s) {
        let a = n,
            o = n + i - 1;
        const c = s.pos,
            l = s.axis * 2;
        for (;;) {
            for (; a <= o && t[a * 6 + l] < c;) a++;
            for (; a <= o && t[o * 6 + l] >= c;) o--;
            if (a < o) {
                for (let f = 0; f < 3; f++) {
                    let h = e[a * 3 + f];
                    e[a * 3 + f] = e[o * 3 + f], e[o * 3 + f] = h
                }
                for (let f = 0; f < 6; f++) {
                    let h = t[a * 6 + f];
                    t[a * 6 + f] = t[o * 6 + f], t[o * 6 + f] = h
                }
                a++, o--
            } else return a
        }
    }

    function YD(r, e, t, n, i, s) {
        let a = n,
            o = n + i - 1;
        const c = s.pos,
            l = s.axis * 2;
        for (;;) {
            for (; a <= o && t[a * 6 + l] < c;) a++;
            for (; a <= o && t[o * 6 + l] >= c;) o--;
            if (a < o) {
                let f = r[a];
                r[a] = r[o], r[o] = f;
                for (let h = 0; h < 6; h++) {
                    let d = t[a * 6 + h];
                    t[a * 6 + h] = t[o * 6 + h], t[o * 6 + h] = d
                }
                a++, o--
            } else return a
        }
    }

    function ii(r, e) {
        return e[r + 15] === 65535
    }

    function pi(r, e) {
        return e[r + 6]
    }

    function Di(r, e) {
        return e[r + 14]
    }

    function Ci(r) {
        return r + 8
    }

    function Ri(r, e) {
        return e[r + 6]
    }

    function Hb(r, e) {
        return e[r + 7]
    }

    function J2(r) {
        return r
    }
    let Vb, Bc, qu, Wb;
    const $D = Math.pow(2, 32);

    function Wd(r) {
        return "count" in r ? 1 : 1 + Wd(r.left) + Wd(r.right)
    }

    function KD(r, e, t) {
        return Vb = new Float32Array(t), Bc = new Uint32Array(t), qu = new Uint16Array(t), Wb = new Uint8Array(t), Xd(r, e)
    }

    function Xd(r, e) {
        const t = r / 4,
            n = r / 2,
            i = "count" in e,
            s = e.boundingData;
        for (let a = 0; a < 6; a++) Vb[t + a] = s[a];
        if (i)
            if (e.buffer) {
                const a = e.buffer;
                Wb.set(new Uint8Array(a), r);
                for (let o = r, c = r + a.byteLength; o < c; o += Uc) {
                    const l = o / 2;
                    ii(l, qu) || (Bc[o / 4 + 6] += t)
                }
                return r + a.byteLength
            } else {
                const a = e.offset,
                    o = e.count;
                return Bc[t + 6] = a, qu[n + 14] = o, qu[n + 15] = Wu, r + Uc
            }
        else {
            const a = e.left,
                o = e.right,
                c = e.splitAxis;
            let l;
            if (l = Xd(r + Uc, a), l / 4 > $D) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return Bc[t + 6] = l / 4, l = Xd(l, o), Bc[t + 7] = c, l
        }
    }

    function JD(r, e) {
        const t = (r.index ? r.index.count : r.attributes.position.count) / 3,
            n = t > 2 ** 16,
            i = n ? 4 : 2,
            s = e ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i),
            a = n ? new Uint32Array(s) : new Uint16Array(s);
        for (let o = 0, c = a.length; o < c; o++) a[o] = o;
        return a
    }

    function ZD(r, e, t, n, i) {
        const {
            maxDepth: s,
            verbose: a,
            maxLeafTris: o,
            strategy: c,
            onProgress: l,
            indirect: f
        } = i, h = r._indirectBuffer, d = r.geometry, u = d.index ? d.index.array : null, _ = f ? YD : qD, g = mo(d), m = new Float32Array(6);
        let p = !1;
        const v = new Vd;
        return Hd(e, t, n, v.boundingData, m), b(v, t, n, m), v;

        function x(S) {
            l && l(S / g)
        }

        function b(S, E, T, w = null, M = 0) {
            if (!p && M >= s && (p = !0, a && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`), console.warn(d))), T <= o || M >= s) return x(E + T), S.offset = E, S.count = T, S;
            const y = XD(S.boundingData, w, e, E, T, c);
            if (y.axis === -1) return x(E + T), S.offset = E, S.count = T, S;
            const D = _(h, u, e, E, T, y);
            if (D === E || D === E + T) x(E + T), S.offset = E, S.count = T;
            else {
                S.splitAxis = y.axis;
                const R = new Vd,
                    P = E,
                    O = D - E;
                S.left = R, Hd(e, P, O, R.boundingData, m), b(R, P, O, m, M + 1);
                const z = new Vd,
                    k = D,
                    X = T - O;
                S.right = z, Hd(e, k, X, z.boundingData, m), b(z, k, X, m, M + 1)
            }
            return S
        }
    }

    function QD(r, e) {
        const t = r.geometry;
        e.indirect && (r._indirectBuffer = JD(t, e.useSharedArrayBuffer), HD(t, e.range) && !e.verbose && console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), r._indirectBuffer || GD(t, e);
        const n = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
            i = VD(t),
            s = e.indirect ? Ob(t, e.range) : Bb(t, e.range);
        r._roots = s.map(a => {
            const o = ZD(r, i, a.offset, a.count, e),
                c = Wd(o),
                l = new n(Uc * c);
            return KD(0, o, l), l
        })
    }
    class Hr {
        constructor() {
            this.min = 1 / 0, this.max = -1 / 0
        }
        setFromPointsField(e, t) {
            let n = 1 / 0,
                i = -1 / 0;
            for (let s = 0, a = e.length; s < a; s++) {
                const c = e[s][t];
                n = c < n ? c : n, i = c > i ? c : i
            }
            this.min = n, this.max = i
        }
        setFromPoints(e, t) {
            let n = 1 / 0,
                i = -1 / 0;
            for (let s = 0, a = t.length; s < a; s++) {
                const o = t[s],
                    c = e.dot(o);
                n = c < n ? c : n, i = c > i ? c : i
            }
            this.min = n, this.max = i
        }
        isSeparated(e) {
            return this.min > e.max || e.min > this.max
        }
    }
    Hr.prototype.setFromBox = function() {
        const r = new B;
        return function(t, n) {
            const i = n.min,
                s = n.max;
            let a = 1 / 0,
                o = -1 / 0;
            for (let c = 0; c <= 1; c++)
                for (let l = 0; l <= 1; l++)
                    for (let f = 0; f <= 1; f++) {
                        r.x = i.x * c + s.x * (1 - c), r.y = i.y * l + s.y * (1 - l), r.z = i.z * f + s.z * (1 - f);
                        const h = t.dot(r);
                        a = Math.min(h, a), o = Math.max(h, o)
                    }
            this.min = a, this.max = o
        }
    }();
    const e1 = function() {
            const r = new B,
                e = new B,
                t = new B;
            return function(i, s, a) {
                const o = i.start,
                    c = r,
                    l = s.start,
                    f = e;
                t.subVectors(o, l), r.subVectors(i.end, i.start), e.subVectors(s.end, s.start);
                const h = t.dot(f),
                    d = f.dot(c),
                    u = f.dot(f),
                    _ = t.dot(c),
                    m = c.dot(c) * u - d * d;
                let p, v;
                m !== 0 ? p = (h * d - _ * u) / m : p = 0, v = (h + p * d) / u, a.x = p, a.y = v
            }
        }(),
        jd = function() {
            const r = new at,
                e = new B,
                t = new B;
            return function(i, s, a, o) {
                e1(i, s, r);
                let c = r.x,
                    l = r.y;
                if (c >= 0 && c <= 1 && l >= 0 && l <= 1) {
                    i.at(c, a), s.at(l, o);
                    return
                } else if (c >= 0 && c <= 1) {
                    l < 0 ? s.at(0, o) : s.at(1, o), i.closestPointToPoint(o, !0, a);
                    return
                } else if (l >= 0 && l <= 1) {
                    c < 0 ? i.at(0, a) : i.at(1, a), s.closestPointToPoint(a, !0, o);
                    return
                } else {
                    let f;
                    c < 0 ? f = i.start : f = i.end;
                    let h;
                    l < 0 ? h = s.start : h = s.end;
                    const d = e,
                        u = t;
                    if (i.closestPointToPoint(h, !0, e), s.closestPointToPoint(f, !0, t), d.distanceToSquared(h) <= u.distanceToSquared(f)) {
                        a.copy(d), o.copy(h);
                        return
                    } else {
                        a.copy(f), o.copy(u);
                        return
                    }
                }
            }
        }(),
        t1 = function() {
            const r = new B,
                e = new B,
                t = new Ur,
                n = new Br;
            return function(s, a) {
                const {
                    radius: o,
                    center: c
                } = s, {
                    a: l,
                    b: f,
                    c: h
                } = a;
                if (n.start = l, n.end = f, n.closestPointToPoint(c, !0, r).distanceTo(c) <= o || (n.start = l, n.end = h, n.closestPointToPoint(c, !0, r).distanceTo(c) <= o) || (n.start = f, n.end = h, n.closestPointToPoint(c, !0, r).distanceTo(c) <= o)) return !0;
                const g = a.getPlane(t);
                if (Math.abs(g.distanceToPoint(c)) <= o) {
                    const p = g.projectPoint(c, e);
                    if (a.containsPoint(p)) return !0
                }
                return !1
            }
        }(),
        n1 = 1e-15;

    function qd(r) {
        return Math.abs(r) < n1
    }
    class Qi extends Mn {
        constructor(...e) {
            super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new B), this.satBounds = new Array(4).fill().map(() => new Hr), this.points = [this.a, this.b, this.c], this.sphere = new Rn, this.plane = new Ur, this.needsUpdate = !0
        }
        intersectsSphere(e) {
            return t1(e, this)
        }
        update() {
            const e = this.a,
                t = this.b,
                n = this.c,
                i = this.points,
                s = this.satAxes,
                a = this.satBounds,
                o = s[0],
                c = a[0];
            this.getNormal(o), c.setFromPoints(o, i);
            const l = s[1],
                f = a[1];
            l.subVectors(e, t), f.setFromPoints(l, i);
            const h = s[2],
                d = a[2];
            h.subVectors(t, n), d.setFromPoints(h, i);
            const u = s[3],
                _ = a[3];
            u.subVectors(n, e), _.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, e), this.needsUpdate = !1
        }
    }
    Qi.prototype.closestPointToSegment = function() {
        const r = new B,
            e = new B,
            t = new Br;
        return function(i, s = null, a = null) {
            const {
                start: o,
                end: c
            } = i, l = this.points;
            let f, h = 1 / 0;
            for (let d = 0; d < 3; d++) {
                const u = (d + 1) % 3;
                t.start.copy(l[d]), t.end.copy(l[u]), jd(t, i, r, e), f = r.distanceToSquared(e), f < h && (h = f, s && s.copy(r), a && a.copy(e))
            }
            return this.closestPointToPoint(o, r), f = o.distanceToSquared(r), f < h && (h = f, s && s.copy(r), a && a.copy(o)), this.closestPointToPoint(c, r), f = c.distanceToSquared(r), f < h && (h = f, s && s.copy(r), a && a.copy(c)), Math.sqrt(h)
        }
    }(), Qi.prototype.intersectsTriangle = function() {
        const r = new Qi,
            e = new Array(3),
            t = new Array(3),
            n = new Hr,
            i = new Hr,
            s = new B,
            a = new B,
            o = new B,
            c = new B,
            l = new B,
            f = new Br,
            h = new Br,
            d = new Br,
            u = new B;

        function _(g, m, p) {
            const v = g.points;
            let x = 0,
                b = -1;
            for (let S = 0; S < 3; S++) {
                const {
                    start: E,
                    end: T
                } = f;
                E.copy(v[S]), T.copy(v[(S + 1) % 3]), f.delta(a);
                const w = qd(m.distanceToPoint(E));
                if (qd(m.normal.dot(a)) && w) {
                    p.copy(f), x = 2;
                    break
                }
                const M = m.intersectLine(f, u);
                if (!M && w && u.copy(E), (M || w) && !qd(u.distanceTo(T))) {
                    if (x <= 1)(x === 1 ? p.start : p.end).copy(u), w && (b = x);
                    else if (x >= 2) {
                        (b === 1 ? p.start : p.end).copy(u), x = 2;
                        break
                    }
                    if (x++, x === 2 && b === -1) break
                }
            }
            return x
        }
        return function(m, p = null, v = !1) {
            this.needsUpdate && this.update(), m.isExtendedTriangle ? m.needsUpdate && m.update() : (r.copy(m), r.update(), m = r);
            const x = this.plane,
                b = m.plane;
            if (Math.abs(x.normal.dot(b.normal)) > 1 - 1e-10) {
                const S = this.satBounds,
                    E = this.satAxes;
                t[0] = m.a, t[1] = m.b, t[2] = m.c;
                for (let M = 0; M < 4; M++) {
                    const y = S[M],
                        D = E[M];
                    if (n.setFromPoints(D, t), y.isSeparated(n)) return !1
                }
                const T = m.satBounds,
                    w = m.satAxes;
                e[0] = this.a, e[1] = this.b, e[2] = this.c;
                for (let M = 0; M < 4; M++) {
                    const y = T[M],
                        D = w[M];
                    if (n.setFromPoints(D, e), y.isSeparated(n)) return !1
                }
                for (let M = 0; M < 4; M++) {
                    const y = E[M];
                    for (let D = 0; D < 4; D++) {
                        const R = w[D];
                        if (s.crossVectors(y, R), n.setFromPoints(s, e), i.setFromPoints(s, t), n.isSeparated(i)) return !1
                    }
                }
                return p && (v || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), p.start.set(0, 0, 0), p.end.set(0, 0, 0)), !0
            } else {
                const S = _(this, b, h);
                if (S === 1 && m.containsPoint(h.end)) return p && (p.start.copy(h.end), p.end.copy(h.end)), !0;
                if (S !== 2) return !1;
                const E = _(m, x, d);
                if (E === 1 && this.containsPoint(d.end)) return p && (p.start.copy(d.end), p.end.copy(d.end)), !0;
                if (E !== 2) return !1;
                if (h.delta(o), d.delta(c), o.dot(c) < 0) {
                    let P = d.start;
                    d.start = d.end, d.end = P
                }
                const T = h.start.dot(o),
                    w = h.end.dot(o),
                    M = d.start.dot(o),
                    y = d.end.dot(o),
                    D = w < M,
                    R = T < y;
                return T !== y && M !== w && D === R ? !1 : (p && (l.subVectors(h.start, d.start), l.dot(o) > 0 ? p.start.copy(h.start) : p.start.copy(d.start), l.subVectors(h.end, d.end), l.dot(o) < 0 ? p.end.copy(h.end) : p.end.copy(d.end)), !0)
            }
        }
    }(), Qi.prototype.distanceToPoint = function() {
        const r = new B;
        return function(t) {
            return this.closestPointToPoint(t, r), t.distanceTo(r)
        }
    }(), Qi.prototype.distanceToTriangle = function() {
        const r = new B,
            e = new B,
            t = ["a", "b", "c"],
            n = new Br,
            i = new Br;
        return function(a, o = null, c = null) {
            const l = o || c ? n : null;
            if (this.intersectsTriangle(a, l)) return (o || c) && (o && l.getCenter(o), c && l.getCenter(c)), 0;
            let f = 1 / 0;
            for (let h = 0; h < 3; h++) {
                let d;
                const u = t[h],
                    _ = a[u];
                this.closestPointToPoint(_, r), d = _.distanceToSquared(r), d < f && (f = d, o && o.copy(r), c && c.copy(_));
                const g = this[u];
                a.closestPointToPoint(g, r), d = g.distanceToSquared(r), d < f && (f = d, o && o.copy(g), c && c.copy(r))
            }
            for (let h = 0; h < 3; h++) {
                const d = t[h],
                    u = t[(h + 1) % 3];
                n.set(this[d], this[u]);
                for (let _ = 0; _ < 3; _++) {
                    const g = t[_],
                        m = t[(_ + 1) % 3];
                    i.set(a[g], a[m]), jd(n, i, r, e);
                    const p = r.distanceToSquared(e);
                    p < f && (f = p, o && o.copy(r), c && c.copy(e))
                }
            }
            return Math.sqrt(f)
        }
    }();
    class Xn {
        constructor(e, t, n) {
            this.isOrientedBox = !0, this.min = new B, this.max = new B, this.matrix = new Ke, this.invMatrix = new Ke, this.points = new Array(8).fill().map(() => new B), this.satAxes = new Array(3).fill().map(() => new B), this.satBounds = new Array(3).fill().map(() => new Hr), this.alignedSatBounds = new Array(3).fill().map(() => new Hr), this.needsUpdate = !1, e && this.min.copy(e), t && this.max.copy(t), n && this.matrix.copy(n)
        }
        set(e, t, n) {
            this.min.copy(e), this.max.copy(t), this.matrix.copy(n), this.needsUpdate = !0
        }
        copy(e) {
            this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0
        }
    }
    Xn.prototype.update = function() {
        return function() {
            const e = this.matrix,
                t = this.min,
                n = this.max,
                i = this.points;
            for (let l = 0; l <= 1; l++)
                for (let f = 0; f <= 1; f++)
                    for (let h = 0; h <= 1; h++) {
                        const d = 1 * l | 2 * f | 4 * h,
                            u = i[d];
                        u.x = l ? n.x : t.x, u.y = f ? n.y : t.y, u.z = h ? n.z : t.z, u.applyMatrix4(e)
                    }
            const s = this.satBounds,
                a = this.satAxes,
                o = i[0];
            for (let l = 0; l < 3; l++) {
                const f = a[l],
                    h = s[l],
                    d = 1 << l,
                    u = i[d];
                f.subVectors(o, u), h.setFromPoints(f, i)
            }
            const c = this.alignedSatBounds;
            c[0].setFromPointsField(i, "x"), c[1].setFromPointsField(i, "y"), c[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1
        }
    }(), Xn.prototype.intersectsBox = function() {
        const r = new Hr;
        return function(t) {
            this.needsUpdate && this.update();
            const n = t.min,
                i = t.max,
                s = this.satBounds,
                a = this.satAxes,
                o = this.alignedSatBounds;
            if (r.min = n.x, r.max = i.x, o[0].isSeparated(r) || (r.min = n.y, r.max = i.y, o[1].isSeparated(r)) || (r.min = n.z, r.max = i.z, o[2].isSeparated(r))) return !1;
            for (let c = 0; c < 3; c++) {
                const l = a[c],
                    f = s[c];
                if (r.setFromBox(l, t), f.isSeparated(r)) return !1
            }
            return !0
        }
    }(), Xn.prototype.intersectsTriangle = function() {
        const r = new Qi,
            e = new Array(3),
            t = new Hr,
            n = new Hr,
            i = new B;
        return function(a) {
            this.needsUpdate && this.update(), a.isExtendedTriangle ? a.needsUpdate && a.update() : (r.copy(a), r.update(), a = r);
            const o = this.satBounds,
                c = this.satAxes;
            e[0] = a.a, e[1] = a.b, e[2] = a.c;
            for (let d = 0; d < 3; d++) {
                const u = o[d],
                    _ = c[d];
                if (t.setFromPoints(_, e), u.isSeparated(t)) return !1
            }
            const l = a.satBounds,
                f = a.satAxes,
                h = this.points;
            for (let d = 0; d < 3; d++) {
                const u = l[d],
                    _ = f[d];
                if (t.setFromPoints(_, h), u.isSeparated(t)) return !1
            }
            for (let d = 0; d < 3; d++) {
                const u = c[d];
                for (let _ = 0; _ < 4; _++) {
                    const g = f[_];
                    if (i.crossVectors(u, g), t.setFromPoints(i, e), n.setFromPoints(i, h), t.isSeparated(n)) return !1
                }
            }
            return !0
        }
    }(), Xn.prototype.closestPointToPoint = function() {
        return function(e, t) {
            return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t
        }
    }(), Xn.prototype.distanceToPoint = function() {
        const r = new B;
        return function(t) {
            return this.closestPointToPoint(t, r), t.distanceTo(r)
        }
    }(), Xn.prototype.distanceToBox = function() {
        const r = ["x", "y", "z"],
            e = new Array(12).fill().map(() => new Br),
            t = new Array(12).fill().map(() => new Br),
            n = new B,
            i = new B;
        return function(a, o = 0, c = null, l = null) {
            if (this.needsUpdate && this.update(), this.intersectsBox(a)) return (c || l) && (a.getCenter(i), this.closestPointToPoint(i, n), a.closestPointToPoint(n, i), c && c.copy(n), l && l.copy(i)), 0;
            const f = o * o,
                h = a.min,
                d = a.max,
                u = this.points;
            let _ = 1 / 0;
            for (let m = 0; m < 8; m++) {
                const p = u[m];
                i.copy(p).clamp(h, d);
                const v = p.distanceToSquared(i);
                if (v < _ && (_ = v, c && c.copy(p), l && l.copy(i), v < f)) return Math.sqrt(v)
            }
            let g = 0;
            for (let m = 0; m < 3; m++)
                for (let p = 0; p <= 1; p++)
                    for (let v = 0; v <= 1; v++) {
                        const x = (m + 1) % 3,
                            b = (m + 2) % 3,
                            S = p << x | v << b,
                            E = 1 << m | p << x | v << b,
                            T = u[S],
                            w = u[E];
                        e[g].set(T, w);
                        const y = r[m],
                            D = r[x],
                            R = r[b],
                            P = t[g],
                            O = P.start,
                            z = P.end;
                        O[y] = h[y], O[D] = p ? h[D] : d[D], O[R] = v ? h[R] : d[D], z[y] = d[y], z[D] = p ? h[D] : d[D], z[R] = v ? h[R] : d[D], g++
                    }
            for (let m = 0; m <= 1; m++)
                for (let p = 0; p <= 1; p++)
                    for (let v = 0; v <= 1; v++) {
                        i.x = m ? d.x : h.x, i.y = p ? d.y : h.y, i.z = v ? d.z : h.z, this.closestPointToPoint(i, n);
                        const x = i.distanceToSquared(n);
                        if (x < _ && (_ = x, c && c.copy(n), l && l.copy(i), x < f)) return Math.sqrt(x)
                    }
            for (let m = 0; m < 12; m++) {
                const p = e[m];
                for (let v = 0; v < 12; v++) {
                    const x = t[v];
                    jd(p, x, n, i);
                    const b = n.distanceToSquared(i);
                    if (b < _ && (_ = b, c && c.copy(n), l && l.copy(i), b < f)) return Math.sqrt(b)
                }
            }
            return Math.sqrt(_)
        }
    }();
    class Yd {
        constructor(e) {
            this._getNewPrimitive = e, this._primitives = []
        }
        getPrimitive() {
            const e = this._primitives;
            return e.length === 0 ? this._getNewPrimitive() : e.pop()
        }
        releasePrimitive(e) {
            this._primitives.push(e)
        }
    }
    class i1 extends Yd {
        constructor() {
            super(() => new Qi)
        }
    }
    const Pi = new i1;
    class r1 {
        constructor() {
            this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
            const e = [];
            let t = null;
            this.setBuffer = n => {
                t && e.push(t), t = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n)
            }, this.clearBuffer = () => {
                t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, e.length !== 0 && this.setBuffer(e.pop())
            }
        }
    }
    const Nt = new r1;
    let ys, go;
    const _o = [],
        Yu = new Yd(() => new Gt);

    function s1(r, e, t, n, i, s) {
        ys = Yu.getPrimitive(), go = Yu.getPrimitive(), _o.push(ys, go), Nt.setBuffer(r._roots[e]);
        const a = $d(0, r.geometry, t, n, i, s);
        Nt.clearBuffer(), Yu.releasePrimitive(ys), Yu.releasePrimitive(go), _o.pop(), _o.pop();
        const o = _o.length;
        return o > 0 && (go = _o[o - 1], ys = _o[o - 2]), a
    }

    function $d(r, e, t, n, i = null, s = 0, a = 0) {
        const {
            float32Array: o,
            uint16Array: c,
            uint32Array: l
        } = Nt;
        let f = r * 2;
        if (ii(f, c)) {
            const d = pi(r, l),
                u = Di(f, c);
            return Yt(r, o, ys), n(d, u, !1, a, s + r, ys)
        } else {
            let y = function(R) {
                    const {
                        uint16Array: P,
                        uint32Array: O
                    } = Nt;
                    let z = R * 2;
                    for (; !ii(z, P);) R = Ci(R), z = R * 2;
                    return pi(R, O)
                },
                D = function(R) {
                    const {
                        uint16Array: P,
                        uint32Array: O
                    } = Nt;
                    let z = R * 2;
                    for (; !ii(z, P);) R = Ri(R, O), z = R * 2;
                    return pi(R, O) + Di(z, P)
                };
            const d = Ci(r),
                u = Ri(r, l);
            let _ = d,
                g = u,
                m, p, v, x;
            if (i && (v = ys, x = go, Yt(_, o, v), Yt(g, o, x), m = i(v), p = i(x), p < m)) {
                _ = u, g = d;
                const R = m;
                m = p, p = R, v = x
            }
            v || (v = ys, Yt(_, o, v));
            const b = ii(_ * 2, c),
                S = t(v, b, m, a + 1, s + _);
            let E;
            if (S === Nb) {
                const R = y(_),
                    O = D(_) - R;
                E = n(R, O, !0, a + 1, s + _, v)
            } else E = S && $d(_, e, t, n, i, s, a + 1);
            if (E) return !0;
            x = go, Yt(g, o, x);
            const T = ii(g * 2, c),
                w = t(x, T, p, a + 1, s + g);
            let M;
            if (w === Nb) {
                const R = y(g),
                    O = D(g) - R;
                M = n(R, O, !0, a + 1, s + g, x)
            } else M = w && $d(g, e, t, n, i, s, a + 1);
            return !!M
        }
    }
    const kc = new B,
        Kd = new B;

    function a1(r, e, t = {}, n = 0, i = 1 / 0) {
        const s = n * n,
            a = i * i;
        let o = 1 / 0,
            c = null;
        if (r.shapecast({
                boundsTraverseOrder: f => (kc.copy(e).clamp(f.min, f.max), kc.distanceToSquared(e)),
                intersectsBounds: (f, h, d) => d < o && d < a,
                intersectsTriangle: (f, h) => {
                    f.closestPointToPoint(e, kc);
                    const d = e.distanceToSquared(kc);
                    return d < o && (Kd.copy(kc), o = d, c = h), d < s
                }
            }), o === 1 / 0) return null;
        const l = Math.sqrt(o);
        return t.point ? t.point.copy(Kd) : t.point = Kd.clone(), t.distance = l, t.faceIndex = c, t
    }
    const o1 = parseInt(Jl) >= 169,
        aa = new B,
        oa = new B,
        ca = new B,
        $u = new at,
        Ku = new at,
        Ju = new at,
        Xb = new B,
        jb = new B,
        qb = new B,
        zc = new B;

    function c1(r, e, t, n, i, s, a, o) {
        let c;
        if (s === 1 ? c = r.intersectTriangle(n, t, e, !0, i) : c = r.intersectTriangle(e, t, n, s !== 2, i), c === null) return null;
        const l = r.origin.distanceTo(i);
        return l < a || l > o ? null : {
            distance: l,
            point: i.clone()
        }
    }

    function l1(r, e, t, n, i, s, a, o, c, l, f) {
        aa.fromBufferAttribute(e, s), oa.fromBufferAttribute(e, a), ca.fromBufferAttribute(e, o);
        const h = c1(r, aa, oa, ca, zc, c, l, f);
        if (h) {
            const d = new B;
            Mn.getBarycoord(zc, aa, oa, ca, d), n && ($u.fromBufferAttribute(n, s), Ku.fromBufferAttribute(n, a), Ju.fromBufferAttribute(n, o), h.uv = Mn.getInterpolation(zc, aa, oa, ca, $u, Ku, Ju, new at)), i && ($u.fromBufferAttribute(i, s), Ku.fromBufferAttribute(i, a), Ju.fromBufferAttribute(i, o), h.uv1 = Mn.getInterpolation(zc, aa, oa, ca, $u, Ku, Ju, new at)), t && (Xb.fromBufferAttribute(t, s), jb.fromBufferAttribute(t, a), qb.fromBufferAttribute(t, o), h.normal = Mn.getInterpolation(zc, aa, oa, ca, Xb, jb, qb, new B), h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
            const u = {
                a: s,
                b: a,
                c: o,
                normal: new B,
                materialIndex: 0
            };
            Mn.getNormal(aa, oa, ca, u.normal), h.face = u, h.faceIndex = s, o1 && (h.barycoord = d)
        }
        return h
    }

    function Zu(r, e, t, n, i, s, a) {
        const o = n * 3;
        let c = o + 0,
            l = o + 1,
            f = o + 2;
        const h = r.index;
        r.index && (c = h.getX(c), l = h.getX(l), f = h.getX(f));
        const {
            position: d,
            normal: u,
            uv: _,
            uv1: g
        } = r.attributes, m = l1(t, d, u, _, g, c, l, f, e, s, a);
        return m ? (m.faceIndex = n, i && i.push(m), m) : null
    }

    function nn(r, e, t, n) {
        const i = r.a,
            s = r.b,
            a = r.c;
        let o = e,
            c = e + 1,
            l = e + 2;
        t && (o = t.getX(o), c = t.getX(c), l = t.getX(l)), i.x = n.getX(o), i.y = n.getY(o), i.z = n.getZ(o), s.x = n.getX(c), s.y = n.getY(c), s.z = n.getZ(c), a.x = n.getX(l), a.y = n.getY(l), a.z = n.getZ(l)
    }

    function u1(r, e, t, n, i, s, a, o) {
        const {
            geometry: c,
            _indirectBuffer: l
        } = r;
        for (let f = n, h = n + i; f < h; f++) Zu(c, e, t, f, s, a, o)
    }

    function f1(r, e, t, n, i, s, a) {
        const {
            geometry: o,
            _indirectBuffer: c
        } = r;
        let l = 1 / 0,
            f = null;
        for (let h = n, d = n + i; h < d; h++) {
            let u;
            u = Zu(o, e, t, h, null, s, a), u && u.distance < l && (f = u, l = u.distance)
        }
        return f
    }

    function h1(r, e, t, n, i, s, a) {
        const {
            geometry: o
        } = t, {
            index: c
        } = o, l = o.attributes.position;
        for (let f = r, h = e + r; f < h; f++) {
            let d;
            if (d = f, nn(a, d * 3, c, l), a.needsUpdate = !0, n(a, d, i, s)) return !0
        }
        return !1
    }

    function d1(r, e = null) {
        e && Array.isArray(e) && (e = new Set(e));
        const t = r.geometry,
            n = t.index ? t.index.array : null,
            i = t.attributes.position;
        let s, a, o, c, l = 0;
        const f = r._roots;
        for (let d = 0, u = f.length; d < u; d++) s = f[d], a = new Uint32Array(s), o = new Uint16Array(s), c = new Float32Array(s), h(0, l), l += s.byteLength;

        function h(d, u, _ = !1) {
            const g = d * 2;
            if (o[g + 15] === Wu) {
                const p = a[d + 6],
                    v = o[g + 14];
                let x = 1 / 0,
                    b = 1 / 0,
                    S = 1 / 0,
                    E = -1 / 0,
                    T = -1 / 0,
                    w = -1 / 0;
                for (let M = 3 * p, y = 3 * (p + v); M < y; M++) {
                    let D = n[M];
                    const R = i.getX(D),
                        P = i.getY(D),
                        O = i.getZ(D);
                    R < x && (x = R), R > E && (E = R), P < b && (b = P), P > T && (T = P), O < S && (S = O), O > w && (w = O)
                }
                return c[d + 0] !== x || c[d + 1] !== b || c[d + 2] !== S || c[d + 3] !== E || c[d + 4] !== T || c[d + 5] !== w ? (c[d + 0] = x, c[d + 1] = b, c[d + 2] = S, c[d + 3] = E, c[d + 4] = T, c[d + 5] = w, !0) : !1
            } else {
                const p = d + 8,
                    v = a[d + 6],
                    x = p + u,
                    b = v + u;
                let S = _,
                    E = !1,
                    T = !1;
                e ? S || (E = e.has(x), T = e.has(b), S = !E && !T) : (E = !0, T = !0);
                const w = S || E,
                    M = S || T;
                let y = !1;
                w && (y = h(p, u, S));
                let D = !1;
                M && (D = h(v, u, S));
                const R = y || D;
                if (R)
                    for (let P = 0; P < 3; P++) {
                        const O = p + P,
                            z = v + P,
                            k = c[O],
                            X = c[O + 3],
                            V = c[z],
                            H = c[z + 3];
                        c[d + P] = k < V ? k : V, c[d + P + 3] = X > H ? X : H
                    }
                return R
            }
        }
    }

    function Ss(r, e, t, n, i) {
        let s, a, o, c, l, f;
        const h = 1 / t.direction.x,
            d = 1 / t.direction.y,
            u = 1 / t.direction.z,
            _ = t.origin.x,
            g = t.origin.y,
            m = t.origin.z;
        let p = e[r],
            v = e[r + 3],
            x = e[r + 1],
            b = e[r + 3 + 1],
            S = e[r + 2],
            E = e[r + 3 + 2];
        return h >= 0 ? (s = (p - _) * h, a = (v - _) * h) : (s = (v - _) * h, a = (p - _) * h), d >= 0 ? (o = (x - g) * d, c = (b - g) * d) : (o = (b - g) * d, c = (x - g) * d), s > c || o > a || ((o > s || isNaN(s)) && (s = o), (c < a || isNaN(a)) && (a = c), u >= 0 ? (l = (S - m) * u, f = (E - m) * u) : (l = (E - m) * u, f = (S - m) * u), s > f || l > a) ? !1 : ((l > s || s !== s) && (s = l), (f < a || a !== a) && (a = f), s <= i && a >= n)
    }

    function p1(r, e, t, n, i, s, a, o) {
        const {
            geometry: c,
            _indirectBuffer: l
        } = r;
        for (let f = n, h = n + i; f < h; f++) {
            let d = l ? l[f] : f;
            Zu(c, e, t, d, s, a, o)
        }
    }

    function m1(r, e, t, n, i, s, a) {
        const {
            geometry: o,
            _indirectBuffer: c
        } = r;
        let l = 1 / 0,
            f = null;
        for (let h = n, d = n + i; h < d; h++) {
            let u;
            u = Zu(o, e, t, c ? c[h] : h, null, s, a), u && u.distance < l && (f = u, l = u.distance)
        }
        return f
    }

    function g1(r, e, t, n, i, s, a) {
        const {
            geometry: o
        } = t, {
            index: c
        } = o, l = o.attributes.position;
        for (let f = r, h = e + r; f < h; f++) {
            let d;
            if (d = t.resolveTriangleIndex(f), nn(a, d * 3, c, l), a.needsUpdate = !0, n(a, d, i, s)) return !0
        }
        return !1
    }

    function _1(r, e, t, n, i, s, a) {
        Nt.setBuffer(r._roots[e]), Jd(0, r, t, n, i, s, a), Nt.clearBuffer()
    }

    function Jd(r, e, t, n, i, s, a) {
        const {
            float32Array: o,
            uint16Array: c,
            uint32Array: l
        } = Nt, f = r * 2;
        if (ii(f, c)) {
            const d = pi(r, l),
                u = Di(f, c);
            u1(e, t, n, d, u, i, s, a)
        } else {
            const d = Ci(r);
            Ss(d, o, n, s, a) && Jd(d, e, t, n, i, s, a);
            const u = Ri(r, l);
            Ss(u, o, n, s, a) && Jd(u, e, t, n, i, s, a)
        }
    }
    const b1 = ["x", "y", "z"];

    function x1(r, e, t, n, i, s) {
        Nt.setBuffer(r._roots[e]);
        const a = Zd(0, r, t, n, i, s);
        return Nt.clearBuffer(), a
    }

    function Zd(r, e, t, n, i, s) {
        const {
            float32Array: a,
            uint16Array: o,
            uint32Array: c
        } = Nt;
        let l = r * 2;
        if (ii(l, o)) {
            const h = pi(r, c),
                d = Di(l, o);
            return f1(e, t, n, h, d, i, s)
        } else {
            const h = Hb(r, c),
                d = b1[h],
                _ = n.direction[d] >= 0;
            let g, m;
            _ ? (g = Ci(r), m = Ri(r, c)) : (g = Ri(r, c), m = Ci(r));
            const v = Ss(g, a, n, i, s) ? Zd(g, e, t, n, i, s) : null;
            if (v) {
                const S = v.point[d];
                if (_ ? S <= a[m + h] : S >= a[m + h + 3]) return v
            }
            const b = Ss(m, a, n, i, s) ? Zd(m, e, t, n, i, s) : null;
            return v && b ? v.distance <= b.distance ? v : b : v || b || null
        }
    }
    const Qu = new Gt,
        bo = new Qi,
        xo = new Qi,
        Gc = new Ke,
        Yb = new Xn,
        ef = new Xn;

    function v1(r, e, t, n) {
        Nt.setBuffer(r._roots[e]);
        const i = Qd(0, r, t, n);
        return Nt.clearBuffer(), i
    }

    function Qd(r, e, t, n, i = null) {
        const {
            float32Array: s,
            uint16Array: a,
            uint32Array: o
        } = Nt;
        let c = r * 2;
        if (i === null && (t.boundingBox || t.computeBoundingBox(), Yb.set(t.boundingBox.min, t.boundingBox.max, n), i = Yb), ii(c, a)) {
            const f = e.geometry,
                h = f.index,
                d = f.attributes.position,
                u = t.index,
                _ = t.attributes.position,
                g = pi(r, o),
                m = Di(c, a);
            if (Gc.copy(n).invert(), t.boundsTree) return Yt(r, s, ef), ef.matrix.copy(Gc), ef.needsUpdate = !0, t.boundsTree.shapecast({
                intersectsBounds: v => ef.intersectsBox(v),
                intersectsTriangle: v => {
                    v.a.applyMatrix4(n), v.b.applyMatrix4(n), v.c.applyMatrix4(n), v.needsUpdate = !0;
                    for (let x = g * 3, b = (m + g) * 3; x < b; x += 3)
                        if (nn(xo, x, h, d), xo.needsUpdate = !0, v.intersectsTriangle(xo)) return !0;
                    return !1
                }
            });
            for (let p = g * 3, v = (m + g) * 3; p < v; p += 3) {
                nn(bo, p, h, d), bo.a.applyMatrix4(Gc), bo.b.applyMatrix4(Gc), bo.c.applyMatrix4(Gc), bo.needsUpdate = !0;
                for (let x = 0, b = u.count; x < b; x += 3)
                    if (nn(xo, x, u, _), xo.needsUpdate = !0, bo.intersectsTriangle(xo)) return !0
            }
        } else {
            const f = r + 8,
                h = o[r + 6];
            return Yt(f, s, Qu), !!(i.intersectsBox(Qu) && Qd(f, e, t, n, i) || (Yt(h, s, Qu), i.intersectsBox(Qu) && Qd(h, e, t, n, i)))
        }
    }
    const tf = new Ke,
        ep = new Xn,
        Hc = new Xn,
        y1 = new B,
        S1 = new B,
        M1 = new B,
        T1 = new B;

    function E1(r, e, t, n = {}, i = {}, s = 0, a = 1 / 0) {
        e.boundingBox || e.computeBoundingBox(), ep.set(e.boundingBox.min, e.boundingBox.max, t), ep.needsUpdate = !0;
        const o = r.geometry,
            c = o.attributes.position,
            l = o.index,
            f = e.attributes.position,
            h = e.index,
            d = Pi.getPrimitive(),
            u = Pi.getPrimitive();
        let _ = y1,
            g = S1,
            m = null,
            p = null;
        i && (m = M1, p = T1);
        let v = 1 / 0,
            x = null,
            b = null;
        return tf.copy(t).invert(), Hc.matrix.copy(tf), r.shapecast({
            boundsTraverseOrder: S => ep.distanceToBox(S),
            intersectsBounds: (S, E, T) => T < v && T < a ? (E && (Hc.min.copy(S.min), Hc.max.copy(S.max), Hc.needsUpdate = !0), !0) : !1,
            intersectsRange: (S, E) => {
                if (e.boundsTree) return e.boundsTree.shapecast({
                    boundsTraverseOrder: w => Hc.distanceToBox(w),
                    intersectsBounds: (w, M, y) => y < v && y < a,
                    intersectsRange: (w, M) => {
                        for (let y = w, D = w + M; y < D; y++) {
                            nn(u, 3 * y, h, f), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
                            for (let R = S, P = S + E; R < P; R++) {
                                nn(d, 3 * R, l, c), d.needsUpdate = !0;
                                const O = d.distanceToTriangle(u, _, m);
                                if (O < v && (g.copy(_), p && p.copy(m), v = O, x = R, b = y), O < s) return !0
                            }
                        }
                    }
                }); {
                    const T = mo(e);
                    for (let w = 0, M = T; w < M; w++) {
                        nn(u, 3 * w, h, f), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
                        for (let y = S, D = S + E; y < D; y++) {
                            nn(d, 3 * y, l, c), d.needsUpdate = !0;
                            const R = d.distanceToTriangle(u, _, m);
                            if (R < v && (g.copy(_), p && p.copy(m), v = R, x = y, b = w), R < s) return !0
                        }
                    }
                }
            }
        }), Pi.releasePrimitive(d), Pi.releasePrimitive(u), v === 1 / 0 ? null : (n.point ? n.point.copy(g) : n.point = g.clone(), n.distance = v, n.faceIndex = x, i && (i.point ? i.point.copy(p) : i.point = p.clone(), i.point.applyMatrix4(tf), g.applyMatrix4(tf), i.distance = g.sub(i.point).length(), i.faceIndex = b), n)
    }

    function w1(r, e = null) {
        e && Array.isArray(e) && (e = new Set(e));
        const t = r.geometry,
            n = t.index ? t.index.array : null,
            i = t.attributes.position;
        let s, a, o, c, l = 0;
        const f = r._roots;
        for (let d = 0, u = f.length; d < u; d++) s = f[d], a = new Uint32Array(s), o = new Uint16Array(s), c = new Float32Array(s), h(0, l), l += s.byteLength;

        function h(d, u, _ = !1) {
            const g = d * 2;
            if (o[g + 15] === Wu) {
                const p = a[d + 6],
                    v = o[g + 14];
                let x = 1 / 0,
                    b = 1 / 0,
                    S = 1 / 0,
                    E = -1 / 0,
                    T = -1 / 0,
                    w = -1 / 0;
                for (let M = p, y = p + v; M < y; M++) {
                    const D = 3 * r.resolveTriangleIndex(M);
                    for (let R = 0; R < 3; R++) {
                        let P = D + R;
                        P = n ? n[P] : P;
                        const O = i.getX(P),
                            z = i.getY(P),
                            k = i.getZ(P);
                        O < x && (x = O), O > E && (E = O), z < b && (b = z), z > T && (T = z), k < S && (S = k), k > w && (w = k)
                    }
                }
                return c[d + 0] !== x || c[d + 1] !== b || c[d + 2] !== S || c[d + 3] !== E || c[d + 4] !== T || c[d + 5] !== w ? (c[d + 0] = x, c[d + 1] = b, c[d + 2] = S, c[d + 3] = E, c[d + 4] = T, c[d + 5] = w, !0) : !1
            } else {
                const p = d + 8,
                    v = a[d + 6],
                    x = p + u,
                    b = v + u;
                let S = _,
                    E = !1,
                    T = !1;
                e ? S || (E = e.has(x), T = e.has(b), S = !E && !T) : (E = !0, T = !0);
                const w = S || E,
                    M = S || T;
                let y = !1;
                w && (y = h(p, u, S));
                let D = !1;
                M && (D = h(v, u, S));
                const R = y || D;
                if (R)
                    for (let P = 0; P < 3; P++) {
                        const O = p + P,
                            z = v + P,
                            k = c[O],
                            X = c[O + 3],
                            V = c[z],
                            H = c[z + 3];
                        c[d + P] = k < V ? k : V, c[d + P + 3] = X > H ? X : H
                    }
                return R
            }
        }
    }

    function A1(r, e, t, n, i, s, a) {
        Nt.setBuffer(r._roots[e]), tp(0, r, t, n, i, s, a), Nt.clearBuffer()
    }

    function tp(r, e, t, n, i, s, a) {
        const {
            float32Array: o,
            uint16Array: c,
            uint32Array: l
        } = Nt, f = r * 2;
        if (ii(f, c)) {
            const d = pi(r, l),
                u = Di(f, c);
            p1(e, t, n, d, u, i, s, a)
        } else {
            const d = Ci(r);
            Ss(d, o, n, s, a) && tp(d, e, t, n, i, s, a);
            const u = Ri(r, l);
            Ss(u, o, n, s, a) && tp(u, e, t, n, i, s, a)
        }
    }
    const D1 = ["x", "y", "z"];

    function C1(r, e, t, n, i, s) {
        Nt.setBuffer(r._roots[e]);
        const a = np(0, r, t, n, i, s);
        return Nt.clearBuffer(), a
    }

    function np(r, e, t, n, i, s) {
        const {
            float32Array: a,
            uint16Array: o,
            uint32Array: c
        } = Nt;
        let l = r * 2;
        if (ii(l, o)) {
            const h = pi(r, c),
                d = Di(l, o);
            return m1(e, t, n, h, d, i, s)
        } else {
            const h = Hb(r, c),
                d = D1[h],
                _ = n.direction[d] >= 0;
            let g, m;
            _ ? (g = Ci(r), m = Ri(r, c)) : (g = Ri(r, c), m = Ci(r));
            const v = Ss(g, a, n, i, s) ? np(g, e, t, n, i, s) : null;
            if (v) {
                const S = v.point[d];
                if (_ ? S <= a[m + h] : S >= a[m + h + 3]) return v
            }
            const b = Ss(m, a, n, i, s) ? np(m, e, t, n, i, s) : null;
            return v && b ? v.distance <= b.distance ? v : b : v || b || null
        }
    }
    const nf = new Gt,
        vo = new Qi,
        yo = new Qi,
        Vc = new Ke,
        $b = new Xn,
        rf = new Xn;

    function R1(r, e, t, n) {
        Nt.setBuffer(r._roots[e]);
        const i = ip(0, r, t, n);
        return Nt.clearBuffer(), i
    }

    function ip(r, e, t, n, i = null) {
        const {
            float32Array: s,
            uint16Array: a,
            uint32Array: o
        } = Nt;
        let c = r * 2;
        if (i === null && (t.boundingBox || t.computeBoundingBox(), $b.set(t.boundingBox.min, t.boundingBox.max, n), i = $b), ii(c, a)) {
            const f = e.geometry,
                h = f.index,
                d = f.attributes.position,
                u = t.index,
                _ = t.attributes.position,
                g = pi(r, o),
                m = Di(c, a);
            if (Vc.copy(n).invert(), t.boundsTree) return Yt(r, s, rf), rf.matrix.copy(Vc), rf.needsUpdate = !0, t.boundsTree.shapecast({
                intersectsBounds: v => rf.intersectsBox(v),
                intersectsTriangle: v => {
                    v.a.applyMatrix4(n), v.b.applyMatrix4(n), v.c.applyMatrix4(n), v.needsUpdate = !0;
                    for (let x = g, b = m + g; x < b; x++)
                        if (nn(yo, 3 * e.resolveTriangleIndex(x), h, d), yo.needsUpdate = !0, v.intersectsTriangle(yo)) return !0;
                    return !1
                }
            });
            for (let p = g, v = m + g; p < v; p++) {
                const x = e.resolveTriangleIndex(p);
                nn(vo, 3 * x, h, d), vo.a.applyMatrix4(Vc), vo.b.applyMatrix4(Vc), vo.c.applyMatrix4(Vc), vo.needsUpdate = !0;
                for (let b = 0, S = u.count; b < S; b += 3)
                    if (nn(yo, b, u, _), yo.needsUpdate = !0, vo.intersectsTriangle(yo)) return !0
            }
        } else {
            const f = r + 8,
                h = o[r + 6];
            return Yt(f, s, nf), !!(i.intersectsBox(nf) && ip(f, e, t, n, i) || (Yt(h, s, nf), i.intersectsBox(nf) && ip(h, e, t, n, i)))
        }
    }
    const sf = new Ke,
        rp = new Xn,
        Wc = new Xn,
        P1 = new B,
        F1 = new B,
        I1 = new B,
        L1 = new B;

    function N1(r, e, t, n = {}, i = {}, s = 0, a = 1 / 0) {
        e.boundingBox || e.computeBoundingBox(), rp.set(e.boundingBox.min, e.boundingBox.max, t), rp.needsUpdate = !0;
        const o = r.geometry,
            c = o.attributes.position,
            l = o.index,
            f = e.attributes.position,
            h = e.index,
            d = Pi.getPrimitive(),
            u = Pi.getPrimitive();
        let _ = P1,
            g = F1,
            m = null,
            p = null;
        i && (m = I1, p = L1);
        let v = 1 / 0,
            x = null,
            b = null;
        return sf.copy(t).invert(), Wc.matrix.copy(sf), r.shapecast({
            boundsTraverseOrder: S => rp.distanceToBox(S),
            intersectsBounds: (S, E, T) => T < v && T < a ? (E && (Wc.min.copy(S.min), Wc.max.copy(S.max), Wc.needsUpdate = !0), !0) : !1,
            intersectsRange: (S, E) => {
                if (e.boundsTree) {
                    const T = e.boundsTree;
                    return T.shapecast({
                        boundsTraverseOrder: w => Wc.distanceToBox(w),
                        intersectsBounds: (w, M, y) => y < v && y < a,
                        intersectsRange: (w, M) => {
                            for (let y = w, D = w + M; y < D; y++) {
                                const R = T.resolveTriangleIndex(y);
                                nn(u, 3 * R, h, f), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
                                for (let P = S, O = S + E; P < O; P++) {
                                    const z = r.resolveTriangleIndex(P);
                                    nn(d, 3 * z, l, c), d.needsUpdate = !0;
                                    const k = d.distanceToTriangle(u, _, m);
                                    if (k < v && (g.copy(_), p && p.copy(m), v = k, x = P, b = y), k < s) return !0
                                }
                            }
                        }
                    })
                } else {
                    const T = mo(e);
                    for (let w = 0, M = T; w < M; w++) {
                        nn(u, 3 * w, h, f), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
                        for (let y = S, D = S + E; y < D; y++) {
                            const R = r.resolveTriangleIndex(y);
                            nn(d, 3 * R, l, c), d.needsUpdate = !0;
                            const P = d.distanceToTriangle(u, _, m);
                            if (P < v && (g.copy(_), p && p.copy(m), v = P, x = y, b = w), P < s) return !0
                        }
                    }
                }
            }
        }), Pi.releasePrimitive(d), Pi.releasePrimitive(u), v === 1 / 0 ? null : (n.point ? n.point.copy(g) : n.point = g.clone(), n.distance = v, n.faceIndex = x, i && (i.point ? i.point.copy(p) : i.point = p.clone(), i.point.applyMatrix4(sf), g.applyMatrix4(sf), i.distance = g.sub(i.point).length(), i.faceIndex = b), n)
    }

    function U1() {
        return typeof SharedArrayBuffer < "u"
    }
    const Xc = new Nt.constructor,
        af = new Nt.constructor,
        Ms = new Yd(() => new Gt),
        So = new Gt,
        Mo = new Gt,
        sp = new Gt,
        ap = new Gt;
    let op = !1;

    function O1(r, e, t, n) {
        if (op) throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
        op = !0;
        const i = r._roots,
            s = e._roots;
        let a, o = 0,
            c = 0;
        const l = new Ke().copy(t).invert();
        for (let f = 0, h = i.length; f < h; f++) {
            Xc.setBuffer(i[f]), c = 0;
            const d = Ms.getPrimitive();
            Yt(0, Xc.float32Array, d), d.applyMatrix4(l);
            for (let u = 0, _ = s.length; u < _ && (af.setBuffer(s[u]), a = er(0, 0, t, l, n, o, c, 0, 0, d), af.clearBuffer(), c += s[u].length, !a); u++);
            if (Ms.releasePrimitive(d), Xc.clearBuffer(), o += i[f].length, a) break
        }
        return op = !1, a
    }

    function er(r, e, t, n, i, s = 0, a = 0, o = 0, c = 0, l = null, f = !1) {
        let h, d;
        f ? (h = af, d = Xc) : (h = Xc, d = af);
        const u = h.float32Array,
            _ = h.uint32Array,
            g = h.uint16Array,
            m = d.float32Array,
            p = d.uint32Array,
            v = d.uint16Array,
            x = r * 2,
            b = e * 2,
            S = ii(x, g),
            E = ii(b, v);
        let T = !1;
        if (E && S) f ? T = i(pi(e, p), Di(e * 2, v), pi(r, _), Di(r * 2, g), c, a + e, o, s + r) : T = i(pi(r, _), Di(r * 2, g), pi(e, p), Di(e * 2, v), o, s + r, c, a + e);
        else if (E) {
            const w = Ms.getPrimitive();
            Yt(e, m, w), w.applyMatrix4(t);
            const M = Ci(r),
                y = Ri(r, _);
            Yt(M, u, So), Yt(y, u, Mo);
            const D = w.intersectsBox(So),
                R = w.intersectsBox(Mo);
            T = D && er(e, M, n, t, i, a, s, c, o + 1, w, !f) || R && er(e, y, n, t, i, a, s, c, o + 1, w, !f), Ms.releasePrimitive(w)
        } else {
            const w = Ci(e),
                M = Ri(e, p);
            Yt(w, m, sp), Yt(M, m, ap);
            const y = l.intersectsBox(sp),
                D = l.intersectsBox(ap);
            if (y && D) T = er(r, w, t, n, i, s, a, o, c + 1, l, f) || er(r, M, t, n, i, s, a, o, c + 1, l, f);
            else if (y)
                if (S) T = er(r, w, t, n, i, s, a, o, c + 1, l, f);
                else {
                    const R = Ms.getPrimitive();
                    R.copy(sp).applyMatrix4(t);
                    const P = Ci(r),
                        O = Ri(r, _);
                    Yt(P, u, So), Yt(O, u, Mo);
                    const z = R.intersectsBox(So),
                        k = R.intersectsBox(Mo);
                    T = z && er(w, P, n, t, i, a, s, c, o + 1, R, !f) || k && er(w, O, n, t, i, a, s, c, o + 1, R, !f), Ms.releasePrimitive(R)
                }
            else if (D)
                if (S) T = er(r, M, t, n, i, s, a, o, c + 1, l, f);
                else {
                    const R = Ms.getPrimitive();
                    R.copy(ap).applyMatrix4(t);
                    const P = Ci(r),
                        O = Ri(r, _);
                    Yt(P, u, So), Yt(O, u, Mo);
                    const z = R.intersectsBox(So),
                        k = R.intersectsBox(Mo);
                    T = z && er(M, P, n, t, i, a, s, c, o + 1, R, !f) || k && er(M, O, n, t, i, a, s, c, o + 1, R, !f), Ms.releasePrimitive(R)
                }
        }
        return T
    }
    const of = new Xn, Kb = new Gt, B1 = {
        strategy: Lb,
        maxDepth: 40,
        maxLeafTris: 10,
        useSharedArrayBuffer: !1,
        setBoundingBox: !0,
        onProgress: null,
        indirect: !1,
        verbose: !0,
        range: null
    };
    class cp {
        static serialize(e, t = {}) {
            t = {
                cloneBuffers: !0,
                ...t
            };
            const n = e.geometry,
                i = e._roots,
                s = e._indirectBuffer,
                a = n.getIndex();
            let o;
            return t.cloneBuffers ? o = {
                roots: i.map(c => c.slice()),
                index: a ? a.array.slice() : null,
                indirectBuffer: s ? s.slice() : null
            } : o = {
                roots: i,
                index: a ? a.array : null,
                indirectBuffer: s
            }, o
        }
        static deserialize(e, t, n = {}) {
            n = {
                setIndex: !0,
                indirect: !!e.indirectBuffer,
                ...n
            };
            const {
                index: i,
                roots: s,
                indirectBuffer: a
            } = e, o = new cp(t, { ...n,
                [Gd]: !0
            });
            if (o._roots = s, o._indirectBuffer = a || null, n.setIndex) {
                const c = t.getIndex();
                if (c === null) {
                    const l = new Zt(e.index, 1, !1);
                    t.setIndex(l)
                } else c.array !== i && (c.array.set(i), c.needsUpdate = !0)
            }
            return o
        }
        get indirect() {
            return !!this._indirectBuffer
        }
        constructor(e, t = {}) {
            if (e.isBufferGeometry) {
                if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")
            } else throw new Error("MeshBVH: Only BufferGeometries are supported.");
            if (t = Object.assign({ ...B1,
                    [Gd]: !1
                }, t), t.useSharedArrayBuffer && !U1()) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
            this.geometry = e, this._roots = null, this._indirectBuffer = null, t[Gd] || (QD(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Gt))), this.resolveTriangleIndex = t.indirect ? n => this._indirectBuffer[n] : n => n
        }
        refit(e = null) {
            return (this.indirect ? w1 : d1)(this, e)
        }
        traverse(e, t = 0) {
            const n = this._roots[t],
                i = new Uint32Array(n),
                s = new Uint16Array(n);
            a(0);

            function a(o, c = 0) {
                const l = o * 2,
                    f = s[l + 15] === Wu;
                if (f) {
                    const h = i[o + 6],
                        d = s[l + 14];
                    e(c, f, new Float32Array(n, o * 4, 6), h, d)
                } else {
                    const h = o + Uc / 4,
                        d = i[o + 6],
                        u = i[o + 7];
                    e(c, f, new Float32Array(n, o * 4, 6), u) || (a(h, c + 1), a(d, c + 1))
                }
            }
        }
        raycast(e, t = 0, n = 0, i = 1 / 0) {
            const s = this._roots,
                a = this.geometry,
                o = [],
                c = t.isMaterial,
                l = Array.isArray(t),
                f = a.groups,
                h = c ? t.side : t,
                d = this.indirect ? A1 : _1;
            for (let u = 0, _ = s.length; u < _; u++) {
                const g = l ? t[f[u].materialIndex].side : h,
                    m = o.length;
                if (d(this, u, g, e, o, n, i), l) {
                    const p = f[u].materialIndex;
                    for (let v = m, x = o.length; v < x; v++) o[v].face.materialIndex = p
                }
            }
            return o
        }
        raycastFirst(e, t = 0, n = 0, i = 1 / 0) {
            const s = this._roots,
                a = this.geometry,
                o = t.isMaterial,
                c = Array.isArray(t);
            let l = null;
            const f = a.groups,
                h = o ? t.side : t,
                d = this.indirect ? C1 : x1;
            for (let u = 0, _ = s.length; u < _; u++) {
                const g = c ? t[f[u].materialIndex].side : h,
                    m = d(this, u, g, e, n, i);
                m != null && (l == null || m.distance < l.distance) && (l = m, c && (m.face.materialIndex = f[u].materialIndex))
            }
            return l
        }
        intersectsGeometry(e, t) {
            let n = !1;
            const i = this._roots,
                s = this.indirect ? R1 : v1;
            for (let a = 0, o = i.length; a < o && (n = s(this, a, e, t), !n); a++);
            return n
        }
        shapecast(e) {
            const t = Pi.getPrimitive(),
                n = this.indirect ? g1 : h1;
            let {
                boundsTraverseOrder: i,
                intersectsBounds: s,
                intersectsRange: a,
                intersectsTriangle: o
            } = e;
            if (a && o) {
                const h = a;
                a = (d, u, _, g, m) => h(d, u, _, g, m) ? !0 : n(d, u, this, o, _, g, t)
            } else a || (o ? a = (h, d, u, _) => n(h, d, this, o, u, _, t) : a = (h, d, u) => u);
            let c = !1,
                l = 0;
            const f = this._roots;
            for (let h = 0, d = f.length; h < d; h++) {
                const u = f[h];
                if (c = s1(this, h, s, a, i, l), c) break;
                l += u.byteLength
            }
            return Pi.releasePrimitive(t), c
        }
        bvhcast(e, t, n) {
            let {
                intersectsRanges: i,
                intersectsTriangles: s
            } = n;
            const a = Pi.getPrimitive(),
                o = this.geometry.index,
                c = this.geometry.attributes.position,
                l = this.indirect ? _ => {
                    const g = this.resolveTriangleIndex(_);
                    nn(a, g * 3, o, c)
                } : _ => {
                    nn(a, _ * 3, o, c)
                },
                f = Pi.getPrimitive(),
                h = e.geometry.index,
                d = e.geometry.attributes.position,
                u = e.indirect ? _ => {
                    const g = e.resolveTriangleIndex(_);
                    nn(f, g * 3, h, d)
                } : _ => {
                    nn(f, _ * 3, h, d)
                };
            if (s) {
                const _ = (g, m, p, v, x, b, S, E) => {
                    for (let T = p, w = p + v; T < w; T++) {
                        u(T), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
                        for (let M = g, y = g + m; M < y; M++)
                            if (l(M), a.needsUpdate = !0, s(a, f, M, T, x, b, S, E)) return !0
                    }
                    return !1
                };
                if (i) {
                    const g = i;
                    i = function(m, p, v, x, b, S, E, T) {
                        return g(m, p, v, x, b, S, E, T) ? !0 : _(m, p, v, x, b, S, E, T)
                    }
                } else i = _
            }
            return O1(this, e, t, i)
        }
        intersectsBox(e, t) {
            return of.set(e.min, e.max, t), of .needsUpdate = !0, this.shapecast({
                intersectsBounds: n => of .intersectsBox(n),
                intersectsTriangle: n => of .intersectsTriangle(n)
            })
        }
        intersectsSphere(e) {
            return this.shapecast({
                intersectsBounds: t => e.intersectsBox(t),
                intersectsTriangle: t => t.intersectsSphere(e)
            })
        }
        closestPointToGeometry(e, t, n = {}, i = {}, s = 0, a = 1 / 0) {
            return (this.indirect ? N1 : E1)(this, e, t, n, i, s, a)
        }
        closestPointToPoint(e, t = {}, n = 0, i = 1 / 0) {
            return a1(this, e, t, n, i)
        }
        getBoundingBox(e) {
            return e.makeEmpty(), this._roots.forEach(n => {
                Yt(0, new Float32Array(n), Kb), e.union(Kb)
            }), e
        }
    }

    function Jb(r, e, t) {
        return r === null ? null : (r.point.applyMatrix4(e.matrixWorld), r.distance = r.point.distanceTo(t.ray.origin), r.object = e, r)
    }
    const cf = new Xa,
        Zb = new B,
        Qb = new Ke,
        k1 = bn.prototype.raycast,
        z1 = GS.prototype.raycast,
        e0 = new B,
        Tn = new bn,
        lf = [];

    function G1(r, e) {
        this.isBatchedMesh ? H1.call(this, r, e) : V1.call(this, r, e)
    }

    function H1(r, e) {
        if (this.boundsTrees) {
            const t = this.boundsTrees,
                n = this._drawInfo || this._instanceInfo,
                i = this._drawRanges || this._geometryInfo,
                s = this.matrixWorld;
            Tn.material = this.material, Tn.geometry = this.geometry;
            const a = Tn.geometry.boundsTree,
                o = Tn.geometry.drawRange;
            Tn.geometry.boundingSphere === null && (Tn.geometry.boundingSphere = new Rn);
            for (let c = 0, l = n.length; c < l; c++) {
                if (!this.getVisibleAt(c)) continue;
                const f = n[c].geometryIndex;
                if (Tn.geometry.boundsTree = t[f], this.getMatrixAt(c, Tn.matrixWorld).premultiply(s), !Tn.geometry.boundsTree) {
                    this.getBoundingBoxAt(f, Tn.geometry.boundingBox), this.getBoundingSphereAt(f, Tn.geometry.boundingSphere);
                    const h = i[f];
                    Tn.geometry.setDrawRange(h.start, h.count)
                }
                Tn.raycast(r, lf);
                for (let h = 0, d = lf.length; h < d; h++) {
                    const u = lf[h];
                    u.object = this, u.batchId = c, e.push(u)
                }
                lf.length = 0
            }
            Tn.geometry.boundsTree = a, Tn.geometry.drawRange = o, Tn.material = null, Tn.geometry = null
        } else z1.call(this, r, e)
    }

    function V1(r, e) {
        if (this.geometry.boundsTree) {
            if (this.material === void 0) return;
            Qb.copy(this.matrixWorld).invert(), cf.copy(r.ray).applyMatrix4(Qb), e0.setFromMatrixScale(this.matrixWorld), Zb.copy(cf.direction).multiply(e0);
            const t = Zb.length(),
                n = r.near / t,
                i = r.far / t,
                s = this.geometry.boundsTree;
            if (r.firstHitOnly === !0) {
                const a = Jb(s.raycastFirst(cf, this.material, n, i), this, r);
                a && e.push(a)
            } else {
                const a = s.raycast(cf, this.material, n, i);
                for (let o = 0, c = a.length; o < c; o++) {
                    const l = Jb(a[o], this, r);
                    l && e.push(l)
                }
            }
        } else k1.call(this, r, e)
    }

    function W1(r = {}) {
        return this.boundsTree = new cp(this, r), this.boundsTree
    }

    function X1() {
        this.boundsTree = null
    }
    class j1 {
        constructor(e) {
            this.loader = new A_(e)
        }
        async load(e) {
            if (Array.isArray(e)) {
                const t = e.map(n => this.#e(n));
                return await Promise.all(t)
            } else return await this.#e(e)
        }#
        e(e) {
            return new Promise(t => {
                this.loader.load(e, n => {
                    t(n)
                })
            })
        }
    }

    function t0(r, e) {
        if (e === 0) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
        if (e === 2 || e === 1) {
            let t = r.getIndex();
            if (t === null) {
                const a = [],
                    o = r.getAttribute("position");
                if (o !== void 0) {
                    for (let c = 0; c < o.count; c++) a.push(c);
                    r.setIndex(a), t = r.getIndex()
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r
            }
            const n = t.count - 2,
                i = [];
            if (e === 2)
                for (let a = 1; a <= n; a++) i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
            else
                for (let a = 0; a < n; a++) a % 2 === 0 ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2))) : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
            i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = r.clone();
            return s.setIndex(i), s.clearGroups(), s
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r
    }
    let q1 = class extends Js {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                return new Z1(t)
            }), this.register(function(t) {
                return new Q1(t)
            }), this.register(function(t) {
                return new cC(t)
            }), this.register(function(t) {
                return new lC(t)
            }), this.register(function(t) {
                return new uC(t)
            }), this.register(function(t) {
                return new tC(t)
            }), this.register(function(t) {
                return new nC(t)
            }), this.register(function(t) {
                return new iC(t)
            }), this.register(function(t) {
                return new rC(t)
            }), this.register(function(t) {
                return new J1(t)
            }), this.register(function(t) {
                return new sC(t)
            }), this.register(function(t) {
                return new eC(t)
            }), this.register(function(t) {
                return new oC(t)
            }), this.register(function(t) {
                return new aC(t)
            }), this.register(function(t) {
                return new $1(t)
            }), this.register(function(t) {
                return new fC(t)
            }), this.register(function(t) {
                return new hC(t)
            })
        }
        load(e, t, n, i) {
            const s = this;
            let a;
            if (this.resourcePath !== "") a = this.resourcePath;
            else if (this.path !== "") {
                const l = Ac.extractUrlBase(e);
                a = Ac.resolveURL(l, this.path)
            } else a = Ac.extractUrlBase(e);
            this.manager.itemStart(e);
            const o = function(l) {
                    i ? i(l) : console.error(l), s.manager.itemError(e), s.manager.itemEnd(e)
                },
                c = new Au(this.manager);
            c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(l) {
                try {
                    s.parse(l, a, function(f) {
                        t(f), s.manager.itemEnd(e)
                    }, o)
                } catch (f) {
                    o(f)
                }
            }, n, o)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, i) {
            let s;
            const a = {},
                o = {},
                c = new TextDecoder;
            if (typeof e == "string") s = JSON.parse(e);
            else if (e instanceof ArrayBuffer)
                if (c.decode(new Uint8Array(e, 0, 4)) === n0) {
                    try {
                        a[mt.KHR_BINARY_GLTF] = new dC(e)
                    } catch (h) {
                        i && i(h);
                        return
                    }
                    s = JSON.parse(a[mt.KHR_BINARY_GLTF].content)
                } else s = JSON.parse(c.decode(e));
            else s = e;
            if (s.asset === void 0 || s.asset.version[0] < 2) {
                i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return
            }
            const l = new wC(s, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let f = 0; f < this.pluginCallbacks.length; f++) {
                const h = this.pluginCallbacks[f](l);
                h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[h.name] = h, a[h.name] = !0
            }
            if (s.extensionsUsed)
                for (let f = 0; f < s.extensionsUsed.length; ++f) {
                    const h = s.extensionsUsed[f],
                        d = s.extensionsRequired || [];
                    switch (h) {
                        case mt.KHR_MATERIALS_UNLIT:
                            a[h] = new K1;
                            break;
                        case mt.KHR_DRACO_MESH_COMPRESSION:
                            a[h] = new pC(s, this.dracoLoader);
                            break;
                        case mt.KHR_TEXTURE_TRANSFORM:
                            a[h] = new mC;
                            break;
                        case mt.KHR_MESH_QUANTIZATION:
                            a[h] = new gC;
                            break;
                        default:
                            d.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                    }
                }
            l.setExtensions(a), l.setPlugins(o), l.parse(n, i)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise(function(i, s) {
                n.parse(e, t, i, s)
            })
        }
    };

    function Y1() {
        let r = {};
        return {
            get: function(e) {
                return r[e]
            },
            add: function(e, t) {
                r[e] = t
            },
            remove: function(e) {
                delete r[e]
            },
            removeAll: function() {
                r = {}
            }
        }
    }
    const mt = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class $1 {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const s = t[n];
                s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
            }
        }
        _loadLight(e) {
            const t = this.parser,
                n = "light:" + e;
            let i = t.cache.get(n);
            if (i) return i;
            const s = t.json,
                c = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
            let l;
            const f = new rt(16777215);
            c.color !== void 0 && f.setRGB(c.color[0], c.color[1], c.color[2], Dn);
            const h = c.range !== void 0 ? c.range : 0;
            switch (c.type) {
                case "directional":
                    l = new fM(f), l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                case "point":
                    l = new lM(f), l.distance = h;
                    break;
                case "spot":
                    l = new oM(f), l.distance = h, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type)
            }
            return l.position.set(0, 0, 0), Vr(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = t.createUniqueName(c.name || "light_" + e), i = Promise.resolve(l), t.cache.add(n, i), i
        }
        getDependency(e, t) {
            if (e === "light") return this._loadLight(t)
        }
        createNodeAttachment(e) {
            const t = this,
                n = this.parser,
                s = n.json.nodes[e],
                o = (s.extensions && s.extensions[this.name] || {}).light;
            return o === void 0 ? null : this._loadLight(o).then(function(c) {
                return n._getNodeRef(t.cache, o, c)
            })
        }
    }
    class K1 {
        constructor() {
            this.name = mt.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return hs
        }
        extendParams(e, t, n) {
            const i = [];
            e.color = new rt(1, 1, 1), e.opacity = 1;
            const s = t.pbrMetallicRoughness;
            if (s) {
                if (Array.isArray(s.baseColorFactor)) {
                    const a = s.baseColorFactor;
                    e.color.setRGB(a[0], a[1], a[2], Dn), e.opacity = a[3]
                }
                s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, Jt))
            }
            return Promise.all(i)
        }
    }
    class J1 {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_EMISSIVE_STRENGTH
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name].emissiveStrength;
            return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve()
        }
    }
    class Z1 {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
                const o = a.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new at(o, o)
            }
            return Promise.all(s)
        }
    }
    class Q1 {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_DISPERSION
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name];
            return t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0, Promise.resolve()
        }
    }
    class eC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_IRIDESCENCE
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s)
        }
    }
    class tC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [];
            t.sheenColor = new rt(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const a = i.extensions[this.name];
            if (a.sheenColorFactor !== void 0) {
                const o = a.sheenColorFactor;
                t.sheenColor.setRGB(o[0], o[1], o[2], Dn)
            }
            return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Jt)), a.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s)
        }
    }
    class nC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s)
        }
    }
    class iC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
            const o = a.attenuationColor || [1, 1, 1];
            return t.attenuationColor = new rt().setRGB(o[0], o[1], o[2], Dn), Promise.all(s)
        }
    }
    class rC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_IOR
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = i.extensions[this.name];
            return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
        }
    }
    class sC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
            const o = a.specularColorFactor || [1, 1, 1];
            return t.specularColor = new rt().setRGB(o[0], o[1], o[2], Dn), a.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Jt)), Promise.all(s)
        }
    }
    class aC {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_MATERIALS_BUMP
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s)
        }
    }
    class oC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_MATERIALS_ANISOTROPY
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : hr
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const s = [],
                a = i.extensions[this.name];
            return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s)
        }
    }
    class cC {
        constructor(e) {
            this.parser = e, this.name = mt.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                n = t.json,
                i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const s = i.extensions[this.name],
                a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, s.source, a)
        }
    }
    class lC {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_TEXTURE_WEBP
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                s = i.textures[e];
            if (!s.extensions || !s.extensions[t]) return null;
            const a = s.extensions[t],
                o = i.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l)
            }
            return n.loadTextureImage(e, a.source, c)
        }
    }
    class uC {
        constructor(e) {
            this.parser = e, this.name = mt.EXT_TEXTURE_AVIF
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                i = n.json,
                s = i.textures[e];
            if (!s.extensions || !s.extensions[t]) return null;
            const a = s.extensions[t],
                o = i.images[a.source];
            let c = n.textureLoader;
            if (o.uri) {
                const l = n.options.manager.getHandler(o.uri);
                l !== null && (c = l)
            }
            return n.loadTextureImage(e, a.source, c)
        }
    }
    class fC {
        constructor(e) {
            this.name = mt.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const i = n.extensions[this.name],
                    s = this.parser.getDependency("buffer", i.buffer),
                    a = this.parser.options.meshoptDecoder;
                if (!a || !a.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return s.then(function(o) {
                    const c = i.byteOffset || 0,
                        l = i.byteLength || 0,
                        f = i.count,
                        h = i.byteStride,
                        d = new Uint8Array(o, c, l);
                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(f, h, d, i.mode, i.filter).then(function(u) {
                        return u.buffer
                    }) : a.ready.then(function() {
                        const u = new ArrayBuffer(f * h);
                        return a.decodeGltfBuffer(new Uint8Array(u), f, h, d, i.mode, i.filter), u
                    })
                })
            } else return null
        }
    }
    class hC {
        constructor(e) {
            this.name = mt.EXT_MESH_GPU_INSTANCING, this.parser = e
        }
        createNodeMesh(e) {
            const t = this.parser.json,
                n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const i = t.meshes[n.mesh];
            for (const l of i.primitives)
                if (l.mode !== Fi.TRIANGLES && l.mode !== Fi.TRIANGLE_STRIP && l.mode !== Fi.TRIANGLE_FAN && l.mode !== void 0) return null;
            const a = n.extensions[this.name].attributes,
                o = [],
                c = {};
            for (const l in a) o.push(this.parser.getDependency("accessor", a[l]).then(f => (c[l] = f, c[l])));
            return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then(l => {
                const f = l.pop(),
                    h = f.isGroup ? f.children : [f],
                    d = l[0].count,
                    u = [];
                for (const _ of h) {
                    const g = new Ke,
                        m = new B,
                        p = new as,
                        v = new B(1, 1, 1),
                        x = new PS(_.geometry, _.material, d);
                    for (let b = 0; b < d; b++) c.TRANSLATION && m.fromBufferAttribute(c.TRANSLATION, b), c.ROTATION && p.fromBufferAttribute(c.ROTATION, b), c.SCALE && v.fromBufferAttribute(c.SCALE, b), x.setMatrixAt(b, g.compose(m, p, v));
                    for (const b in c)
                        if (b === "_COLOR_0") {
                            const S = c[b];
                            x.instanceColor = new qh(S.array, S.itemSize, S.normalized)
                        } else b !== "TRANSLATION" && b !== "ROTATION" && b !== "SCALE" && _.geometry.setAttribute(b, c[b]);
                    Ht.prototype.copy.call(x, _), this.parser.assignFinalMaterial(x), u.push(x)
                }
                return f.isGroup ? (f.clear(), f.add(...u), f) : u[0]
            }))
        }
    }
    const n0 = "glTF",
        jc = 12,
        i0 = {
            JSON: 1313821514,
            BIN: 5130562
        };
    class dC {
        constructor(e) {
            this.name = mt.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, jc),
                n = new TextDecoder;
            if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== n0) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - jc,
                s = new DataView(e, jc);
            let a = 0;
            for (; a < i;) {
                const o = s.getUint32(a, !0);
                a += 4;
                const c = s.getUint32(a, !0);
                if (a += 4, c === i0.JSON) {
                    const l = new Uint8Array(e, jc + a, o);
                    this.content = n.decode(l)
                } else if (c === i0.BIN) {
                    const l = jc + a;
                    this.body = e.slice(l, l + o)
                }
                a += o
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class pC {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = mt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const n = this.json,
                i = this.dracoLoader,
                s = e.extensions[this.name].bufferView,
                a = e.extensions[this.name].attributes,
                o = {},
                c = {},
                l = {};
            for (const f in a) {
                const h = up[f] || f.toLowerCase();
                o[h] = a[f]
            }
            for (const f in e.attributes) {
                const h = up[f] || f.toLowerCase();
                if (a[f] !== void 0) {
                    const d = n.accessors[e.attributes[f]],
                        u = To[d.componentType];
                    l[h] = u.name, c[h] = d.normalized === !0
                }
            }
            return t.getDependency("bufferView", s).then(function(f) {
                return new Promise(function(h, d) {
                    i.decodeDracoFile(f, function(u) {
                        for (const _ in u.attributes) {
                            const g = u.attributes[_],
                                m = c[_];
                            m !== void 0 && (g.normalized = m)
                        }
                        h(u)
                    }, o, l, Dn, d)
                })
            })
        }
    }
    class mC {
        constructor() {
            this.name = mt.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
        }
    }
    class gC {
        constructor() {
            this.name = mt.KHR_MESH_QUANTIZATION
        }
    }
    class r0 extends Ec {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                s = e * i * 3 + i;
            for (let a = 0; a !== i; a++) t[a] = n[s + a];
            return t
        }
        interpolate_(e, t, n, i) {
            const s = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                c = o * 2,
                l = o * 3,
                f = i - t,
                h = (n - t) / f,
                d = h * h,
                u = d * h,
                _ = e * l,
                g = _ - l,
                m = -2 * u + 3 * d,
                p = u - d,
                v = 1 - m,
                x = p - d + h;
            for (let b = 0; b !== o; b++) {
                const S = a[g + b + o],
                    E = a[g + b + c] * f,
                    T = a[_ + b + o],
                    w = a[_ + b] * f;
                s[b] = v * S + x * E + m * T + p * w
            }
            return s
        }
    }
    const _C = new as;
    class bC extends r0 {
        interpolate_(e, t, n, i) {
            const s = super.interpolate_(e, t, n, i);
            return _C.fromArray(s).normalize().toArray(s), s
        }
    }
    const Fi = {
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6
        },
        To = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        s0 = {
            9728: 1003,
            9729: 1006,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008
        },
        a0 = {
            33071: 1001,
            33648: 1002,
            10497: 1e3
        },
        lp = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        up = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        Ts = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        xC = {
            CUBICSPLINE: void 0,
            LINEAR: 2301,
            STEP: 2300
        },
        fp = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
        };

    function vC(r) {
        return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new td({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: 0
        })), r.DefaultMaterial
    }

    function la(r, e, t) {
        for (const n in t.extensions) r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n])
    }

    function Vr(r, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
    }

    function yC(r, e, t) {
        let n = !1,
            i = !1,
            s = !1;
        for (let l = 0, f = e.length; l < f; l++) {
            const h = e[l];
            if (h.POSITION !== void 0 && (n = !0), h.NORMAL !== void 0 && (i = !0), h.COLOR_0 !== void 0 && (s = !0), n && i && s) break
        }
        if (!n && !i && !s) return Promise.resolve(r);
        const a = [],
            o = [],
            c = [];
        for (let l = 0, f = e.length; l < f; l++) {
            const h = e[l];
            if (n) {
                const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : r.attributes.position;
                a.push(d)
            }
            if (i) {
                const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : r.attributes.normal;
                o.push(d)
            }
            if (s) {
                const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : r.attributes.color;
                c.push(d)
            }
        }
        return Promise.all([Promise.all(a), Promise.all(o), Promise.all(c)]).then(function(l) {
            const f = l[0],
                h = l[1],
                d = l[2];
            return n && (r.morphAttributes.position = f), i && (r.morphAttributes.normal = h), s && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r
        })
    }

    function SC(r, e) {
        if (r.updateMorphTargets(), e.weights !== void 0)
            for (let t = 0, n = e.weights.length; t < n; t++) r.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const t = e.extras.targetNames;
            if (r.morphTargetInfluences.length === t.length) {
                r.morphTargetDictionary = {};
                for (let n = 0, i = t.length; n < i; n++) r.morphTargetDictionary[t[n]] = n
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function MC(r) {
        let e;
        const t = r.extensions && r.extensions[mt.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + hp(t.attributes) : e = r.indices + ":" + hp(r.attributes) + ":" + r.mode, r.targets !== void 0)
            for (let n = 0, i = r.targets.length; n < i; n++) e += ":" + hp(r.targets[n]);
        return e
    }

    function hp(r) {
        let e = "";
        const t = Object.keys(r).sort();
        for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
        return e
    }

    function dp(r) {
        switch (r) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }

    function TC(r) {
        return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : r.search(/\.ktx2($|\?)/i) > 0 || r.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png"
    }
    const EC = new Ke;
    class wC {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Y1, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1,
                i = -1,
                s = !1,
                a = -1;
            if (typeof navigator < "u") {
                const o = navigator.userAgent;
                n = /^((?!chrome|android).)*safari/i.test(o) === !0;
                const c = o.match(/Version\/(\d+)/);
                i = n && c ? parseInt(c[1], 10) : -1, s = o.indexOf("Firefox") > -1, a = s ? o.match(/Firefox\/([0-9]+)\./)[1] : -1
            }
            typeof createImageBitmap > "u" || n && i < 17 || s && a < 98 ? this.textureLoader = new A_(this.options.manager) : this.textureLoader = new hM(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Au(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const n = this,
                i = this.json,
                s = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
                return a._markDefs && a._markDefs()
            }), Promise.all(this._invokeAll(function(a) {
                return a.beforeRoot && a.beforeRoot()
            })).then(function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            }).then(function(a) {
                const o = {
                    scene: a[0][i.scene || 0],
                    scenes: a[0],
                    animations: a[1],
                    cameras: a[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                return la(s, o, i), Vr(o, i), Promise.all(n._invokeAll(function(c) {
                    return c.afterRoot && c.afterRoot(o)
                })).then(function() {
                    for (const c of o.scenes) c.updateMatrixWorld();
                    e(o)
                })
            }).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [],
                t = this.json.skins || [],
                n = this.json.meshes || [];
            for (let i = 0, s = t.length; i < s; i++) {
                const a = t[i].joints;
                for (let o = 0, c = a.length; o < c; o++) e[a[o]].isBone = !0
            }
            for (let i = 0, s = e.length; i < s; i++) {
                const a = e[i];
                a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera)
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(),
                s = (a, o) => {
                    const c = this.associations.get(a);
                    c != null && this.associations.set(o, c);
                    for (const [l, f] of a.children.entries()) s(f, o.children[l])
                };
            return s(n, i), i.name += "_instance_" + e.uses[t]++, i
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const i = e(t[n]);
                if (i) return i
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const s = e(t[i]);
                s && n.push(s)
            }
            return n
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne(function(s) {
                            return s.loadNode && s.loadNode(t)
                        });
                        break;
                    case "mesh":
                        i = this._invokeOne(function(s) {
                            return s.loadMesh && s.loadMesh(t)
                        });
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne(function(s) {
                            return s.loadBufferView && s.loadBufferView(t)
                        });
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne(function(s) {
                            return s.loadMaterial && s.loadMaterial(t)
                        });
                        break;
                    case "texture":
                        i = this._invokeOne(function(s) {
                            return s.loadTexture && s.loadTexture(t)
                        });
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne(function(s) {
                            return s.loadAnimation && s.loadAnimation(t)
                        });
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne(function(s) {
                                return s != this && s.getDependency && s.getDependency(e, t)
                            }), !i) throw new Error("Unknown type: " + e);
                        break
                }
                this.cache.add(n, i)
            }
            return i
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this,
                    i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(i.map(function(s, a) {
                    return n.getDependency(e, a)
                })), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const t = this.json.buffers[e],
                n = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[mt.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise(function(s, a) {
                n.load(Ac.resolveURL(t.uri, i.path), s, void 0, function() {
                    a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                })
            })
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(n) {
                const i = t.byteLength || 0,
                    s = t.byteOffset || 0;
                return n.slice(s, s + i)
            })
        }
        loadAccessor(e) {
            const t = this,
                n = this.json,
                i = this.json.accessors[e];
            if (i.bufferView === void 0 && i.sparse === void 0) {
                const a = lp[i.type],
                    o = To[i.componentType],
                    c = i.normalized === !0,
                    l = new o(i.count * a);
                return Promise.resolve(new Zt(l, a, c))
            }
            const s = [];
            return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(a) {
                const o = a[0],
                    c = lp[i.type],
                    l = To[i.componentType],
                    f = l.BYTES_PER_ELEMENT,
                    h = f * c,
                    d = i.byteOffset || 0,
                    u = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
                    _ = i.normalized === !0;
                let g, m;
                if (u && u !== h) {
                    const p = Math.floor(d / u),
                        v = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                    let x = t.cache.get(v);
                    x || (g = new l(o, p * u, i.count * u / f), x = new wS(g, u / f), t.cache.add(v, x)), m = new Vh(x, c, d % u / f, _)
                } else o === null ? g = new l(i.count * c) : g = new l(o, d, i.count * c), m = new Zt(g, c, _);
                if (i.sparse !== void 0) {
                    const p = lp.SCALAR,
                        v = To[i.sparse.indices.componentType],
                        x = i.sparse.indices.byteOffset || 0,
                        b = i.sparse.values.byteOffset || 0,
                        S = new v(a[1], x, i.sparse.count * p),
                        E = new l(a[2], b, i.sparse.count * c);
                    o !== null && (m = new Zt(m.array.slice(), m.itemSize, m.normalized)), m.normalized = !1;
                    for (let T = 0, w = S.length; T < w; T++) {
                        const M = S[T];
                        if (m.setX(M, E[T * c]), c >= 2 && m.setY(M, E[T * c + 1]), c >= 3 && m.setZ(M, E[T * c + 2]), c >= 4 && m.setW(M, E[T * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                    m.normalized = _
                }
                return m
            })
        }
        loadTexture(e) {
            const t = this.json,
                n = this.options,
                s = t.textures[e].source,
                a = t.images[s];
            let o = this.textureLoader;
            if (a.uri) {
                const c = n.manager.getHandler(a.uri);
                c !== null && (o = c)
            }
            return this.loadTextureImage(e, s, o)
        }
        loadTextureImage(e, t, n) {
            const i = this,
                s = this.json,
                a = s.textures[e],
                o = s.images[t],
                c = (o.uri || o.bufferView) + ":" + a.sampler;
            if (this.textureCache[c]) return this.textureCache[c];
            const l = this.loadImageSource(t, n).then(function(f) {
                f.flipY = !1, f.name = a.name || o.name || "", f.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (f.name = o.uri);
                const d = (s.samplers || {})[a.sampler] || {};
                return f.magFilter = s0[d.magFilter] || 1006, f.minFilter = s0[d.minFilter] || 1008, f.wrapS = a0[d.wrapS] || 1e3, f.wrapT = a0[d.wrapT] || 1e3, f.generateMipmaps = !f.isCompressedTexture && f.minFilter !== 1003 && f.minFilter !== 1006, i.associations.set(f, {
                    textures: e
                }), f
            }).catch(function() {
                return null
            });
            return this.textureCache[c] = l, l
        }
        loadImageSource(e, t) {
            const n = this,
                i = this.json,
                s = this.options;
            if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone());
            const a = i.images[e],
                o = self.URL || self.webkitURL;
            let c = a.uri || "",
                l = !1;
            if (a.bufferView !== void 0) c = n.getDependency("bufferView", a.bufferView).then(function(h) {
                l = !0;
                const d = new Blob([h], {
                    type: a.mimeType
                });
                return c = o.createObjectURL(d), c
            });
            else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const f = Promise.resolve(c).then(function(h) {
                return new Promise(function(d, u) {
                    let _ = d;
                    t.isImageBitmapLoader === !0 && (_ = function(g) {
                        const m = new on(g);
                        m.needsUpdate = !0, d(m)
                    }), t.load(Ac.resolveURL(h, s.path), _, void 0, u)
                })
            }).then(function(h) {
                return l === !0 && o.revokeObjectURL(c), Vr(h, a), h.userData.mimeType = a.mimeType || TC(a.uri), h
            }).catch(function(h) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", c), h
            });
            return this.sourceCache[e] = f, f
        }
        assignTexture(e, t, n, i) {
            const s = this;
            return this.getDependency("texture", n.index).then(function(a) {
                if (!a) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), s.extensions[mt.KHR_TEXTURE_TRANSFORM]) {
                    const o = n.extensions !== void 0 ? n.extensions[mt.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        const c = s.associations.get(a);
                        a = s.extensions[mt.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, c)
                    }
                }
                return i !== void 0 && (a.colorSpace = i), e[t] = a, a
            })
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = t.attributes.tangent === void 0,
                s = t.attributes.color !== void 0,
                a = t.attributes.normal === void 0;
            if (e.isPoints) {
                const o = "PointsMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new x_, Ei.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = !1, this.cache.add(o, c)), n = c
            } else if (e.isLine) {
                const o = "LineBasicMaterial:" + n.uuid;
                let c = this.cache.get(o);
                c || (c = new p_, Ei.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(o, c)), n = c
            }
            if (i || s || a) {
                let o = "ClonedMaterial:" + n.uuid + ":";
                i && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
                let c = this.cache.get(o);
                c || (c = n.clone(), s && (c.vertexColors = !0), a && (c.flatShading = !0), i && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(n))), n = c
            }
            e.material = n
        }
        getMaterialType() {
            return td
        }
        loadMaterial(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                s = n.materials[e];
            let a;
            const o = {},
                c = s.extensions || {},
                l = [];
            if (c[mt.KHR_MATERIALS_UNLIT]) {
                const h = i[mt.KHR_MATERIALS_UNLIT];
                a = h.getMaterialType(), l.push(h.extendParams(o, s, t))
            } else {
                const h = s.pbrMetallicRoughness || {};
                if (o.color = new rt(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
                    const d = h.baseColorFactor;
                    o.color.setRGB(d[0], d[1], d[2], Dn), o.opacity = d[3]
                }
                h.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", h.baseColorTexture, Jt)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
                    return d.getMaterialType && d.getMaterialType(e)
                }), l.push(Promise.all(this._invokeAll(function(d) {
                    return d.extendMaterialParams && d.extendMaterialParams(e, o)
                })))
            }
            s.doubleSided === !0 && (o.side = 2);
            const f = s.alphaMode || fp.OPAQUE;
            if (f === fp.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, f === fp.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && a !== hs && (l.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new at(1, 1), s.normalTexture.scale !== void 0)) {
                const h = s.normalTexture.scale;
                o.normalScale.set(h, h)
            }
            if (s.occlusionTexture !== void 0 && a !== hs && (l.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== hs) {
                const h = s.emissiveFactor;
                o.emissive = new rt().setRGB(h[0], h[1], h[2], Dn)
            }
            return s.emissiveTexture !== void 0 && a !== hs && l.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Jt)), Promise.all(l).then(function() {
                const h = new a(o);
                return s.name && (h.name = s.name), Vr(h, s), t.associations.set(h, {
                    materials: e
                }), s.extensions && la(i, h, s), h
            })
        }
        createUniqueName(e) {
            const t = Dt.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
        }
        loadGeometries(e) {
            const t = this,
                n = this.extensions,
                i = this.primitiveCache;

            function s(o) {
                return n[mt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(c) {
                    return o0(c, o, t)
                })
            }
            const a = [];
            for (let o = 0, c = e.length; o < c; o++) {
                const l = e[o],
                    f = MC(l),
                    h = i[f];
                if (h) a.push(h.promise);
                else {
                    let d;
                    l.extensions && l.extensions[mt.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = o0(new Fn, l, t), i[f] = {
                        primitive: l,
                        promise: d
                    }, a.push(d)
                }
            }
            return Promise.all(a)
        }
        loadMesh(e) {
            const t = this,
                n = this.json,
                i = this.extensions,
                s = n.meshes[e],
                a = s.primitives,
                o = [];
            for (let c = 0, l = a.length; c < l; c++) {
                const f = a[c].material === void 0 ? vC(this.cache) : this.getDependency("material", a[c].material);
                o.push(f)
            }
            return o.push(t.loadGeometries(a)), Promise.all(o).then(function(c) {
                const l = c.slice(0, c.length - 1),
                    f = c[c.length - 1],
                    h = [];
                for (let u = 0, _ = f.length; u < _; u++) {
                    const g = f[u],
                        m = a[u];
                    let p;
                    const v = l[u];
                    if (m.mode === Fi.TRIANGLES || m.mode === Fi.TRIANGLE_STRIP || m.mode === Fi.TRIANGLE_FAN || m.mode === void 0) p = s.isSkinnedMesh === !0 ? new DS(g, v) : new bn(g, v), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), m.mode === Fi.TRIANGLE_STRIP ? p.geometry = t0(p.geometry, 1) : m.mode === Fi.TRIANGLE_FAN && (p.geometry = t0(p.geometry, 2));
                    else if (m.mode === Fi.LINES) p = new HS(g, v);
                    else if (m.mode === Fi.LINE_STRIP) p = new Qh(g, v);
                    else if (m.mode === Fi.LINE_LOOP) p = new VS(g, v);
                    else if (m.mode === Fi.POINTS) p = new WS(g, v);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
                    Object.keys(p.geometry.morphAttributes).length > 0 && SC(p, s), p.name = t.createUniqueName(s.name || "mesh_" + e), Vr(p, s), m.extensions && la(i, p, m), t.assignFinalMaterial(p), h.push(p)
                }
                for (let u = 0, _ = h.length; u < _; u++) t.associations.set(h[u], {
                    meshes: e,
                    primitives: u
                });
                if (h.length === 1) return s.extensions && la(i, h[0], s), h[0];
                const d = new ps;
                s.extensions && la(i, d, s), t.associations.set(d, {
                    meshes: e
                });
                for (let u = 0, _ = h.length; u < _; u++) d.add(h[u]);
                return d
            })
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e],
                i = n[n.type];
            if (!i) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return
            }
            return n.type === "perspective" ? t = new Hn(Jy.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Du(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Vr(t, n), Promise.resolve(t)
        }
        loadSkin(e) {
            const t = this.json.skins[e],
                n = [];
            for (let i = 0, s = t.joints.length; i < s; i++) n.push(this._loadNodeShallow(t.joints[i]));
            return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
                const s = i.pop(),
                    a = i,
                    o = [],
                    c = [];
                for (let l = 0, f = a.length; l < f; l++) {
                    const h = a[l];
                    if (h) {
                        o.push(h);
                        const d = new Ke;
                        s !== null && d.fromArray(s.array, l * 16), c.push(d)
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l])
                }
                return new jh(o, c)
            })
        }
        loadAnimation(e) {
            const t = this.json,
                n = this,
                i = t.animations[e],
                s = i.name ? i.name : "animation_" + e,
                a = [],
                o = [],
                c = [],
                l = [],
                f = [];
            for (let h = 0, d = i.channels.length; h < d; h++) {
                const u = i.channels[h],
                    _ = i.samplers[u.sampler],
                    g = u.target,
                    m = g.node,
                    p = i.parameters !== void 0 ? i.parameters[_.input] : _.input,
                    v = i.parameters !== void 0 ? i.parameters[_.output] : _.output;
                g.node !== void 0 && (a.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", p)), c.push(this.getDependency("accessor", v)), l.push(_), f.push(g))
            }
            return Promise.all([Promise.all(a), Promise.all(o), Promise.all(c), Promise.all(l), Promise.all(f)]).then(function(h) {
                const d = h[0],
                    u = h[1],
                    _ = h[2],
                    g = h[3],
                    m = h[4],
                    p = [];
                for (let v = 0, x = d.length; v < x; v++) {
                    const b = d[v],
                        S = u[v],
                        E = _[v],
                        T = g[v],
                        w = m[v];
                    if (b === void 0) continue;
                    b.updateMatrix && b.updateMatrix();
                    const M = n._createAnimationTracks(b, S, E, T, w);
                    if (M)
                        for (let y = 0; y < M.length; y++) p.push(M[y])
                }
                return new eM(s, void 0, p)
            })
        }
        createNodeMesh(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e];
            return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
                const a = n._getNodeRef(n.meshCache, i.mesh, s);
                return i.weights !== void 0 && a.traverse(function(o) {
                    if (o.isMesh)
                        for (let c = 0, l = i.weights.length; c < l; c++) o.morphTargetInfluences[c] = i.weights[c]
                }), a
            })
        }
        loadNode(e) {
            const t = this.json,
                n = this,
                i = t.nodes[e],
                s = n._loadNodeShallow(e),
                a = [],
                o = i.children || [];
            for (let l = 0, f = o.length; l < f; l++) a.push(n.getDependency("node", o[l]));
            const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
            return Promise.all([s, Promise.all(a), c]).then(function(l) {
                const f = l[0],
                    h = l[1],
                    d = l[2];
                d !== null && f.traverse(function(u) {
                    u.isSkinnedMesh && u.bind(d, EC)
                });
                for (let u = 0, _ = h.length; u < _; u++) f.add(h[u]);
                return f
            })
        }
        _loadNodeShallow(e) {
            const t = this.json,
                n = this.extensions,
                i = this;
            if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
            const s = t.nodes[e],
                a = s.name ? i.createUniqueName(s.name) : "",
                o = [],
                c = i._invokeOne(function(l) {
                    return l.createNodeMesh && l.createNodeMesh(e)
                });
            return c && o.push(c), s.camera !== void 0 && o.push(i.getDependency("camera", s.camera).then(function(l) {
                return i._getNodeRef(i.cameraCache, s.camera, l)
            })), i._invokeAll(function(l) {
                return l.createNodeAttachment && l.createNodeAttachment(e)
            }).forEach(function(l) {
                o.push(l)
            }), this.nodeCache[e] = Promise.all(o).then(function(l) {
                let f;
                if (s.isBone === !0 ? f = new c_ : l.length > 1 ? f = new ps : l.length === 1 ? f = l[0] : f = new Ht, f !== l[0])
                    for (let h = 0, d = l.length; h < d; h++) f.add(l[h]);
                if (s.name && (f.userData.name = s.name, f.name = a), Vr(f, s), s.extensions && la(n, f, s), s.matrix !== void 0) {
                    const h = new Ke;
                    h.fromArray(s.matrix), f.applyMatrix4(h)
                } else s.translation !== void 0 && f.position.fromArray(s.translation), s.rotation !== void 0 && f.quaternion.fromArray(s.rotation), s.scale !== void 0 && f.scale.fromArray(s.scale);
                if (!i.associations.has(f)) i.associations.set(f, {});
                else if (s.mesh !== void 0 && i.meshCache.refs[s.mesh] > 1) {
                    const h = i.associations.get(f);
                    i.associations.set(f, { ...h
                    })
                }
                return i.associations.get(f).nodes = e, f
            }), this.nodeCache[e]
        }
        loadScene(e) {
            const t = this.extensions,
                n = this.json.scenes[e],
                i = this,
                s = new ps;
            n.name && (s.name = i.createUniqueName(n.name)), Vr(s, n), n.extensions && la(t, s, n);
            const a = n.nodes || [],
                o = [];
            for (let c = 0, l = a.length; c < l; c++) o.push(i.getDependency("node", a[c]));
            return Promise.all(o).then(function(c) {
                for (let f = 0, h = c.length; f < h; f++) s.add(c[f]);
                const l = f => {
                    const h = new Map;
                    for (const [d, u] of i.associations)(d instanceof Ei || d instanceof on) && h.set(d, u);
                    return f.traverse(d => {
                        const u = i.associations.get(d);
                        u != null && h.set(d, u)
                    }), h
                };
                return i.associations = l(s), s
            })
        }
        _createAnimationTracks(e, t, n, i, s) {
            const a = [],
                o = e.name ? e.name : e.uuid,
                c = [];
            Ts[s.path] === Ts.weights ? e.traverse(function(d) {
                d.morphTargetInfluences && c.push(d.name ? d.name : d.uuid)
            }) : c.push(o);
            let l;
            switch (Ts[s.path]) {
                case Ts.weights:
                    l = io;
                    break;
                case Ts.rotation:
                    l = ro;
                    break;
                case Ts.translation:
                case Ts.scale:
                    l = ao;
                    break;
                default:
                    switch (n.itemSize) {
                        case 1:
                            l = io;
                            break;
                        case 2:
                        case 3:
                        default:
                            l = ao;
                            break
                    }
                    break
            }
            const f = i.interpolation !== void 0 ? xC[i.interpolation] : 2301,
                h = this._getArrayFromAccessor(n);
            for (let d = 0, u = c.length; d < u; d++) {
                const _ = new l(c[d] + "." + Ts[s.path], t.array, h, f);
                i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), a.push(_)
            }
            return a
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const n = dp(t.constructor),
                    i = new Float32Array(t.length);
                for (let s = 0, a = t.length; s < a; s++) i[s] = t[s] * n;
                t = i
            }
            return t
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(n) {
                const i = this instanceof ro ? bC : r0;
                return new i(this.times, this.values, this.getValueSize() / 3, n)
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
        }
    }

    function AC(r, e, t) {
        const n = e.attributes,
            i = new Gt;
        if (n.POSITION !== void 0) {
            const o = t.json.accessors[n.POSITION],
                c = o.min,
                l = o.max;
            if (c !== void 0 && l !== void 0) {
                if (i.set(new B(c[0], c[1], c[2]), new B(l[0], l[1], l[2])), o.normalized) {
                    const f = dp(To[o.componentType]);
                    i.min.multiplyScalar(f), i.max.multiplyScalar(f)
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return
            }
        } else return;
        const s = e.targets;
        if (s !== void 0) {
            const o = new B,
                c = new B;
            for (let l = 0, f = s.length; l < f; l++) {
                const h = s[l];
                if (h.POSITION !== void 0) {
                    const d = t.json.accessors[h.POSITION],
                        u = d.min,
                        _ = d.max;
                    if (u !== void 0 && _ !== void 0) {
                        if (c.setX(Math.max(Math.abs(u[0]), Math.abs(_[0]))), c.setY(Math.max(Math.abs(u[1]), Math.abs(_[1]))), c.setZ(Math.max(Math.abs(u[2]), Math.abs(_[2]))), d.normalized) {
                            const g = dp(To[d.componentType]);
                            c.multiplyScalar(g)
                        }
                        o.max(c)
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }
            i.expandByVector(o)
        }
        r.boundingBox = i;
        const a = new Rn;
        i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, r.boundingSphere = a
    }

    function o0(r, e, t) {
        const n = e.attributes,
            i = [];

        function s(a, o) {
            return t.getDependency("accessor", a).then(function(c) {
                r.setAttribute(o, c)
            })
        }
        for (const a in n) {
            const o = up[a] || a.toLowerCase();
            o in r.attributes || i.push(s(n[a], o))
        }
        if (e.indices !== void 0 && !r.index) {
            const a = t.getDependency("accessor", e.indices).then(function(o) {
                r.setIndex(o)
            });
            i.push(a)
        }
        return bt.workingColorSpace !== Dn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${bt.workingColorSpace}" not supported.`), Vr(r, e), AC(r, e, t), Promise.all(i).then(function() {
            return e.targets !== void 0 ? yC(r, e.targets, t) : r
        })
    }
    const pp = new WeakMap;
    class DC extends Js {
        constructor(e) {
            super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }
        setDecoderPath(e) {
            return this.decoderPath = e, this
        }
        setDecoderConfig(e) {
            return this.decoderConfig = e, this
        }
        setWorkerLimit(e) {
            return this.workerLimit = e, this
        }
        load(e, t, n, i) {
            const s = new Au(this.manager);
            s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, a => {
                this.parse(a, t, i)
            }, n, i)
        }
        parse(e, t, n = () => {}) {
            this.decodeDracoFile(e, t, null, null, Jt, n).catch(n)
        }
        decodeDracoFile(e, t, n, i, s = Dn, a = () => {}) {
            const o = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n,
                vertexColorSpace: s
            };
            return this.decodeGeometry(e, o).then(t).catch(a)
        }
        decodeGeometry(e, t) {
            const n = JSON.stringify(t);
            if (pp.has(e)) {
                const c = pp.get(e);
                if (c.key === n) return c.promise;
                if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let i;
            const s = this.workerNextTaskID++,
                a = e.byteLength,
                o = this._getWorker(s, a).then(c => (i = c, new Promise((l, f) => {
                    i._callbacks[s] = {
                        resolve: l,
                        reject: f
                    }, i.postMessage({
                        type: "decode",
                        id: s,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }))).then(c => this._createGeometry(c.geometry));
            return o.catch(() => !0).then(() => {
                i && s && this._releaseTask(i, s)
            }), pp.set(e, {
                key: n,
                promise: o
            }), o
        }
        _createGeometry(e) {
            const t = new Fn;
            e.index && t.setIndex(new Zt(e.index.array, 1));
            for (let n = 0; n < e.attributes.length; n++) {
                const i = e.attributes[n],
                    s = i.name,
                    a = i.array,
                    o = i.itemSize,
                    c = new Zt(a, o);
                s === "color" && (this._assignVertexColorSpace(c, i.vertexColorSpace), c.normalized = !(a instanceof Float32Array)), t.setAttribute(s, c)
            }
            return t
        }
        _assignVertexColorSpace(e, t) {
            if (t !== Jt) return;
            const n = new rt;
            for (let i = 0, s = e.count; i < s; i++) n.fromBufferAttribute(e, i), bt.colorSpaceToWorking(n, Jt), e.setXYZ(i, n.r, n.g, n.b)
        }
        _loadLibrary(e, t) {
            const n = new Au(this.manager);
            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, s) => {
                n.load(e, i, void 0, s)
            })
        }
        preload() {
            return this._initDecoder(), this
        }
        _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
                t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(n => {
                const i = n[0];
                e || (this.decoderConfig.wasmBinary = n[1]);
                const s = CC.toString(),
                    a = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([a]))
            }), this.decoderPending
        }
        _getWorker(e, t) {
            return this._initDecoder().then(() => {
                if (this.workerPool.length < this.workerLimit) {
                    const i = new Worker(this.workerSourceURL);
                    i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), i.onmessage = function(s) {
                        const a = s.data;
                        switch (a.type) {
                            case "decode":
                                i._callbacks[a.id].resolve(a);
                                break;
                            case "error":
                                i._callbacks[a.id].reject(a);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"')
                        }
                    }, this.workerPool.push(i)
                } else this.workerPool.sort(function(i, s) {
                    return i._taskLoad > s._taskLoad ? -1 : 1
                });
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[e] = t, n._taskLoad += t, n
            })
        }
        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
        }
        debug() {
            console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
        }
        dispose() {
            for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
            return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
        }
    }

    function CC() {
        let r, e;
        onmessage = function(a) {
            const o = a.data;
            switch (o.type) {
                case "init":
                    r = o.decoderConfig, e = new Promise(function(f) {
                        r.onModuleLoaded = function(h) {
                            f({
                                draco: h
                            })
                        }, DracoDecoderModule(r)
                    });
                    break;
                case "decode":
                    const c = o.buffer,
                        l = o.taskConfig;
                    e.then(f => {
                        const h = f.draco,
                            d = new h.Decoder;
                        try {
                            const u = t(h, d, new Int8Array(c), l),
                                _ = u.attributes.map(g => g.array.buffer);
                            u.index && _.push(u.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: o.id,
                                geometry: u
                            }, _)
                        } catch (u) {
                            console.error(u), self.postMessage({
                                type: "error",
                                id: o.id,
                                error: u.message
                            })
                        } finally {
                            h.destroy(d)
                        }
                    });
                    break
            }
        };

        function t(a, o, c, l) {
            const f = l.attributeIDs,
                h = l.attributeTypes;
            let d, u;
            const _ = o.GetEncodedGeometryType(c);
            if (_ === a.TRIANGULAR_MESH) d = new a.Mesh, u = o.DecodeArrayToMesh(c, c.byteLength, d);
            else if (_ === a.POINT_CLOUD) d = new a.PointCloud, u = o.DecodeArrayToPointCloud(c, c.byteLength, d);
            else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
            if (!u.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + u.error_msg());
            const g = {
                index: null,
                attributes: []
            };
            for (const m in f) {
                const p = self[h[m]];
                let v, x;
                if (l.useUniqueIDs) x = f[m], v = o.GetAttributeByUniqueId(d, x);
                else {
                    if (x = o.GetAttributeId(d, a[f[m]]), x === -1) continue;
                    v = o.GetAttribute(d, x)
                }
                const b = i(a, o, d, m, p, v);
                m === "color" && (b.vertexColorSpace = l.vertexColorSpace), g.attributes.push(b)
            }
            return _ === a.TRIANGULAR_MESH && (g.index = n(a, o, d)), a.destroy(d), g
        }

        function n(a, o, c) {
            const f = c.num_faces() * 3,
                h = f * 4,
                d = a._malloc(h);
            o.GetTrianglesUInt32Array(c, h, d);
            const u = new Uint32Array(a.HEAPF32.buffer, d, f).slice();
            return a._free(d), {
                array: u,
                itemSize: 1
            }
        }

        function i(a, o, c, l, f, h) {
            const d = h.num_components(),
                _ = c.num_points() * d,
                g = _ * f.BYTES_PER_ELEMENT,
                m = s(a, f),
                p = a._malloc(g);
            o.GetAttributeDataArrayForAllPoints(c, h, m, g, p);
            const v = new f(a.HEAPF32.buffer, p, _).slice();
            return a._free(p), {
                name: l,
                array: v,
                itemSize: d
            }
        }

        function s(a, o) {
            switch (o) {
                case Float32Array:
                    return a.DT_FLOAT32;
                case Int8Array:
                    return a.DT_INT8;
                case Int16Array:
                    return a.DT_INT16;
                case Int32Array:
                    return a.DT_INT32;
                case Uint8Array:
                    return a.DT_UINT8;
                case Uint16Array:
                    return a.DT_UINT16;
                case Uint32Array:
                    return a.DT_UINT32
            }
        }
    }
    var RC = function() {
        var r = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
            e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb",
            t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
            n = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
        if (typeof WebAssembly != "object") return {
            supported: !1
        };
        var i = WebAssembly.validate(t) ? e : r,
            s, a = WebAssembly.instantiate(o(i), {}).then(function(p) {
                s = p.instance, s.exports.__wasm_call_ctors()
            });

        function o(p) {
            for (var v = new Uint8Array(p.length), x = 0; x < p.length; ++x) {
                var b = p.charCodeAt(x);
                v[x] = b > 96 ? b - 97 : b > 64 ? b - 39 : b + 4
            }
            for (var S = 0, x = 0; x < p.length; ++x) v[S++] = v[x] < 60 ? n[v[x]] : (v[x] - 60) * 64 + v[++x];
            return v.buffer.slice(0, S)
        }

        function c(p, v, x, b, S, E) {
            var T = s.exports.sbrk,
                w = x + 3 & -4,
                M = T(w * b),
                y = T(S.length),
                D = new Uint8Array(s.exports.memory.buffer);
            D.set(S, y);
            var R = p(M, x, b, y, S.length);
            if (R == 0 && E && E(M, w, b), v.set(D.subarray(M, M + x * b)), T(M - T(0)), R != 0) throw new Error("Malformed buffer data: " + R)
        }
        var l = {
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            },
            f = {
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            },
            h = [],
            d = 0;

        function u(p) {
            var v = {
                object: new Worker(p),
                pending: 0,
                requests: {}
            };
            return v.object.onmessage = function(x) {
                var b = x.data;
                v.pending -= b.count, v.requests[b.id][b.action](b.value), delete v.requests[b.id]
            }, v
        }

        function _(p) {
            for (var v = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + c.toString() + m.toString(), x = new Blob([v], {
                    type: "text/javascript"
                }), b = URL.createObjectURL(x), S = 0; S < p; ++S) h[S] = u(b);
            URL.revokeObjectURL(b)
        }

        function g(p, v, x, b, S) {
            for (var E = h[0], T = 1; T < h.length; ++T) h[T].pending < E.pending && (E = h[T]);
            return new Promise(function(w, M) {
                var y = new Uint8Array(x),
                    D = d++;
                E.pending += p, E.requests[D] = {
                    resolve: w,
                    reject: M
                }, E.object.postMessage({
                    id: D,
                    count: p,
                    size: v,
                    source: y,
                    mode: b,
                    filter: S
                }, [y.buffer])
            })
        }

        function m(p) {
            a.then(function() {
                var v = p.data;
                try {
                    var x = new Uint8Array(v.count * v.size);
                    c(s.exports[v.mode], x, v.count, v.size, v.source, s.exports[v.filter]), self.postMessage({
                        id: v.id,
                        count: v.count,
                        action: "resolve",
                        value: x
                    }, [x.buffer])
                } catch (b) {
                    self.postMessage({
                        id: v.id,
                        count: v.count,
                        action: "reject",
                        value: b
                    })
                }
            })
        }
        return {
            ready: a,
            supported: !0,
            useWorkers: function(p) {
                _(p)
            },
            decodeVertexBuffer: function(p, v, x, b, S) {
                c(s.exports.meshopt_decodeVertexBuffer, p, v, x, b, s.exports[l[S]])
            },
            decodeIndexBuffer: function(p, v, x, b) {
                c(s.exports.meshopt_decodeIndexBuffer, p, v, x, b)
            },
            decodeIndexSequence: function(p, v, x, b) {
                c(s.exports.meshopt_decodeIndexSequence, p, v, x, b)
            },
            decodeGltfBuffer: function(p, v, x, b, S, E) {
                c(s.exports[f[S]], p, v, x, b, s.exports[l[E]])
            },
            decodeGltfBufferAsync: function(p, v, x, b, S) {
                return h.length > 0 ? g(p, v, x, f[b], l[S]) : a.then(function() {
                    var E = new Uint8Array(p * v);
                    return c(s.exports[f[b]], E, p, v, x, s.exports[l[S]]), E
                })
            }
        }
    }();
    class PC {
        constructor(e) {
            this.dracoLoader = new DC, this.loader = new q1(e), this.dracoLoader.setDecoderPath("/draco/"), this.dracoLoader.preload(), this.loader.setDRACOLoader(this.dracoLoader), this.loader.setMeshoptDecoder(RC)
        }
        async load(e) {
            if (Array.isArray(e)) {
                const t = e.map(n => this.#e(n));
                return await Promise.all(t)
            } else return await this.#e(e)
        }#
        e(e) {
            return new Promise(t => {
                this.loader.load(e, n => {
                    t(n)
                })
            })
        }
    }
    const qc = new w_;
    qc.onProgress = (r, e, t) => {
        console.log(`Loaded ${e} resources out of ${t} -> ${r}`)
    }, new j1(qc);
    const FC = new PC(qc);

    function Wr(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
    }

    function c0(r, e) {
        r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
    }
    /*!
     * GSAP 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var mi = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Eo = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        mp, Ln, Bt, mr = 1e8,
        Nn = 1 / mr,
        gp = Math.PI * 2,
        IC = gp / 4,
        LC = 0,
        l0 = Math.sqrt,
        NC = Math.cos,
        UC = Math.sin,
        xn = function(e) {
            return typeof e == "string"
        },
        $t = function(e) {
            return typeof e == "function"
        },
        Xr = function(e) {
            return typeof e == "number"
        },
        _p = function(e) {
            return typeof e > "u"
        },
        gr = function(e) {
            return typeof e == "object"
        },
        ri = function(e) {
            return e !== !1
        },
        bp = function() {
            return typeof window < "u"
        },
        uf = function(e) {
            return $t(e) || xn(e)
        },
        u0 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
        Un = Array.isArray,
        xp = /(?:-?\.?\d|\.)+/gi,
        f0 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        wo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        vp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        h0 = /[+-]=-?[.\d]+/,
        d0 = /[^,'"\[\]\s]+/gi,
        OC = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        Vt, _r, yp, Sp, gi = {},
        ff = {},
        p0, m0 = function(e) {
            return (ff = fa(e, gi)) && oi
        },
        Mp = function(e, t) {
            return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
        },
        Yc = function(e, t) {
            return !t && console.warn(e)
        },
        g0 = function(e, t) {
            return e && (gi[e] = t) && ff && (ff[e] = t) || gi
        },
        $c = function() {
            return 0
        },
        BC = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        },
        hf = {
            suppressEvents: !0,
            kill: !1
        },
        kC = {
            suppressEvents: !0
        },
        Tp = {},
        Es = [],
        Ep = {},
        _0, _i = {},
        wp = {},
        b0 = 30,
        df = [],
        Ap = "",
        Dp = function(e) {
            var t = e[0],
                n, i;
            if (gr(t) || $t(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
                for (i = df.length; i-- && !df[i].targetTest(t););
                n = df[i]
            }
            for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new q0(e[i], n))) || e.splice(i, 1);
            return e
        },
        ua = function(e) {
            return e._gsap || Dp(Ni(e))[0]._gsap
        },
        x0 = function(e, t, n) {
            return (n = e[t]) && $t(n) ? e[t]() : _p(n) && e.getAttribute && e.getAttribute(t) || n
        },
        si = function(e, t) {
            return (e = e.split(",")).forEach(t) || e
        },
        Qt = function(e) {
            return Math.round(e * 1e5) / 1e5 || 0
        },
        vn = function(e) {
            return Math.round(e * 1e7) / 1e7 || 0
        },
        Ao = function(e, t) {
            var n = t.charAt(0),
                i = parseFloat(t.substr(2));
            return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
        },
        zC = function(e, t) {
            for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
            return i < n
        },
        pf = function() {
            var e = Es.length,
                t = Es.slice(0),
                n, i;
            for (Ep = {}, Es.length = 0, n = 0; n < e; n++) i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
        },
        v0 = function(e, t, n, i) {
            Es.length && !Ln && pf(), e.render(t, n, Ln && t < 0 && (e._initted || e._startAt)), Es.length && !Ln && pf()
        },
        y0 = function(e) {
            var t = parseFloat(e);
            return (t || t === 0) && (e + "").match(d0).length < 2 ? t : xn(e) ? e.trim() : e
        },
        S0 = function(e) {
            return e
        },
        Ii = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        GC = function(e) {
            return function(t, n) {
                for (var i in n) i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
            }
        },
        fa = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        M0 = function r(e, t) {
            for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = gr(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
            return e
        },
        mf = function(e, t) {
            var n = {},
                i;
            for (i in e) i in t || (n[i] = e[i]);
            return n
        },
        Kc = function(e) {
            var t = e.parent || Vt,
                n = e.keyframes ? GC(Un(e.keyframes)) : Ii;
            if (ri(e.inherit))
                for (; t;) n(e, t.vars.defaults), t = t.parent || t._dp;
            return e
        },
        HC = function(e, t) {
            for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
            return n < 0
        },
        T0 = function(e, t, n, i, s) {
            var a = e[i],
                o;
            if (s)
                for (o = t[s]; a && a[s] > o;) a = a._prev;
            return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t
        },
        gf = function(e, t, n, i) {
            n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
            var s = t._prev,
                a = t._next;
            s ? s._next = a : e[n] === t && (e[n] = a), a ? a._prev = s : e[i] === t && (e[i] = s), t._next = t._prev = t.parent = null
        },
        ws = function(e, t) {
            e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
        },
        ha = function(e, t) {
            if (e && (!t || t._end > e._dur || t._start < 0))
                for (var n = e; n;) n._dirty = 1, n = n.parent;
            return e
        },
        VC = function(e) {
            for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
            return e
        },
        Cp = function(e, t, n, i) {
            return e._startAt && (Ln ? e._startAt.revert(hf) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
        },
        WC = function r(e) {
            return !e || e._ts && r(e.parent)
        },
        E0 = function(e) {
            return e._repeat ? Do(e._tTime, e = e.duration() + e._rDelay) * e : 0
        },
        Do = function(e, t) {
            var n = Math.floor(e /= t);
            return e && n === e ? n - 1 : n
        },
        _f = function(e, t) {
            return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        },
        bf = function(e) {
            return e._end = vn(e._start + (e._tDur / Math.abs(e._ts || e._rts || Nn) || 0))
        },
        xf = function(e, t) {
            var n = e._dp;
            return n && n.smoothChildTiming && e._ts && (e._start = vn(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), bf(e), n._dirty || ha(n, e)), e
        },
        w0 = function(e, t) {
            var n;
            if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = _f(e.rawTime(), t), (!t._dur || Zc(0, t.totalDuration(), n) - t._tTime > Nn) && t.render(n, !0)), ha(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                if (e._dur < e.duration())
                    for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                e._zTime = -1e-8
            }
        },
        br = function(e, t, n, i) {
            return t.parent && ws(t), t._start = vn((Xr(n) ? n : n || e !== Vt ? Li(e, n, t) : e._time) + t._delay), t._end = vn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), T0(e, t, "_first", "_last", e._sort ? "_start" : 0), Rp(t) || (e._recent = t), i || w0(e, t), e._ts < 0 && xf(e, e._tTime), e
        },
        A0 = function(e, t) {
            return (gi.ScrollTrigger || Mp("scrollTrigger", t)) && gi.ScrollTrigger.create(t, e)
        },
        D0 = function(e, t, n, i, s) {
            if (kp(e, t, s), !e._initted) return 1;
            if (!n && e._pt && !Ln && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && _0 !== xi.frame) return Es.push(e), e._lazy = [s, i], 1
        },
        XC = function r(e) {
            var t = e.parent;
            return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t))
        },
        Rp = function(e) {
            var t = e.data;
            return t === "isFromStart" || t === "isStart"
        },
        jC = function(e, t, n, i) {
            var s = e.ratio,
                a = t < 0 || !t && (!e._start && XC(e) && !(!e._initted && Rp(e)) || (e._ts < 0 || e._dp._ts < 0) && !Rp(e)) ? 0 : 1,
                o = e._rDelay,
                c = 0,
                l, f, h;
            if (o && e._repeat && (c = Zc(0, e._tDur, t), f = Do(c, o), e._yoyo && f & 1 && (a = 1 - a), f !== Do(e._tTime, o) && (s = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== s || Ln || i || e._zTime === Nn || !t && e._zTime) {
                if (!e._initted && D0(e, t, i, n, c)) return;
                for (h = e._zTime, e._zTime = t || (n ? Nn : 0), n || (n = t && !h), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = c, l = e._pt; l;) l.r(a, l.d), l = l._next;
                t < 0 && Cp(e, t, n, !0), e._onUpdate && !n && bi(e, "onUpdate"), c && e._repeat && !n && e.parent && bi(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && ws(e, 1), !n && !Ln && (bi(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
            } else e._zTime || (e._zTime = t)
        },
        qC = function(e, t, n) {
            var i;
            if (n > t)
                for (i = e._first; i && i._start <= n;) {
                    if (i.data === "isPause" && i._start > t) return i;
                    i = i._next
                } else
                    for (i = e._last; i && i._start >= n;) {
                        if (i.data === "isPause" && i._start < t) return i;
                        i = i._prev
                    }
        },
        Co = function(e, t, n, i) {
            var s = e._repeat,
                a = vn(t) || 0,
                o = e._tTime / e._tDur;
            return o && !i && (e._time *= a / e._dur), e._dur = a, e._tDur = s ? s < 0 ? 1e10 : vn(a * (s + 1) + e._rDelay * s) : a, o > 0 && !i && xf(e, e._tTime = e._tDur * o), e.parent && bf(e), n || ha(e.parent, e), e
        },
        C0 = function(e) {
            return e instanceof jn ? ha(e) : Co(e, e._dur)
        },
        YC = {
            _start: 0,
            endTime: $c,
            totalDuration: $c
        },
        Li = function r(e, t, n) {
            var i = e.labels,
                s = e._recent || YC,
                a = e.duration() >= mr ? s.endTime(!1) : e._dur,
                o, c, l;
            return xn(t) && (isNaN(t) || t in i) ? (c = t.charAt(0), l = t.substr(-1) === "%", o = t.indexOf("="), c === "<" || c === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (c === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (l ? (o < 0 ? s : n).totalDuration() / 100 : 1)) : o < 0 ? (t in i || (i[t] = a), i[t]) : (c = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), l && n && (c = c / 100 * (Un(n) ? n[0] : n).totalDuration()), o > 1 ? r(e, t.substr(0, o - 1), n) + c : a + c)) : t == null ? a : +t
        },
        Jc = function(e, t, n) {
            var i = Xr(t[1]),
                s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
                a = t[s],
                o, c;
            if (i && (a.duration = t[1]), a.parent = n, e) {
                for (o = a, c = n; c && !("immediateRender" in o);) o = c.vars.defaults || {}, c = ri(c.vars.inherit) && c.parent;
                a.immediateRender = ri(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1]
            }
            return new rn(t[0], a, t[s + 1])
        },
        As = function(e, t) {
            return e || e === 0 ? t(e) : t
        },
        Zc = function(e, t, n) {
            return n < e ? e : n > t ? t : n
        },
        On = function(e, t) {
            return !xn(e) || !(t = OC.exec(e)) ? "" : t[1]
        },
        $C = function(e, t, n) {
            return As(n, function(i) {
                return Zc(e, t, i)
            })
        },
        Pp = [].slice,
        R0 = function(e, t) {
            return e && gr(e) && "length" in e && (!t && !e.length || e.length - 1 in e && gr(e[0])) && !e.nodeType && e !== _r
        },
        KC = function(e, t, n) {
            return n === void 0 && (n = []), e.forEach(function(i) {
                var s;
                return xn(i) && !t || R0(i, 1) ? (s = n).push.apply(s, Ni(i)) : n.push(i)
            }) || n
        },
        Ni = function(e, t, n) {
            return Bt && !t && Bt.selector ? Bt.selector(e) : xn(e) && !n && (yp || !Po()) ? Pp.call((t || Sp).querySelectorAll(e), 0) : Un(e) ? KC(e, n) : R0(e) ? Pp.call(e, 0) : e ? [e] : []
        },
        Fp = function(e) {
            return e = Ni(e)[0] || Yc("Invalid scope") || {},
                function(t) {
                    var n = e.current || e.nativeElement || e;
                    return Ni(t, n.querySelectorAll ? n : n === e ? Yc("Invalid scope") || Sp.createElement("div") : e)
                }
        },
        P0 = function(e) {
            return e.sort(function() {
                return .5 - Math.random()
            })
        },
        F0 = function(e) {
            if ($t(e)) return e;
            var t = gr(e) ? e : {
                    each: e
                },
                n = da(t.ease),
                i = t.from || 0,
                s = parseFloat(t.base) || 0,
                a = {},
                o = i > 0 && i < 1,
                c = isNaN(i) || o,
                l = t.axis,
                f = i,
                h = i;
            return xn(i) ? f = h = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[i] || 0 : !o && c && (f = i[0], h = i[1]),
                function(d, u, _) {
                    var g = (_ || t).length,
                        m = a[g],
                        p, v, x, b, S, E, T, w, M;
                    if (!m) {
                        if (M = t.grid === "auto" ? 0 : (t.grid || [1, mr])[1], !M) {
                            for (T = -1e8; T < (T = _[M++].getBoundingClientRect().left) && M < g;);
                            M < g && M--
                        }
                        for (m = a[g] = [], p = c ? Math.min(M, g) * f - .5 : i % M, v = M === mr ? 0 : c ? g * h / M - .5 : i / M | 0, T = 0, w = mr, E = 0; E < g; E++) x = E % M - p, b = v - (E / M | 0), m[E] = S = l ? Math.abs(l === "y" ? b : x) : l0(x * x + b * b), S > T && (T = S), S < w && (w = S);
                        i === "random" && P0(m), m.max = T - w, m.min = w, m.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (M > g ? g - 1 : l ? l === "y" ? g / M : M : Math.max(M, g / M)) || 0) * (i === "edges" ? -1 : 1), m.b = g < 0 ? s - g : s, m.u = On(t.amount || t.each) || 0, n = n && g < 0 ? W0(n) : n
                    }
                    return g = (m[d] - m.min) / m.max || 0, vn(m.b + (n ? n(g) : g) * m.v) + m.u
                }
        },
        Ip = function(e) {
            var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
            return function(n) {
                var i = vn(Math.round(parseFloat(n) / e) * e * t);
                return (i - i % 1) / t + (Xr(n) ? 0 : On(n))
            }
        },
        I0 = function(e, t) {
            var n = Un(e),
                i, s;
            return !n && gr(e) && (i = n = e.radius || mr, e.values ? (e = Ni(e.values), (s = !Xr(e[0])) && (i *= i)) : e = Ip(e.increment)), As(t, n ? $t(e) ? function(a) {
                return s = e(a), Math.abs(s - a) <= i ? s : a
            } : function(a) {
                for (var o = parseFloat(s ? a.x : a), c = parseFloat(s ? a.y : 0), l = mr, f = 0, h = e.length, d, u; h--;) s ? (d = e[h].x - o, u = e[h].y - c, d = d * d + u * u) : d = Math.abs(e[h] - o), d < l && (l = d, f = h);
                return f = !i || l <= i ? e[f] : a, s || f === a || Xr(a) ? f : f + On(a)
            } : Ip(e))
        },
        L0 = function(e, t, n, i) {
            return As(Un(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
                return Un(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
            })
        },
        JC = function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return function(i) {
                return t.reduce(function(s, a) {
                    return a(s)
                }, i)
            }
        },
        ZC = function(e, t) {
            return function(n) {
                return e(parseFloat(n)) + (t || On(n))
            }
        },
        QC = function(e, t, n) {
            return U0(e, t, 0, 1, n)
        },
        N0 = function(e, t, n) {
            return As(n, function(i) {
                return e[~~t(i)]
            })
        },
        eR = function r(e, t, n) {
            var i = t - e;
            return Un(e) ? N0(e, r(0, e.length), t) : As(n, function(s) {
                return (i + (s - e) % i) % i + e
            })
        },
        tR = function r(e, t, n) {
            var i = t - e,
                s = i * 2;
            return Un(e) ? N0(e, r(0, e.length - 1), t) : As(n, function(a) {
                return a = (s + (a - e) % s) % s || 0, e + (a > i ? s - a : a)
            })
        },
        Qc = function(e) {
            for (var t = 0, n = "", i, s, a, o; ~(i = e.indexOf("random(", t));) a = e.indexOf(")", i), o = e.charAt(i + 7) === "[", s = e.substr(i + 7, a - i - 7).match(o ? d0 : xp), n += e.substr(t, i - t) + L0(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), t = a + 1;
            return n + e.substr(t, e.length - t)
        },
        U0 = function(e, t, n, i, s) {
            var a = t - e,
                o = i - n;
            return As(s, function(c) {
                return n + ((c - e) / a * o || 0)
            })
        },
        nR = function r(e, t, n, i) {
            var s = isNaN(e + t) ? 0 : function(u) {
                return (1 - u) * e + u * t
            };
            if (!s) {
                var a = xn(e),
                    o = {},
                    c, l, f, h, d;
                if (n === !0 && (i = 1) && (n = null), a) e = {
                    p: e
                }, t = {
                    p: t
                };
                else if (Un(e) && !Un(t)) {
                    for (f = [], h = e.length, d = h - 2, l = 1; l < h; l++) f.push(r(e[l - 1], e[l]));
                    h--, s = function(_) {
                        _ *= h;
                        var g = Math.min(d, ~~_);
                        return f[g](_ - g)
                    }, n = t
                } else i || (e = fa(Un(e) ? [] : {}, e));
                if (!f) {
                    for (c in t) Op.call(o, e, c, "get", t[c]);
                    s = function(_) {
                        return Hp(_, o) || (a ? e.p : e)
                    }
                }
            }
            return As(n, s)
        },
        O0 = function(e, t, n) {
            var i = e.labels,
                s = mr,
                a, o, c;
            for (a in i) o = i[a] - t, o < 0 == !!n && o && s > (o = Math.abs(o)) && (c = a, s = o);
            return c
        },
        bi = function(e, t, n) {
            var i = e.vars,
                s = i[t],
                a = Bt,
                o = e._ctx,
                c, l, f;
            if (s) return c = i[t + "Params"], l = i.callbackScope || e, n && Es.length && pf(), o && (Bt = o), f = c ? s.apply(l, c) : s.call(l), Bt = a, f
        },
        el = function(e) {
            return ws(e), e.scrollTrigger && e.scrollTrigger.kill(!!Ln), e.progress() < 1 && bi(e, "onInterrupt"), e
        },
        Ro, B0 = [],
        k0 = function(e) {
            if (e)
                if (e = !e.name && e.default || e, bp() || e.headless) {
                    var t = e.name,
                        n = $t(e),
                        i = t && !n && e.init ? function() {
                            this._props = []
                        } : e,
                        s = {
                            init: $c,
                            render: Hp,
                            add: Op,
                            kill: bR,
                            modifier: _R,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Gp,
                            aliases: {},
                            register: 0
                        };
                    if (Po(), e !== i) {
                        if (_i[t]) return;
                        Ii(i, Ii(mf(e, s), a)), fa(i.prototype, fa(s, mf(e, a))), _i[i.prop = t] = i, e.targetTest && (df.push(i), Tp[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    g0(t, i), e.register && e.register(oi, i, ai)
                } else B0.push(e)
        },
        Ft = 255,
        tl = {
            aqua: [0, Ft, Ft],
            lime: [0, Ft, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, Ft],
            navy: [0, 0, 128],
            white: [Ft, Ft, Ft],
            olive: [128, 128, 0],
            yellow: [Ft, Ft, 0],
            orange: [Ft, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [Ft, 0, 0],
            pink: [Ft, 192, 203],
            cyan: [0, Ft, Ft],
            transparent: [Ft, Ft, Ft, 0]
        },
        Lp = function(e, t, n) {
            return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Ft + .5 | 0
        },
        z0 = function(e, t, n) {
            var i = e ? Xr(e) ? [e >> 16, e >> 8 & Ft, e & Ft] : 0 : tl.black,
                s, a, o, c, l, f, h, d, u, _;
            if (!i) {
                if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), tl[e]) i = tl[e];
                else if (e.charAt(0) === "#") {
                    if (e.length < 6 && (s = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + s + s + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & Ft, i & Ft, parseInt(e.substr(7), 16) / 255];
                    e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & Ft, e & Ft]
                } else if (e.substr(0, 3) === "hsl") {
                    if (i = _ = e.match(xp), !t) c = +i[0] % 360 / 360, l = +i[1] / 100, f = +i[2] / 100, a = f <= .5 ? f * (l + 1) : f + l - f * l, s = f * 2 - a, i.length > 3 && (i[3] *= 1), i[0] = Lp(c + 1 / 3, s, a), i[1] = Lp(c, s, a), i[2] = Lp(c - 1 / 3, s, a);
                    else if (~e.indexOf("=")) return i = e.match(f0), n && i.length < 4 && (i[3] = 1), i
                } else i = e.match(xp) || tl.transparent;
                i = i.map(Number)
            }
            return t && !_ && (s = i[0] / Ft, a = i[1] / Ft, o = i[2] / Ft, h = Math.max(s, a, o), d = Math.min(s, a, o), f = (h + d) / 2, h === d ? c = l = 0 : (u = h - d, l = f > .5 ? u / (2 - h - d) : u / (h + d), c = h === s ? (a - o) / u + (a < o ? 6 : 0) : h === a ? (o - s) / u + 2 : (s - a) / u + 4, c *= 60), i[0] = ~~(c + .5), i[1] = ~~(l * 100 + .5), i[2] = ~~(f * 100 + .5)), n && i.length < 4 && (i[3] = 1), i
        },
        G0 = function(e) {
            var t = [],
                n = [],
                i = -1;
            return e.split(Ds).forEach(function(s) {
                var a = s.match(wo) || [];
                t.push.apply(t, a), n.push(i += a.length + 1)
            }), t.c = n, t
        },
        H0 = function(e, t, n) {
            var i = "",
                s = (e + i).match(Ds),
                a = t ? "hsla(" : "rgba(",
                o = 0,
                c, l, f, h;
            if (!s) return e;
            if (s = s.map(function(d) {
                    return (d = z0(d, t, 1)) && a + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
                }), n && (f = G0(e), c = n.c, c.join(i) !== f.c.join(i)))
                for (l = e.replace(Ds, "1").split(wo), h = l.length - 1; o < h; o++) i += l[o] + (~c.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (f.length ? f : s.length ? s : n).shift());
            if (!l)
                for (l = e.split(Ds), h = l.length - 1; o < h; o++) i += l[o] + s[o];
            return i + l[h]
        },
        Ds = function() {
            var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                e;
            for (e in tl) r += "|" + e + "\\b";
            return new RegExp(r + ")", "gi")
        }(),
        iR = /hsl[a]?\(/,
        V0 = function(e) {
            var t = e.join(" "),
                n;
            if (Ds.lastIndex = 0, Ds.test(t)) return n = iR.test(t), e[1] = H0(e[1], n), e[0] = H0(e[0], n, G0(e[1])), !0
        },
        nl, xi = function() {
            var r = Date.now,
                e = 500,
                t = 33,
                n = r(),
                i = n,
                s = 1e3 / 240,
                a = s,
                o = [],
                c, l, f, h, d, u, _ = function g(m) {
                    var p = r() - i,
                        v = m === !0,
                        x, b, S, E;
                    if ((p > e || p < 0) && (n += p - t), i += p, S = i - n, x = S - a, (x > 0 || v) && (E = ++h.frame, d = S - h.time * 1e3, h.time = S = S / 1e3, a += x + (x >= s ? 4 : s - x), b = 1), v || (c = l(g)), b)
                        for (u = 0; u < o.length; u++) o[u](S, d, E, m)
                };
            return h = {
                time: 0,
                frame: 0,
                tick: function() {
                    _(!0)
                },
                deltaRatio: function(m) {
                    return d / (1e3 / (m || 60))
                },
                wake: function() {
                    p0 && (!yp && bp() && (_r = yp = window, Sp = _r.document || {}, gi.gsap = oi, (_r.gsapVersions || (_r.gsapVersions = [])).push(oi.version), m0(ff || _r.GreenSockGlobals || !_r.gsap && _r || {}), B0.forEach(k0)), f = typeof requestAnimationFrame < "u" && requestAnimationFrame, c && h.sleep(), l = f || function(m) {
                        return setTimeout(m, a - h.time * 1e3 + 1 | 0)
                    }, nl = 1, _(2))
                },
                sleep: function() {
                    (f ? cancelAnimationFrame : clearTimeout)(c), nl = 0, l = $c
                },
                lagSmoothing: function(m, p) {
                    e = m || 1 / 0, t = Math.min(p || 33, e)
                },
                fps: function(m) {
                    s = 1e3 / (m || 240), a = h.time * 1e3 + s
                },
                add: function(m, p, v) {
                    var x = p ? function(b, S, E, T) {
                        m(b, S, E, T), h.remove(x)
                    } : m;
                    return h.remove(m), o[v ? "unshift" : "push"](x), Po(), x
                },
                remove: function(m, p) {
                    ~(p = o.indexOf(m)) && o.splice(p, 1) && u >= p && u--
                },
                _listeners: o
            }, h
        }(),
        Po = function() {
            return !nl && xi.wake()
        },
        vt = {},
        rR = /^[\d.\-M][\d.\-,\s]/,
        sR = /["']/g,
        aR = function(e) {
            for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], s = 1, a = n.length, o, c, l; s < a; s++) c = n[s], o = s !== a - 1 ? c.lastIndexOf(",") : c.length, l = c.substr(0, o), t[i] = isNaN(l) ? l.replace(sR, "").trim() : +l, i = c.substr(o + 1).trim();
            return t
        },
        oR = function(e) {
            var t = e.indexOf("(") + 1,
                n = e.indexOf(")"),
                i = e.indexOf("(", t);
            return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
        },
        cR = function(e) {
            var t = (e + "").split("("),
                n = vt[t[0]];
            return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [aR(t[1])] : oR(e).split(",").map(y0)) : vt._CE && rR.test(e) ? vt._CE("", e) : n
        },
        W0 = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        X0 = function r(e, t) {
            for (var n = e._first, i; n;) n instanceof jn ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
        },
        da = function(e, t) {
            return e && ($t(e) ? e : vt[e] || cR(e)) || t
        },
        pa = function(e, t, n, i) {
            n === void 0 && (n = function(c) {
                return 1 - t(1 - c)
            }), i === void 0 && (i = function(c) {
                return c < .5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2
            });
            var s = {
                    easeIn: t,
                    easeOut: n,
                    easeInOut: i
                },
                a;
            return si(e, function(o) {
                vt[o] = gi[o] = s, vt[a = o.toLowerCase()] = n;
                for (var c in s) vt[a + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")] = vt[o + "." + c] = s[c]
            }), s
        },
        j0 = function(e) {
            return function(t) {
                return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
            }
        },
        Np = function r(e, t, n) {
            var i = t >= 1 ? t : 1,
                s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1),
                a = s / gp * (Math.asin(1 / i) || 0),
                o = function(f) {
                    return f === 1 ? 1 : i * Math.pow(2, -10 * f) * UC((f - a) * s) + 1
                },
                c = e === "out" ? o : e === "in" ? function(l) {
                    return 1 - o(1 - l)
                } : j0(o);
            return s = gp / s, c.config = function(l, f) {
                return r(e, l, f)
            }, c
        },
        Up = function r(e, t) {
            t === void 0 && (t = 1.70158);
            var n = function(a) {
                    return a ? --a * a * ((t + 1) * a + t) + 1 : 0
                },
                i = e === "out" ? n : e === "in" ? function(s) {
                    return 1 - n(1 - s)
                } : j0(n);
            return i.config = function(s) {
                return r(e, s)
            }, i
        };
    si("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
            var t = e < 5 ? e + 1 : e;
            pa(r + ",Power" + (t - 1), e ? function(n) {
                return Math.pow(n, t)
            } : function(n) {
                return n
            }, function(n) {
                return 1 - Math.pow(1 - n, t)
            }, function(n) {
                return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
            })
        }), vt.Linear.easeNone = vt.none = vt.Linear.easeIn, pa("Elastic", Np("in"), Np("out"), Np()),
        function(r, e) {
            var t = 1 / e,
                n = 2 * t,
                i = 2.5 * t,
                s = function(o) {
                    return o < t ? r * o * o : o < n ? r * Math.pow(o - 1.5 / e, 2) + .75 : o < i ? r * (o -= 2.25 / e) * o + .9375 : r * Math.pow(o - 2.625 / e, 2) + .984375
                };
            pa("Bounce", function(a) {
                return 1 - s(1 - a)
            }, s)
        }(7.5625, 2.75), pa("Expo", function(r) {
            return r ? Math.pow(2, 10 * (r - 1)) : 0
        }), pa("Circ", function(r) {
            return -(l0(1 - r * r) - 1)
        }), pa("Sine", function(r) {
            return r === 1 ? 1 : -NC(r * IC) + 1
        }), pa("Back", Up("in"), Up("out"), Up()), vt.SteppedEase = vt.steps = gi.SteppedEase = {
            config: function(e, t) {
                e === void 0 && (e = 1);
                var n = 1 / e,
                    i = e + (t ? 0 : 1),
                    s = t ? 1 : 0,
                    a = 1 - Nn;
                return function(o) {
                    return ((i * Zc(0, a, o) | 0) + s) * n
                }
            }
        }, Eo.ease = vt["quad.out"], si("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
            return Ap += r + "," + r + "Params,"
        });
    var q0 = function(e, t) {
            this.id = LC++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : x0, this.set = t ? t.getSetter : Gp
        },
        il = function() {
            function r(t) {
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Co(this, +t.duration, 1, 1), this.data = t.data, Bt && (this._ctx = Bt, Bt.data.push(this)), nl || xi.wake()
            }
            var e = r.prototype;
            return e.delay = function(n) {
                return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
            }, e.duration = function(n) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
            }, e.totalDuration = function(n) {
                return arguments.length ? (this._dirty = 0, Co(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function(n, i) {
                if (Po(), !arguments.length) return this._tTime;
                var s = this._dp;
                if (s && s.smoothChildTiming && this._ts) {
                    for (xf(this, n), !s._dp || s.parent || w0(s, this); s && s.parent;) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && br(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Nn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), v0(this, n, i)), this
            }, e.time = function(n, i) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + E0(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
            }, e.totalProgress = function(n, i) {
                return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
            }, e.progress = function(n, i) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + E0(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
            }, e.iteration = function(n, i) {
                var s = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (n - 1) * s, i) : this._repeat ? Do(this._tTime, s) + 1 : 1
            }, e.timeScale = function(n, i) {
                if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
                if (this._rts === n) return this;
                var s = this.parent && this._ts ? _f(this.parent._time, this) : this._tTime;
                return this._rts = +n || 0, this._ts = this._ps || n === -1e-8 ? 0 : this._rts, this.totalTime(Zc(-Math.abs(this._delay), this._tDur, s), i !== !1), bf(this), VC(this)
            }, e.paused = function(n) {
                return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Po(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Nn && (this._tTime -= Nn)))), this) : this._ps
            }, e.startTime = function(n) {
                if (arguments.length) {
                    this._start = n;
                    var i = this.parent || this._dp;
                    return i && (i._sort || !this.parent) && br(i, this, n - this._delay), this
                }
                return this._start
            }, e.endTime = function(n) {
                return this._start + (ri(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, e.rawTime = function(n) {
                var i = this.parent || this._dp;
                return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _f(i.rawTime(n), this) : this._tTime : this._tTime
            }, e.revert = function(n) {
                n === void 0 && (n = kC);
                var i = Ln;
                return Ln = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Ln = i, this
            }, e.globalTime = function(n) {
                for (var i = this, s = arguments.length ? n : i.rawTime(); i;) s = i._start + s / (Math.abs(i._ts) || 1), i = i._dp;
                return !this.parent && this._sat ? this._sat.globalTime(n) : s
            }, e.repeat = function(n) {
                return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, C0(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
            }, e.repeatDelay = function(n) {
                if (arguments.length) {
                    var i = this._time;
                    return this._rDelay = n, C0(this), i ? this.time(i) : this
                }
                return this._rDelay
            }, e.yoyo = function(n) {
                return arguments.length ? (this._yoyo = n, this) : this._yoyo
            }, e.seek = function(n, i) {
                return this.totalTime(Li(this, n), ri(i))
            }, e.restart = function(n, i) {
                return this.play().totalTime(n ? -this._delay : 0, ri(i))
            }, e.play = function(n, i) {
                return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
            }, e.reverse = function(n, i) {
                return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1)
            }, e.pause = function(n, i) {
                return n != null && this.seek(n, i), this.paused(!0)
            }, e.resume = function() {
                return this.paused(!1)
            }, e.reversed = function(n) {
                return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function() {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, e.isActive = function() {
                var n = this.parent || this._dp,
                    i = this._start,
                    s;
                return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= i && s < this.endTime(!0) - Nn)
            }, e.eventCallback = function(n, i, s) {
                var a = this.vars;
                return arguments.length > 1 ? (i ? (a[n] = i, s && (a[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = i)) : delete a[n], this) : a[n]
            }, e.then = function(n) {
                var i = this;
                return new Promise(function(s) {
                    var a = $t(n) ? n : S0,
                        o = function() {
                            var l = i.then;
                            i.then = null, $t(a) && (a = a(i)) && (a.then || a === i) && (i.then = l), s(a), i.then = l
                        };
                    i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o
                })
            }, e.kill = function() {
                el(this)
            }, r
        }();
    Ii(il.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var jn = function(r) {
        c0(e, r);

        function e(n, i) {
            var s;
            return n === void 0 && (n = {}), s = r.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = ri(n.sortChildren), Vt && br(n.parent || Vt, Wr(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && A0(Wr(s), n.scrollTrigger), s
        }
        var t = e.prototype;
        return t.to = function(i, s, a) {
            return Jc(0, arguments, this), this
        }, t.from = function(i, s, a) {
            return Jc(1, arguments, this), this
        }, t.fromTo = function(i, s, a, o) {
            return Jc(2, arguments, this), this
        }, t.set = function(i, s, a) {
            return s.duration = 0, s.parent = this, Kc(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new rn(i, s, Li(this, a), 1), this
        }, t.call = function(i, s, a) {
            return br(this, rn.delayedCall(0, i, s), a)
        }, t.staggerTo = function(i, s, a, o, c, l, f) {
            return a.duration = s, a.stagger = a.stagger || o, a.onComplete = l, a.onCompleteParams = f, a.parent = this, new rn(i, a, Li(this, c)), this
        }, t.staggerFrom = function(i, s, a, o, c, l, f) {
            return a.runBackwards = 1, Kc(a).immediateRender = ri(a.immediateRender), this.staggerTo(i, s, a, o, c, l, f)
        }, t.staggerFromTo = function(i, s, a, o, c, l, f, h) {
            return o.startAt = a, Kc(o).immediateRender = ri(o.immediateRender), this.staggerTo(i, s, o, c, l, f, h)
        }, t.render = function(i, s, a) {
            var o = this._time,
                c = this._dirty ? this.totalDuration() : this._tDur,
                l = this._dur,
                f = i <= 0 ? 0 : vn(i),
                h = this._zTime < 0 != i < 0 && (this._initted || !l),
                d, u, _, g, m, p, v, x, b, S, E, T;
            if (this !== Vt && f > c && i >= 0 && (f = c), f !== this._tTime || a || h) {
                if (o !== this._time && l && (f += this._time - o, i += this._time - o), d = f, b = this._start, x = this._ts, p = !x, h && (l || (o = this._zTime), (i || !s) && (this._zTime = i)), this._repeat) {
                    if (E = this._yoyo, m = l + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(m * 100 + i, s, a);
                    if (d = vn(f % m), f === c ? (g = this._repeat, d = l) : (g = ~~(f / m), g && g === f / m && (d = l, g--), d > l && (d = l)), S = Do(this._tTime, m), !o && this._tTime && S !== g && this._tTime - S * m - this._dur <= 0 && (S = g), E && g & 1 && (d = l - d, T = 1), g !== S && !this._lock) {
                        var w = E && S & 1,
                            M = w === (E && g & 1);
                        if (g < S && (w = !w), o = w ? 0 : f % l ? l : f, this._lock = 1, this.render(o || (T ? 0 : vn(g * m)), s, !l)._lock = 0, this._tTime = f, !s && this.parent && bi(this, "onRepeat"), this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1), o && o !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (l = this._dur, c = this._tDur, M && (this._lock = 2, o = w ? l : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !T && this.invalidate()), this._lock = 0, !this._ts && !p) return this;
                        X0(this, T)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (v = qC(this, vn(o), vn(d)), v && (f -= d - (d = v._start))), this._tTime = f, this._time = d, this._act = !x, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && d && !s && !g && (bi(this, "onStart"), this._tTime !== f)) return this;
                if (d >= o && i >= 0)
                    for (u = this._first; u;) {
                        if (_ = u._next, (u._act || d >= u._start) && u._ts && v !== u) {
                            if (u.parent !== this) return this.render(i, s, a);
                            if (u.render(u._ts > 0 ? (d - u._start) * u._ts : (u._dirty ? u.totalDuration() : u._tDur) + (d - u._start) * u._ts, s, a), d !== this._time || !this._ts && !p) {
                                v = 0, _ && (f += this._zTime = -1e-8);
                                break
                            }
                        }
                        u = _
                    } else {
                        u = this._last;
                        for (var y = i < 0 ? i : d; u;) {
                            if (_ = u._prev, (u._act || y <= u._end) && u._ts && v !== u) {
                                if (u.parent !== this) return this.render(i, s, a);
                                if (u.render(u._ts > 0 ? (y - u._start) * u._ts : (u._dirty ? u.totalDuration() : u._tDur) + (y - u._start) * u._ts, s, a || Ln && (u._initted || u._startAt)), d !== this._time || !this._ts && !p) {
                                    v = 0, _ && (f += this._zTime = y ? -1e-8 : Nn);
                                    break
                                }
                            }
                            u = _
                        }
                    }
                if (v && !s && (this.pause(), v.render(d >= o ? 0 : -1e-8)._zTime = d >= o ? 1 : -1, this._ts)) return this._start = b, bf(this), this.render(i, s, a);
                this._onUpdate && !s && bi(this, "onUpdate", !0), (f === c && this._tTime >= this.totalDuration() || !f && o) && (b === this._start || Math.abs(x) !== Math.abs(this._ts)) && (this._lock || ((i || !l) && (f === c && this._ts > 0 || !f && this._ts < 0) && ws(this, 1), !s && !(i < 0 && !o) && (f || o || !c) && (bi(this, f === c && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < c && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, t.add = function(i, s) {
            var a = this;
            if (Xr(s) || (s = Li(this, s, i)), !(i instanceof il)) {
                if (Un(i)) return i.forEach(function(o) {
                    return a.add(o, s)
                }), this;
                if (xn(i)) return this.addLabel(i, s);
                if ($t(i)) i = rn.delayedCall(0, i);
                else return this
            }
            return this !== i ? br(this, i, s) : this
        }, t.getChildren = function(i, s, a, o) {
            i === void 0 && (i = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -1e8);
            for (var c = [], l = this._first; l;) l._start >= o && (l instanceof rn ? s && c.push(l) : (a && c.push(l), i && c.push.apply(c, l.getChildren(!0, s, a)))), l = l._next;
            return c
        }, t.getById = function(i) {
            for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)
                if (s[a].vars.id === i) return s[a]
        }, t.remove = function(i) {
            return xn(i) ? this.removeLabel(i) : $t(i) ? this.killTweensOf(i) : (gf(this, i), i === this._recent && (this._recent = this._last), ha(this))
        }, t.totalTime = function(i, s) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = vn(xi.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, s), this._forcing = 0, this) : this._tTime
        }, t.addLabel = function(i, s) {
            return this.labels[i] = Li(this, s), this
        }, t.removeLabel = function(i) {
            return delete this.labels[i], this
        }, t.addPause = function(i, s, a) {
            var o = rn.delayedCall(0, s || $c, a);
            return o.data = "isPause", this._hasPause = 1, br(this, o, Li(this, i))
        }, t.removePause = function(i) {
            var s = this._first;
            for (i = Li(this, i); s;) s._start === i && s.data === "isPause" && ws(s), s = s._next
        }, t.killTweensOf = function(i, s, a) {
            for (var o = this.getTweensOf(i, a), c = o.length; c--;) Cs !== o[c] && o[c].kill(i, s);
            return this
        }, t.getTweensOf = function(i, s) {
            for (var a = [], o = Ni(i), c = this._first, l = Xr(s), f; c;) c instanceof rn ? zC(c._targets, o) && (l ? (!Cs || c._initted && c._ts) && c.globalTime(0) <= s && c.globalTime(c.totalDuration()) > s : !s || c.isActive()) && a.push(c) : (f = c.getTweensOf(o, s)).length && a.push.apply(a, f), c = c._next;
            return a
        }, t.tweenTo = function(i, s) {
            s = s || {};
            var a = this,
                o = Li(a, i),
                c = s,
                l = c.startAt,
                f = c.onStart,
                h = c.onStartParams,
                d = c.immediateRender,
                u, _ = rn.to(a, Ii({
                    ease: s.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: o,
                    overwrite: "auto",
                    duration: s.duration || Math.abs((o - (l && "time" in l ? l.time : a._time)) / a.timeScale()) || Nn,
                    onStart: function() {
                        if (a.pause(), !u) {
                            var m = s.duration || Math.abs((o - (l && "time" in l ? l.time : a._time)) / a.timeScale());
                            _._dur !== m && Co(_, m, 0, 1).render(_._time, !0, !0), u = 1
                        }
                        f && f.apply(_, h || [])
                    }
                }, s));
            return d ? _.render(0) : _
        }, t.tweenFromTo = function(i, s, a) {
            return this.tweenTo(s, Ii({
                startAt: {
                    time: Li(this, i)
                }
            }, a))
        }, t.recent = function() {
            return this._recent
        }, t.nextLabel = function(i) {
            return i === void 0 && (i = this._time), O0(this, Li(this, i))
        }, t.previousLabel = function(i) {
            return i === void 0 && (i = this._time), O0(this, Li(this, i), 1)
        }, t.currentLabel = function(i) {
            return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Nn)
        }, t.shiftChildren = function(i, s, a) {
            a === void 0 && (a = 0);
            for (var o = this._first, c = this.labels, l; o;) o._start >= a && (o._start += i, o._end += i), o = o._next;
            if (s)
                for (l in c) c[l] >= a && (c[l] += i);
            return ha(this)
        }, t.invalidate = function(i) {
            var s = this._first;
            for (this._lock = 0; s;) s.invalidate(i), s = s._next;
            return r.prototype.invalidate.call(this, i)
        }, t.clear = function(i) {
            i === void 0 && (i = !0);
            for (var s = this._first, a; s;) a = s._next, this.remove(s), s = a;
            return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), ha(this)
        }, t.totalDuration = function(i) {
            var s = 0,
                a = this,
                o = a._last,
                c = mr,
                l, f, h;
            if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -i : i));
            if (a._dirty) {
                for (h = a.parent; o;) l = o._prev, o._dirty && o.totalDuration(), f = o._start, f > c && a._sort && o._ts && !a._lock ? (a._lock = 1, br(a, o, f - o._delay, 1)._lock = 0) : c = f, f < 0 && o._ts && (s -= f, (!h && !a._dp || h && h.smoothChildTiming) && (a._start += f / a._ts, a._time -= f, a._tTime -= f), a.shiftChildren(-f, !1, -1 / 0), c = 0), o._end > s && o._ts && (s = o._end), o = l;
                Co(a, a === Vt && a._time > s ? a._time : s, 1, 1), a._dirty = 0
            }
            return a._tDur
        }, e.updateRoot = function(i) {
            if (Vt._ts && (v0(Vt, _f(i, Vt)), _0 = xi.frame), xi.frame >= b0) {
                b0 += mi.autoSleep || 120;
                var s = Vt._first;
                if ((!s || !s._ts) && mi.autoSleep && xi._listeners.length < 2) {
                    for (; s && !s._ts;) s = s._next;
                    s || xi.sleep()
                }
            }
        }, e
    }(il);
    Ii(jn.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var lR = function(e, t, n, i, s, a, o) {
            var c = new ai(this._pt, e, t, 0, 1, Q0, null, s),
                l = 0,
                f = 0,
                h, d, u, _, g, m, p, v;
            for (c.b = n, c.e = i, n += "", i += "", (p = ~i.indexOf("random(")) && (i = Qc(i)), a && (v = [n, i], a(v, e, t), n = v[0], i = v[1]), d = n.match(vp) || []; h = vp.exec(i);) _ = h[0], g = i.substring(l, h.index), u ? u = (u + 1) % 5 : g.substr(-5) === "rgba(" && (u = 1), _ !== d[f++] && (m = parseFloat(d[f - 1]) || 0, c._pt = {
                _next: c._pt,
                p: g || f === 1 ? g : ",",
                s: m,
                c: _.charAt(1) === "=" ? Ao(m, _) - m : parseFloat(_) - m,
                m: u && u < 4 ? Math.round : 0
            }, l = vp.lastIndex);
            return c.c = l < i.length ? i.substring(l, i.length) : "", c.fp = o, (h0.test(i) || p) && (c.e = 0), this._pt = c, c
        },
        Op = function(e, t, n, i, s, a, o, c, l, f) {
            $t(i) && (i = i(s || 0, e, a));
            var h = e[t],
                d = n !== "get" ? n : $t(h) ? l ? e[t.indexOf("set") || !$t(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h,
                u = $t(h) ? l ? pR : J0 : zp,
                _;
            if (xn(i) && (~i.indexOf("random(") && (i = Qc(i)), i.charAt(1) === "=" && (_ = Ao(d, i) + (On(d) || 0), (_ || _ === 0) && (i = _))), !f || d !== i || Bp) return !isNaN(d * i) && i !== "" ? (_ = new ai(this._pt, e, t, +d || 0, i - (d || 0), typeof h == "boolean" ? gR : Z0, 0, u), l && (_.fp = l), o && _.modifier(o, this, e), this._pt = _) : (!h && !(t in e) && Mp(t, i), lR.call(this, e, t, d, i, u, c || mi.stringFilter, l))
        },
        uR = function(e, t, n, i, s) {
            if ($t(e) && (e = rl(e, s, t, n, i)), !gr(e) || e.style && e.nodeType || Un(e) || u0(e)) return xn(e) ? rl(e, s, t, n, i) : e;
            var a = {},
                o;
            for (o in e) a[o] = rl(e[o], s, t, n, i);
            return a
        },
        Y0 = function(e, t, n, i, s, a) {
            var o, c, l, f;
            if (_i[e] && (o = new _i[e]).init(s, o.rawVars ? t[e] : uR(t[e], i, s, a, n), n, i, a) !== !1 && (n._pt = c = new ai(n._pt, s, e, 0, 1, o.render, o, 0, o.priority), n !== Ro))
                for (l = n._ptLookup[n._targets.indexOf(s)], f = o._props.length; f--;) l[o._props[f]] = c;
            return o
        },
        Cs, Bp, kp = function r(e, t, n) {
            var i = e.vars,
                s = i.ease,
                a = i.startAt,
                o = i.immediateRender,
                c = i.lazy,
                l = i.onUpdate,
                f = i.runBackwards,
                h = i.yoyoEase,
                d = i.keyframes,
                u = i.autoRevert,
                _ = e._dur,
                g = e._startAt,
                m = e._targets,
                p = e.parent,
                v = p && p.data === "nested" ? p.vars.targets : m,
                x = e._overwrite === "auto" && !mp,
                b = e.timeline,
                S, E, T, w, M, y, D, R, P, O, z, k, X;
            if (b && (!d || !s) && (s = "none"), e._ease = da(s, Eo.ease), e._yEase = h ? W0(da(h === !0 ? s : h, Eo.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !b && !!i.runBackwards, !b || d && !i.stagger) {
                if (R = m[0] ? ua(m[0]).harness : 0, k = R && i[R.prop], S = mf(i, Tp), g && (g._zTime < 0 && g.progress(1), t < 0 && f && o && !u ? g.render(-1, !0) : g.revert(f && _ ? hf : BC), g._lazy = 0), a) {
                    if (ws(e._startAt = rn.set(m, Ii({
                            data: "isStart",
                            overwrite: !1,
                            parent: p,
                            immediateRender: !0,
                            lazy: !g && ri(c),
                            startAt: null,
                            delay: 0,
                            onUpdate: l && function() {
                                return bi(e, "onUpdate")
                            },
                            stagger: 0
                        }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Ln || !o && !u) && e._startAt.revert(hf), o && _ && t <= 0 && n <= 0) {
                        t && (e._zTime = t);
                        return
                    }
                } else if (f && _ && !g) {
                    if (t && (o = !1), T = Ii({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: o && !g && ri(c),
                            immediateRender: o,
                            stagger: 0,
                            parent: p
                        }, S), k && (T[R.prop] = k), ws(e._startAt = rn.set(m, T)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Ln ? e._startAt.revert(hf) : e._startAt.render(-1, !0)), e._zTime = t, !o) r(e._startAt, Nn, Nn);
                    else if (!t) return
                }
                for (e._pt = e._ptCache = 0, c = _ && ri(c) || c && !_, E = 0; E < m.length; E++) {
                    if (M = m[E], D = M._gsap || Dp(m)[E]._gsap, e._ptLookup[E] = O = {}, Ep[D.id] && Es.length && pf(), z = v === m ? E : v.indexOf(M), R && (P = new R).init(M, k || S, e, z, v) !== !1 && (e._pt = w = new ai(e._pt, M, P.name, 0, 1, P.render, P, 0, P.priority), P._props.forEach(function(V) {
                            O[V] = w
                        }), P.priority && (y = 1)), !R || k)
                        for (T in S) _i[T] && (P = Y0(T, S, e, z, M, v)) ? P.priority && (y = 1) : O[T] = w = Op.call(e, M, T, "get", S[T], z, v, 0, i.stringFilter);
                    e._op && e._op[E] && e.kill(M, e._op[E]), x && e._pt && (Cs = e, Vt.killTweensOf(M, O, e.globalTime(t)), X = !e.parent, Cs = 0), e._pt && c && (Ep[D.id] = 1)
                }
                y && ex(e), e._onInit && e._onInit(e)
            }
            e._onUpdate = l, e._initted = (!e._op || e._pt) && !X, d && t <= 0 && b.render(mr, !0, !0)
        },
        fR = function(e, t, n, i, s, a, o, c) {
            var l = (e._pt && e._ptCache || (e._ptCache = {}))[t],
                f, h, d, u;
            if (!l)
                for (l = e._ptCache[t] = [], d = e._ptLookup, u = e._targets.length; u--;) {
                    if (f = d[u][t], f && f.d && f.d._pt)
                        for (f = f.d._pt; f && f.p !== t && f.fp !== t;) f = f._next;
                    if (!f) return Bp = 1, e.vars[t] = "+=0", kp(e, o), Bp = 0, c ? Yc(t + " not eligible for reset") : 1;
                    l.push(f)
                }
            for (u = l.length; u--;) h = l[u], f = h._pt || h, f.s = (i || i === 0) && !s ? i : f.s + (i || 0) + a * f.c, f.c = n - f.s, h.e && (h.e = Qt(n) + On(h.e)), h.b && (h.b = f.s + On(h.b))
        },
        hR = function(e, t) {
            var n = e[0] ? ua(e[0]).harness : 0,
                i = n && n.aliases,
                s, a, o, c;
            if (!i) return t;
            s = fa({}, t);
            for (a in i)
                if (a in s)
                    for (c = i[a].split(","), o = c.length; o--;) s[c[o]] = s[a];
            return s
        },
        dR = function(e, t, n, i) {
            var s = t.ease || i || "power1.inOut",
                a, o;
            if (Un(t)) o = n[e] || (n[e] = []), t.forEach(function(c, l) {
                return o.push({
                    t: l / (t.length - 1) * 100,
                    v: c,
                    e: s
                })
            });
            else
                for (a in t) o = n[a] || (n[a] = []), a === "ease" || o.push({
                    t: parseFloat(e),
                    v: t[a],
                    e: s
                })
        },
        rl = function(e, t, n, i, s) {
            return $t(e) ? e.call(t, n, i, s) : xn(e) && ~e.indexOf("random(") ? Qc(e) : e
        },
        $0 = Ap + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        K0 = {};
    si($0 + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
        return K0[r] = 1
    });
    var rn = function(r) {
        c0(e, r);

        function e(n, i, s, a) {
            var o;
            typeof i == "number" && (s.duration = i, i = s, s = null), o = r.call(this, a ? i : Kc(i)) || this;
            var c = o.vars,
                l = c.duration,
                f = c.delay,
                h = c.immediateRender,
                d = c.stagger,
                u = c.overwrite,
                _ = c.keyframes,
                g = c.defaults,
                m = c.scrollTrigger,
                p = c.yoyoEase,
                v = i.parent || Vt,
                x = (Un(n) || u0(n) ? Xr(n[0]) : "length" in i) ? [n] : Ni(n),
                b, S, E, T, w, M, y, D;
            if (o._targets = x.length ? Dp(x) : Yc("GSAP target " + n + " not found. https://gsap.com", !mi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = u, _ || d || uf(l) || uf(f)) {
                if (i = o.vars, b = o.timeline = new jn({
                        data: "nested",
                        defaults: g || {},
                        targets: v && v.data === "nested" ? v.vars.targets : x
                    }), b.kill(), b.parent = b._dp = Wr(o), b._start = 0, d || uf(l) || uf(f)) {
                    if (T = x.length, y = d && F0(d), gr(d))
                        for (w in d) ~$0.indexOf(w) && (D || (D = {}), D[w] = d[w]);
                    for (S = 0; S < T; S++) E = mf(i, K0), E.stagger = 0, p && (E.yoyoEase = p), D && fa(E, D), M = x[S], E.duration = +rl(l, Wr(o), S, M, x), E.delay = (+rl(f, Wr(o), S, M, x) || 0) - o._delay, !d && T === 1 && E.delay && (o._delay = f = E.delay, o._start += f, E.delay = 0), b.to(M, E, y ? y(S, M, x) : 0), b._ease = vt.none;
                    b.duration() ? l = f = 0 : o.timeline = 0
                } else if (_) {
                    Kc(Ii(b.vars.defaults, {
                        ease: "none"
                    })), b._ease = da(_.ease || i.ease || "none");
                    var R = 0,
                        P, O, z;
                    if (Un(_)) _.forEach(function(k) {
                        return b.to(x, k, ">")
                    }), b.duration();
                    else {
                        E = {};
                        for (w in _) w === "ease" || w === "easeEach" || dR(w, _[w], E, _.easeEach);
                        for (w in E)
                            for (P = E[w].sort(function(k, X) {
                                    return k.t - X.t
                                }), R = 0, S = 0; S < P.length; S++) O = P[S], z = {
                                ease: O.e,
                                duration: (O.t - (S ? P[S - 1].t : 0)) / 100 * l
                            }, z[w] = O.v, b.to(x, z, R), R += z.duration;
                        b.duration() < l && b.to({}, {
                            duration: l - b.duration()
                        })
                    }
                }
                l || o.duration(l = b.duration())
            } else o.timeline = 0;
            return u === !0 && !mp && (Cs = Wr(o), Vt.killTweensOf(x), Cs = 0), br(v, Wr(o), s), i.reversed && o.reverse(), i.paused && o.paused(!0), (h || !l && !_ && o._start === vn(v._time) && ri(h) && WC(Wr(o)) && v.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -f) || 0)), m && A0(Wr(o), m), o
        }
        var t = e.prototype;
        return t.render = function(i, s, a) {
            var o = this._time,
                c = this._tDur,
                l = this._dur,
                f = i < 0,
                h = i > c - Nn && !f ? c : i < Nn ? 0 : i,
                d, u, _, g, m, p, v, x, b;
            if (!l) jC(this, i, s, a);
            else if (h !== this._tTime || !i || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f) {
                if (d = h, x = this.timeline, this._repeat) {
                    if (g = l + this._rDelay, this._repeat < -1 && f) return this.totalTime(g * 100 + i, s, a);
                    if (d = vn(h % g), h === c ? (_ = this._repeat, d = l) : (_ = ~~(h / g), _ && _ === vn(h / g) && (d = l, _--), d > l && (d = l)), p = this._yoyo && _ & 1, p && (b = this._yEase, d = l - d), m = Do(this._tTime, g), d === o && !a && this._initted && _ === m) return this._tTime = h, this;
                    _ !== m && (x && this._yEase && X0(x, p), this.vars.repeatRefresh && !p && !this._lock && this._time !== g && this._initted && (this._lock = a = 1, this.render(vn(g * _), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (D0(this, f ? i : d, a, s, h)) return this._tTime = 0, this;
                    if (o !== this._time && !(a && this.vars.repeatRefresh && _ !== m)) return this;
                    if (l !== this._dur) return this.render(i, s, a)
                }
                if (this._tTime = h, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (b || this._ease)(d / l), this._from && (this.ratio = v = 1 - v), d && !o && !s && !_ && (bi(this, "onStart"), this._tTime !== h)) return this;
                for (u = this._pt; u;) u.r(v, u.d), u = u._next;
                x && x.render(i < 0 ? i : x._dur * x._ease(d / this._dur), s, a) || this._startAt && (this._zTime = i), this._onUpdate && !s && (f && Cp(this, i, s, a), bi(this, "onUpdate")), this._repeat && _ !== m && this.vars.onRepeat && !s && this.parent && bi(this, "onRepeat"), (h === this._tDur || !h) && this._tTime === h && (f && !this._onUpdate && Cp(this, i, !0, !0), (i || !l) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && ws(this, 1), !s && !(f && !o) && (h || o || p) && (bi(this, h === c ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < c && this.timeScale() > 0) && this._prom()))
            }
            return this
        }, t.targets = function() {
            return this._targets
        }, t.invalidate = function(i) {
            return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i)
        }, t.resetTo = function(i, s, a, o, c) {
            nl || xi.wake(), this._ts || this.play();
            var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                f;
            return this._initted || kp(this, l), f = this._ease(l / this._dur), fR(this, i, s, a, o, f, l, c) ? this.resetTo(i, s, a, o, 1) : (xf(this, 0), this.parent || T0(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, t.kill = function(i, s) {
            if (s === void 0 && (s = "all"), !i && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? el(this) : this;
            if (this.timeline) {
                var a = this.timeline.totalDuration();
                return this.timeline.killTweensOf(i, s, Cs && Cs.vars.overwrite !== !0)._first || el(this), this.parent && a !== this.timeline.totalDuration() && Co(this, this._dur * this.timeline._tDur / a, 0, 1), this
            }
            var o = this._targets,
                c = i ? Ni(i) : o,
                l = this._ptLookup,
                f = this._pt,
                h, d, u, _, g, m, p;
            if ((!s || s === "all") && HC(o, c)) return s === "all" && (this._pt = 0), el(this);
            for (h = this._op = this._op || [], s !== "all" && (xn(s) && (g = {}, si(s, function(v) {
                    return g[v] = 1
                }), s = g), s = hR(o, s)), p = o.length; p--;)
                if (~c.indexOf(o[p])) {
                    d = l[p], s === "all" ? (h[p] = s, _ = d, u = {}) : (u = h[p] = h[p] || {}, _ = s);
                    for (g in _) m = d && d[g], m && ((!("kill" in m.d) || m.d.kill(g) === !0) && gf(this, m, "_pt"), delete d[g]), u !== "all" && (u[g] = 1)
                }
            return this._initted && !this._pt && f && el(this), this
        }, e.to = function(i, s) {
            return new e(i, s, arguments[2])
        }, e.from = function(i, s) {
            return Jc(1, arguments)
        }, e.delayedCall = function(i, s, a, o) {
            return new e(s, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: i,
                onComplete: s,
                onReverseComplete: s,
                onCompleteParams: a,
                onReverseCompleteParams: a,
                callbackScope: o
            })
        }, e.fromTo = function(i, s, a) {
            return Jc(2, arguments)
        }, e.set = function(i, s) {
            return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(i, s)
        }, e.killTweensOf = function(i, s, a) {
            return Vt.killTweensOf(i, s, a)
        }, e
    }(il);
    Ii(rn.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), si("staggerTo,staggerFrom,staggerFromTo", function(r) {
        rn[r] = function() {
            var e = new jn,
                t = Pp.call(arguments, 0);
            return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t)
        }
    });
    var zp = function(e, t, n) {
            return e[t] = n
        },
        J0 = function(e, t, n) {
            return e[t](n)
        },
        pR = function(e, t, n, i) {
            return e[t](i.fp, n)
        },
        mR = function(e, t, n) {
            return e.setAttribute(t, n)
        },
        Gp = function(e, t) {
            return $t(e[t]) ? J0 : _p(e[t]) && e.setAttribute ? mR : zp
        },
        Z0 = function(e, t) {
            return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
        },
        gR = function(e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        },
        Q0 = function(e, t) {
            var n = t._pt,
                i = "";
            if (!e && t.b) i = t.b;
            else if (e === 1 && t.e) i = t.e;
            else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
                i += t.c
            }
            t.set(t.t, t.p, i, t)
        },
        Hp = function(e, t) {
            for (var n = t._pt; n;) n.r(e, n.d), n = n._next
        },
        _R = function(e, t, n, i) {
            for (var s = this._pt, a; s;) a = s._next, s.p === i && s.modifier(e, t, n), s = a
        },
        bR = function(e) {
            for (var t = this._pt, n, i; t;) i = t._next, t.p === e && !t.op || t.op === e ? gf(this, t, "_pt") : t.dep || (n = 1), t = i;
            return !n
        },
        xR = function(e, t, n, i) {
            i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
        },
        ex = function(e) {
            for (var t = e._pt, n, i, s, a; t;) {
                for (n = t._next, i = s; i && i.pr > t.pr;) i = i._next;
                (t._prev = i ? i._prev : a) ? t._prev._next = t: s = t, (t._next = i) ? i._prev = t : a = t, t = n
            }
            e._pt = s
        },
        ai = function() {
            function r(t, n, i, s, a, o, c, l, f) {
                this.t = n, this.s = s, this.c = a, this.p = i, this.r = o || Z0, this.d = c || this, this.set = l || zp, this.pr = f || 0, this._next = t, t && (t._prev = this)
            }
            var e = r.prototype;
            return e.modifier = function(n, i, s) {
                this.mSet = this.mSet || this.set, this.set = xR, this.m = n, this.mt = s, this.tween = i
            }, r
        }();
    si(Ap + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
        return Tp[r] = 1
    }), gi.TweenMax = gi.TweenLite = rn, gi.TimelineLite = gi.TimelineMax = jn, Vt = new jn({
        sortChildren: !1,
        defaults: Eo,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), mi.stringFilter = V0;
    var ma = [],
        vf = {},
        vR = [],
        tx = 0,
        yR = 0,
        Vp = function(e) {
            return (vf[e] || vR).map(function(t) {
                return t()
            })
        },
        Wp = function() {
            var e = Date.now(),
                t = [];
            e - tx > 2 && (Vp("matchMediaInit"), ma.forEach(function(n) {
                var i = n.queries,
                    s = n.conditions,
                    a, o, c, l;
                for (o in i) a = _r.matchMedia(i[o]).matches, a && (c = 1), a !== s[o] && (s[o] = a, l = 1);
                l && (n.revert(), c && t.push(n))
            }), Vp("matchMediaRevert"), t.forEach(function(n) {
                return n.onMatch(n, function(i) {
                    return n.add(null, i)
                })
            }), tx = e, Vp("matchMedia"))
        },
        nx = function() {
            function r(t, n) {
                this.selector = n && Fp(n), this.data = [], this._r = [], this.isReverted = !1, this.id = yR++, t && this.add(t)
            }
            var e = r.prototype;
            return e.add = function(n, i, s) {
                $t(n) && (s = i, i = n, n = $t);
                var a = this,
                    o = function() {
                        var l = Bt,
                            f = a.selector,
                            h;
                        return l && l !== a && l.data.push(a), s && (a.selector = Fp(s)), Bt = a, h = i.apply(a, arguments), $t(h) && a._r.push(h), Bt = l, a.selector = f, a.isReverted = !1, h
                    };
                return a.last = o, n === $t ? o(a, function(c) {
                    return a.add(null, c)
                }) : n ? a[n] = o : o
            }, e.ignore = function(n) {
                var i = Bt;
                Bt = null, n(this), Bt = i
            }, e.getTweens = function() {
                var n = [];
                return this.data.forEach(function(i) {
                    return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof rn && !(i.parent && i.parent.data === "nested") && n.push(i)
                }), n
            }, e.clear = function() {
                this._r.length = this.data.length = 0
            }, e.kill = function(n, i) {
                var s = this;
                if (n ? function() {
                        for (var o = s.getTweens(), c = s.data.length, l; c--;) l = s.data[c], l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function(f) {
                            return o.splice(o.indexOf(f), 1)
                        }));
                        for (o.map(function(f) {
                                return {
                                    g: f._dur || f._delay || f._sat && !f._sat.vars.immediateRender ? f.globalTime(0) : -1 / 0,
                                    t: f
                                }
                            }).sort(function(f, h) {
                                return h.g - f.g || -1 / 0
                            }).forEach(function(f) {
                                return f.t.revert(n)
                            }), c = s.data.length; c--;) l = s.data[c], l instanceof jn ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof rn) && l.revert && l.revert(n);
                        s._r.forEach(function(f) {
                            return f(n, s)
                        }), s.isReverted = !0
                    }() : this.data.forEach(function(o) {
                        return o.kill && o.kill()
                    }), this.clear(), i)
                    for (var a = ma.length; a--;) ma[a].id === this.id && ma.splice(a, 1)
            }, e.revert = function(n) {
                this.kill(n || {})
            }, r
        }(),
        SR = function() {
            function r(t) {
                this.contexts = [], this.scope = t, Bt && Bt.data.push(this)
            }
            var e = r.prototype;
            return e.add = function(n, i, s) {
                gr(n) || (n = {
                    matches: n
                });
                var a = new nx(0, s || this.scope),
                    o = a.conditions = {},
                    c, l, f;
                Bt && !a.selector && (a.selector = Bt.selector), this.contexts.push(a), i = a.add("onMatch", i), a.queries = n;
                for (l in n) l === "all" ? f = 1 : (c = _r.matchMedia(n[l]), c && (ma.indexOf(a) < 0 && ma.push(a), (o[l] = c.matches) && (f = 1), c.addListener ? c.addListener(Wp) : c.addEventListener("change", Wp)));
                return f && i(a, function(h) {
                    return a.add(null, h)
                }), this
            }, e.revert = function(n) {
                this.kill(n || {})
            }, e.kill = function(n) {
                this.contexts.forEach(function(i) {
                    return i.kill(n, !0)
                })
            }, r
        }(),
        yf = {
            registerPlugin: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                t.forEach(function(i) {
                    return k0(i)
                })
            },
            timeline: function(e) {
                return new jn(e)
            },
            getTweensOf: function(e, t) {
                return Vt.getTweensOf(e, t)
            },
            getProperty: function(e, t, n, i) {
                xn(e) && (e = Ni(e)[0]);
                var s = ua(e || {}).get,
                    a = n ? S0 : y0;
                return n === "native" && (n = ""), e && (t ? a((_i[t] && _i[t].get || s)(e, t, n, i)) : function(o, c, l) {
                    return a((_i[o] && _i[o].get || s)(e, o, c, l))
                })
            },
            quickSetter: function(e, t, n) {
                if (e = Ni(e), e.length > 1) {
                    var i = e.map(function(f) {
                            return oi.quickSetter(f, t, n)
                        }),
                        s = i.length;
                    return function(f) {
                        for (var h = s; h--;) i[h](f)
                    }
                }
                e = e[0] || {};
                var a = _i[t],
                    o = ua(e),
                    c = o.harness && (o.harness.aliases || {})[t] || t,
                    l = a ? function(f) {
                        var h = new a;
                        Ro._pt = 0, h.init(e, n ? f + n : f, Ro, 0, [e]), h.render(1, h), Ro._pt && Hp(1, Ro)
                    } : o.set(e, c);
                return a ? l : function(f) {
                    return l(e, c, n ? f + n : f, o, 1)
                }
            },
            quickTo: function(e, t, n) {
                var i, s = oi.to(e, fa((i = {}, i[t] = "+=0.1", i.paused = !0, i), n || {})),
                    a = function(c, l, f) {
                        return s.resetTo(t, c, l, f)
                    };
                return a.tween = s, a
            },
            isTweening: function(e) {
                return Vt.getTweensOf(e, !0).length > 0
            },
            defaults: function(e) {
                return e && e.ease && (e.ease = da(e.ease, Eo.ease)), M0(Eo, e || {})
            },
            config: function(e) {
                return M0(mi, e || {})
            },
            registerEffect: function(e) {
                var t = e.name,
                    n = e.effect,
                    i = e.plugins,
                    s = e.defaults,
                    a = e.extendTimeline;
                (i || "").split(",").forEach(function(o) {
                    return o && !_i[o] && !gi[o] && Yc(t + " effect requires " + o + " plugin.")
                }), wp[t] = function(o, c, l) {
                    return n(Ni(o), Ii(c || {}, s), l)
                }, a && (jn.prototype[t] = function(o, c, l) {
                    return this.add(wp[t](o, gr(c) ? c : (l = c) && {}, this), l)
                })
            },
            registerEase: function(e, t) {
                vt[e] = da(t)
            },
            parseEase: function(e, t) {
                return arguments.length ? da(e, t) : vt
            },
            getById: function(e) {
                return Vt.getById(e)
            },
            exportRoot: function(e, t) {
                e === void 0 && (e = {});
                var n = new jn(e),
                    i, s;
                for (n.smoothChildTiming = ri(e.smoothChildTiming), Vt.remove(n), n._dp = 0, n._time = n._tTime = Vt._time, i = Vt._first; i;) s = i._next, (t || !(!i._dur && i instanceof rn && i.vars.onComplete === i._targets[0])) && br(n, i, i._start - i._delay), i = s;
                return br(Vt, n, 0), n
            },
            context: function(e, t) {
                return e ? new nx(e, t) : Bt
            },
            matchMedia: function(e) {
                return new SR(e)
            },
            matchMediaRefresh: function() {
                return ma.forEach(function(e) {
                    var t = e.conditions,
                        n, i;
                    for (i in t) t[i] && (t[i] = !1, n = 1);
                    n && e.revert()
                }) || Wp()
            },
            addEventListener: function(e, t) {
                var n = vf[e] || (vf[e] = []);
                ~n.indexOf(t) || n.push(t)
            },
            removeEventListener: function(e, t) {
                var n = vf[e],
                    i = n && n.indexOf(t);
                i >= 0 && n.splice(i, 1)
            },
            utils: {
                wrap: eR,
                wrapYoyo: tR,
                distribute: F0,
                random: L0,
                snap: I0,
                normalize: QC,
                getUnit: On,
                clamp: $C,
                splitColor: z0,
                toArray: Ni,
                selector: Fp,
                mapRange: U0,
                pipe: JC,
                unitize: ZC,
                interpolate: nR,
                shuffle: P0
            },
            install: m0,
            effects: wp,
            ticker: xi,
            updateRoot: jn.updateRoot,
            plugins: _i,
            globalTimeline: Vt,
            core: {
                PropTween: ai,
                globals: g0,
                Tween: rn,
                Timeline: jn,
                Animation: il,
                getCache: ua,
                _removeLinkedListItem: gf,
                reverting: function() {
                    return Ln
                },
                context: function(e) {
                    return e && Bt && (Bt.data.push(e), e._ctx = Bt), Bt
                },
                suppressOverwrites: function(e) {
                    return mp = e
                }
            }
        };
    si("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
        return yf[r] = rn[r]
    }), xi.add(jn.updateRoot), Ro = yf.to({}, {
        duration: 0
    });
    var MR = function(e, t) {
            for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
            return n
        },
        TR = function(e, t) {
            var n = e._targets,
                i, s, a;
            for (i in t)
                for (s = n.length; s--;) a = e._ptLookup[s][i], a && (a = a.d) && (a._pt && (a = MR(a, i)), a && a.modifier && a.modifier(t[i], e, n[s], i))
        },
        Xp = function(e, t) {
            return {
                name: e,
                rawVars: 1,
                init: function(i, s, a) {
                    a._onInit = function(o) {
                        var c, l;
                        if (xn(s) && (c = {}, si(s, function(f) {
                                return c[f] = 1
                            }), s = c), t) {
                            c = {};
                            for (l in s) c[l] = t(s[l]);
                            s = c
                        }
                        TR(o, s)
                    }
                }
            }
        },
        oi = yf.registerPlugin({
            name: "attr",
            init: function(e, t, n, i, s) {
                var a, o, c;
                this.tween = n;
                for (a in t) c = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (c || 0) + "", t[a], i, s, 0, 0, a), o.op = a, o.b = c, this._props.push(a)
            },
            render: function(e, t) {
                for (var n = t._pt; n;) Ln ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
            }
        }, {
            name: "endArray",
            init: function(e, t) {
                for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
            }
        }, Xp("roundProps", Ip), Xp("modifiers"), Xp("snap", I0)) || yf;
    rn.version = jn.version = oi.version = "3.12.5", p0 = 1, bp() && Po(), vt.Power0, vt.Power1, vt.Power2, vt.Power3, vt.Power4, vt.Linear, vt.Quad, vt.Cubic, vt.Quart, vt.Quint, vt.Strong, vt.Elastic, vt.Back, vt.SteppedEase, vt.Bounce, vt.Sine, vt.Expo, vt.Circ;
    /*!
     * CSSPlugin 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var ix, Rs, Fo, jp, ga, rx, qp, ER = function() {
            return typeof window < "u"
        },
        jr = {},
        _a = 180 / Math.PI,
        Io = Math.PI / 180,
        Lo = Math.atan2,
        sx = 1e8,
        Yp = /([A-Z])/g,
        wR = /(left|right|width|margin|padding|x)/i,
        AR = /[\s,\(]\S/,
        xr = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        $p = function(e, t) {
            return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
        },
        DR = function(e, t) {
            return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
        },
        CR = function(e, t) {
            return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
        },
        RR = function(e, t) {
            var n = t.s + t.c * e;
            t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
        },
        ax = function(e, t) {
            return t.set(t.t, t.p, e ? t.e : t.b, t)
        },
        ox = function(e, t) {
            return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
        },
        PR = function(e, t, n) {
            return e.style[t] = n
        },
        FR = function(e, t, n) {
            return e.style.setProperty(t, n)
        },
        IR = function(e, t, n) {
            return e._gsap[t] = n
        },
        LR = function(e, t, n) {
            return e._gsap.scaleX = e._gsap.scaleY = n
        },
        NR = function(e, t, n, i, s) {
            var a = e._gsap;
            a.scaleX = a.scaleY = n, a.renderTransform(s, a)
        },
        UR = function(e, t, n, i, s) {
            var a = e._gsap;
            a[t] = n, a.renderTransform(s, a)
        },
        Wt = "transform",
        ci = Wt + "Origin",
        OR = function r(e, t) {
            var n = this,
                i = this.target,
                s = i.style,
                a = i._gsap;
            if (e in jr && s) {
                if (this.tfm = this.tfm || {}, e !== "transform") e = xr[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
                    return n.tfm[o] = qr(i, o)
                }) : this.tfm[e] = a.x ? a[e] : qr(i, e), e === ci && (this.tfm.zOrigin = a.zOrigin);
                else return xr.transform.split(",").forEach(function(o) {
                    return r.call(n, o, t)
                });
                if (this.props.indexOf(Wt) >= 0) return;
                a.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(ci, t, "")), e = Wt
            }(s || t) && this.props.push(e, t, s[e])
        },
        cx = function(e) {
            e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
        },
        BR = function() {
            var e = this.props,
                t = this.target,
                n = t.style,
                i = t._gsap,
                s, a;
            for (s = 0; s < e.length; s += 3) e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(Yp, "-$1").toLowerCase());
            if (this.tfm) {
                for (a in this.tfm) i[a] = this.tfm[a];
                i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = qp(), (!s || !s.isStart) && !n[Wt] && (cx(n), i.zOrigin && n[ci] && (n[ci] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1)
            }
        },
        lx = function(e, t) {
            var n = {
                target: e,
                props: [],
                revert: BR,
                save: OR
            };
            return e._gsap || oi.core.getCache(e), t && t.split(",").forEach(function(i) {
                return n.save(i)
            }), n
        },
        ux, Kp = function(e, t) {
            var n = Rs.createElementNS ? Rs.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Rs.createElement(e);
            return n && n.style ? n : Rs.createElement(e)
        },
        vr = function r(e, t, n) {
            var i = getComputedStyle(e);
            return i[t] || i.getPropertyValue(t.replace(Yp, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, No(t) || t, 1) || ""
        },
        fx = "O,Moz,ms,Ms,Webkit".split(","),
        No = function(e, t, n) {
            var i = t || ga,
                s = i.style,
                a = 5;
            if (e in s && !n) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(fx[a] + e in s););
            return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? fx[a] : "") + e
        },
        Jp = function() {
            ER() && window.document && (ix = window, Rs = ix.document, Fo = Rs.documentElement, ga = Kp("div") || {
                style: {}
            }, Kp("div"), Wt = No(Wt), ci = Wt + "Origin", ga.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", ux = !!No("perspective"), qp = oi.core.reverting, jp = 1)
        },
        Zp = function r(e) {
            var t = Kp("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                n = this.parentNode,
                i = this.nextSibling,
                s = this.style.cssText,
                a;
            if (Fo.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
                a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = r
            } catch {} else this._gsapBBox && (a = this._gsapBBox());
            return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), Fo.removeChild(t), this.style.cssText = s, a
        },
        hx = function(e, t) {
            for (var n = t.length; n--;)
                if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
        },
        dx = function(e) {
            var t;
            try {
                t = e.getBBox()
            } catch {
                t = Zp.call(e, !0)
            }
            return t && (t.width || t.height) || e.getBBox === Zp || (t = Zp.call(e, !0)), t && !t.width && !t.x && !t.y ? {
                x: +hx(e, ["x", "cx", "x1"]) || 0,
                y: +hx(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            } : t
        },
        px = function(e) {
            return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && dx(e))
        },
        ba = function(e, t) {
            if (t) {
                var n = e.style,
                    i;
                t in jr && t !== ci && (t = Wt), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(Yp, "-$1").toLowerCase())) : n.removeAttribute(t)
            }
        },
        Ps = function(e, t, n, i, s, a) {
            var o = new ai(e._pt, t, n, 0, 1, a ? ox : ax);
            return e._pt = o, o.b = i, o.e = s, e._props.push(n), o
        },
        mx = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        kR = {
            grid: 1,
            flex: 1
        },
        Fs = function r(e, t, n, i) {
            var s = parseFloat(n) || 0,
                a = (n + "").trim().substr((s + "").length) || "px",
                o = ga.style,
                c = wR.test(t),
                l = e.tagName.toLowerCase() === "svg",
                f = (l ? "client" : "offset") + (c ? "Width" : "Height"),
                h = 100,
                d = i === "px",
                u = i === "%",
                _, g, m, p;
            if (i === a || !s || mx[i] || mx[a]) return s;
            if (a !== "px" && !d && (s = r(e, t, n, "px")), p = e.getCTM && px(e), (u || a === "%") && (jr[t] || ~t.indexOf("adius"))) return _ = p ? e.getBBox()[c ? "width" : "height"] : e[f], Qt(u ? s / _ * h : s / 100 * _);
            if (o[c ? "width" : "height"] = h + (d ? a : i), g = ~t.indexOf("adius") || i === "em" && e.appendChild && !l ? e : e.parentNode, p && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === Rs || !g.appendChild) && (g = Rs.body), m = g._gsap, m && u && m.width && c && m.time === xi.time && !m.uncache) return Qt(s / m.width * h);
            if (u && (t === "height" || t === "width")) {
                var v = e.style[t];
                e.style[t] = h + i, _ = e[f], v ? e.style[t] = v : ba(e, t)
            } else(u || a === "%") && !kR[vr(g, "display")] && (o.position = vr(e, "position")), g === e && (o.position = "static"), g.appendChild(ga), _ = ga[f], g.removeChild(ga), o.position = "absolute";
            return c && u && (m = ua(g), m.time = xi.time, m.width = g[f]), Qt(d ? _ * s / h : _ && s ? h / _ * s : 0)
        },
        qr = function(e, t, n, i) {
            var s;
            return jp || Jp(), t in xr && t !== "transform" && (t = xr[t], ~t.indexOf(",") && (t = t.split(",")[0])), jr[t] && t !== "transform" ? (s = al(e, i), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : Mf(vr(e, ci)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = Sf[t] && Sf[t](e, t, n) || vr(e, t) || x0(e, t) || (t === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? Fs(e, t, s, n) + n : s
        },
        zR = function(e, t, n, i) {
            if (!n || n === "none") {
                var s = No(t, e, 1),
                    a = s && vr(e, s, 1);
                a && a !== n ? (t = s, n = a) : t === "borderColor" && (n = vr(e, "borderTopColor"))
            }
            var o = new ai(this._pt, e.style, t, 0, 1, Q0),
                c = 0,
                l = 0,
                f, h, d, u, _, g, m, p, v, x, b, S;
            if (o.b = n, o.e = i, n += "", i += "", i === "auto" && (g = e.style[t], e.style[t] = i, i = vr(e, t) || i, g ? e.style[t] = g : ba(e, t)), f = [n, i], V0(f), n = f[0], i = f[1], d = n.match(wo) || [], S = i.match(wo) || [], S.length) {
                for (; h = wo.exec(i);) m = h[0], v = i.substring(c, h.index), _ ? _ = (_ + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (_ = 1), m !== (g = d[l++] || "") && (u = parseFloat(g) || 0, b = g.substr((u + "").length), m.charAt(1) === "=" && (m = Ao(u, m) + b), p = parseFloat(m), x = m.substr((p + "").length), c = wo.lastIndex - x.length, x || (x = x || mi.units[t] || b, c === i.length && (i += x, o.e += x)), b !== x && (u = Fs(e, t, g, x) || 0), o._pt = {
                    _next: o._pt,
                    p: v || l === 1 ? v : ",",
                    s: u,
                    c: p - u,
                    m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
                });
                o.c = c < i.length ? i.substring(c, i.length) : ""
            } else o.r = t === "display" && i === "none" ? ox : ax;
            return h0.test(i) && (o.e = 0), this._pt = o, o
        },
        gx = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        GR = function(e) {
            var t = e.split(" "),
                n = t[0],
                i = t[1] || "50%";
            return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = gx[n] || n, t[1] = gx[i] || i, t.join(" ")
        },
        HR = function(e, t) {
            if (t.tween && t.tween._time === t.tween._dur) {
                var n = t.t,
                    i = n.style,
                    s = t.u,
                    a = n._gsap,
                    o, c, l;
                if (s === "all" || s === !0) i.cssText = "", c = 1;
                else
                    for (s = s.split(","), l = s.length; --l > -1;) o = s[l], jr[o] && (c = 1, o = o === "transformOrigin" ? ci : Wt), ba(n, o);
                c && (ba(n, Wt), a && (a.svg && n.removeAttribute("transform"), al(n, 1), a.uncache = 1, cx(i)))
            }
        },
        Sf = {
            clearProps: function(e, t, n, i, s) {
                if (s.data !== "isFromStart") {
                    var a = e._pt = new ai(e._pt, t, n, 0, 0, HR);
                    return a.u = i, a.pr = -10, a.tween = s, e._props.push(n), 1
                }
            }
        },
        sl = [1, 0, 0, 1, 0, 0],
        _x = {},
        bx = function(e) {
            return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
        },
        xx = function(e) {
            var t = vr(e, Wt);
            return bx(t) ? sl : t.substr(7).match(f0).map(Qt)
        },
        Qp = function(e, t) {
            var n = e._gsap || ua(e),
                i = e.style,
                s = xx(e),
                a, o, c, l;
            return n.svg && e.getAttribute("transform") ? (c = e.transform.baseVal.consolidate().matrix, s = [c.a, c.b, c.c, c.d, c.e, c.f], s.join(",") === "1,0,0,1,0,0" ? sl : s) : (s === sl && !e.offsetParent && e !== Fo && !n.svg && (c = i.display, i.display = "block", a = e.parentNode, (!a || !e.offsetParent) && (l = 1, o = e.nextElementSibling, Fo.appendChild(e)), s = xx(e), c ? i.display = c : ba(e, "display"), l && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Fo.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
        },
        em = function(e, t, n, i, s, a) {
            var o = e._gsap,
                c = s || Qp(e, !0),
                l = o.xOrigin || 0,
                f = o.yOrigin || 0,
                h = o.xOffset || 0,
                d = o.yOffset || 0,
                u = c[0],
                _ = c[1],
                g = c[2],
                m = c[3],
                p = c[4],
                v = c[5],
                x = t.split(" "),
                b = parseFloat(x[0]) || 0,
                S = parseFloat(x[1]) || 0,
                E, T, w, M;
            n ? c !== sl && (T = u * m - _ * g) && (w = b * (m / T) + S * (-g / T) + (g * v - m * p) / T, M = b * (-_ / T) + S * (u / T) - (u * v - _ * p) / T, b = w, S = M) : (E = dx(e), b = E.x + (~x[0].indexOf("%") ? b / 100 * E.width : b), S = E.y + (~(x[1] || x[0]).indexOf("%") ? S / 100 * E.height : S)), i || i !== !1 && o.smooth ? (p = b - l, v = S - f, o.xOffset = h + (p * u + v * g) - p, o.yOffset = d + (p * _ + v * m) - v) : o.xOffset = o.yOffset = 0, o.xOrigin = b, o.yOrigin = S, o.smooth = !!i, o.origin = t, o.originIsAbsolute = !!n, e.style[ci] = "0px 0px", a && (Ps(a, o, "xOrigin", l, b), Ps(a, o, "yOrigin", f, S), Ps(a, o, "xOffset", h, o.xOffset), Ps(a, o, "yOffset", d, o.yOffset)), e.setAttribute("data-svg-origin", b + " " + S)
        },
        al = function(e, t) {
            var n = e._gsap || new q0(e);
            if ("x" in n && !t && !n.uncache) return n;
            var i = e.style,
                s = n.scaleX < 0,
                a = "px",
                o = "deg",
                c = getComputedStyle(e),
                l = vr(e, ci) || "0",
                f, h, d, u, _, g, m, p, v, x, b, S, E, T, w, M, y, D, R, P, O, z, k, X, V, H, L, se, de, ke, Y, ee;
            return f = h = d = g = m = p = v = x = b = 0, u = _ = 1, n.svg = !!(e.getCTM && px(e)), c.translate && ((c.translate !== "none" || c.scale !== "none" || c.rotate !== "none") && (i[Wt] = (c.translate !== "none" ? "translate3d(" + (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") + (c.scale !== "none" ? "scale(" + c.scale.split(" ").join(",") + ") " : "") + (c[Wt] !== "none" ? c[Wt] : "")), i.scale = i.rotate = i.translate = "none"), T = Qp(e, n.svg), n.svg && (n.uncache ? (V = e.getBBox(), l = n.xOrigin - V.x + "px " + (n.yOrigin - V.y) + "px", X = "") : X = !t && e.getAttribute("data-svg-origin"), em(e, X || l, !!X || n.originIsAbsolute, n.smooth !== !1, T)), S = n.xOrigin || 0, E = n.yOrigin || 0, T !== sl && (D = T[0], R = T[1], P = T[2], O = T[3], f = z = T[4], h = k = T[5], T.length === 6 ? (u = Math.sqrt(D * D + R * R), _ = Math.sqrt(O * O + P * P), g = D || R ? Lo(R, D) * _a : 0, v = P || O ? Lo(P, O) * _a + g : 0, v && (_ *= Math.abs(Math.cos(v * Io))), n.svg && (f -= S - (S * D + E * P), h -= E - (S * R + E * O))) : (ee = T[6], ke = T[7], L = T[8], se = T[9], de = T[10], Y = T[11], f = T[12], h = T[13], d = T[14], w = Lo(ee, de), m = w * _a, w && (M = Math.cos(-w), y = Math.sin(-w), X = z * M + L * y, V = k * M + se * y, H = ee * M + de * y, L = z * -y + L * M, se = k * -y + se * M, de = ee * -y + de * M, Y = ke * -y + Y * M, z = X, k = V, ee = H), w = Lo(-P, de), p = w * _a, w && (M = Math.cos(-w), y = Math.sin(-w), X = D * M - L * y, V = R * M - se * y, H = P * M - de * y, Y = O * y + Y * M, D = X, R = V, P = H), w = Lo(R, D), g = w * _a, w && (M = Math.cos(w), y = Math.sin(w), X = D * M + R * y, V = z * M + k * y, R = R * M - D * y, k = k * M - z * y, D = X, z = V), m && Math.abs(m) + Math.abs(g) > 359.9 && (m = g = 0, p = 180 - p), u = Qt(Math.sqrt(D * D + R * R + P * P)), _ = Qt(Math.sqrt(k * k + ee * ee)), w = Lo(z, k), v = Math.abs(w) > 2e-4 ? w * _a : 0, b = Y ? 1 / (Y < 0 ? -Y : Y) : 0), n.svg && (X = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !bx(vr(e, Wt)), X && e.setAttribute("transform", X))), Math.abs(v) > 90 && Math.abs(v) < 270 && (s ? (u *= -1, v += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (_ *= -1, v += v <= 0 ? 180 : -180)), t = t || n.uncache, n.x = f - ((n.xPercent = f && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + a, n.y = h - ((n.yPercent = h && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + a, n.z = d + a, n.scaleX = Qt(u), n.scaleY = Qt(_), n.rotation = Qt(g) + o, n.rotationX = Qt(m) + o, n.rotationY = Qt(p) + o, n.skewX = v + o, n.skewY = x + o, n.transformPerspective = b + a, (n.zOrigin = parseFloat(l.split(" ")[2]) || !t && n.zOrigin || 0) && (i[ci] = Mf(l)), n.xOffset = n.yOffset = 0, n.force3D = mi.force3D, n.renderTransform = n.svg ? WR : ux ? vx : VR, n.uncache = 0, n
        },
        Mf = function(e) {
            return (e = e.split(" "))[0] + " " + e[1]
        },
        tm = function(e, t, n) {
            var i = On(t);
            return Qt(parseFloat(t) + parseFloat(Fs(e, "x", n + "px", i))) + i
        },
        VR = function(e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, vx(e, t)
        },
        xa = "0deg",
        ol = "0px",
        va = ") ",
        vx = function(e, t) {
            var n = t || this,
                i = n.xPercent,
                s = n.yPercent,
                a = n.x,
                o = n.y,
                c = n.z,
                l = n.rotation,
                f = n.rotationY,
                h = n.rotationX,
                d = n.skewX,
                u = n.skewY,
                _ = n.scaleX,
                g = n.scaleY,
                m = n.transformPerspective,
                p = n.force3D,
                v = n.target,
                x = n.zOrigin,
                b = "",
                S = p === "auto" && e && e !== 1 || p === !0;
            if (x && (h !== xa || f !== xa)) {
                var E = parseFloat(f) * Io,
                    T = Math.sin(E),
                    w = Math.cos(E),
                    M;
                E = parseFloat(h) * Io, M = Math.cos(E), a = tm(v, a, T * M * -x), o = tm(v, o, -Math.sin(E) * -x), c = tm(v, c, w * M * -x + x)
            }
            m !== ol && (b += "perspective(" + m + va), (i || s) && (b += "translate(" + i + "%, " + s + "%) "), (S || a !== ol || o !== ol || c !== ol) && (b += c !== ol || S ? "translate3d(" + a + ", " + o + ", " + c + ") " : "translate(" + a + ", " + o + va), l !== xa && (b += "rotate(" + l + va), f !== xa && (b += "rotateY(" + f + va), h !== xa && (b += "rotateX(" + h + va), (d !== xa || u !== xa) && (b += "skew(" + d + ", " + u + va), (_ !== 1 || g !== 1) && (b += "scale(" + _ + ", " + g + va), v.style[Wt] = b || "translate(0, 0)"
        },
        WR = function(e, t) {
            var n = t || this,
                i = n.xPercent,
                s = n.yPercent,
                a = n.x,
                o = n.y,
                c = n.rotation,
                l = n.skewX,
                f = n.skewY,
                h = n.scaleX,
                d = n.scaleY,
                u = n.target,
                _ = n.xOrigin,
                g = n.yOrigin,
                m = n.xOffset,
                p = n.yOffset,
                v = n.forceCSS,
                x = parseFloat(a),
                b = parseFloat(o),
                S, E, T, w, M;
            c = parseFloat(c), l = parseFloat(l), f = parseFloat(f), f && (f = parseFloat(f), l += f, c += f), c || l ? (c *= Io, l *= Io, S = Math.cos(c) * h, E = Math.sin(c) * h, T = Math.sin(c - l) * -d, w = Math.cos(c - l) * d, l && (f *= Io, M = Math.tan(l - f), M = Math.sqrt(1 + M * M), T *= M, w *= M, f && (M = Math.tan(f), M = Math.sqrt(1 + M * M), S *= M, E *= M)), S = Qt(S), E = Qt(E), T = Qt(T), w = Qt(w)) : (S = h, w = d, E = T = 0), (x && !~(a + "").indexOf("px") || b && !~(o + "").indexOf("px")) && (x = Fs(u, "x", a, "px"), b = Fs(u, "y", o, "px")), (_ || g || m || p) && (x = Qt(x + _ - (_ * S + g * T) + m), b = Qt(b + g - (_ * E + g * w) + p)), (i || s) && (M = u.getBBox(), x = Qt(x + i / 100 * M.width), b = Qt(b + s / 100 * M.height)), M = "matrix(" + S + "," + E + "," + T + "," + w + "," + x + "," + b + ")", u.setAttribute("transform", M), v && (u.style[Wt] = M)
        },
        XR = function(e, t, n, i, s) {
            var a = 360,
                o = xn(s),
                c = parseFloat(s) * (o && ~s.indexOf("rad") ? _a : 1),
                l = c - i,
                f = i + l + "deg",
                h, d;
            return o && (h = s.split("_")[1], h === "short" && (l %= a, l !== l % (a / 2) && (l += l < 0 ? a : -360)), h === "cw" && l < 0 ? l = (l + a * sx) % a - ~~(l / a) * a : h === "ccw" && l > 0 && (l = (l - a * sx) % a - ~~(l / a) * a)), e._pt = d = new ai(e._pt, t, n, i, l, DR), d.e = f, d.u = "deg", e._props.push(n), d
        },
        yx = function(e, t) {
            for (var n in t) e[n] = t[n];
            return e
        },
        jR = function(e, t, n) {
            var i = yx({}, n._gsap),
                s = "perspective,force3D,transformOrigin,svgOrigin",
                a = n.style,
                o, c, l, f, h, d, u, _;
            i.svg ? (l = n.getAttribute("transform"), n.setAttribute("transform", ""), a[Wt] = t, o = al(n, 1), ba(n, Wt), n.setAttribute("transform", l)) : (l = getComputedStyle(n)[Wt], a[Wt] = t, o = al(n, 1), a[Wt] = l);
            for (c in jr) l = i[c], f = o[c], l !== f && s.indexOf(c) < 0 && (u = On(l), _ = On(f), h = u !== _ ? Fs(n, c, l, _) : parseFloat(l), d = parseFloat(f), e._pt = new ai(e._pt, o, c, h, d - h, $p), e._pt.u = _ || 0, e._props.push(c));
            yx(o, i)
        };
    si("padding,margin,Width,Radius", function(r, e) {
        var t = "Top",
            n = "Right",
            i = "Bottom",
            s = "Left",
            a = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function(o) {
                return e < 2 ? r + o : "border" + o + r
            });
        Sf[e > 1 ? "border" + r : r] = function(o, c, l, f, h) {
            var d, u;
            if (arguments.length < 4) return d = a.map(function(_) {
                return qr(o, _, l)
            }), u = d.join(" "), u.split(d[0]).length === 5 ? d[0] : u;
            d = (f + "").split(" "), u = {}, a.forEach(function(_, g) {
                return u[_] = d[g] = d[g] || d[(g - 1) / 2 | 0]
            }), o.init(c, u, h)
        }
    });
    var Sx = {
        name: "css",
        register: Jp,
        targetTest: function(e) {
            return e.style && e.nodeType
        },
        init: function(e, t, n, i, s) {
            var a = this._props,
                o = e.style,
                c = n.vars.startAt,
                l, f, h, d, u, _, g, m, p, v, x, b, S, E, T, w;
            jp || Jp(), this.styles = this.styles || lx(e), w = this.styles.props, this.tween = n;
            for (g in t)
                if (g !== "autoRound" && (f = t[g], !(_i[g] && Y0(g, t, n, i, e, s)))) {
                    if (u = typeof f, _ = Sf[g], u === "function" && (f = f.call(n, i, e, s), u = typeof f), u === "string" && ~f.indexOf("random(") && (f = Qc(f)), _) _(this, e, g, f, n) && (T = 1);
                    else if (g.substr(0, 2) === "--") l = (getComputedStyle(e).getPropertyValue(g) + "").trim(), f += "", Ds.lastIndex = 0, Ds.test(l) || (m = On(l), p = On(f)), p ? m !== p && (l = Fs(e, g, l, p) + p) : m && (f += m), this.add(o, "setProperty", l, f, i, s, 0, 0, g), a.push(g), w.push(g, 0, o[g]);
                    else if (u !== "undefined") {
                        if (c && g in c ? (l = typeof c[g] == "function" ? c[g].call(n, i, e, s) : c[g], xn(l) && ~l.indexOf("random(") && (l = Qc(l)), On(l + "") || l === "auto" || (l += mi.units[g] || On(qr(e, g)) || ""), (l + "").charAt(1) === "=" && (l = qr(e, g))) : l = qr(e, g), d = parseFloat(l), v = u === "string" && f.charAt(1) === "=" && f.substr(0, 2), v && (f = f.substr(2)), h = parseFloat(f), g in xr && (g === "autoAlpha" && (d === 1 && qr(e, "visibility") === "hidden" && h && (d = 0), w.push("visibility", 0, o.visibility), Ps(this, o, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), g !== "scale" && g !== "transform" && (g = xr[g], ~g.indexOf(",") && (g = g.split(",")[0]))), x = g in jr, x) {
                            if (this.styles.save(g), b || (S = e._gsap, S.renderTransform && !t.parseTransform || al(e, t.parseTransform), E = t.smoothOrigin !== !1 && S.smooth, b = this._pt = new ai(this._pt, o, Wt, 0, 1, S.renderTransform, S, 0, -1), b.dep = 1), g === "scale") this._pt = new ai(this._pt, S, "scaleY", S.scaleY, (v ? Ao(S.scaleY, v + h) : h) - S.scaleY || 0, $p), this._pt.u = 0, a.push("scaleY", g), g += "X";
                            else if (g === "transformOrigin") {
                                w.push(ci, 0, o[ci]), f = GR(f), S.svg ? em(e, f, 0, E, 0, this) : (p = parseFloat(f.split(" ")[2]) || 0, p !== S.zOrigin && Ps(this, S, "zOrigin", S.zOrigin, p), Ps(this, o, g, Mf(l), Mf(f)));
                                continue
                            } else if (g === "svgOrigin") {
                                em(e, f, 1, E, 0, this);
                                continue
                            } else if (g in _x) {
                                XR(this, S, g, d, v ? Ao(d, v + f) : f);
                                continue
                            } else if (g === "smoothOrigin") {
                                Ps(this, S, "smooth", S.smooth, f);
                                continue
                            } else if (g === "force3D") {
                                S[g] = f;
                                continue
                            } else if (g === "transform") {
                                jR(this, f, e);
                                continue
                            }
                        } else g in o || (g = No(g) || g);
                        if (x || (h || h === 0) && (d || d === 0) && !AR.test(f) && g in o) m = (l + "").substr((d + "").length), h || (h = 0), p = On(f) || (g in mi.units ? mi.units[g] : m), m !== p && (d = Fs(e, g, l, p)), this._pt = new ai(this._pt, x ? S : o, g, d, (v ? Ao(d, v + h) : h) - d, !x && (p === "px" || g === "zIndex") && t.autoRound !== !1 ? RR : $p), this._pt.u = p || 0, m !== p && p !== "%" && (this._pt.b = l, this._pt.r = CR);
                        else if (g in o) zR.call(this, e, g, l, v ? v + f : f);
                        else if (g in e) this.add(e, g, l || e[g], v ? v + f : f, i, s);
                        else if (g !== "parseTransform") {
                            Mp(g, f);
                            continue
                        }
                        x || (g in o ? w.push(g, 0, o[g]) : w.push(g, 1, l || e[g])), a.push(g)
                    }
                }
            T && ex(this)
        },
        render: function(e, t) {
            if (t.tween._time || !qp())
                for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
            else t.styles.revert()
        },
        get: qr,
        aliases: xr,
        getSetter: function(e, t, n) {
            var i = xr[t];
            return i && i.indexOf(",") < 0 && (t = i), t in jr && t !== ci && (e._gsap.x || qr(e, "x")) ? n && rx === n ? t === "scale" ? LR : IR : (rx = n || {}) && (t === "scale" ? NR : UR) : e.style && !_p(e.style[t]) ? PR : ~t.indexOf("-") ? FR : Gp(e, t)
        },
        core: {
            _removeProperty: ba,
            _getMatrix: Qp
        }
    };
    oi.utils.checkPrefix = No, oi.core.getStyleSaver = lx,
        function(r, e, t, n) {
            var i = si(r + "," + e + "," + t, function(s) {
                jr[s] = 1
            });
            si(e, function(s) {
                mi.units[s] = "deg", _x[s] = 1
            }), xr[i[13]] = r + "," + e, si(n, function(s) {
                var a = s.split(":");
                xr[a[1]] = i[a[0]]
            })
        }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), si("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
            mi.units[r] = "px"
        }), oi.registerPlugin(Sx);
    var Tf = oi.registerPlugin(Sx) || oi;
    Tf.core.Tween;

    function qR(r, e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, n.key, n)
        }
    }

    function YR(r, e, t) {
        return e && qR(r.prototype, e), r
    }
    /*!
     * Observer 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var En, Ef, vi, Is, Ls, Uo, Mx, ya, cl, Tx, Yr, tr, Ex, wx = function() {
            return En || typeof window < "u" && (En = window.gsap) && En.registerPlugin && En
        },
        Ax = 1,
        Oo = [],
        gt = [],
        yr = [],
        ll = Date.now,
        nm = function(e, t) {
            return t
        },
        $R = function() {
            var e = cl.core,
                t = e.bridge || {},
                n = e._scrollers,
                i = e._proxies;
            n.push.apply(n, gt), i.push.apply(i, yr), gt = n, yr = i, nm = function(a, o) {
                return t[a](o)
            }
        },
        Ns = function(e, t) {
            return ~yr.indexOf(e) && yr[yr.indexOf(e) + 1][t]
        },
        ul = function(e) {
            return !!~Tx.indexOf(e)
        },
        qn = function(e, t, n, i, s) {
            return e.addEventListener(t, n, {
                passive: i !== !1,
                capture: !!s
            })
        },
        Yn = function(e, t, n, i) {
            return e.removeEventListener(t, n, !!i)
        },
        wf = "scrollLeft",
        Af = "scrollTop",
        im = function() {
            return Yr && Yr.isPressed || gt.cache++
        },
        Df = function(e, t) {
            var n = function i(s) {
                if (s || s === 0) {
                    Ax && (vi.history.scrollRestoration = "manual");
                    var a = Yr && Yr.isPressed;
                    s = i.v = Math.round(s) || (Yr && Yr.iOS ? 1 : 0), e(s), i.cacheID = gt.cache, a && nm("ss", s)
                } else(t || gt.cache !== i.cacheID || nm("ref")) && (i.cacheID = gt.cache, i.v = e());
                return i.v + i.offset
            };
            return n.offset = 0, e && n
        },
        $n = {
            s: wf,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: Df(function(r) {
                return arguments.length ? vi.scrollTo(r, un.sc()) : vi.pageXOffset || Is[wf] || Ls[wf] || Uo[wf] || 0
            })
        },
        un = {
            s: Af,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: $n,
            sc: Df(function(r) {
                return arguments.length ? vi.scrollTo($n.sc(), r) : vi.pageYOffset || Is[Af] || Ls[Af] || Uo[Af] || 0
            })
        },
        li = function(e, t) {
            return (t && t._ctx && t._ctx.selector || En.utils.toArray)(e)[0] || (typeof e == "string" && En.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
        },
        Us = function(e, t) {
            var n = t.s,
                i = t.sc;
            ul(e) && (e = Is.scrollingElement || Ls);
            var s = gt.indexOf(e),
                a = i === un.sc ? 1 : 2;
            !~s && (s = gt.push(e) - 1), gt[s + a] || qn(e, "scroll", im);
            var o = gt[s + a],
                c = o || (gt[s + a] = Df(Ns(e, n), !0) || (ul(e) ? i : Df(function(l) {
                    return arguments.length ? e[n] = l : e[n]
                })));
            return c.target = e, o || (c.smooth = En.getProperty(e, "scrollBehavior") === "smooth"), c
        },
        rm = function(e, t, n) {
            var i = e,
                s = e,
                a = ll(),
                o = a,
                c = t || 50,
                l = Math.max(500, c * 3),
                f = function(_, g) {
                    var m = ll();
                    g || m - a > c ? (s = i, i = _, o = a, a = m) : n ? i += _ : i = s + (_ - s) / (m - o) * (a - o)
                },
                h = function() {
                    s = i = n ? 0 : i, o = a = 0
                },
                d = function(_) {
                    var g = o,
                        m = s,
                        p = ll();
                    return (_ || _ === 0) && _ !== i && f(_), a === o || p - o > l ? 0 : (i + (n ? m : -m)) / ((n ? p : a) - g) * 1e3
                };
            return {
                update: f,
                reset: h,
                getVelocity: d
            }
        },
        fl = function(e, t) {
            return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
        },
        Dx = function(e) {
            var t = Math.max.apply(Math, e),
                n = Math.min.apply(Math, e);
            return Math.abs(t) >= Math.abs(n) ? t : n
        },
        Cx = function() {
            cl = En.core.globals().ScrollTrigger, cl && cl.core && $R()
        },
        Rx = function(e) {
            return En = e || wx(), !Ef && En && typeof document < "u" && document.body && (vi = window, Is = document, Ls = Is.documentElement, Uo = Is.body, Tx = [vi, Is, Ls, Uo], En.utils.clamp, Ex = En.core.context || function() {}, ya = "onpointerenter" in Uo ? "pointer" : "mouse", Mx = Xt.isTouch = vi.matchMedia && vi.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in vi || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, tr = Xt.eventTypes = ("ontouchstart" in Ls ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Ls ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                return Ax = 0
            }, 500), Cx(), Ef = 1), Ef
        };
    $n.op = un, gt.cache = 0;
    var Xt = function() {
        function r(t) {
            this.init(t)
        }
        var e = r.prototype;
        return e.init = function(n) {
            Ef || Rx(En) || console.warn("Please gsap.registerPlugin(Observer)"), cl || Cx();
            var i = n.tolerance,
                s = n.dragMinimum,
                a = n.type,
                o = n.target,
                c = n.lineHeight,
                l = n.debounce,
                f = n.preventDefault,
                h = n.onStop,
                d = n.onStopDelay,
                u = n.ignore,
                _ = n.wheelSpeed,
                g = n.event,
                m = n.onDragStart,
                p = n.onDragEnd,
                v = n.onDrag,
                x = n.onPress,
                b = n.onRelease,
                S = n.onRight,
                E = n.onLeft,
                T = n.onUp,
                w = n.onDown,
                M = n.onChangeX,
                y = n.onChangeY,
                D = n.onChange,
                R = n.onToggleX,
                P = n.onToggleY,
                O = n.onHover,
                z = n.onHoverEnd,
                k = n.onMove,
                X = n.ignoreCheck,
                V = n.isNormalizer,
                H = n.onGestureStart,
                L = n.onGestureEnd,
                se = n.onWheel,
                de = n.onEnable,
                ke = n.onDisable,
                Y = n.onClick,
                ee = n.scrollSpeed,
                he = n.capture,
                fe = n.allowClicks,
                be = n.lockAxis,
                Ye = n.onLockAxis;
            this.target = o = li(o) || Ls, this.vars = n, u && (u = En.utils.toArray(u)), i = i || 1e-9, s = s || 0, _ = _ || 1, ee = ee || 1, a = a || "wheel,touch,pointer", l = l !== !1, c || (c = parseFloat(vi.getComputedStyle(Uo).lineHeight) || 22);
            var Pe, Xe, nt, xe, F, Ge, Je, q = this,
                ve = 0,
                et = 0,
                Le = n.passive || !f,
                ge = Us(o, $n),
                st = Us(o, un),
                I = ge(),
                A = st(),
                $ = ~a.indexOf("touch") && !~a.indexOf("pointer") && tr[0] === "pointerdown",
                ne = ul(o),
                ie = o.ownerDocument || Is,
                te = [0, 0, 0],
                Fe = [0, 0, 0],
                ye = 0,
                Ue = function() {
                    return ye = ll()
                },
                we = function(J, le) {
                    return (q.event = J) && u && ~u.indexOf(J.target) || le && $ && J.pointerType !== "touch" || X && X(J, le)
                },
                pe = function() {
                    q._vx.reset(), q._vy.reset(), Xe.pause(), h && h(q)
                },
                Ae = function() {
                    var J = q.deltaX = Dx(te),
                        le = q.deltaY = Dx(Fe),
                        Q = Math.abs(J) >= i,
                        Te = Math.abs(le) >= i;
                    D && (Q || Te) && D(q, J, le, te, Fe), Q && (S && q.deltaX > 0 && S(q), E && q.deltaX < 0 && E(q), M && M(q), R && q.deltaX < 0 != ve < 0 && R(q), ve = q.deltaX, te[0] = te[1] = te[2] = 0), Te && (w && q.deltaY > 0 && w(q), T && q.deltaY < 0 && T(q), y && y(q), P && q.deltaY < 0 != et < 0 && P(q), et = q.deltaY, Fe[0] = Fe[1] = Fe[2] = 0), (xe || nt) && (k && k(q), nt && (v(q), nt = !1), xe = !1), Ge && !(Ge = !1) && Ye && Ye(q), F && (se(q), F = !1), Pe = 0
                },
                Ve = function(J, le, Q) {
                    te[Q] += J, Fe[Q] += le, q._vx.update(J), q._vy.update(le), l ? Pe || (Pe = requestAnimationFrame(Ae)) : Ae()
                },
                He = function(J, le) {
                    be && !Je && (q.axis = Je = Math.abs(J) > Math.abs(le) ? "x" : "y", Ge = !0), Je !== "y" && (te[2] += J, q._vx.update(J, !0)), Je !== "x" && (Fe[2] += le, q._vy.update(le, !0)), l ? Pe || (Pe = requestAnimationFrame(Ae)) : Ae()
                },
                Se = function(J) {
                    if (!we(J, 1)) {
                        J = fl(J, f);
                        var le = J.clientX,
                            Q = J.clientY,
                            Te = le - q.x,
                            ue = Q - q.y,
                            De = q.isDragging;
                        q.x = le, q.y = Q, (De || Math.abs(q.startX - le) >= s || Math.abs(q.startY - Q) >= s) && (v && (nt = !0), De || (q.isDragging = !0), He(Te, ue), De || m && m(q))
                    }
                },
                je = q.onPress = function(G) {
                    we(G, 1) || G && G.button || (q.axis = Je = null, Xe.pause(), q.isPressed = !0, G = fl(G), ve = et = 0, q.startX = q.x = G.clientX, q.startY = q.y = G.clientY, q._vx.reset(), q._vy.reset(), qn(V ? o : ie, tr[1], Se, Le, !0), q.deltaX = q.deltaY = 0, x && x(q))
                },
                U = q.onRelease = function(G) {
                    if (!we(G, 1)) {
                        Yn(V ? o : ie, tr[1], Se, !0);
                        var J = !isNaN(q.y - q.startY),
                            le = q.isDragging,
                            Q = le && (Math.abs(q.x - q.startX) > 3 || Math.abs(q.y - q.startY) > 3),
                            Te = fl(G);
                        !Q && J && (q._vx.reset(), q._vy.reset(), f && fe && En.delayedCall(.08, function() {
                            if (ll() - ye > 300 && !G.defaultPrevented) {
                                if (G.target.click) G.target.click();
                                else if (ie.createEvent) {
                                    var ue = ie.createEvent("MouseEvents");
                                    ue.initMouseEvent("click", !0, !0, vi, 1, Te.screenX, Te.screenY, Te.clientX, Te.clientY, !1, !1, !1, !1, 0, null), G.target.dispatchEvent(ue)
                                }
                            }
                        })), q.isDragging = q.isGesturing = q.isPressed = !1, h && le && !V && Xe.restart(!0), p && le && p(q), b && b(q, Q)
                    }
                },
                Me = function(J) {
                    return J.touches && J.touches.length > 1 && (q.isGesturing = !0) && H(J, q.isDragging)
                },
                oe = function() {
                    return (q.isGesturing = !1) || L(q)
                },
                Ee = function(J) {
                    if (!we(J)) {
                        var le = ge(),
                            Q = st();
                        Ve((le - I) * ee, (Q - A) * ee, 1), I = le, A = Q, h && Xe.restart(!0)
                    }
                },
                me = function(J) {
                    if (!we(J)) {
                        J = fl(J, f), se && (F = !0);
                        var le = (J.deltaMode === 1 ? c : J.deltaMode === 2 ? vi.innerHeight : 1) * _;
                        Ve(J.deltaX * le, J.deltaY * le, 0), h && !V && Xe.restart(!0)
                    }
                },
                ce = function(J) {
                    if (!we(J)) {
                        var le = J.clientX,
                            Q = J.clientY,
                            Te = le - q.x,
                            ue = Q - q.y;
                        q.x = le, q.y = Q, xe = !0, h && Xe.restart(!0), (Te || ue) && He(Te, ue)
                    }
                },
                ae = function(J) {
                    q.event = J, O(q)
                },
                N = function(J) {
                    q.event = J, z(q)
                },
                re = function(J) {
                    return we(J) || fl(J, f) && Y(q)
                };
            Xe = q._dc = En.delayedCall(d || .25, pe).pause(), q.deltaX = q.deltaY = 0, q._vx = rm(0, 50, !0), q._vy = rm(0, 50, !0), q.scrollX = ge, q.scrollY = st, q.isDragging = q.isGesturing = q.isPressed = !1, Ex(this), q.enable = function(G) {
                return q.isEnabled || (qn(ne ? ie : o, "scroll", im), a.indexOf("scroll") >= 0 && qn(ne ? ie : o, "scroll", Ee, Le, he), a.indexOf("wheel") >= 0 && qn(o, "wheel", me, Le, he), (a.indexOf("touch") >= 0 && Mx || a.indexOf("pointer") >= 0) && (qn(o, tr[0], je, Le, he), qn(ie, tr[2], U), qn(ie, tr[3], U), fe && qn(o, "click", Ue, !0, !0), Y && qn(o, "click", re), H && qn(ie, "gesturestart", Me), L && qn(ie, "gestureend", oe), O && qn(o, ya + "enter", ae), z && qn(o, ya + "leave", N), k && qn(o, ya + "move", ce)), q.isEnabled = !0, G && G.type && je(G), de && de(q)), q
            }, q.disable = function() {
                q.isEnabled && (Oo.filter(function(G) {
                    return G !== q && ul(G.target)
                }).length || Yn(ne ? ie : o, "scroll", im), q.isPressed && (q._vx.reset(), q._vy.reset(), Yn(V ? o : ie, tr[1], Se, !0)), Yn(ne ? ie : o, "scroll", Ee, he), Yn(o, "wheel", me, he), Yn(o, tr[0], je, he), Yn(ie, tr[2], U), Yn(ie, tr[3], U), Yn(o, "click", Ue, !0), Yn(o, "click", re), Yn(ie, "gesturestart", Me), Yn(ie, "gestureend", oe), Yn(o, ya + "enter", ae), Yn(o, ya + "leave", N), Yn(o, ya + "move", ce), q.isEnabled = q.isPressed = q.isDragging = !1, ke && ke(q))
            }, q.kill = q.revert = function() {
                q.disable();
                var G = Oo.indexOf(q);
                G >= 0 && Oo.splice(G, 1), Yr === q && (Yr = 0)
            }, Oo.push(q), V && ul(o) && (Yr = q), q.enable(g)
        }, YR(r, [{
            key: "velocityX",
            get: function() {
                return this._vx.getVelocity()
            }
        }, {
            key: "velocityY",
            get: function() {
                return this._vy.getVelocity()
            }
        }]), r
    }();
    Xt.version = "3.12.5", Xt.create = function(r) {
        return new Xt(r)
    }, Xt.register = Rx, Xt.getAll = function() {
        return Oo.slice()
    }, Xt.getById = function(r) {
        return Oo.filter(function(e) {
            return e.vars.id === r
        })[0]
    }, wx() && En.registerPlugin(Xt);
    /*!
     * matrix 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var $r, Sa, sm, Cf, hl, Rf, Pf, dl, nr = "transform",
        am = nr + "Origin",
        Px, om = function(e) {
            var t = e.ownerDocument || e;
            for (!(nr in e.style) && ("msTransform" in e.style) && (nr = "msTransform", am = nr + "Origin"); t.parentNode && (t = t.parentNode););
            if (Sa = window, Pf = new Kr, t) {
                $r = t, sm = t.documentElement, Cf = t.body, dl = $r.createElementNS("http://www.w3.org/2000/svg", "g"), dl.style.transform = "none";
                var n = t.createElement("div"),
                    i = t.createElement("div"),
                    s = t && (t.body || t.firstElementChild);
                s && s.appendChild && (s.appendChild(n), n.appendChild(i), n.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), Px = i.offsetParent !== n, s.removeChild(n))
            }
            return t
        },
        KR = function(e) {
            for (var t, n; e && e !== Cf;) n = e._gsap, n && n.uncache && n.get(e, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), t ? t.push(n) : t = [n]), e = e.parentNode;
            return t
        },
        Fx = [],
        Ix = [],
        cm = function() {
            return Sa.pageYOffset || $r.scrollTop || sm.scrollTop || Cf.scrollTop || 0
        },
        lm = function() {
            return Sa.pageXOffset || $r.scrollLeft || sm.scrollLeft || Cf.scrollLeft || 0
        },
        um = function(e) {
            return e.ownerSVGElement || ((e.tagName + "").toLowerCase() === "svg" ? e : null)
        },
        JR = function r(e) {
            if (Sa.getComputedStyle(e).position === "fixed") return !0;
            if (e = e.parentNode, e && e.nodeType === 1) return r(e)
        },
        fm = function r(e, t) {
            if (e.parentNode && ($r || om(e))) {
                var n = um(e),
                    i = n ? n.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                    s = n ? t ? "rect" : "g" : "div",
                    a = t !== 2 ? 0 : 100,
                    o = t === 3 ? 100 : 0,
                    c = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                    l = $r.createElementNS ? $r.createElementNS(i.replace(/^https/, "http"), s) : $r.createElement(s);
                return t && (n ? (Rf || (Rf = r(e)), l.setAttribute("width", .01), l.setAttribute("height", .01), l.setAttribute("transform", "translate(" + a + "," + o + ")"), Rf.appendChild(l)) : (hl || (hl = r(e), hl.style.cssText = c), l.style.cssText = c + "width:0.1px;height:0.1px;top:" + o + "px;left:" + a + "px", hl.appendChild(l))), l
            }
            throw "Need document and parent."
        },
        ZR = function(e) {
            for (var t = new Kr, n = 0; n < e.numberOfItems; n++) t.multiply(e.getItem(n).matrix);
            return t
        },
        Lx = function(e) {
            var t = e.getCTM(),
                n;
            return t || (n = e.style[nr], e.style[nr] = "none", e.appendChild(dl), t = dl.getCTM(), e.removeChild(dl), n ? e.style[nr] = n : e.style.removeProperty(nr.replace(/([A-Z])/g, "-$1").toLowerCase())), t || Pf.clone()
        },
        QR = function(e, t) {
            var n = um(e),
                i = e === n,
                s = n ? Fx : Ix,
                a = e.parentNode,
                o, c, l, f, h, d;
            if (e === Sa) return e;
            if (s.length || s.push(fm(e, 1), fm(e, 2), fm(e, 3)), o = n ? Rf : hl, n) i ? (l = Lx(e), f = -l.e / l.a, h = -l.f / l.d, c = Pf) : e.getBBox ? (l = e.getBBox(), c = e.transform ? e.transform.baseVal : {}, c = c.numberOfItems ? c.numberOfItems > 1 ? ZR(c) : c.getItem(0).matrix : Pf, f = c.a * l.x + c.c * l.y, h = c.b * l.x + c.d * l.y) : (c = new Kr, f = h = 0), t && e.tagName.toLowerCase() === "g" && (f = h = 0), (i ? n : a).appendChild(o), o.setAttribute("transform", "matrix(" + c.a + "," + c.b + "," + c.c + "," + c.d + "," + (c.e + f) + "," + (c.f + h) + ")");
            else {
                if (f = h = 0, Px)
                    for (c = e.offsetParent, l = e; l && (l = l.parentNode) && l !== c && l.parentNode;)(Sa.getComputedStyle(l)[nr] + "").length > 4 && (f = l.offsetLeft, h = l.offsetTop, l = 0);
                if (d = Sa.getComputedStyle(e), d.position !== "absolute" && d.position !== "fixed")
                    for (c = e.offsetParent; a && a !== c;) f += a.scrollLeft || 0, h += a.scrollTop || 0, a = a.parentNode;
                l = o.style, l.top = e.offsetTop - h + "px", l.left = e.offsetLeft - f + "px", l[nr] = d[nr], l[am] = d[am], l.position = d.position === "fixed" ? "fixed" : "absolute", e.parentNode.appendChild(o)
            }
            return o
        },
        hm = function(e, t, n, i, s, a, o) {
            return e.a = t, e.b = n, e.c = i, e.d = s, e.e = a, e.f = o, e
        },
        Kr = function() {
            function r(t, n, i, s, a, o) {
                t === void 0 && (t = 1), n === void 0 && (n = 0), i === void 0 && (i = 0), s === void 0 && (s = 1), a === void 0 && (a = 0), o === void 0 && (o = 0), hm(this, t, n, i, s, a, o)
            }
            var e = r.prototype;
            return e.inverse = function() {
                var n = this.a,
                    i = this.b,
                    s = this.c,
                    a = this.d,
                    o = this.e,
                    c = this.f,
                    l = n * a - i * s || 1e-10;
                return hm(this, a / l, -i / l, -s / l, n / l, (s * c - a * o) / l, -(n * c - i * o) / l)
            }, e.multiply = function(n) {
                var i = this.a,
                    s = this.b,
                    a = this.c,
                    o = this.d,
                    c = this.e,
                    l = this.f,
                    f = n.a,
                    h = n.c,
                    d = n.b,
                    u = n.d,
                    _ = n.e,
                    g = n.f;
                return hm(this, f * i + d * a, f * s + d * o, h * i + u * a, h * s + u * o, c + _ * i + g * a, l + _ * s + g * o)
            }, e.clone = function() {
                return new r(this.a, this.b, this.c, this.d, this.e, this.f)
            }, e.equals = function(n) {
                var i = this.a,
                    s = this.b,
                    a = this.c,
                    o = this.d,
                    c = this.e,
                    l = this.f;
                return i === n.a && s === n.b && a === n.c && o === n.d && c === n.e && l === n.f
            }, e.apply = function(n, i) {
                i === void 0 && (i = {});
                var s = n.x,
                    a = n.y,
                    o = this.a,
                    c = this.b,
                    l = this.c,
                    f = this.d,
                    h = this.e,
                    d = this.f;
                return i.x = s * o + a * l + h || 0, i.y = s * c + a * f + d || 0, i
            }, r
        }();

    function wn(r, e, t, n) {
        if (!r || !r.parentNode || ($r || om(r)).documentElement === r) return new Kr;
        var i = KR(r),
            s = um(r),
            a = s ? Fx : Ix,
            o = QR(r, t),
            c = a[0].getBoundingClientRect(),
            l = a[1].getBoundingClientRect(),
            f = a[2].getBoundingClientRect(),
            h = o.parentNode,
            d = !n && JR(r),
            u = new Kr((l.left - c.left) / 100, (l.top - c.top) / 100, (f.left - c.left) / 100, (f.top - c.top) / 100, c.left + (d ? 0 : lm()), c.top + (d ? 0 : cm()));
        if (h.removeChild(o), i)
            for (c = i.length; c--;) l = i[c], l.scaleX = l.scaleY = 0, l.renderTransform(1, l);
        return e ? u.inverse() : u
    }

    function Nx(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
    }

    function eP(r, e) {
        r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
    }
    var yt, It, yi, ir, Jr, dm, Zr, pm, pl, Os, Ux, mm, ml, gm, gl, rr, _l, Ff, Ox, _m, If = 0,
        Bx = function() {
            return typeof window < "u"
        },
        kx = function() {
            return yt || Bx() && (yt = window.gsap) && yt.registerPlugin && yt
        },
        Bs = function(e) {
            return typeof e == "function"
        },
        bl = function(e) {
            return typeof e == "object"
        },
        sr = function(e) {
            return typeof e > "u"
        },
        Lf = function() {
            return !1
        },
        xl = "transform",
        bm = "transformOrigin",
        ks = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        vl = Array.isArray,
        Nf = function(e, t) {
            var n = yi.createElementNS ? yi.createElementNS("http://www.w3.org/1999/xhtml".replace(/^https/, "http"), e) : yi.createElement(e);
            return n.style ? n : yi.createElement(e)
        },
        zx = 180 / Math.PI,
        Bo = 1e20,
        tP = new Kr,
        zs = Date.now || function() {
            return new Date().getTime()
        },
        Ma = [],
        ko = {},
        nP = 0,
        iP = /^(?:a|input|textarea|button|select)$/i,
        Gx = 0,
        zo = {},
        Qr = {},
        Hx = function(e, t) {
            var n = {},
                i;
            for (i in e) n[i] = t ? e[i] * t : e[i];
            return n
        },
        rP = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        Vx = function r(e, t) {
            for (var n = e.length, i; n--;) t ? e[n].style.touchAction = t : e[n].style.removeProperty("touch-action"), i = e[n].children, i && i.length && r(i, t)
        },
        Wx = function() {
            return Ma.forEach(function(e) {
                return e()
            })
        },
        sP = function(e) {
            Ma.push(e), Ma.length === 1 && yt.ticker.add(Wx)
        },
        Xx = function() {
            return !Ma.length && yt.ticker.remove(Wx)
        },
        jx = function(e) {
            for (var t = Ma.length; t--;) Ma[t] === e && Ma.splice(t, 1);
            yt.to(Xx, {
                overwrite: !0,
                delay: 15,
                duration: 0,
                onComplete: Xx,
                data: "_draggable"
            })
        },
        aP = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        fn = function(e, t, n, i) {
            if (e.addEventListener) {
                var s = ml[t];
                i = i || (Ux ? {
                    passive: !1
                } : null), e.addEventListener(s || t, n, i), s && t !== s && e.addEventListener(t, n, i)
            }
        },
        sn = function(e, t, n, i) {
            if (e.removeEventListener) {
                var s = ml[t];
                e.removeEventListener(s || t, n, i), s && t !== s && e.removeEventListener(t, n, i)
            }
        },
        Ui = function(e) {
            e.preventDefault && e.preventDefault(), e.preventManipulation && e.preventManipulation()
        },
        oP = function(e, t) {
            for (var n = e.length; n--;)
                if (e[n].identifier === t) return !0
        },
        cP = function r(e) {
            gm = e.touches && If < e.touches.length, sn(e.target, "touchend", r)
        },
        qx = function(e) {
            gm = e.touches && If < e.touches.length, fn(e.target, "touchend", cP)
        },
        Go = function(e) {
            return It.pageYOffset || e.scrollTop || e.documentElement.scrollTop || e.body.scrollTop || 0
        },
        Ho = function(e) {
            return It.pageXOffset || e.scrollLeft || e.documentElement.scrollLeft || e.body.scrollLeft || 0
        },
        Yx = function r(e, t) {
            fn(e, "scroll", t), Vo(e.parentNode) || r(e.parentNode, t)
        },
        $x = function r(e, t) {
            sn(e, "scroll", t), Vo(e.parentNode) || r(e.parentNode, t)
        },
        Vo = function(e) {
            return !e || e === ir || e.nodeType === 9 || e === yi.body || e === It || !e.nodeType || !e.parentNode
        },
        Kx = function(e, t) {
            var n = t === "x" ? "Width" : "Height",
                i = "scroll" + n,
                s = "client" + n;
            return Math.max(0, Vo(e) ? Math.max(ir[i], Jr[i]) - (It["inner" + n] || ir[s] || Jr[s]) : e[i] - e[s])
        },
        xm = function r(e, t) {
            var n = Kx(e, "x"),
                i = Kx(e, "y");
            Vo(e) ? e = Qr : r(e.parentNode, t), e._gsMaxScrollX = n, e._gsMaxScrollY = i, t || (e._gsScrollX = e.scrollLeft || 0, e._gsScrollY = e.scrollTop || 0)
        },
        vm = function(e, t, n) {
            var i = e.style;
            i && (sr(i[t]) && (t = pl(t, e) || t), n == null ? i.removeProperty && i.removeProperty(t.replace(/([A-Z])/g, "-$1").toLowerCase()) : i[t] = n)
        },
        yl = function(e) {
            return It.getComputedStyle(e instanceof Element ? e : e.host || (e.parentNode || {}).host || e)
        },
        Ta = {},
        Wo = function(e) {
            if (e === It) return Ta.left = Ta.top = 0, Ta.width = Ta.right = ir.clientWidth || e.innerWidth || Jr.clientWidth || 0, Ta.height = Ta.bottom = (e.innerHeight || 0) - 20 < ir.clientHeight ? ir.clientHeight : e.innerHeight || Jr.clientHeight || 0, Ta;
            var t = e.ownerDocument || yi,
                n = sr(e.pageX) ? !e.nodeType && !sr(e.left) && !sr(e.top) ? e : Os(e)[0].getBoundingClientRect() : {
                    left: e.pageX - Ho(t),
                    top: e.pageY - Go(t),
                    right: e.pageX - Ho(t) + 1,
                    bottom: e.pageY - Go(t) + 1
                };
            return sr(n.right) && !sr(n.width) ? (n.right = n.left + n.width, n.bottom = n.top + n.height) : sr(n.width) && (n = {
                width: n.right - n.left,
                height: n.bottom - n.top,
                right: n.right,
                left: n.left,
                bottom: n.bottom,
                top: n.top
            }), n
        },
        en = function(e, t, n) {
            var i = e.vars,
                s = i[n],
                a = e._listeners[t],
                o;
            return Bs(s) && (o = s.apply(i.callbackScope || e, i[n + "Params"] || [e.pointerEvent])), a && e.dispatchEvent(t) === !1 && (o = !1), o
        },
        Jx = function(e, t) {
            var n = Os(e)[0],
                i, s, a;
            return !n.nodeType && n !== It ? sr(e.left) ? (s = e.min || e.minX || e.minRotation || 0, i = e.min || e.minY || 0, {
                left: s,
                top: i,
                width: (e.max || e.maxX || e.maxRotation || 0) - s,
                height: (e.max || e.maxY || 0) - i
            }) : (a = {
                x: 0,
                y: 0
            }, {
                left: e.left - a.x,
                top: e.top - a.y,
                width: e.width,
                height: e.height
            }) : lP(n, t)
        },
        Oi = {},
        lP = function(e, t) {
            t = Os(t)[0];
            var n = e.getBBox && e.ownerSVGElement,
                i = e.ownerDocument || yi,
                s, a, o, c, l, f, h, d, u, _, g, m, p;
            if (e === It) o = Go(i), s = Ho(i), a = s + (i.documentElement.clientWidth || e.innerWidth || i.body.clientWidth || 0), c = o + ((e.innerHeight || 0) - 20 < i.documentElement.clientHeight ? i.documentElement.clientHeight : e.innerHeight || i.body.clientHeight || 0);
            else {
                if (t === It || sr(t)) return e.getBoundingClientRect();
                s = o = 0, n ? (_ = e.getBBox(), g = _.width, m = _.height) : (e.viewBox && (_ = e.viewBox.baseVal) && (s = _.x || 0, o = _.y || 0, g = _.width, m = _.height), g || (p = yl(e), _ = p.boxSizing === "border-box", g = (parseFloat(p.width) || e.clientWidth || 0) + (_ ? 0 : parseFloat(p.borderLeftWidth) + parseFloat(p.borderRightWidth)), m = (parseFloat(p.height) || e.clientHeight || 0) + (_ ? 0 : parseFloat(p.borderTopWidth) + parseFloat(p.borderBottomWidth)))), a = g, c = m
            }
            return e === t ? {
                left: s,
                top: o,
                width: a - s,
                height: c - o
            } : (l = wn(t, !0).multiply(wn(e)), f = l.apply({
                x: s,
                y: o
            }), h = l.apply({
                x: a,
                y: o
            }), d = l.apply({
                x: a,
                y: c
            }), u = l.apply({
                x: s,
                y: c
            }), s = Math.min(f.x, h.x, d.x, u.x), o = Math.min(f.y, h.y, d.y, u.y), {
                left: s,
                top: o,
                width: Math.max(f.x, h.x, d.x, u.x) - s,
                height: Math.max(f.y, h.y, d.y, u.y) - o
            })
        },
        ym = function(e, t, n, i, s, a) {
            var o = {},
                c, l, f;
            if (t)
                if (s !== 1 && t instanceof Array) {
                    if (o.end = c = [], f = t.length, bl(t[0]))
                        for (l = 0; l < f; l++) c[l] = Hx(t[l], s);
                    else
                        for (l = 0; l < f; l++) c[l] = t[l] * s;
                    n += 1.1, i -= 1.1
                } else Bs(t) ? o.end = function(h) {
                    var d = t.call(e, h),
                        u, _;
                    if (s !== 1)
                        if (bl(d)) {
                            u = {};
                            for (_ in d) u[_] = d[_] * s;
                            d = u
                        } else d *= s;
                    return d
                } : o.end = t;
            return (n || n === 0) && (o.max = n), (i || i === 0) && (o.min = i), a && (o.velocity = 0), o
        },
        uP = function r(e) {
            var t;
            return !e || !e.getAttribute || e === Jr ? !1 : (t = e.getAttribute("data-clickable")) === "true" || t !== "false" && (iP.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true") ? !0 : r(e.parentNode)
        },
        Uf = function(e, t) {
            for (var n = e.length, i; n--;) i = e[n], i.ondragstart = i.onselectstart = t ? null : Lf, yt.set(i, {
                lazy: !0,
                userSelect: t ? "text" : "none"
            })
        },
        fP = function r(e) {
            if (yl(e).position === "fixed") return !0;
            if (e = e.parentNode, e && e.nodeType === 1) return r(e)
        },
        Zx, Sm, hP = function(e, t) {
            e = yt.utils.toArray(e)[0], t = t || {};
            var n = document.createElement("div"),
                i = n.style,
                s = e.firstChild,
                a = 0,
                o = 0,
                c = e.scrollTop,
                l = e.scrollLeft,
                f = e.scrollWidth,
                h = e.scrollHeight,
                d = 0,
                u = 0,
                _ = 0,
                g, m, p, v, x, b;
            Zx && t.force3D !== !1 ? (x = "translate3d(", b = "px,0px)") : xl && (x = "translate(", b = "px)"), this.scrollTop = function(S, E) {
                if (!arguments.length) return -this.top();
                this.top(-S, E)
            }, this.scrollLeft = function(S, E) {
                if (!arguments.length) return -this.left();
                this.left(-S, E)
            }, this.left = function(S, E) {
                if (!arguments.length) return -(e.scrollLeft + o);
                var T = e.scrollLeft - l,
                    w = o;
                if ((T > 2 || T < -2) && !E) {
                    l = e.scrollLeft, yt.killTweensOf(this, {
                        left: 1,
                        scrollLeft: 1
                    }), this.left(-l), t.onKill && t.onKill();
                    return
                }
                S = -S, S < 0 ? (o = S - .5 | 0, S = 0) : S > u ? (o = S - u | 0, S = u) : o = 0, (o || w) && (this._skip || (i[xl] = x + -o + "px," + -a + b), o + d >= 0 && (i.paddingRight = o + d + "px")), e.scrollLeft = S | 0, l = e.scrollLeft
            }, this.top = function(S, E) {
                if (!arguments.length) return -(e.scrollTop + a);
                var T = e.scrollTop - c,
                    w = a;
                if ((T > 2 || T < -2) && !E) {
                    c = e.scrollTop, yt.killTweensOf(this, {
                        top: 1,
                        scrollTop: 1
                    }), this.top(-c), t.onKill && t.onKill();
                    return
                }
                S = -S, S < 0 ? (a = S - .5 | 0, S = 0) : S > _ ? (a = S - _ | 0, S = _) : a = 0, (a || w) && (this._skip || (i[xl] = x + -o + "px," + -a + b)), e.scrollTop = S | 0, c = e.scrollTop
            }, this.maxScrollTop = function() {
                return _
            }, this.maxScrollLeft = function() {
                return u
            }, this.disable = function() {
                for (s = n.firstChild; s;) v = s.nextSibling, e.appendChild(s), s = v;
                e === n.parentNode && e.removeChild(n)
            }, this.enable = function() {
                if (s = e.firstChild, s !== n) {
                    for (; s;) v = s.nextSibling, n.appendChild(s), s = v;
                    e.appendChild(n), this.calibrate()
                }
            }, this.calibrate = function(S) {
                var E = e.clientWidth === g,
                    T, w, M;
                c = e.scrollTop, l = e.scrollLeft, !(E && e.clientHeight === m && n.offsetHeight === p && f === e.scrollWidth && h === e.scrollHeight && !S) && ((a || o) && (w = this.left(), M = this.top(), this.left(-e.scrollLeft), this.top(-e.scrollTop)), T = yl(e), (!E || S) && (i.display = "block", i.width = "auto", i.paddingRight = "0px", d = Math.max(0, e.scrollWidth - e.clientWidth), d && (d += parseFloat(T.paddingLeft) + (Sm ? parseFloat(T.paddingRight) : 0))), i.display = "inline-block", i.position = "relative", i.overflow = "visible", i.verticalAlign = "top", i.boxSizing = "content-box", i.width = "100%", i.paddingRight = d + "px", Sm && (i.paddingBottom = T.paddingBottom), g = e.clientWidth, m = e.clientHeight, f = e.scrollWidth, h = e.scrollHeight, u = e.scrollWidth - g, _ = e.scrollHeight - m, p = n.offsetHeight, i.display = "block", (w || M) && (this.left(w), this.top(M)))
            }, this.content = n, this.element = e, this._skip = !1, this.enable()
        },
        Mm = function(e) {
            if (Bx() && document.body) {
                var t = window && window.navigator;
                It = window, yi = document, ir = yi.documentElement, Jr = yi.body, dm = Nf("div"), Ff = !!window.PointerEvent, Zr = Nf("div"), Zr.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab", _l = Zr.style.cursor === "grab" ? "grab" : "move", gl = t && t.userAgent.toLowerCase().indexOf("android") !== -1, mm = "ontouchstart" in ir && "orientation" in It || t && (t.MaxTouchPoints > 0 || t.msMaxTouchPoints > 0), Sm = function() {
                    var n = Nf("div"),
                        i = Nf("div"),
                        s = i.style,
                        a = Jr,
                        o;
                    return s.display = "inline-block", s.position = "relative", n.style.cssText = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden", n.appendChild(i), a.appendChild(n), o = i.offsetHeight + 18 > n.scrollHeight, a.removeChild(n), o
                }(), ml = function(n) {
                    for (var i = n.split(","), s = ("onpointerdown" in dm ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in dm ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : n).split(","), a = {}, o = 4; --o > -1;) a[i[o]] = s[o], a[s[o]] = i[o];
                    try {
                        ir.addEventListener("test", null, Object.defineProperty({}, "passive", {
                            get: function() {
                                Ux = 1
                            }
                        }))
                    } catch {}
                    return a
                }("touchstart,touchmove,touchend,touchcancel"), fn(yi, "touchcancel", Lf), fn(It, "touchmove", Lf), Jr && Jr.addEventListener("touchstart", Lf), fn(yi, "contextmenu", function() {
                    for (var n in ko) ko[n].isPressed && ko[n].endDrag()
                }), yt = pm = kx()
            }
            yt ? (rr = yt.plugins.inertia, Ox = yt.core.context || function() {}, pl = yt.utils.checkPrefix, xl = pl(xl), bm = pl(bm), Os = yt.utils.toArray, _m = yt.core.getStyleSaver, Zx = !!pl("perspective")) : e && console.warn("Please gsap.registerPlugin(Draggable)")
        },
        dP = function() {
            function r(t) {
                this._listeners = {}, this.target = t || this
            }
            var e = r.prototype;
            return e.addEventListener = function(n, i) {
                var s = this._listeners[n] || (this._listeners[n] = []);
                ~s.indexOf(i) || s.push(i)
            }, e.removeEventListener = function(n, i) {
                var s = this._listeners[n],
                    a = s && s.indexOf(i);
                a >= 0 && s.splice(a, 1)
            }, e.dispatchEvent = function(n) {
                var i = this,
                    s;
                return (this._listeners[n] || []).forEach(function(a) {
                    return a.call(i, {
                        type: n,
                        target: i.target
                    }) === !1 && (s = !1)
                }), s
            }, r
        }(),
        Xo = function(r) {
            eP(e, r);

            function e(t, n) {
                var i;
                i = r.call(this) || this, pm || Mm(1), t = Os(t)[0], i.styles = _m && _m(t, "transform,left,top"), rr || (rr = yt.plugins.inertia), i.vars = n = Hx(n || {}), i.target = t, i.x = i.y = i.rotation = 0, i.dragResistance = parseFloat(n.dragResistance) || 0, i.edgeResistance = isNaN(n.edgeResistance) ? 1 : parseFloat(n.edgeResistance) || 0, i.lockAxis = n.lockAxis, i.autoScroll = n.autoScroll || 0, i.lockedAxis = null, i.allowEventDefault = !!n.allowEventDefault, yt.getProperty(t, "x");
                var s = (n.type || "x,y").toLowerCase(),
                    a = ~s.indexOf("x") || ~s.indexOf("y"),
                    o = s.indexOf("rotation") !== -1,
                    c = o ? "rotation" : a ? "x" : "left",
                    l = a ? "y" : "top",
                    f = !!(~s.indexOf("x") || ~s.indexOf("left") || s === "scroll"),
                    h = !!(~s.indexOf("y") || ~s.indexOf("top") || s === "scroll"),
                    d = n.minimumMovement || 2,
                    u = Nx(i),
                    _ = Os(n.trigger || n.handle || t),
                    g = {},
                    m = 0,
                    p = !1,
                    v = n.autoScrollMarginTop || 40,
                    x = n.autoScrollMarginRight || 40,
                    b = n.autoScrollMarginBottom || 40,
                    S = n.autoScrollMarginLeft || 40,
                    E = n.clickableTest || uP,
                    T = 0,
                    w = t._gsap || yt.core.getCache(t),
                    M = fP(t),
                    y = function(N, re) {
                        return parseFloat(w.get(t, N, re))
                    },
                    D = t.ownerDocument || yi,
                    R, P, O, z, k, X, V, H, L, se, de, ke, Y, ee, he, fe, be, Ye, Pe, Xe, nt, xe, F, Ge, Je, q, ve, et, Le, ge, st, I, A, $ = function(N) {
                        return Ui(N), N.stopImmediatePropagation && N.stopImmediatePropagation(), !1
                    },
                    ne = function ae(N) {
                        if (u.autoScroll && u.isDragging && (p || be)) {
                            var re = t,
                                G = u.autoScroll * 15,
                                J, le, Q, Te, ue, De, $e, Oe;
                            for (p = !1, Qr.scrollTop = It.pageYOffset != null ? It.pageYOffset : D.documentElement.scrollTop != null ? D.documentElement.scrollTop : D.body.scrollTop, Qr.scrollLeft = It.pageXOffset != null ? It.pageXOffset : D.documentElement.scrollLeft != null ? D.documentElement.scrollLeft : D.body.scrollLeft, Te = u.pointerX - Qr.scrollLeft, ue = u.pointerY - Qr.scrollTop; re && !le;) le = Vo(re.parentNode), J = le ? Qr : re.parentNode, Q = le ? {
                                bottom: Math.max(ir.clientHeight, It.innerHeight || 0),
                                right: Math.max(ir.clientWidth, It.innerWidth || 0),
                                left: 0,
                                top: 0
                            } : J.getBoundingClientRect(), De = $e = 0, h && (Oe = J._gsMaxScrollY - J.scrollTop, Oe < 0 ? $e = Oe : ue > Q.bottom - b && Oe ? (p = !0, $e = Math.min(Oe, G * (1 - Math.max(0, Q.bottom - ue) / b) | 0)) : ue < Q.top + v && J.scrollTop && (p = !0, $e = -Math.min(J.scrollTop, G * (1 - Math.max(0, ue - Q.top) / v) | 0)), $e && (J.scrollTop += $e)), f && (Oe = J._gsMaxScrollX - J.scrollLeft, Oe < 0 ? De = Oe : Te > Q.right - x && Oe ? (p = !0, De = Math.min(Oe, G * (1 - Math.max(0, Q.right - Te) / x) | 0)) : Te < Q.left + S && J.scrollLeft && (p = !0, De = -Math.min(J.scrollLeft, G * (1 - Math.max(0, Te - Q.left) / S) | 0)), De && (J.scrollLeft += De)), le && (De || $e) && (It.scrollTo(J.scrollLeft, J.scrollTop), Me(u.pointerX + De, u.pointerY + $e)), re = J
                        }
                        if (be) {
                            var tt = u.x,
                                xt = u.y;
                            o ? (u.deltaX = tt - parseFloat(w.rotation), u.rotation = tt, w.rotation = tt + "deg", w.renderTransform(1, w)) : P ? (h && (u.deltaY = xt - P.top(), P.top(xt)), f && (u.deltaX = tt - P.left(), P.left(tt))) : a ? (h && (u.deltaY = xt - parseFloat(w.y), w.y = xt + "px"), f && (u.deltaX = tt - parseFloat(w.x), w.x = tt + "px"), w.renderTransform(1, w)) : (h && (u.deltaY = xt - parseFloat(t.style.top || 0), t.style.top = xt + "px"), f && (u.deltaX = tt - parseFloat(t.style.left || 0), t.style.left = tt + "px")), H && !N && !et && (et = !0, en(u, "drag", "onDrag") === !1 && (f && (u.x -= u.deltaX), h && (u.y -= u.deltaY), ae(!0)), et = !1)
                        }
                        be = !1
                    },
                    ie = function(N, re) {
                        var G = u.x,
                            J = u.y,
                            le, Q;
                        t._gsap || (w = yt.core.getCache(t)), w.uncache && yt.getProperty(t, "x"), a ? (u.x = parseFloat(w.x), u.y = parseFloat(w.y)) : o ? u.x = u.rotation = parseFloat(w.rotation) : P ? (u.y = P.top(), u.x = P.left()) : (u.y = parseFloat(t.style.top || (Q = yl(t)) && Q.top) || 0, u.x = parseFloat(t.style.left || (Q || {}).left) || 0), (Pe || Xe || nt) && !re && (u.isDragging || u.isThrowing) && (nt && (zo.x = u.x, zo.y = u.y, le = nt(zo), le.x !== u.x && (u.x = le.x, be = !0), le.y !== u.y && (u.y = le.y, be = !0)), Pe && (le = Pe(u.x), le !== u.x && (u.x = le, o && (u.rotation = le), be = !0)), Xe && (le = Xe(u.y), le !== u.y && (u.y = le), be = !0)), be && ne(!0), N || (u.deltaX = u.x - G, u.deltaY = u.y - J, en(u, "throwupdate", "onThrowUpdate"))
                    },
                    te = function(N, re, G, J) {
                        return re == null && (re = -1e20), G == null && (G = Bo), Bs(N) ? function(le) {
                            var Q = u.isPressed ? 1 - u.edgeResistance : 1;
                            return N.call(u, (le > G ? G + (le - G) * Q : le < re ? re + (le - re) * Q : le) * J) * J
                        } : vl(N) ? function(le) {
                            for (var Q = N.length, Te = 0, ue = Bo, De, $e; --Q > -1;) De = N[Q], $e = De - le, $e < 0 && ($e = -$e), $e < ue && De >= re && De <= G && (Te = Q, ue = $e);
                            return N[Te]
                        } : isNaN(N) ? function(le) {
                            return le
                        } : function() {
                            return N * J
                        }
                    },
                    Fe = function(N, re, G, J, le, Q, Te) {
                        return Q = Q && Q < Bo ? Q * Q : Bo, Bs(N) ? function(ue) {
                            var De = u.isPressed ? 1 - u.edgeResistance : 1,
                                $e = ue.x,
                                Oe = ue.y,
                                tt, xt, _t;
                            return ue.x = $e = $e > G ? G + ($e - G) * De : $e < re ? re + ($e - re) * De : $e, ue.y = Oe = Oe > le ? le + (Oe - le) * De : Oe < J ? J + (Oe - J) * De : Oe, tt = N.call(u, ue), tt !== ue && (ue.x = tt.x, ue.y = tt.y), Te !== 1 && (ue.x *= Te, ue.y *= Te), Q < Bo && (xt = ue.x - $e, _t = ue.y - Oe, xt * xt + _t * _t > Q && (ue.x = $e, ue.y = Oe)), ue
                        } : vl(N) ? function(ue) {
                            for (var De = N.length, $e = 0, Oe = Bo, tt, xt, _t, ut; --De > -1;) _t = N[De], tt = _t.x - ue.x, xt = _t.y - ue.y, ut = tt * tt + xt * xt, ut < Oe && ($e = De, Oe = ut);
                            return Oe <= Q ? N[$e] : ue
                        } : function(ue) {
                            return ue
                        }
                    },
                    ye = function() {
                        var N, re, G, J;
                        V = !1, P ? (P.calibrate(), u.minX = de = -P.maxScrollLeft(), u.minY = Y = -P.maxScrollTop(), u.maxX = se = u.maxY = ke = 0, V = !0) : n.bounds && (N = Jx(n.bounds, t.parentNode), o ? (u.minX = de = N.left, u.maxX = se = N.left + N.width, u.minY = Y = u.maxY = ke = 0) : !sr(n.bounds.maxX) || !sr(n.bounds.maxY) ? (N = n.bounds, u.minX = de = N.minX, u.minY = Y = N.minY, u.maxX = se = N.maxX, u.maxY = ke = N.maxY) : (re = Jx(t, t.parentNode), u.minX = de = Math.round(y(c, "px") + N.left - re.left), u.minY = Y = Math.round(y(l, "px") + N.top - re.top), u.maxX = se = Math.round(de + (N.width - re.width)), u.maxY = ke = Math.round(Y + (N.height - re.height))), de > se && (u.minX = se, u.maxX = se = de, de = u.minX), Y > ke && (u.minY = ke, u.maxY = ke = Y, Y = u.minY), o && (u.minRotation = de, u.maxRotation = se), V = !0), n.liveSnap && (G = n.liveSnap === !0 ? n.snap || {} : n.liveSnap, J = vl(G) || Bs(G), o ? (Pe = te(J ? G : G.rotation, de, se, 1), Xe = null) : G.points ? nt = Fe(J ? G : G.points, de, se, Y, ke, G.radius, P ? -1 : 1) : (f && (Pe = te(J ? G : G.x || G.left || G.scrollLeft, de, se, P ? -1 : 1)), h && (Xe = te(J ? G : G.y || G.top || G.scrollTop, Y, ke, P ? -1 : 1))))
                    },
                    Ue = function() {
                        u.isThrowing = !1, en(u, "throwcomplete", "onThrowComplete")
                    },
                    we = function() {
                        u.isThrowing = !1
                    },
                    pe = function(N, re) {
                        var G, J, le, Q;
                        N && rr ? (N === !0 && (G = n.snap || n.liveSnap || {}, J = vl(G) || Bs(G), N = {
                            resistance: (n.throwResistance || n.resistance || 1e3) / (o ? 10 : 1)
                        }, o ? N.rotation = ym(u, J ? G : G.rotation, se, de, 1, re) : (f && (N[c] = ym(u, J ? G : G.points || G.x || G.left, se, de, P ? -1 : 1, re || u.lockedAxis === "x")), h && (N[l] = ym(u, J ? G : G.points || G.y || G.top, ke, Y, P ? -1 : 1, re || u.lockedAxis === "y")), (G.points || vl(G) && bl(G[0])) && (N.linkedProps = c + "," + l, N.radius = G.radius))), u.isThrowing = !0, Q = isNaN(n.overshootTolerance) ? n.edgeResistance === 1 ? 0 : 1 - u.edgeResistance + .2 : n.overshootTolerance, N.duration || (N.duration = {
                            max: Math.max(n.minDuration || 0, "maxDuration" in n ? n.maxDuration : 2),
                            min: isNaN(n.minDuration) ? Q === 0 || bl(N) && N.resistance > 1e3 ? 0 : .5 : n.minDuration,
                            overshoot: Q
                        }), u.tween = le = yt.to(P || t, {
                            inertia: N,
                            data: "_draggable",
                            inherit: !1,
                            onComplete: Ue,
                            onInterrupt: we,
                            onUpdate: n.fastMode ? en : ie,
                            onUpdateParams: n.fastMode ? [u, "onthrowupdate", "onThrowUpdate"] : G && G.radius ? [!1, !0] : []
                        }), n.fastMode || (P && (P._skip = !0), le.render(1e9, !0, !0), ie(!0, !0), u.endX = u.x, u.endY = u.y, o && (u.endRotation = u.x), le.play(0), ie(!0, !0), P && (P._skip = !1))) : V && u.applyBounds()
                    },
                    Ae = function(N) {
                        var re = Ge,
                            G;
                        Ge = wn(t.parentNode, !0), N && u.isPressed && !Ge.equals(re || new Kr) && (G = re.inverse().apply({
                            x: O,
                            y: z
                        }), Ge.apply(G, G), O = G.x, z = G.y), Ge.equals(tP) && (Ge = null)
                    },
                    Ve = function() {
                        var N = 1 - u.edgeResistance,
                            re = M ? Ho(D) : 0,
                            G = M ? Go(D) : 0,
                            J, le, Q;
                        a && (w.x = y(c, "px") + "px", w.y = y(l, "px") + "px", w.renderTransform()), Ae(!1), Oi.x = u.pointerX - re, Oi.y = u.pointerY - G, Ge && Ge.apply(Oi, Oi), O = Oi.x, z = Oi.y, be && (Me(u.pointerX, u.pointerY), ne(!0)), I = wn(t), P ? (ye(), X = P.top(), k = P.left()) : (He() ? (ie(!0, !0), ye()) : u.applyBounds(), o ? (J = t.ownerSVGElement ? [w.xOrigin - t.getBBox().x, w.yOrigin - t.getBBox().y] : (yl(t)[bm] || "0 0").split(" "), fe = u.rotationOrigin = wn(t).apply({
                            x: parseFloat(J[0]) || 0,
                            y: parseFloat(J[1]) || 0
                        }), ie(!0, !0), le = u.pointerX - fe.x - re, Q = fe.y - u.pointerY + G, k = u.x, X = u.y = Math.atan2(Q, le) * zx) : (X = y(l, "px"), k = y(c, "px"))), V && N && (k > se ? k = se + (k - se) / N : k < de && (k = de - (de - k) / N), o || (X > ke ? X = ke + (X - ke) / N : X < Y && (X = Y - (Y - X) / N))), u.startX = k = ks(k), u.startY = X = ks(X)
                    },
                    He = function() {
                        return u.tween && u.tween.isActive()
                    },
                    Se = function() {
                        Zr.parentNode && !He() && !u.isDragging && Zr.parentNode.removeChild(Zr)
                    },
                    je = function(N, re) {
                        var G;
                        if (!R || u.isPressed || !N || (N.type === "mousedown" || N.type === "pointerdown") && !re && zs() - T < 30 && ml[u.pointerEvent.type]) {
                            st && N && R && Ui(N);
                            return
                        }
                        if (Je = He(), A = !1, u.pointerEvent = N, ml[N.type] ? (F = ~N.type.indexOf("touch") ? N.currentTarget || N.target : D, fn(F, "touchend", oe), fn(F, "touchmove", U), fn(F, "touchcancel", oe), fn(D, "touchstart", qx)) : (F = null, fn(D, "mousemove", U)), ve = null, (!Ff || !F) && (fn(D, "mouseup", oe), N && N.target && fn(N.target, "mouseup", oe)), xe = E.call(u, N.target) && n.dragClickables === !1 && !re, xe) {
                            fn(N.target, "change", oe), en(u, "pressInit", "onPressInit"), en(u, "press", "onPress"), Uf(_, !0), st = !1;
                            return
                        }
                        if (q = !F || f === h || u.vars.allowNativeTouchScrolling === !1 || u.vars.allowContextMenu && N && (N.ctrlKey || N.which > 2) ? !1 : f ? "y" : "x", st = !q && !u.allowEventDefault, st && (Ui(N), fn(It, "touchforcechange", Ui)), N.changedTouches ? (N = ee = N.changedTouches[0], he = N.identifier) : N.pointerId ? he = N.pointerId : ee = he = null, If++, sP(ne), z = u.pointerY = N.pageY, O = u.pointerX = N.pageX, en(u, "pressInit", "onPressInit"), (q || u.autoScroll) && xm(t.parentNode), t.parentNode && u.autoScroll && !P && !o && t.parentNode._gsMaxScrollX && !Zr.parentNode && !t.getBBox && (Zr.style.width = t.parentNode.scrollWidth + "px", t.parentNode.appendChild(Zr)), Ve(), u.tween && u.tween.kill(), u.isThrowing = !1, yt.killTweensOf(P || t, g, !0), P && yt.killTweensOf(t, {
                                scrollTo: 1
                            }, !0), u.tween = u.lockedAxis = null, (n.zIndexBoost || !o && !P && n.zIndexBoost !== !1) && (t.style.zIndex = e.zIndex++), u.isPressed = !0, H = !!(n.onDrag || u._listeners.drag), L = !!(n.onMove || u._listeners.move), n.cursor !== !1 || n.activeCursor)
                            for (G = _.length; --G > -1;) yt.set(_[G], {
                                cursor: n.activeCursor || n.cursor || (_l === "grab" ? "grabbing" : _l)
                            });
                        en(u, "press", "onPress")
                    },
                    U = function(N) {
                        var re = N,
                            G, J, le, Q, Te, ue;
                        if (!R || gm || !u.isPressed || !N) {
                            st && N && R && Ui(N);
                            return
                        }
                        if (u.pointerEvent = N, G = N.changedTouches, G) {
                            if (N = G[0], N !== ee && N.identifier !== he) {
                                for (Q = G.length; --Q > -1 && (N = G[Q]).identifier !== he && N.target !== t;);
                                if (Q < 0) return
                            }
                        } else if (N.pointerId && he && N.pointerId !== he) return;
                        if (F && q && !ve && (Oi.x = N.pageX - (M ? Ho(D) : 0), Oi.y = N.pageY - (M ? Go(D) : 0), Ge && Ge.apply(Oi, Oi), J = Oi.x, le = Oi.y, Te = Math.abs(J - O), ue = Math.abs(le - z), (Te !== ue && (Te > d || ue > d) || gl && q === ve) && (ve = Te > ue && f ? "x" : "y", q && ve !== q && fn(It, "touchforcechange", Ui), u.vars.lockAxisOnTouchScroll !== !1 && f && h && (u.lockedAxis = ve === "x" ? "y" : "x", Bs(u.vars.onLockAxis) && u.vars.onLockAxis.call(u, re)), gl && q === ve))) {
                            oe(re);
                            return
                        }!u.allowEventDefault && (!q || ve && q !== ve) && re.cancelable !== !1 ? (Ui(re), st = !0) : st && (st = !1), u.autoScroll && (p = !0), Me(N.pageX, N.pageY, L)
                    },
                    Me = function(N, re, G) {
                        var J = 1 - u.dragResistance,
                            le = 1 - u.edgeResistance,
                            Q = u.pointerX,
                            Te = u.pointerY,
                            ue = X,
                            De = u.x,
                            $e = u.y,
                            Oe = u.endX,
                            tt = u.endY,
                            xt = u.endRotation,
                            _t = be,
                            ut, ft, Et, it, pn, kt;
                        u.pointerX = N, u.pointerY = re, M && (N -= Ho(D), re -= Go(D)), o ? (it = Math.atan2(fe.y - re, N - fe.x) * zx, pn = u.y - it, pn > 180 ? (X -= 360, u.y = it) : pn < -180 && (X += 360, u.y = it), u.x !== k || Math.abs(X - it) > d ? (u.y = it, Et = k + (X - it) * J) : Et = k) : (Ge && (kt = N * Ge.a + re * Ge.c + Ge.e, re = N * Ge.b + re * Ge.d + Ge.f, N = kt), ft = re - z, ut = N - O, ft < d && ft > -d && (ft = 0), ut < d && ut > -d && (ut = 0), (u.lockAxis || u.lockedAxis) && (ut || ft) && (kt = u.lockedAxis, kt || (u.lockedAxis = kt = f && Math.abs(ut) > Math.abs(ft) ? "y" : h ? "x" : null, kt && Bs(u.vars.onLockAxis) && u.vars.onLockAxis.call(u, u.pointerEvent)), kt === "y" ? ft = 0 : kt === "x" && (ut = 0)), Et = ks(k + ut * J), it = ks(X + ft * J)), (Pe || Xe || nt) && (u.x !== Et || u.y !== it && !o) && (nt && (zo.x = Et, zo.y = it, kt = nt(zo), Et = ks(kt.x), it = ks(kt.y)), Pe && (Et = ks(Pe(Et))), Xe && (it = ks(Xe(it)))), V && (Et > se ? Et = se + Math.round((Et - se) * le) : Et < de && (Et = de + Math.round((Et - de) * le)), o || (it > ke ? it = Math.round(ke + (it - ke) * le) : it < Y && (it = Math.round(Y + (it - Y) * le)))), (u.x !== Et || u.y !== it && !o) && (o ? (u.endRotation = u.x = u.endX = Et, be = !0) : (h && (u.y = u.endY = it, be = !0), f && (u.x = u.endX = Et, be = !0)), !G || en(u, "move", "onMove") !== !1 ? !u.isDragging && u.isPressed && (u.isDragging = A = !0, en(u, "dragstart", "onDragStart")) : (u.pointerX = Q, u.pointerY = Te, X = ue, u.x = De, u.y = $e, u.endX = Oe, u.endY = tt, u.endRotation = xt, be = _t))
                    },
                    oe = function ae(N, re) {
                        if (!R || !u.isPressed || N && he != null && !re && (N.pointerId && N.pointerId !== he && N.target !== t || N.changedTouches && !oP(N.changedTouches, he))) {
                            st && N && R && Ui(N);
                            return
                        }
                        u.isPressed = !1;
                        var G = N,
                            J = u.isDragging,
                            le = u.vars.allowContextMenu && N && (N.ctrlKey || N.which > 2),
                            Q = yt.delayedCall(.001, Se),
                            Te, ue, De, $e, Oe;
                        if (F ? (sn(F, "touchend", ae), sn(F, "touchmove", U), sn(F, "touchcancel", ae), sn(D, "touchstart", qx)) : sn(D, "mousemove", U), sn(It, "touchforcechange", Ui), (!Ff || !F) && (sn(D, "mouseup", ae), N && N.target && sn(N.target, "mouseup", ae)), be = !1, J && (m = Gx = zs(), u.isDragging = !1), jx(ne), xe && !le) {
                            N && (sn(N.target, "change", ae), u.pointerEvent = G), Uf(_, !1), en(u, "release", "onRelease"), en(u, "click", "onClick"), xe = !1;
                            return
                        }
                        for (ue = _.length; --ue > -1;) vm(_[ue], "cursor", n.cursor || (n.cursor !== !1 ? _l : null));
                        if (If--, N) {
                            if (Te = N.changedTouches, Te && (N = Te[0], N !== ee && N.identifier !== he)) {
                                for (ue = Te.length; --ue > -1 && (N = Te[ue]).identifier !== he && N.target !== t;);
                                if (ue < 0 && !re) return
                            }
                            u.pointerEvent = G, u.pointerX = N.pageX, u.pointerY = N.pageY
                        }
                        return le && G ? (Ui(G), st = !0, en(u, "release", "onRelease")) : G && !J ? (st = !1, Je && (n.snap || n.bounds) && pe(n.inertia || n.throwProps), en(u, "release", "onRelease"), (!gl || G.type !== "touchmove") && G.type.indexOf("cancel") === -1 && (en(u, "click", "onClick"), zs() - T < 300 && en(u, "doubleclick", "onDoubleClick"), $e = G.target || t, T = zs(), Oe = function() {
                            T !== Le && u.enabled() && !u.isPressed && !G.defaultPrevented && ($e.click ? $e.click() : D.createEvent && (De = D.createEvent("MouseEvents"), De.initMouseEvent("click", !0, !0, It, 1, u.pointerEvent.screenX, u.pointerEvent.screenY, u.pointerX, u.pointerY, !1, !1, !1, !1, 0, null), $e.dispatchEvent(De)))
                        }, !gl && !G.defaultPrevented && yt.delayedCall(.05, Oe))) : (pe(n.inertia || n.throwProps), !u.allowEventDefault && G && (n.dragClickables !== !1 || !E.call(u, G.target)) && J && (!q || ve && q === ve) && G.cancelable !== !1 ? (st = !0, Ui(G)) : st = !1, en(u, "release", "onRelease")), He() && Q.duration(u.tween.duration()), J && en(u, "dragend", "onDragEnd"), !0
                    },
                    Ee = function(N) {
                        if (N && u.isDragging && !P) {
                            var re = N.target || t.parentNode,
                                G = re.scrollLeft - re._gsScrollX,
                                J = re.scrollTop - re._gsScrollY;
                            (G || J) && (Ge ? (O -= G * Ge.a + J * Ge.c, z -= J * Ge.d + G * Ge.b) : (O -= G, z -= J), re._gsScrollX += G, re._gsScrollY += J, Me(u.pointerX, u.pointerY))
                        }
                    },
                    me = function(N) {
                        var re = zs(),
                            G = re - T < 100,
                            J = re - m < 50,
                            le = G && Le === T,
                            Q = u.pointerEvent && u.pointerEvent.defaultPrevented,
                            Te = G && ge === T,
                            ue = N.isTrusted || N.isTrusted == null && G && le;
                        if ((le || J && u.vars.suppressClickOnDrag !== !1) && N.stopImmediatePropagation && N.stopImmediatePropagation(), G && !(u.pointerEvent && u.pointerEvent.defaultPrevented) && (!le || ue && !Te)) {
                            ue && le && (ge = T), Le = T;
                            return
                        }(u.isPressed || J || G) && (!ue || !N.detail || !G || Q) && Ui(N), !G && !J && !A && (N && N.target && (u.pointerEvent = N), en(u, "click", "onClick"))
                    },
                    ce = function(N) {
                        return Ge ? {
                            x: N.x * Ge.a + N.y * Ge.c + Ge.e,
                            y: N.x * Ge.b + N.y * Ge.d + Ge.f
                        } : {
                            x: N.x,
                            y: N.y
                        }
                    };
                return Ye = e.get(t), Ye && Ye.kill(), i.startDrag = function(ae, N) {
                    var re, G, J, le;
                    je(ae || u.pointerEvent, !0), N && !u.hitTest(ae || u.pointerEvent) && (re = Wo(ae || u.pointerEvent), G = Wo(t), J = ce({
                        x: re.left + re.width / 2,
                        y: re.top + re.height / 2
                    }), le = ce({
                        x: G.left + G.width / 2,
                        y: G.top + G.height / 2
                    }), O -= J.x - le.x, z -= J.y - le.y), u.isDragging || (u.isDragging = A = !0, en(u, "dragstart", "onDragStart"))
                }, i.drag = U, i.endDrag = function(ae) {
                    return oe(ae || u.pointerEvent, !0)
                }, i.timeSinceDrag = function() {
                    return u.isDragging ? 0 : (zs() - m) / 1e3
                }, i.timeSinceClick = function() {
                    return (zs() - T) / 1e3
                }, i.hitTest = function(ae, N) {
                    return e.hitTest(u.target, ae, N)
                }, i.getDirection = function(ae, N) {
                    var re = ae === "velocity" && rr ? ae : bl(ae) && !o ? "element" : "start",
                        G, J, le, Q, Te, ue;
                    return re === "element" && (Te = Wo(u.target), ue = Wo(ae)), G = re === "start" ? u.x - k : re === "velocity" ? rr.getVelocity(t, c) : Te.left + Te.width / 2 - (ue.left + ue.width / 2), o ? G < 0 ? "counter-clockwise" : "clockwise" : (N = N || 2, J = re === "start" ? u.y - X : re === "velocity" ? rr.getVelocity(t, l) : Te.top + Te.height / 2 - (ue.top + ue.height / 2), le = Math.abs(G / J), Q = le < 1 / N ? "" : G < 0 ? "left" : "right", le < N && (Q !== "" && (Q += "-"), Q += J < 0 ? "up" : "down"), Q)
                }, i.applyBounds = function(ae, N) {
                    var re, G, J, le, Q, Te;
                    if (ae && n.bounds !== ae) return n.bounds = ae, u.update(!0, N);
                    if (ie(!0), ye(), V && !He()) {
                        if (re = u.x, G = u.y, re > se ? re = se : re < de && (re = de), G > ke ? G = ke : G < Y && (G = Y), (u.x !== re || u.y !== G) && (J = !0, u.x = u.endX = re, o ? u.endRotation = re : u.y = u.endY = G, be = !0, ne(!0), u.autoScroll && !u.isDragging))
                            for (xm(t.parentNode), le = t, Qr.scrollTop = It.pageYOffset != null ? It.pageYOffset : D.documentElement.scrollTop != null ? D.documentElement.scrollTop : D.body.scrollTop, Qr.scrollLeft = It.pageXOffset != null ? It.pageXOffset : D.documentElement.scrollLeft != null ? D.documentElement.scrollLeft : D.body.scrollLeft; le && !Te;) Te = Vo(le.parentNode), Q = Te ? Qr : le.parentNode, h && Q.scrollTop > Q._gsMaxScrollY && (Q.scrollTop = Q._gsMaxScrollY), f && Q.scrollLeft > Q._gsMaxScrollX && (Q.scrollLeft = Q._gsMaxScrollX), le = Q;
                        u.isThrowing && (J || u.endX > se || u.endX < de || u.endY > ke || u.endY < Y) && pe(n.inertia || n.throwProps, J)
                    }
                    return u
                }, i.update = function(ae, N, re) {
                    if (N && u.isPressed) {
                        var G = wn(t),
                            J = I.apply({
                                x: u.x - k,
                                y: u.y - X
                            }),
                            le = wn(t.parentNode, !0);
                        le.apply({
                            x: G.e - J.x,
                            y: G.f - J.y
                        }, J), u.x -= J.x - le.e, u.y -= J.y - le.f, ne(!0), Ve()
                    }
                    var Q = u.x,
                        Te = u.y;
                    return Ae(!N), ae ? u.applyBounds() : (be && re && ne(!0), ie(!0)), N && (Me(u.pointerX, u.pointerY), be && ne(!0)), u.isPressed && !N && (f && Math.abs(Q - u.x) > .01 || h && Math.abs(Te - u.y) > .01 && !o) && Ve(), u.autoScroll && (xm(t.parentNode, u.isDragging), p = u.isDragging, ne(!0), $x(t, Ee), Yx(t, Ee)), u
                }, i.enable = function(ae) {
                    var N = {
                            lazy: !0
                        },
                        re, G, J;
                    if (n.cursor !== !1 && (N.cursor = n.cursor || _l), yt.utils.checkPrefix("touchCallout") && (N.touchCallout = "none"), ae !== "soft") {
                        for (Vx(_, f === h ? "none" : n.allowNativeTouchScrolling && t.scrollHeight === t.clientHeight == (t.scrollWidth === t.clientHeight) || n.allowEventDefault ? "manipulation" : f ? "pan-y" : "pan-x"), G = _.length; --G > -1;) J = _[G], Ff || fn(J, "mousedown", je), fn(J, "touchstart", je), fn(J, "click", me, !0), yt.set(J, N), J.getBBox && J.ownerSVGElement && f !== h && yt.set(J.ownerSVGElement, {
                            touchAction: n.allowNativeTouchScrolling || n.allowEventDefault ? "manipulation" : f ? "pan-y" : "pan-x"
                        }), n.allowContextMenu || fn(J, "contextmenu", $);
                        Uf(_, !1)
                    }
                    return Yx(t, Ee), R = !0, rr && ae !== "soft" && rr.track(P || t, a ? "x,y" : o ? "rotation" : "top,left"), t._gsDragID = re = "d" + nP++, ko[re] = u, P && (P.enable(), P.element._gsDragID = re), (n.bounds || o) && Ve(), n.bounds && u.applyBounds(), u
                }, i.disable = function(ae) {
                    for (var N = u.isDragging, re = _.length, G; --re > -1;) vm(_[re], "cursor", null);
                    if (ae !== "soft") {
                        for (Vx(_, null), re = _.length; --re > -1;) G = _[re], vm(G, "touchCallout", null), sn(G, "mousedown", je), sn(G, "touchstart", je), sn(G, "click", me, !0), sn(G, "contextmenu", $);
                        Uf(_, !0), F && (sn(F, "touchcancel", oe), sn(F, "touchend", oe), sn(F, "touchmove", U)), sn(D, "mouseup", oe), sn(D, "mousemove", U)
                    }
                    return $x(t, Ee), R = !1, rr && ae !== "soft" && (rr.untrack(P || t, a ? "x,y" : o ? "rotation" : "top,left"), u.tween && u.tween.kill()), P && P.disable(), jx(ne), u.isDragging = u.isPressed = xe = !1, N && en(u, "dragend", "onDragEnd"), u
                }, i.enabled = function(ae, N) {
                    return arguments.length ? ae ? u.enable(N) : u.disable(N) : R
                }, i.kill = function() {
                    return u.isThrowing = !1, u.tween && u.tween.kill(), u.disable(), yt.set(_, {
                        clearProps: "userSelect"
                    }), delete ko[t._gsDragID], u
                }, i.revert = function() {
                    this.kill(), this.styles && this.styles.revert()
                }, ~s.indexOf("scroll") && (P = i.scrollProxy = new hP(t, rP({
                    onKill: function() {
                        u.isPressed && oe(null)
                    }
                }, n)), t.style.overflowY = h && !mm ? "auto" : "hidden", t.style.overflowX = f && !mm ? "auto" : "hidden", t = P.content), o ? g.rotation = 1 : (f && (g[c] = 1), h && (g[l] = 1)), w.force3D = "force3D" in n ? n.force3D : !0, Ox(Nx(i)), i.enable(), i
            }
            return e.register = function(n) {
                yt = n, Mm()
            }, e.create = function(n, i) {
                return pm || Mm(!0), Os(n).map(function(s) {
                    return new e(s, i)
                })
            }, e.get = function(n) {
                return ko[(Os(n)[0] || {})._gsDragID]
            }, e.timeSinceDrag = function() {
                return (zs() - Gx) / 1e3
            }, e.hitTest = function(n, i, s) {
                if (n === i) return !1;
                var a = Wo(n),
                    o = Wo(i),
                    c = a.top,
                    l = a.left,
                    f = a.right,
                    h = a.bottom,
                    d = a.width,
                    u = a.height,
                    _ = o.left > f || o.right < l || o.top > h || o.bottom < c,
                    g, m, p;
                return _ || !s ? !_ : (p = (s + "").indexOf("%") !== -1, s = parseFloat(s) || 0, g = {
                    left: Math.max(l, o.left),
                    top: Math.max(c, o.top)
                }, g.width = Math.min(f, o.right) - g.left, g.height = Math.min(h, o.bottom) - g.top, g.width < 0 || g.height < 0 ? !1 : p ? (s *= .01, m = g.width * g.height, m >= d * u * s || m >= o.width * o.height * s) : g.width > s && g.height > s)
            }, e
        }(dP);
    aP(Xo.prototype, {
        pointerX: 0,
        pointerY: 0,
        startX: 0,
        startY: 0,
        deltaX: 0,
        deltaY: 0,
        isDragging: !1,
        isPressed: !1
    }), Xo.zIndex = 1e3, Xo.version = "3.12.5", kx() && yt.registerPlugin(Xo);
    /*!
     * VelocityTracker: 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Sr, Tm, Sl, Qx, jo, qo, Em, ev, tv = function() {
            return Sr || typeof window < "u" && (Sr = window.gsap)
        },
        wm = {},
        pP = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        Am = function(e) {
            return ev(e).id
        },
        Ml = function(e) {
            return wm[Am(typeof e == "string" ? Sl(e)[0] : e)]
        },
        nv = function(e) {
            var t = jo,
                n;
            if (e - Em >= .05)
                for (Em = e; t;) n = t.g(t.t, t.p), (n !== t.v1 || e - t.t1 > .2) && (t.v2 = t.v1, t.v1 = n, t.t2 = t.t1, t.t1 = e), t = t._next
        },
        mP = {
            deg: 360,
            rad: Math.PI * 2
        },
        Dm = function() {
            Sr = tv(), Sr && (Sl = Sr.utils.toArray, Qx = Sr.utils.getUnit, ev = Sr.core.getCache, qo = Sr.ticker, Tm = 1)
        },
        gP = function(e, t, n, i) {
            this.t = e, this.p = t, this.g = e._gsap.get, this.rCap = mP[n || Qx(this.g(e, t))], this.v1 = this.v2 = 0, this.t1 = this.t2 = qo.time, i && (this._next = i, i._prev = this)
        },
        Tl = function() {
            function r(t, n) {
                Tm || Dm(), this.target = Sl(t)[0], wm[Am(this.target)] = this, this._props = {}, n && this.add(n)
            }
            r.register = function(n) {
                Sr = n, Dm()
            };
            var e = r.prototype;
            return e.get = function(n, i) {
                var s = this._props[n] || console.warn("Not tracking " + n + " velocity."),
                    a, o, c;
                return a = parseFloat(i ? s.v1 : s.g(s.t, s.p)), o = a - parseFloat(s.v2), c = s.rCap, c && (o = o % c, o !== o % (c / 2) && (o = o < 0 ? o + c : o - c)), pP(o / ((i ? s.t1 : qo.time) - s.t2))
            }, e.getAll = function() {
                var n = {},
                    i = this._props,
                    s;
                for (s in i) n[s] = this.get(s);
                return n
            }, e.isTracking = function(n) {
                return n in this._props
            }, e.add = function(n, i) {
                n in this._props || (jo || (qo.add(nv), Em = qo.time), jo = this._props[n] = new gP(this.target, n, i, jo))
            }, e.remove = function(n) {
                var i = this._props[n],
                    s, a;
                i && (s = i._prev, a = i._next, s && (s._next = a), a ? a._prev = s : jo === i && (qo.remove(nv), jo = 0), delete this._props[n])
            }, e.kill = function(n) {
                for (var i in this._props) this.remove(i);
                n || delete wm[Am(this.target)]
            }, r.track = function(n, i, s) {
                Tm || Dm();
                for (var a = [], o = Sl(n), c = i.split(","), l = (s || "").split(","), f = o.length, h, d; f--;) {
                    for (h = Ml(o[f]) || new r(o[f]), d = c.length; d--;) h.add(c[d], l[d] || l[0]);
                    a.push(h)
                }
                return a
            }, r.untrack = function(n, i) {
                var s = (i || "").split(",");
                Sl(n).forEach(function(a) {
                    var o = Ml(a);
                    o && (s.length ? s.forEach(function(c) {
                        return o.remove(c)
                    }) : o.kill(1))
                })
            }, r.isTracking = function(n, i) {
                var s = Ml(n);
                return s && s.isTracking(i)
            }, r.getVelocity = function(n, i) {
                var s = Ml(n);
                return !s || !s.isTracking(i) ? console.warn("Not tracking velocity of " + i) : s.get(i)
            }, r
        }();
    Tl.getByTarget = Ml, tv() && Sr.registerPlugin(Tl);
    /*!
     * InertiaPlugin 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var hn, iv, rv, sv, Cm, El, av, ov, cv, Rm, lv, wl, Pm, uv, Of = Tl.getByTarget,
        fv = function() {
            return hn || typeof window < "u" && (hn = window.gsap) && hn.registerPlugin && hn
        },
        _P = function(e) {
            return typeof e == "string"
        },
        Al = function(e) {
            return typeof e == "number"
        },
        Gs = function(e) {
            return typeof e == "object"
        },
        Fm = function(e) {
            return typeof e == "function"
        },
        bP = 1,
        hv = Array.isArray,
        xP = function(e) {
            return e
        },
        Yo = 1e10,
        dv = 1 / Yo,
        pv = .05,
        vP = function(e) {
            return Math.round(e * 1e4) / 1e4
        },
        yP = function(e, t, n) {
            for (var i in t) !(i in e) && i !== n && (e[i] = t[i]);
            return e
        },
        SP = function r(e) {
            var t = {},
                n, i;
            for (n in e) t[n] = Gs(i = e[n]) && !hv(i) ? r(i) : i;
            return t
        },
        mv = function(e, t, n, i, s) {
            var a = t.length,
                o = 0,
                c = Yo,
                l, f, h, d;
            if (Gs(e)) {
                for (; a--;) {
                    l = t[a], f = 0;
                    for (h in e) d = l[h] - e[h], f += d * d;
                    f < c && (o = a, c = f)
                }
                if ((s || Yo) < Yo && s < Math.sqrt(c)) return e
            } else
                for (; a--;) l = t[a], f = l - e, f < 0 && (f = -f), f < c && l >= i && l <= n && (o = a, c = f);
            return t[o]
        },
        gv = function(e, t, n, i, s, a, o) {
            if (e.end === "auto") return e;
            var c = e.end,
                l, f;
            if (n = isNaN(n) ? Yo : n, i = isNaN(i) ? -1e10 : i, Gs(t)) {
                if (l = t.calculated ? t : (Fm(c) ? c(t, o) : mv(t, c, n, i, a)) || t, !t.calculated) {
                    for (f in l) t[f] = l[f];
                    t.calculated = !0
                }
                l = l[s]
            } else l = Fm(c) ? c(t, o) : hv(c) ? mv(t, c, n, i, a) : parseFloat(c);
            return l > n ? l = n : l < i && (l = i), {
                max: l,
                min: l,
                unitFactor: e.unitFactor
            }
        },
        Bf = function(e, t, n) {
            return isNaN(e[t]) ? n : +e[t]
        },
        Im = function(e, t) {
            return t * pv * e / Rm
        },
        _v = function(e, t, n) {
            return Math.abs((t - e) * Rm / n / pv)
        },
        bv = {
            resistance: 1,
            checkpoint: 1,
            preventOvershoot: 1,
            linkedProps: 1,
            radius: 1,
            duration: 1
        },
        xv = function(e, t, n, i) {
            if (t.linkedProps) {
                var s = t.linkedProps.split(","),
                    a = {},
                    o, c, l, f, h, d;
                for (o = 0; o < s.length; o++) c = s[o], l = t[c], l && (Al(l.velocity) ? f = l.velocity : (h = h || Of(e), f = h && h.isTracking(c) ? h.get(c) : 0), d = Math.abs(f / Bf(l, "resistance", i)), a[c] = parseFloat(n(e, c)) + Im(f, d));
                return a
            }
        },
        MP = function(e, t, n, i, s, a) {
            if (n === void 0 && (n = 10), i === void 0 && (i = .2), s === void 0 && (s = 1), _P(e) && (e = sv(e)[0]), !e) return 0;
            var o = 0,
                c = Yo,
                l = t.inertia || t,
                f = cv(e).get,
                h = Bf(l, "resistance", El.resistance),
                d, u, _, g, m, p, v, x, b, S;
            S = xv(e, l, f, h);
            for (d in l) bv[d] || (u = l[d], Gs(u) || (x = x || Of(e), x && x.isTracking(d) ? u = Al(u) ? {
                velocity: u
            } : {
                velocity: x.get(d)
            } : (g = +u || 0, _ = Math.abs(g / h))), Gs(u) && (Al(u.velocity) ? g = u.velocity : (x = x || Of(e), g = x && x.isTracking(d) ? x.get(d) : 0), _ = lv(i, n, Math.abs(g / Bf(u, "resistance", h))), m = parseFloat(f(e, d)) || 0, p = m + Im(g, _), "end" in u && (u = gv(u, S && d in S ? S : p, u.max, u.min, d, l.radius, g), wl === t && (wl = l = SP(t)), l[d] = yP(u, l[d], "end")), "max" in u && p > +u.max + dv ? (b = u.unitFactor || El.unitFactors[d] || 1, v = m > u.max && u.min !== u.max || g * b > -15 && g * b < 45 ? i + (n - i) * .1 : _v(m, u.max, g), v + s < c && (c = v + s)) : "min" in u && p < +u.min - dv && (b = u.unitFactor || El.unitFactors[d] || 1, v = m < u.min && u.min !== u.max || g * b > -45 && g * b < 15 ? i + (n - i) * .1 : _v(m, u.min, g), v + s < c && (c = v + s)), v > o && (o = v)), _ > o && (o = _));
            return o > c && (o = c), o > n ? n : o < i ? i : o
        },
        vv = function() {
            hn = fv(), hn && (rv = hn.parseEase, sv = hn.utils.toArray, av = hn.utils.getUnit, cv = hn.core.getCache, lv = hn.utils.clamp, Pm = hn.core.getStyleSaver, uv = hn.core.reverting || function() {}, Cm = rv("power3"), Rm = Cm(.05), ov = hn.core.PropTween, hn.config({
                resistance: 100,
                unitFactors: {
                    time: 1e3,
                    totalTime: 1e3,
                    progress: 1e3,
                    totalProgress: 1e3
                }
            }), El = hn.config(), hn.registerPlugin(Tl), iv = 1)
        },
        Lm = {
            version: "3.12.5",
            name: "inertia",
            register: function(e) {
                hn = e, vv()
            },
            init: function(e, t, n, i, s) {
                iv || vv();
                var a = Of(e);
                if (t === "auto") {
                    if (!a) {
                        console.warn("No inertia tracking on " + e + ". InertiaPlugin.track(target) first.");
                        return
                    }
                    t = a.getAll()
                }
                this.styles = Pm && typeof e.style == "object" && Pm(e), this.target = e, this.tween = n, wl = t;
                var o = e._gsap,
                    c = o.get,
                    l = t.duration,
                    f = Gs(l),
                    h = t.preventOvershoot || f && l.overshoot === 0,
                    d = Bf(t, "resistance", El.resistance),
                    u = Al(l) ? l : MP(e, t, f && l.max || 10, f && l.min || .2, f && "overshoot" in l ? +l.overshoot : h ? 0 : 1),
                    _, g, m, p, v, x, b, S, E;
                t = wl, wl = 0, E = xv(e, t, c, d);
                for (_ in t) bv[_] || (g = t[_], Fm(g) && (g = g(i, e, s)), Al(g) ? v = g : Gs(g) && !isNaN(g.velocity) ? v = +g.velocity : a && a.isTracking(_) ? v = a.get(_) : console.warn("ERROR: No velocity was defined for " + e + " property: " + _), x = Im(v, u), S = 0, m = c(e, _), p = av(m), m = parseFloat(m), Gs(g) && (b = m + x, "end" in g && (g = gv(g, E && _ in E ? E : b, g.max, g.min, _, t.radius, v)), "max" in g && +g.max < b ? h || g.preventOvershoot ? x = g.max - m : S = g.max - m - x : "min" in g && +g.min > b && (h || g.preventOvershoot ? x = g.min - m : S = g.min - m - x)), this._props.push(_), this.styles && this.styles.save(_), this._pt = new ov(this._pt, e, _, m, 0, xP, 0, o.set(e, _, this)), this._pt.u = p || 0, this._pt.c1 = x, this._pt.c2 = S);
                return n.duration(u), bP
            },
            render: function(e, t) {
                var n = t._pt;
                if (e = Cm(t.tween._time / t.tween._dur), e || !uv())
                    for (; n;) n.set(n.t, n.p, vP(n.s + n.c1 * e + n.c2 * e * e) + n.u, n.d, e), n = n._next;
                else t.styles.revert()
            }
        };
    "track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(function(r) {
        return Lm[r] = Tl[r]
    }), fv() && hn.registerPlugin(Lm);
    /*!
     * Flip 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var TP = 1,
        $o, Bn, Ut, Dl, Hs, es, Nm, yv = function(e, t) {
            return e.actions.forEach(function(n) {
                return n.vars[t] && n.vars[t](n)
            })
        },
        Um = {},
        Sv = 180 / Math.PI,
        EP = Math.PI / 180,
        kf = {},
        Mv = {},
        zf = {},
        Om = function(e) {
            return typeof e == "string" ? e.split(" ").join("").split(",") : e
        },
        wP = Om("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
        Gf = Om("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
        Cl = function(e) {
            return $o(e)[0] || console.warn("Element not found:", e)
        },
        Ko = function(e) {
            return Math.round(e * 1e4) / 1e4 || 0
        },
        Bm = function(e, t, n) {
            return e.forEach(function(i) {
                return i.classList[n](t)
            })
        },
        Tv = {
            zIndex: 1,
            kill: 1,
            simple: 1,
            spin: 1,
            clearProps: 1,
            targets: 1,
            toggleClass: 1,
            onComplete: 1,
            onUpdate: 1,
            onInterrupt: 1,
            onStart: 1,
            delay: 1,
            repeat: 1,
            repeatDelay: 1,
            yoyo: 1,
            scale: 1,
            fade: 1,
            absolute: 1,
            props: 1,
            onEnter: 1,
            onLeave: 1,
            custom: 1,
            paused: 1,
            nested: 1,
            prune: 1,
            absoluteOnLeave: 1
        },
        Ev = {
            zIndex: 1,
            simple: 1,
            clearProps: 1,
            scale: 1,
            absolute: 1,
            fitChild: 1,
            getVars: 1,
            props: 1
        },
        wv = function(e) {
            return e.replace(/([A-Z])/g, "-$1").toLowerCase()
        },
        Jo = function(e, t) {
            var n = {},
                i;
            for (i in e) t[i] || (n[i] = e[i]);
            return n
        },
        km = {},
        Av = function(e) {
            var t = km[e] = Om(e);
            return zf[e] = t.concat(Gf), t
        },
        AP = function(e) {
            var t = e._gsap || Bn.core.getCache(e);
            return t.gmCache === Bn.ticker.frame ? t.gMatrix : (t.gmCache = Bn.ticker.frame, t.gMatrix = wn(e, !0, !1, !0))
        },
        DP = function r(e, t, n) {
            n === void 0 && (n = 0);
            for (var i = e.parentNode, s = 1e3 * Math.pow(10, n) * (t ? -1 : 1), a = t ? -s * 900 : 0; e;) a += s, e = e.previousSibling;
            return i ? a + r(i, t, n + 1) : a
        },
        Hf = function(e, t, n) {
            return e.forEach(function(i) {
                return i.d = DP(n ? i.element : i.t, t)
            }), e.sort(function(i, s) {
                return i.d - s.d
            }), e
        },
        Rl = function(e, t) {
            for (var n = e.element.style, i = e.css = e.css || [], s = t.length, a, o; s--;) a = t[s], o = n[a] || n.getPropertyValue(a), i.push(o ? a : Mv[a] || (Mv[a] = wv(a)), o);
            return n
        },
        Vf = function(e) {
            var t = e.css,
                n = e.element.style,
                i = 0;
            for (e.cache.uncache = 1; i < t.length; i += 2) t[i + 1] ? n[t[i]] = t[i + 1] : n.removeProperty(t[i]);
            !t[t.indexOf("transform") + 1] && n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"))
        },
        Dv = function(e, t) {
            e.forEach(function(n) {
                return n.a.cache.uncache = 1
            }), t || e.finalStates.forEach(Vf)
        },
        zm = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
        Gm = function(e, t, n) {
            var i = e.element,
                s = e.width,
                a = e.height,
                o = e.uncache,
                c = e.getProp,
                l = i.style,
                f = 4,
                h, d, u;
            if (typeof t != "object" && (t = e), Ut && n !== 1) return Ut._abs.push({
                t: i,
                b: e,
                a: e,
                sd: 0
            }), Ut._final.push(function() {
                return (e.cache.uncache = 1) && Vf(e)
            }), i;
            for (d = c("display") === "none", (!e.isVisible || d) && (d && (Rl(e, ["display"]).display = t.display), e.matrix = t.matrix, e.width = s = e.width || t.width, e.height = a = e.height || t.height), Rl(e, zm), u = window.getComputedStyle(i); f--;) l[zm[f]] = u[zm[f]];
            if (l.gridArea = "1 / 1 / 1 / 1", l.transition = "none", l.position = "absolute", l.width = s + "px", l.height = a + "px", l.top || (l.top = "0px"), l.left || (l.left = "0px"), o) h = new Ea(i);
            else if (h = Jo(e, kf), h.position = "absolute", e.simple) {
                var _ = i.getBoundingClientRect();
                h.matrix = new Kr(1, 0, 0, 1, _.left + lm(), _.top + cm())
            } else h.matrix = wn(i, !1, !1, !0);
            return h = Zo(h, e, !0), e.x = es(h.x, .01), e.y = es(h.y, .01), i
        },
        Cv = function(e, t) {
            return t !== !0 && (t = $o(t), e = e.filter(function(n) {
                if (t.indexOf((n.sd < 0 ? n.b : n.a).element) !== -1) return !0;
                n.t._gsap.renderTransform(1), n.b.isVisible && (n.t.style.width = n.b.width + "px", n.t.style.height = n.b.height + "px")
            })), e
        },
        Rv = function(e) {
            return Hf(e, !0).forEach(function(t) {
                return (t.a.isVisible || t.b.isVisible) && Gm(t.sd < 0 ? t.b : t.a, t.b, 1)
            })
        },
        CP = function(e, t) {
            return t && e.idLookup[Hm(t).id] || e.elementStates[0]
        },
        Hm = function(e, t, n, i) {
            return e instanceof Ea ? e : e instanceof ar ? CP(e, i) : new Ea(typeof e == "string" ? Cl(e) || console.warn(e + " not found") : e, t, n)
        },
        RP = function(e, t) {
            for (var n = Bn.getProperty(e.element, null, "native"), i = e.props = {}, s = t.length; s--;) i[t[s]] = (n(t[s]) + "").trim();
            return i.zIndex && (i.zIndex = parseFloat(i.zIndex) || 0), e
        },
        Pv = function(e, t) {
            var n = e.style || e,
                i;
            for (i in t) n[i] = t[i]
        },
        PP = function(e) {
            var t = e.getAttribute("data-flip-id");
            return t || e.setAttribute("data-flip-id", t = "auto-" + TP++), t
        },
        Fv = function(e) {
            return e.map(function(t) {
                return t.element
            })
        },
        Iv = function(e, t, n) {
            return e && t.length && n.add(e(Fv(t), n, new ar(t, 0, !0)), 0)
        },
        Zo = function(e, t, n, i, s, a) {
            var o = e.element,
                c = e.cache,
                l = e.parent,
                f = e.x,
                h = e.y,
                d = t.width,
                u = t.height,
                _ = t.scaleX,
                g = t.scaleY,
                m = t.rotation,
                p = t.bounds,
                v = a && Nm && Nm(o, "transform"),
                x = e,
                b = t.matrix,
                S = b.e,
                E = b.f,
                T = e.bounds.width !== p.width || e.bounds.height !== p.height || e.scaleX !== _ || e.scaleY !== g || e.rotation !== m,
                w = !T && e.simple && t.simple && !s,
                M, y, D, R, P, O, z;
            return w || !l ? (_ = g = 1, m = M = 0) : (P = AP(l), O = P.clone().multiply(t.ctm ? t.matrix.clone().multiply(t.ctm) : t.matrix), m = Ko(Math.atan2(O.b, O.a) * Sv), M = Ko(Math.atan2(O.c, O.d) * Sv + m) % 360, _ = Math.sqrt(Math.pow(O.a, 2) + Math.pow(O.b, 2)), g = Math.sqrt(Math.pow(O.c, 2) + Math.pow(O.d, 2)) * Math.cos(M * EP), s && (s = $o(s)[0], R = Bn.getProperty(s), z = s.getBBox && typeof s.getBBox == "function" && s.getBBox(), x = {
                scaleX: R("scaleX"),
                scaleY: R("scaleY"),
                width: z ? z.width : Math.ceil(parseFloat(R("width", "px"))),
                height: z ? z.height : parseFloat(R("height", "px"))
            }), c.rotation = m + "deg", c.skewX = M + "deg"), n ? (_ *= d === x.width || !x.width ? 1 : d / x.width, g *= u === x.height || !x.height ? 1 : u / x.height, c.scaleX = _, c.scaleY = g) : (d = es(d * _ / x.scaleX, 0), u = es(u * g / x.scaleY, 0), o.style.width = d + "px", o.style.height = u + "px"), i && Pv(o, t.props), w || !l ? (f += S - e.matrix.e, h += E - e.matrix.f) : T || l !== t.parent ? (c.renderTransform(1, c), O = wn(s || o, !1, !1, !0), y = P.apply({
                x: O.e,
                y: O.f
            }), D = P.apply({
                x: S,
                y: E
            }), f += D.x - y.x, h += D.y - y.y) : (P.e = P.f = 0, D = P.apply({
                x: S - e.matrix.e,
                y: E - e.matrix.f
            }), f += D.x, h += D.y), f = es(f, .02), h = es(h, .02), a && !(a instanceof Ea) ? v && v.revert() : (c.x = f + "px", c.y = h + "px", c.renderTransform(1, c)), a && (a.x = f, a.y = h, a.rotation = m, a.skewX = M, n ? (a.scaleX = _, a.scaleY = g) : (a.width = d, a.height = u)), a || c
        },
        Vm = function(e, t) {
            return e instanceof ar ? e : new ar(e, t)
        },
        Lv = function(e, t, n) {
            var i = e.idLookup[n],
                s = e.alt[n];
            return s.isVisible && (!(t.getElementState(s.element) || s).isVisible || !i.isVisible) ? s : i
        },
        Wm = [],
        Xm = "width,height,overflowX,overflowY".split(","),
        Wf, Nv = function(e) {
            if (e !== Wf) {
                var t = Hs.style,
                    n = Hs.clientWidth === window.outerWidth,
                    i = Hs.clientHeight === window.outerHeight,
                    s = 4;
                if (e && (n || i)) {
                    for (; s--;) Wm[s] = t[Xm[s]];
                    n && (t.width = Hs.clientWidth + "px", t.overflowY = "hidden"), i && (t.height = Hs.clientHeight + "px", t.overflowX = "hidden"), Wf = e
                } else if (Wf) {
                    for (; s--;) Wm[s] ? t[Xm[s]] = Wm[s] : t.removeProperty(wv(Xm[s]));
                    Wf = e
                }
            }
        },
        jm = function(e, t, n, i) {
            e instanceof ar && t instanceof ar || console.warn("Not a valid state object."), n = n || {};
            var s = n,
                a = s.clearProps,
                o = s.onEnter,
                c = s.onLeave,
                l = s.absolute,
                f = s.absoluteOnLeave,
                h = s.custom,
                d = s.delay,
                u = s.paused,
                _ = s.repeat,
                g = s.repeatDelay,
                m = s.yoyo,
                p = s.toggleClass,
                v = s.nested,
                x = s.zIndex,
                b = s.scale,
                S = s.fade,
                E = s.stagger,
                T = s.spin,
                w = s.prune,
                M = ("props" in n ? n : e).props,
                y = Jo(n, Tv),
                D = Bn.timeline({
                    delay: d,
                    paused: u,
                    repeat: _,
                    repeatDelay: g,
                    yoyo: m,
                    data: "isFlip"
                }),
                R = y,
                P = [],
                O = [],
                z = [],
                k = [],
                X = T === !0 ? 1 : T || 0,
                V = typeof T == "function" ? T : function() {
                    return X
                },
                H = e.interrupted || t.interrupted,
                L = D[i !== 1 ? "to" : "from"],
                se, de, ke, Y, ee, he, fe, be, Ye, Pe, Xe, nt, xe, F;
            for (de in t.idLookup) Xe = t.alt[de] ? Lv(t, e, de) : t.idLookup[de], ee = Xe.element, Pe = e.idLookup[de], e.alt[de] && ee === Pe.element && (e.alt[de].isVisible || !Xe.isVisible) && (Pe = e.alt[de]), Pe ? (he = {
                t: ee,
                b: Pe,
                a: Xe,
                sd: Pe.element === ee ? 0 : Xe.isVisible ? 1 : -1
            }, z.push(he), he.sd && (he.sd < 0 && (he.b = Xe, he.a = Pe), H && Rl(he.b, M ? zf[M] : Gf), S && z.push(he.swap = {
                t: Pe.element,
                b: he.b,
                a: he.a,
                sd: -he.sd,
                swap: he
            })), ee._flip = Pe.element._flip = Ut ? Ut.timeline : D) : Xe.isVisible && (z.push({
                t: ee,
                b: Jo(Xe, {
                    isVisible: 1
                }),
                a: Xe,
                sd: 0,
                entering: 1
            }), ee._flip = Ut ? Ut.timeline : D);
            if (M && (km[M] || Av(M)).forEach(function(q) {
                    return y[q] = function(ve) {
                        return z[ve].a.props[q]
                    }
                }), z.finalStates = Ye = [], nt = function() {
                    for (Hf(z), Nv(!0), Y = 0; Y < z.length; Y++) he = z[Y], xe = he.a, F = he.b, w && !xe.isDifferent(F) && !he.entering ? z.splice(Y--, 1) : (ee = he.t, v && !(he.sd < 0) && Y && (xe.matrix = wn(ee, !1, !1, !0)), F.isVisible && xe.isVisible ? (he.sd < 0 ? (fe = new Ea(ee, M, e.simple), Zo(fe, xe, b, 0, 0, fe), fe.matrix = wn(ee, !1, !1, !0), fe.css = he.b.css, he.a = xe = fe, S && (ee.style.opacity = H ? F.opacity : xe.opacity), E && k.push(ee)) : he.sd > 0 && S && (ee.style.opacity = H ? xe.opacity - F.opacity : "0"), Zo(xe, F, b, M)) : F.isVisible !== xe.isVisible && (F.isVisible ? xe.isVisible || (F.css = xe.css, O.push(F), z.splice(Y--, 1), l && v && Zo(xe, F, b, M)) : (xe.isVisible && P.push(xe), z.splice(Y--, 1))), b || (ee.style.maxWidth = Math.max(xe.width, F.width) + "px", ee.style.maxHeight = Math.max(xe.height, F.height) + "px", ee.style.minWidth = Math.min(xe.width, F.width) + "px", ee.style.minHeight = Math.min(xe.height, F.height) + "px"), v && p && ee.classList.add(p)), Ye.push(xe);
                    var ve;
                    if (p && (ve = Ye.map(function(ge) {
                            return ge.element
                        }), v && ve.forEach(function(ge) {
                            return ge.classList.remove(p)
                        })), Nv(!1), b ? (y.scaleX = function(ge) {
                            return z[ge].a.scaleX
                        }, y.scaleY = function(ge) {
                            return z[ge].a.scaleY
                        }) : (y.width = function(ge) {
                            return z[ge].a.width + "px"
                        }, y.height = function(ge) {
                            return z[ge].a.height + "px"
                        }, y.autoRound = n.autoRound || !1), y.x = function(ge) {
                            return z[ge].a.x + "px"
                        }, y.y = function(ge) {
                            return z[ge].a.y + "px"
                        }, y.rotation = function(ge) {
                            return z[ge].a.rotation + (T ? V(ge, be[ge], be) * 360 : 0)
                        }, y.skewX = function(ge) {
                            return z[ge].a.skewX
                        }, be = z.map(function(ge) {
                            return ge.t
                        }), (x || x === 0) && (y.modifiers = {
                            zIndex: function() {
                                return x
                            }
                        }, y.zIndex = x, y.immediateRender = n.immediateRender !== !1), S && (y.opacity = function(ge) {
                            return z[ge].sd < 0 ? 0 : z[ge].sd > 0 ? z[ge].a.opacity : "+=0"
                        }), k.length) {
                        E = Bn.utils.distribute(E);
                        var et = be.slice(k.length);
                        y.stagger = function(ge, st) {
                            return E(~k.indexOf(st) ? be.indexOf(z[ge].swap.t) : ge, st, et)
                        }
                    }
                    if (wP.forEach(function(ge) {
                            return n[ge] && D.eventCallback(ge, n[ge], n[ge + "Params"])
                        }), h && be.length) {
                        R = Jo(y, Tv), "scale" in h && (h.scaleX = h.scaleY = h.scale, delete h.scale);
                        for (de in h) se = Jo(h[de], Ev), se[de] = y[de], !("duration" in se) && "duration" in y && (se.duration = y.duration), se.stagger = y.stagger, L.call(D, be, se, 0), delete R[de]
                    }(be.length || O.length || P.length) && (p && D.add(function() {
                        return Bm(ve, p, D._zTime < 0 ? "remove" : "add")
                    }, 0) && !u && Bm(ve, p, "add"), be.length && L.call(D, be, R, 0)), Iv(o, P, D), Iv(c, O, D);
                    var Le = Ut && Ut.timeline;
                    Le && (Le.add(D, 0), Ut._final.push(function() {
                        return Dv(z, !a)
                    })), ke = D.duration(), D.call(function() {
                        var ge = D.time() >= ke;
                        ge && !Le && Dv(z, !a), p && Bm(ve, p, ge ? "remove" : "add")
                    })
                }, f && (l = z.filter(function(q) {
                    return !q.sd && !q.a.isVisible && q.b.isVisible
                }).map(function(q) {
                    return q.a.element
                })), Ut) {
                var Ge;
                l && (Ge = Ut._abs).push.apply(Ge, Cv(z, l)), Ut._run.push(nt)
            } else l && Rv(Cv(z, l)), nt();
            var Je = Ut ? Ut.timeline : D;
            return Je.revert = function() {
                return qm(Je, 1, 1)
            }, Je
        },
        FP = function r(e) {
            e.vars.onInterrupt && e.vars.onInterrupt.apply(e, e.vars.onInterruptParams || []), e.getChildren(!0, !1, !0).forEach(r)
        },
        qm = function(e, t, n) {
            if (e && e.progress() < 1 && (!e.paused() || n)) return t && (FP(e), t < 2 && e.progress(1), e.kill()), !0
        },
        Xf = function(e) {
            for (var t = e.idLookup = {}, n = e.alt = {}, i = e.elementStates, s = i.length, a; s--;) a = i[s], t[a.id] ? n[a.id] = a : t[a.id] = a
        },
        ar = function() {
            function r(t, n, i) {
                if (this.props = n && n.props, this.simple = !!(n && n.simple), i) this.targets = Fv(t), this.elementStates = t, Xf(this);
                else {
                    this.targets = $o(t);
                    var s = n && (n.kill === !1 || n.batch && !n.kill);
                    Ut && !s && Ut._kill.push(this), this.update(s || !!Ut)
                }
            }
            var e = r.prototype;
            return e.update = function(n) {
                var i = this;
                return this.elementStates = this.targets.map(function(s) {
                    return new Ea(s, i.props, i.simple)
                }), Xf(this), this.interrupt(n), this.recordInlineStyles(), this
            }, e.clear = function() {
                return this.targets.length = this.elementStates.length = 0, Xf(this), this
            }, e.fit = function(n, i, s) {
                for (var a = Hf(this.elementStates.slice(0), !1, !0), o = (n || this).idLookup, c = 0, l, f; c < a.length; c++) l = a[c], s && (l.matrix = wn(l.element, !1, !1, !0)), f = o[l.id], f && Zo(l, f, i, !0, 0, l), l.matrix = wn(l.element, !1, !1, !0);
                return this
            }, e.getProperty = function(n, i) {
                var s = this.getElementState(n) || kf;
                return (i in s ? s : s.props || kf)[i]
            }, e.add = function(n) {
                for (var i = n.targets.length, s = this.idLookup, a = this.alt, o, c, l; i--;) c = n.elementStates[i], l = s[c.id], l && (c.element === l.element || a[c.id] && a[c.id].element === c.element) ? (o = this.elementStates.indexOf(c.element === l.element ? l : a[c.id]), this.targets.splice(o, 1, n.targets[i]), this.elementStates.splice(o, 1, c)) : (this.targets.push(n.targets[i]), this.elementStates.push(c));
                return n.interrupted && (this.interrupted = !0), n.simple || (this.simple = !1), Xf(this), this
            }, e.compare = function(n) {
                var i = n.idLookup,
                    s = this.idLookup,
                    a = [],
                    o = [],
                    c = [],
                    l = [],
                    f = [],
                    h = n.alt,
                    d = this.alt,
                    u = function(w, M, y) {
                        return (w.isVisible !== M.isVisible ? w.isVisible ? c : l : w.isVisible ? o : a).push(y) && f.push(y)
                    },
                    _ = function(w, M, y) {
                        return f.indexOf(y) < 0 && u(w, M, y)
                    },
                    g, m, p, v, x, b, S, E;
                for (p in i) x = h[p], b = d[p], g = x ? Lv(n, this, p) : i[p], v = g.element, m = s[p], b ? (E = m.isVisible || !b.isVisible && v === m.element ? m : b, S = x && !g.isVisible && !x.isVisible && E.element === x.element ? x : g, S.isVisible && E.isVisible && S.element !== E.element ? ((S.isDifferent(E) ? o : a).push(S.element, E.element), f.push(S.element, E.element)) : u(S, E, S.element), x && S.element === x.element && (x = i[p]), _(S.element !== m.element && x ? x : S, m, m.element), _(x && x.element === b.element ? x : S, b, b.element), x && _(x, b.element === x.element ? b : m, x.element)) : (m ? m.isDifferent(g) ? u(g, m, v) : a.push(v) : c.push(v), x && _(x, m, x.element));
                for (p in s) i[p] || (l.push(s[p].element), d[p] && l.push(d[p].element));
                return {
                    changed: o,
                    unchanged: a,
                    enter: c,
                    leave: l
                }
            }, e.recordInlineStyles = function() {
                for (var n = zf[this.props] || Gf, i = this.elementStates.length; i--;) Rl(this.elementStates[i], n)
            }, e.interrupt = function(n) {
                var i = this,
                    s = [];
                this.targets.forEach(function(a) {
                    var o = a._flip,
                        c = qm(o, n ? 0 : 1);
                    n && c && s.indexOf(o) < 0 && o.add(function() {
                        return i.updateVisibility()
                    }), c && s.push(o)
                }), !n && s.length && this.updateVisibility(), this.interrupted || (this.interrupted = !!s.length)
            }, e.updateVisibility = function() {
                this.elementStates.forEach(function(n) {
                    var i = n.element.getBoundingClientRect();
                    n.isVisible = !!(i.width || i.height || i.top || i.left), n.uncache = 1
                })
            }, e.getElementState = function(n) {
                return this.elementStates[this.targets.indexOf(Cl(n))]
            }, e.makeAbsolute = function() {
                return Hf(this.elementStates.slice(0), !0, !0).map(Gm)
            }, r
        }(),
        Ea = function() {
            function r(t, n, i) {
                this.element = t, this.update(n, i)
            }
            var e = r.prototype;
            return e.isDifferent = function(n) {
                var i = this.bounds,
                    s = n.bounds;
                return i.top !== s.top || i.left !== s.left || i.width !== s.width || i.height !== s.height || !this.matrix.equals(n.matrix) || this.opacity !== n.opacity || this.props && n.props && JSON.stringify(this.props) !== JSON.stringify(n.props)
            }, e.update = function(n, i) {
                var s = this,
                    a = s.element,
                    o = Bn.getProperty(a),
                    c = Bn.core.getCache(a),
                    l = a.getBoundingClientRect(),
                    f = a.getBBox && typeof a.getBBox == "function" && a.nodeName.toLowerCase() !== "svg" && a.getBBox(),
                    h = i ? new Kr(1, 0, 0, 1, l.left + lm(), l.top + cm()) : wn(a, !1, !1, !0);
                s.getProp = o, s.element = a, s.id = PP(a), s.matrix = h, s.cache = c, s.bounds = l, s.isVisible = !!(l.width || l.height || l.left || l.top), s.display = o("display"), s.position = o("position"), s.parent = a.parentNode, s.x = o("x"), s.y = o("y"), s.scaleX = c.scaleX, s.scaleY = c.scaleY, s.rotation = o("rotation"), s.skewX = o("skewX"), s.opacity = o("opacity"), s.width = f ? f.width : es(o("width", "px"), .04), s.height = f ? f.height : es(o("height", "px"), .04), n && RP(s, km[n] || Av(n)), s.ctm = a.getCTM && a.nodeName.toLowerCase() === "svg" && Lx(a).inverse(), s.simple = i || Ko(h.a) === 1 && !Ko(h.b) && !Ko(h.c) && Ko(h.d) === 1, s.uncache = 0
            }, r
        }(),
        IP = function() {
            function r(t, n) {
                this.vars = t, this.batch = n, this.states = [], this.timeline = n.timeline
            }
            var e = r.prototype;
            return e.getStateById = function(n) {
                for (var i = this.states.length; i--;)
                    if (this.states[i].idLookup[n]) return this.states[i]
            }, e.kill = function() {
                this.batch.remove(this)
            }, r
        }(),
        LP = function() {
            function r(t) {
                this.id = t, this.actions = [], this._kill = [], this._final = [], this._abs = [], this._run = [], this.data = {}, this.state = new ar, this.timeline = Bn.timeline()
            }
            var e = r.prototype;
            return e.add = function(n) {
                var i = this.actions.filter(function(s) {
                    return s.vars === n
                });
                return i.length ? i[0] : (i = new IP(typeof n == "function" ? {
                    animate: n
                } : n, this), this.actions.push(i), i)
            }, e.remove = function(n) {
                var i = this.actions.indexOf(n);
                return i >= 0 && this.actions.splice(i, 1), this
            }, e.getState = function(n) {
                var i = this,
                    s = Ut,
                    a = Dl;
                return Ut = this, this.state.clear(), this._kill.length = 0, this.actions.forEach(function(o) {
                    o.vars.getState && (o.states.length = 0, Dl = o, o.state = o.vars.getState(o)), n && o.states.forEach(function(c) {
                        return i.state.add(c)
                    })
                }), Dl = a, Ut = s, this.killConflicts(), this
            }, e.animate = function() {
                var n = this,
                    i = Ut,
                    s = this.timeline,
                    a = this.actions.length,
                    o, c;
                for (Ut = this, s.clear(), this._abs.length = this._final.length = this._run.length = 0, this.actions.forEach(function(l) {
                        l.vars.animate && l.vars.animate(l);
                        var f = l.vars.onEnter,
                            h = l.vars.onLeave,
                            d = l.targets,
                            u, _;
                        d && d.length && (f || h) && (u = new ar, l.states.forEach(function(g) {
                            return u.add(g)
                        }), _ = u.compare(Pl.getState(d)), _.enter.length && f && f(_.enter), _.leave.length && h && h(_.leave))
                    }), Rv(this._abs), this._run.forEach(function(l) {
                        return l()
                    }), c = s.duration(), o = this._final.slice(0), s.add(function() {
                        c <= s.time() && (o.forEach(function(l) {
                            return l()
                        }), yv(n, "onComplete"))
                    }), Ut = i; a--;) this.actions[a].vars.once && this.actions[a].kill();
                return yv(this, "onStart"), s.restart(), this
            }, e.loadState = function(n) {
                n || (n = function() {
                    return 0
                });
                var i = [];
                return this.actions.forEach(function(s) {
                    if (s.vars.loadState) {
                        var a, o = function c(l) {
                            l && (s.targets = l), a = i.indexOf(c), ~a && (i.splice(a, 1), i.length || n())
                        };
                        i.push(o), s.vars.loadState(o)
                    }
                }), i.length || n(), this
            }, e.setState = function() {
                return this.actions.forEach(function(n) {
                    return n.targets = n.vars.setState && n.vars.setState(n)
                }), this
            }, e.killConflicts = function(n) {
                return this.state.interrupt(n), this._kill.forEach(function(i) {
                    return i.interrupt(n)
                }), this
            }, e.run = function(n, i) {
                var s = this;
                return this !== Ut && (n || this.getState(i), this.loadState(function() {
                    s._killed || (s.setState(), s.animate())
                })), this
            }, e.clear = function(n) {
                this.state.clear(), n || (this.actions.length = 0)
            }, e.getStateById = function(n) {
                for (var i = this.actions.length, s; i--;)
                    if (s = this.actions[i].getStateById(n), s) return s;
                return this.state.idLookup[n] && this.state
            }, e.kill = function() {
                this._killed = 1, this.clear(), delete Um[this.id]
            }, r
        }(),
        Pl = function() {
            function r() {}
            return r.getState = function(t, n) {
                var i = Vm(t, n);
                return Dl && Dl.states.push(i), n && n.batch && r.batch(n.batch).state.add(i), i
            }, r.from = function(t, n) {
                return n = n || {}, "clearProps" in n || (n.clearProps = !0), jm(t, Vm(n.targets || t.targets, {
                    props: n.props || t.props,
                    simple: n.simple,
                    kill: !!n.kill
                }), n, -1)
            }, r.to = function(t, n) {
                return jm(t, Vm(n.targets || t.targets, {
                    props: n.props || t.props,
                    simple: n.simple,
                    kill: !!n.kill
                }), n, 1)
            }, r.fromTo = function(t, n, i) {
                return jm(t, n, i)
            }, r.fit = function(t, n, i) {
                var s = i ? Jo(i, Ev) : {},
                    a = i || s,
                    o = a.absolute,
                    c = a.scale,
                    l = a.getVars,
                    f = a.props,
                    h = a.runBackwards,
                    d = a.onComplete,
                    u = a.simple,
                    _ = i && i.fitChild && Cl(i.fitChild),
                    g = Hm(n, f, u, t),
                    m = Hm(t, 0, u, g),
                    p = f ? zf[f] : Gf,
                    v = Bn.context();
                return f && Pv(s, g.props), Rl(m, p), h && ("immediateRender" in s || (s.immediateRender = !0), s.onComplete = function() {
                    Vf(m), d && d.apply(this, arguments)
                }), o && Gm(m, g), s = Zo(m, g, c || _, f, _, s.duration || l ? s : 0), v && !l && v.add(function() {
                    return function() {
                        return Vf(m)
                    }
                }), l ? s : s.duration ? Bn.to(m.element, s) : null
            }, r.makeAbsolute = function(t, n) {
                return (t instanceof ar ? t : new ar(t, n)).makeAbsolute()
            }, r.batch = function(t) {
                return t || (t = "default"), Um[t] || (Um[t] = new LP(t))
            }, r.killFlipsOf = function(t, n) {
                (t instanceof ar ? t.targets : $o(t)).forEach(function(i) {
                    return i && qm(i._flip, n !== !1 ? 1 : 2)
                })
            }, r.isFlipping = function(t) {
                var n = r.getByTarget(t);
                return !!n && n.isActive()
            }, r.getByTarget = function(t) {
                return (Cl(t) || kf)._flip
            }, r.getElementState = function(t, n) {
                return new Ea(Cl(t), n)
            }, r.convertCoordinates = function(t, n, i) {
                var s = wn(n, !0, !0).multiply(wn(t));
                return i ? s.apply(i) : s
            }, r.register = function(t) {
                if (Hs = typeof document < "u" && document.body, Hs) {
                    Bn = t, om(Hs), $o = Bn.utils.toArray, Nm = Bn.core.getStyleSaver;
                    var n = Bn.utils.snap(.1);
                    es = function(s, a) {
                        return n(parseFloat(s) + a)
                    }
                }
            }, r
        }();
    Pl.version = "3.12.5", typeof window < "u" && window.gsap && window.gsap.registerPlugin(Pl);
    /*!
     * ScrollTrigger 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Be, Qo, St, jt, or, Ot, Uv, jf, Fl, Il, Ll, qf, kn, Yf, Ym, Kn, Ov, Bv, ec, kv, $m, zv, Jn, Km, Gv, Hv, Vs, Jm, Zm, tc, Qm, $f, eg, tg, Kf = 1,
        zn = Date.now,
        ng = zn(),
        Bi = 0,
        Nl = 0,
        Vv = function(e, t, n) {
            var i = Si(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
            return n["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e
        },
        Wv = function(e, t) {
            return t && (!Si(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
        },
        NP = function r() {
            return Nl && requestAnimationFrame(r)
        },
        Xv = function() {
            return Yf = 1
        },
        jv = function() {
            return Yf = 0
        },
        Mr = function(e) {
            return e
        },
        Ul = function(e) {
            return Math.round(e * 1e5) / 1e5 || 0
        },
        qv = function() {
            return typeof window < "u"
        },
        Yv = function() {
            return Be || qv() && (Be = window.gsap) && Be.registerPlugin && Be
        },
        wa = function(e) {
            return !!~Uv.indexOf(e)
        },
        $v = function(e) {
            return (e === "Height" ? Qm : St["inner" + e]) || or["client" + e] || Ot["client" + e]
        },
        Kv = function(e) {
            return Ns(e, "getBoundingClientRect") || (wa(e) ? function() {
                return lh.width = St.innerWidth, lh.height = Qm, lh
            } : function() {
                return ts(e)
            })
        },
        UP = function(e, t, n) {
            var i = n.d,
                s = n.d2,
                a = n.a;
            return (a = Ns(e, "getBoundingClientRect")) ? function() {
                return a()[i]
            } : function() {
                return (t ? $v(s) : e["client" + s]) || 0
            }
        },
        OP = function(e, t) {
            return !t || ~yr.indexOf(e) ? Kv(e) : function() {
                return lh
            }
        },
        Tr = function(e, t) {
            var n = t.s,
                i = t.d2,
                s = t.d,
                a = t.a;
            return Math.max(0, (n = "scroll" + i) && (a = Ns(e, n)) ? a() - Kv(e)()[s] : wa(e) ? (or[n] || Ot[n]) - $v(i) : e[n] - e["offset" + i])
        },
        Jf = function(e, t) {
            for (var n = 0; n < ec.length; n += 3)(!t || ~t.indexOf(ec[n + 1])) && e(ec[n], ec[n + 1], ec[n + 2])
        },
        Si = function(e) {
            return typeof e == "string"
        },
        Zn = function(e) {
            return typeof e == "function"
        },
        Ol = function(e) {
            return typeof e == "number"
        },
        Aa = function(e) {
            return typeof e == "object"
        },
        Bl = function(e, t, n) {
            return e && e.progress(t ? 0 : 1) && n && e.pause()
        },
        ig = function(e, t) {
            if (e.enabled) {
                var n = e._ctx ? e._ctx.add(function() {
                    return t(e)
                }) : t(e);
                n && n.totalTime && (e.callbackAnimation = n)
            }
        },
        nc = Math.abs,
        Jv = "left",
        Zv = "top",
        rg = "right",
        sg = "bottom",
        Da = "width",
        Ca = "height",
        kl = "Right",
        zl = "Left",
        Gl = "Top",
        Hl = "Bottom",
        an = "padding",
        ki = "margin",
        ic = "Width",
        ag = "Height",
        dn = "px",
        zi = function(e) {
            return St.getComputedStyle(e)
        },
        BP = function(e) {
            var t = zi(e).position;
            e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
        },
        Qv = function(e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        },
        ts = function(e, t) {
            var n = t && zi(e)[Ym] !== "matrix(1, 0, 0, 1, 0, 0)" && Be.to(e, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1),
                i = e.getBoundingClientRect();
            return n && n.progress(0).kill(), i
        },
        Zf = function(e, t) {
            var n = t.d2;
            return e["offset" + n] || e["client" + n] || 0
        },
        ey = function(e) {
            var t = [],
                n = e.labels,
                i = e.duration(),
                s;
            for (s in n) t.push(n[s] / i);
            return t
        },
        kP = function(e) {
            return function(t) {
                return Be.utils.snap(ey(e), t)
            }
        },
        og = function(e) {
            var t = Be.utils.snap(e),
                n = Array.isArray(e) && e.slice(0).sort(function(i, s) {
                    return i - s
                });
            return n ? function(i, s, a) {
                a === void 0 && (a = .001);
                var o;
                if (!s) return t(i);
                if (s > 0) {
                    for (i -= a, o = 0; o < n.length; o++)
                        if (n[o] >= i) return n[o];
                    return n[o - 1]
                } else
                    for (o = n.length, i += a; o--;)
                        if (n[o] <= i) return n[o];
                return n[0]
            } : function(i, s, a) {
                a === void 0 && (a = .001);
                var o = t(i);
                return !s || Math.abs(o - i) < a || o - i < 0 == s < 0 ? o : t(s < 0 ? i - e : i + e)
            }
        },
        zP = function(e) {
            return function(t, n) {
                return og(ey(e))(t, n.direction)
            }
        },
        Qf = function(e, t, n, i) {
            return n.split(",").forEach(function(s) {
                return e(t, s, i)
            })
        },
        yn = function(e, t, n, i, s) {
            return e.addEventListener(t, n, {
                passive: !i,
                capture: !!s
            })
        },
        Sn = function(e, t, n, i) {
            return e.removeEventListener(t, n, !!i)
        },
        eh = function(e, t, n) {
            n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n))
        },
        ty = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        },
        th = {
            toggleActions: "play",
            anticipatePin: 0
        },
        nh = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        },
        ih = function(e, t) {
            if (Si(e)) {
                var n = e.indexOf("="),
                    i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
                ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in nh ? nh[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
            }
            return e
        },
        rh = function(e, t, n, i, s, a, o, c) {
            var l = s.startColor,
                f = s.endColor,
                h = s.fontSize,
                d = s.indent,
                u = s.fontWeight,
                _ = jt.createElement("div"),
                g = wa(n) || Ns(n, "pinType") === "fixed",
                m = e.indexOf("scroller") !== -1,
                p = g ? Ot : n,
                v = e.indexOf("start") !== -1,
                x = v ? l : f,
                b = "border-color:" + x + ";font-size:" + h + ";color:" + x + ";font-weight:" + u + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return b += "position:" + ((m || c) && g ? "fixed;" : "absolute;"), (m || c || !g) && (b += (i === un ? rg : sg) + ":" + (a + parseFloat(d)) + "px;"), o && (b += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), _._isStart = v, _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), _.style.cssText = b, _.innerText = t || t === 0 ? e + "-" + t : e, p.children[0] ? p.insertBefore(_, p.children[0]) : p.appendChild(_), _._offset = _["offset" + i.op.d2], sh(_, 0, i, v), _
        },
        sh = function(e, t, n, i) {
            var s = {
                    display: "block"
                },
                a = n[i ? "os2" : "p2"],
                o = n[i ? "p2" : "os2"];
            e._isFlipped = i, s[n.a + "Percent"] = i ? -100 : 0, s[n.a] = i ? "1px" : 0, s["border" + a + ic] = 1, s["border" + o + ic] = 0, s[n.p] = t + "px", Be.set(e, s)
        },
        dt = [],
        cg = {},
        Vl, ny = function() {
            return zn() - Bi > 34 && (Vl || (Vl = requestAnimationFrame(ns)))
        },
        rc = function() {
            (!Jn || !Jn.isPressed || Jn.startX > Ot.clientWidth) && (gt.cache++, Jn ? Vl || (Vl = requestAnimationFrame(ns)) : ns(), Bi || Pa("scrollStart"), Bi = zn())
        },
        lg = function() {
            Hv = St.innerWidth, Gv = St.innerHeight
        },
        Wl = function() {
            gt.cache++, !kn && !zv && !jt.fullscreenElement && !jt.webkitFullscreenElement && (!Km || Hv !== St.innerWidth || Math.abs(St.innerHeight - Gv) > St.innerHeight * .25) && jf.restart(!0)
        },
        Ra = {},
        GP = [],
        iy = function r() {
            return Sn(pt, "scrollEnd", r) || Ia(!0)
        },
        Pa = function(e) {
            return Ra[e] && Ra[e].map(function(t) {
                return t()
            }) || GP
        },
        Mi = [],
        ry = function(e) {
            for (var t = 0; t < Mi.length; t += 5)(!e || Mi[t + 4] && Mi[t + 4].query === e) && (Mi[t].style.cssText = Mi[t + 1], Mi[t].getBBox && Mi[t].setAttribute("transform", Mi[t + 2] || ""), Mi[t + 3].uncache = 1)
        },
        ug = function(e, t) {
            var n;
            for (Kn = 0; Kn < dt.length; Kn++) n = dt[Kn], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
            $f = !0, t && ry(t), t || Pa("revert")
        },
        sy = function(e, t) {
            gt.cache++, (t || !Qn) && gt.forEach(function(n) {
                return Zn(n) && n.cacheID++ && (n.rec = 0)
            }), Si(e) && (St.history.scrollRestoration = Zm = e)
        },
        Qn, Fa = 0,
        ay, HP = function() {
            if (ay !== Fa) {
                var e = ay = Fa;
                requestAnimationFrame(function() {
                    return e === Fa && Ia(!0)
                })
            }
        },
        oy = function() {
            Ot.appendChild(tc), Qm = !Jn && tc.offsetHeight || St.innerHeight, Ot.removeChild(tc)
        },
        cy = function(e) {
            return Fl(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
                return t.style.display = e ? "none" : "block"
            })
        },
        Ia = function(e, t) {
            if (Bi && !e && !$f) {
                yn(pt, "scrollEnd", iy);
                return
            }
            oy(), Qn = pt.isRefreshing = !0, gt.forEach(function(i) {
                return Zn(i) && ++i.cacheID && (i.rec = i())
            });
            var n = Pa("refreshInit");
            kv && pt.sort(), t || ug(), gt.forEach(function(i) {
                Zn(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0))
            }), dt.slice(0).forEach(function(i) {
                return i.refresh()
            }), $f = !1, dt.forEach(function(i) {
                if (i._subPinOffset && i.pin) {
                    var s = i.vars.horizontal ? "offsetWidth" : "offsetHeight",
                        a = i.pin[s];
                    i.revert(!0, 1), i.adjustPinSpacing(i.pin[s] - a), i.refresh()
                }
            }), eg = 1, cy(!0), dt.forEach(function(i) {
                var s = Tr(i.scroller, i._dir),
                    a = i.vars.end === "max" || i._endClamp && i.end > s,
                    o = i._startClamp && i.start >= s;
                (a || o) && i.setPositions(o ? s - 1 : i.start, a ? Math.max(o ? s : i.start + 1, s) : i.end, !0)
            }), cy(!1), eg = 0, n.forEach(function(i) {
                return i && i.render && i.render(-1)
            }), gt.forEach(function(i) {
                Zn(i) && (i.smooth && requestAnimationFrame(function() {
                    return i.target.style.scrollBehavior = "smooth"
                }), i.rec && i(i.rec))
            }), sy(Zm, 1), jf.pause(), Fa++, Qn = 2, ns(2), dt.forEach(function(i) {
                return Zn(i.vars.onRefresh) && i.vars.onRefresh(i)
            }), Qn = pt.isRefreshing = !1, Pa("refresh")
        },
        fg = 0,
        ah = 1,
        Xl, ns = function(e) {
            if (e === 2 || !Qn && !$f) {
                pt.isUpdating = !0, Xl && Xl.update(0);
                var t = dt.length,
                    n = zn(),
                    i = n - ng >= 50,
                    s = t && dt[0].scroll();
                if (ah = fg > s ? -1 : 1, Qn || (fg = s), i && (Bi && !Yf && n - Bi > 200 && (Bi = 0, Pa("scrollEnd")), Ll = ng, ng = n), ah < 0) {
                    for (Kn = t; Kn-- > 0;) dt[Kn] && dt[Kn].update(0, i);
                    ah = 1
                } else
                    for (Kn = 0; Kn < t; Kn++) dt[Kn] && dt[Kn].update(0, i);
                pt.isUpdating = !1
            }
            Vl = 0
        },
        hg = [Jv, Zv, sg, rg, ki + Hl, ki + kl, ki + Gl, ki + zl, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        oh = hg.concat([Da, Ca, "boxSizing", "max" + ic, "max" + ag, "position", ki, an, an + Gl, an + kl, an + Hl, an + zl]),
        VP = function(e, t, n) {
            sc(n);
            var i = e._gsap;
            if (i.spacerIsNative) sc(i.spacerState);
            else if (e._gsap.swappedIn) {
                var s = t.parentNode;
                s && (s.insertBefore(e, t), s.removeChild(t))
            }
            e._gsap.swappedIn = !1
        },
        dg = function(e, t, n, i) {
            if (!e._gsap.swappedIn) {
                for (var s = hg.length, a = t.style, o = e.style, c; s--;) c = hg[s], a[c] = n[c];
                a.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (a.display = "inline-block"), o[sg] = o[rg] = "auto", a.flexBasis = n.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[Da] = Zf(e, $n) + dn, a[Ca] = Zf(e, un) + dn, a[an] = o[ki] = o[Zv] = o[Jv] = "0", sc(i), o[Da] = o["max" + ic] = n[Da], o[Ca] = o["max" + ag] = n[Ca], o[an] = n[an], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
            }
        },
        WP = /([A-Z])/g,
        sc = function(e) {
            if (e) {
                var t = e.t.style,
                    n = e.length,
                    i = 0,
                    s, a;
                for ((e.t._gsap || Be.core.getCache(e.t)).uncache = 1; i < n; i += 2) a = e[i + 1], s = e[i], a ? t[s] = a : t[s] && t.removeProperty(s.replace(WP, "-$1").toLowerCase())
            }
        },
        ch = function(e) {
            for (var t = oh.length, n = e.style, i = [], s = 0; s < t; s++) i.push(oh[s], n[oh[s]]);
            return i.t = e, i
        },
        XP = function(e, t, n) {
            for (var i = [], s = e.length, a = n ? 8 : 0, o; a < s; a += 2) o = e[a], i.push(o, o in t ? t[o] : e[a + 1]);
            return i.t = e.t, i
        },
        lh = {
            left: 0,
            top: 0
        },
        ly = function(e, t, n, i, s, a, o, c, l, f, h, d, u, _) {
            Zn(e) && (e = e(c)), Si(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? ih("0" + e.substr(3), n) : 0));
            var g = u ? u.time() : 0,
                m, p, v;
            if (u && u.seek(0), isNaN(e) || (e = +e), Ol(e)) u && (e = Be.utils.mapRange(u.scrollTrigger.start, u.scrollTrigger.end, 0, d, e)), o && sh(o, n, i, !0);
            else {
                Zn(t) && (t = t(c));
                var x = (e || "0").split(" "),
                    b, S, E, T;
                v = li(t, c) || Ot, b = ts(v) || {}, (!b || !b.left && !b.top) && zi(v).display === "none" && (T = v.style.display, v.style.display = "block", b = ts(v), T ? v.style.display = T : v.style.removeProperty("display")), S = ih(x[0], b[i.d]), E = ih(x[1] || "0", n), e = b[i.p] - l[i.p] - f + S + s - E, o && sh(o, E, i, n - E < 20 || o._isStart && E > 20), n -= n - E
            }
            if (_ && (c[_] = e || -.001, e < 0 && (e = 0)), a) {
                var w = e + n,
                    M = a._isStart;
                m = "scroll" + i.d2, sh(a, w, i, M && w > 20 || !M && (h ? Math.max(Ot[m], or[m]) : a.parentNode[m]) <= w + 1), h && (l = ts(o), h && (a.style[i.op.p] = l[i.op.p] - i.op.m - a._offset + dn))
            }
            return u && v && (m = ts(v), u.seek(d), p = ts(v), u._caScrollDist = m[i.p] - p[i.p], e = e / u._caScrollDist * d), u && u.seek(g), u ? e : Math.round(e)
        },
        jP = /(webkit|moz|length|cssText|inset)/i,
        uy = function(e, t, n, i) {
            if (e.parentNode !== t) {
                var s = e.style,
                    a, o;
                if (t === Ot) {
                    e._stOrig = s.cssText, o = zi(e);
                    for (a in o) !+a && !jP.test(a) && o[a] && typeof s[a] == "string" && a !== "0" && (s[a] = o[a]);
                    s.top = n, s.left = i
                } else s.cssText = e._stOrig;
                Be.core.getCache(e).uncache = 1, t.appendChild(e)
            }
        },
        fy = function(e, t, n) {
            var i = t,
                s = i;
            return function(a) {
                var o = Math.round(e());
                return o !== i && o !== s && Math.abs(o - i) > 3 && Math.abs(o - s) > 3 && (a = o, n && n()), s = i, i = a, a
            }
        },
        uh = function(e, t, n) {
            var i = {};
            i[t.p] = "+=" + n, Be.set(e, i)
        },
        hy = function(e, t) {
            var n = Us(e, t),
                i = "_scroll" + t.p2,
                s = function a(o, c, l, f, h) {
                    var d = a.tween,
                        u = c.onComplete,
                        _ = {};
                    l = l || n();
                    var g = fy(n, l, function() {
                        d.kill(), a.tween = 0
                    });
                    return h = f && h || 0, f = f || o - l, d && d.kill(), c[i] = o, c.inherit = !1, c.modifiers = _, _[i] = function() {
                        return g(l + f * d.ratio + h * d.ratio * d.ratio)
                    }, c.onUpdate = function() {
                        gt.cache++, a.tween && ns()
                    }, c.onComplete = function() {
                        a.tween = 0, u && u.call(d)
                    }, d = a.tween = Be.to(e, c), d
                };
            return e[i] = n, n.wheelHandler = function() {
                return s.tween && s.tween.kill() && (s.tween = 0)
            }, yn(e, "wheel", n.wheelHandler), pt.isTouch && yn(e, "touchmove", n.wheelHandler), s
        },
        pt = function() {
            function r(t, n) {
                Qo || r.register(Be) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), Jm(this), this.init(t, n)
            }
            var e = r.prototype;
            return e.init = function(n, i) {
                if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Nl) {
                    this.update = this.refresh = this.kill = Mr;
                    return
                }
                n = Qv(Si(n) || Ol(n) || n.nodeType ? {
                    trigger: n
                } : n, th);
                var s = n,
                    a = s.onUpdate,
                    o = s.toggleClass,
                    c = s.id,
                    l = s.onToggle,
                    f = s.onRefresh,
                    h = s.scrub,
                    d = s.trigger,
                    u = s.pin,
                    _ = s.pinSpacing,
                    g = s.invalidateOnRefresh,
                    m = s.anticipatePin,
                    p = s.onScrubComplete,
                    v = s.onSnapComplete,
                    x = s.once,
                    b = s.snap,
                    S = s.pinReparent,
                    E = s.pinSpacer,
                    T = s.containerAnimation,
                    w = s.fastScrollEnd,
                    M = s.preventOverlaps,
                    y = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? $n : un,
                    D = !h && h !== 0,
                    R = li(n.scroller || St),
                    P = Be.core.getCache(R),
                    O = wa(R),
                    z = ("pinType" in n ? n.pinType : Ns(R, "pinType") || O && "fixed") === "fixed",
                    k = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
                    X = D && n.toggleActions.split(" "),
                    V = "markers" in n ? n.markers : th.markers,
                    H = O ? 0 : parseFloat(zi(R)["border" + y.p2 + ic]) || 0,
                    L = this,
                    se = n.onRefreshInit && function() {
                        return n.onRefreshInit(L)
                    },
                    de = UP(R, O, y),
                    ke = OP(R, O),
                    Y = 0,
                    ee = 0,
                    he = 0,
                    fe = Us(R, y),
                    be, Ye, Pe, Xe, nt, xe, F, Ge, Je, q, ve, et, Le, ge, st, I, A, $, ne, ie, te, Fe, ye, Ue, we, pe, Ae, Ve, He, Se, je, U, Me, oe, Ee, me, ce, ae, N;
                if (L._startClamp = L._endClamp = !1, L._dir = y, m *= 45, L.scroller = R, L.scroll = T ? T.time.bind(T) : fe, Xe = fe(), L.vars = n, i = i || n.animation, "refreshPriority" in n && (kv = 1, n.refreshPriority === -9999 && (Xl = L)), P.tweenScroll = P.tweenScroll || {
                        top: hy(R, un),
                        left: hy(R, $n)
                    }, L.tweenTo = be = P.tweenScroll[y.p], L.scrubDuration = function(Q) {
                        Me = Ol(Q) && Q, Me ? U ? U.duration(Q) : U = Be.to(i, {
                            ease: "expo",
                            totalProgress: "+=0",
                            inherit: !1,
                            duration: Me,
                            paused: !0,
                            onComplete: function() {
                                return p && p(L)
                            }
                        }) : (U && U.progress(1).kill(), U = 0)
                    }, i && (i.vars.lazy = !1, i._initted && !L.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), L.animation = i.pause(), i.scrollTrigger = L, L.scrubDuration(h), Se = 0, c || (c = i.vars.id)), b && ((!Aa(b) || b.push) && (b = {
                        snapTo: b
                    }), "scrollBehavior" in Ot.style && Be.set(O ? [Ot, or] : R, {
                        scrollBehavior: "auto"
                    }), gt.forEach(function(Q) {
                        return Zn(Q) && Q.target === (O ? jt.scrollingElement || or : R) && (Q.smooth = !1)
                    }), Pe = Zn(b.snapTo) ? b.snapTo : b.snapTo === "labels" ? kP(i) : b.snapTo === "labelsDirectional" ? zP(i) : b.directional !== !1 ? function(Q, Te) {
                        return og(b.snapTo)(Q, zn() - ee < 500 ? 0 : Te.direction)
                    } : Be.utils.snap(b.snapTo), oe = b.duration || {
                        min: .1,
                        max: 2
                    }, oe = Aa(oe) ? Il(oe.min, oe.max) : Il(oe, oe), Ee = Be.delayedCall(b.delay || Me / 2 || .1, function() {
                        var Q = fe(),
                            Te = zn() - ee < 500,
                            ue = be.tween;
                        if ((Te || Math.abs(L.getVelocity()) < 10) && !ue && !Yf && Y !== Q) {
                            var De = (Q - xe) / ge,
                                $e = i && !D ? i.totalProgress() : De,
                                Oe = Te ? 0 : ($e - je) / (zn() - Ll) * 1e3 || 0,
                                tt = Be.utils.clamp(-De, 1 - De, nc(Oe / 2) * Oe / .185),
                                xt = De + (b.inertia === !1 ? 0 : tt),
                                _t, ut, ft = b,
                                Et = ft.onStart,
                                it = ft.onInterrupt,
                                pn = ft.onComplete;
                            if (_t = Pe(xt, L), Ol(_t) || (_t = xt), ut = Math.round(xe + _t * ge), Q <= F && Q >= xe && ut !== Q) {
                                if (ue && !ue._initted && ue.data <= nc(ut - Q)) return;
                                b.inertia === !1 && (tt = _t - De), be(ut, {
                                    duration: oe(nc(Math.max(nc(xt - $e), nc(_t - $e)) * .185 / Oe / .05 || 0)),
                                    ease: b.ease || "power3",
                                    data: nc(ut - Q),
                                    onInterrupt: function() {
                                        return Ee.restart(!0) && it && it(L)
                                    },
                                    onComplete: function() {
                                        L.update(), Y = fe(), i && (U ? U.resetTo("totalProgress", _t, i._tTime / i._tDur) : i.progress(_t)), Se = je = i && !D ? i.totalProgress() : L.progress, v && v(L), pn && pn(L)
                                    }
                                }, Q, tt * ge, ut - Q - tt * ge), Et && Et(L, be.tween)
                            }
                        } else L.isActive && Y !== Q && Ee.restart(!0)
                    }).pause()), c && (cg[c] = L), d = L.trigger = li(d || u !== !0 && u), N = d && d._gsap && d._gsap.stRevert, N && (N = N(L)), u = u === !0 ? d : li(u), Si(o) && (o = {
                        targets: d,
                        className: o
                    }), u && (_ === !1 || _ === ki || (_ = !_ && u.parentNode && u.parentNode.style && zi(u.parentNode).display === "flex" ? !1 : an), L.pin = u, Ye = Be.core.getCache(u), Ye.spacer ? st = Ye.pinState : (E && (E = li(E), E && !E.nodeType && (E = E.current || E.nativeElement), Ye.spacerIsNative = !!E, E && (Ye.spacerState = ch(E))), Ye.spacer = $ = E || jt.createElement("div"), $.classList.add("pin-spacer"), c && $.classList.add("pin-spacer-" + c), Ye.pinState = st = ch(u)), n.force3D !== !1 && Be.set(u, {
                        force3D: !0
                    }), L.spacer = $ = Ye.spacer, He = zi(u), Ue = He[_ + y.os2], ie = Be.getProperty(u), te = Be.quickSetter(u, y.a, dn), dg(u, $, He), A = ch(u)), V) {
                    et = Aa(V) ? Qv(V, ty) : ty, q = rh("scroller-start", c, R, y, et, 0), ve = rh("scroller-end", c, R, y, et, 0, q), ne = q["offset" + y.op.d2];
                    var re = li(Ns(R, "content") || R);
                    Ge = this.markerStart = rh("start", c, re, y, et, ne, 0, T), Je = this.markerEnd = rh("end", c, re, y, et, ne, 0, T), T && (ae = Be.quickSetter([Ge, Je], y.a, dn)), !z && !(yr.length && Ns(R, "fixedMarkers") === !0) && (BP(O ? Ot : R), Be.set([q, ve], {
                        force3D: !0
                    }), pe = Be.quickSetter(q, y.a, dn), Ve = Be.quickSetter(ve, y.a, dn))
                }
                if (T) {
                    var G = T.vars.onUpdate,
                        J = T.vars.onUpdateParams;
                    T.eventCallback("onUpdate", function() {
                        L.update(0, 0, 1), G && G.apply(T, J || [])
                    })
                }
                if (L.previous = function() {
                        return dt[dt.indexOf(L) - 1]
                    }, L.next = function() {
                        return dt[dt.indexOf(L) + 1]
                    }, L.revert = function(Q, Te) {
                        if (!Te) return L.kill(!0);
                        var ue = Q !== !1 || !L.enabled,
                            De = kn;
                        ue !== L.isReverted && (ue && (me = Math.max(fe(), L.scroll.rec || 0), he = L.progress, ce = i && i.progress()), Ge && [Ge, Je, q, ve].forEach(function($e) {
                            return $e.style.display = ue ? "none" : "block"
                        }), ue && (kn = L, L.update(ue)), u && (!S || !L.isActive) && (ue ? VP(u, $, st) : dg(u, $, zi(u), we)), ue || L.update(ue), kn = De, L.isReverted = ue)
                    }, L.refresh = function(Q, Te, ue, De) {
                        if (!((kn || !L.enabled) && !Te)) {
                            if (u && Q && Bi) {
                                yn(r, "scrollEnd", iy);
                                return
                            }!Qn && se && se(L), kn = L, be.tween && !ue && (be.tween.kill(), be.tween = 0), U && U.pause(), g && i && i.revert({
                                kill: !1
                            }).invalidate(), L.isReverted || L.revert(!0, !0), L._subPinOffset = !1;
                            var $e = de(),
                                Oe = ke(),
                                tt = T ? T.duration() : Tr(R, y),
                                xt = ge <= .01,
                                _t = 0,
                                ut = De || 0,
                                ft = Aa(ue) ? ue.end : n.end,
                                Et = n.endTrigger || d,
                                it = Aa(ue) ? ue.start : n.start || (n.start === 0 || !d ? 0 : u ? "0 0" : "0 100%"),
                                pn = L.pinnedContainer = n.pinnedContainer && li(n.pinnedContainer, L),
                                kt = d && Math.max(0, dt.indexOf(L)) || 0,
                                mn = kt,
                                gn, C, j, Z, K, W, _e, Ce, ze, Ie, qe, Ze, We;
                            for (V && Aa(ue) && (Ze = Be.getProperty(q, y.p), We = Be.getProperty(ve, y.p)); mn--;) W = dt[mn], W.end || W.refresh(0, 1) || (kn = L), _e = W.pin, _e && (_e === d || _e === u || _e === pn) && !W.isReverted && (Ie || (Ie = []), Ie.unshift(W), W.revert(!0, !0)), W !== dt[mn] && (kt--, mn--);
                            for (Zn(it) && (it = it(L)), it = Vv(it, "start", L), xe = ly(it, d, $e, y, fe(), Ge, q, L, Oe, H, z, tt, T, L._startClamp && "_startClamp") || (u ? -.001 : 0), Zn(ft) && (ft = ft(L)), Si(ft) && !ft.indexOf("+=") && (~ft.indexOf(" ") ? ft = (Si(it) ? it.split(" ")[0] : "") + ft : (_t = ih(ft.substr(2), $e), ft = Si(it) ? it : (T ? Be.utils.mapRange(0, T.duration(), T.scrollTrigger.start, T.scrollTrigger.end, xe) : xe) + _t, Et = d)), ft = Vv(ft, "end", L), F = Math.max(xe, ly(ft || (Et ? "100% 0" : tt), Et, $e, y, fe() + _t, Je, ve, L, Oe, H, z, tt, T, L._endClamp && "_endClamp")) || -.001, _t = 0, mn = kt; mn--;) W = dt[mn], _e = W.pin, _e && W.start - W._pinPush <= xe && !T && W.end > 0 && (gn = W.end - (L._startClamp ? Math.max(0, W.start) : W.start), (_e === d && W.start - W._pinPush < xe || _e === pn) && isNaN(it) && (_t += gn * (1 - W.progress)), _e === u && (ut += gn));
                            if (xe += _t, F += _t, L._startClamp && (L._startClamp += _t), L._endClamp && !Qn && (L._endClamp = F || -.001, F = Math.min(F, Tr(R, y))), ge = F - xe || (xe -= .01) && .001, xt && (he = Be.utils.clamp(0, 1, Be.utils.normalize(xe, F, me))), L._pinPush = ut, Ge && _t && (gn = {}, gn[y.a] = "+=" + _t, pn && (gn[y.p] = "-=" + fe()), Be.set([Ge, Je], gn)), u && !(eg && L.end >= Tr(R, y))) gn = zi(u), Z = y === un, j = fe(), Fe = parseFloat(ie(y.a)) + ut, !tt && F > 1 && (qe = (O ? jt.scrollingElement || or : R).style, qe = {
                                style: qe,
                                value: qe["overflow" + y.a.toUpperCase()]
                            }, O && zi(Ot)["overflow" + y.a.toUpperCase()] !== "scroll" && (qe.style["overflow" + y.a.toUpperCase()] = "scroll")), dg(u, $, gn), A = ch(u), C = ts(u, !0), Ce = z && Us(R, Z ? $n : un)(), _ ? (we = [_ + y.os2, ge + ut + dn], we.t = $, mn = _ === an ? Zf(u, y) + ge + ut : 0, mn && (we.push(y.d, mn + dn), $.style.flexBasis !== "auto" && ($.style.flexBasis = mn + dn)), sc(we), pn && dt.forEach(function(lt) {
                                lt.pin === pn && lt.vars.pinSpacing !== !1 && (lt._subPinOffset = !0)
                            }), z && fe(me)) : (mn = Zf(u, y), mn && $.style.flexBasis !== "auto" && ($.style.flexBasis = mn + dn)), z && (K = {
                                top: C.top + (Z ? j - xe : Ce) + dn,
                                left: C.left + (Z ? Ce : j - xe) + dn,
                                boxSizing: "border-box",
                                position: "fixed"
                            }, K[Da] = K["max" + ic] = Math.ceil(C.width) + dn, K[Ca] = K["max" + ag] = Math.ceil(C.height) + dn, K[ki] = K[ki + Gl] = K[ki + kl] = K[ki + Hl] = K[ki + zl] = "0", K[an] = gn[an], K[an + Gl] = gn[an + Gl], K[an + kl] = gn[an + kl], K[an + Hl] = gn[an + Hl], K[an + zl] = gn[an + zl], I = XP(st, K, S), Qn && fe(0)), i ? (ze = i._initted, $m(1), i.render(i.duration(), !0, !0), ye = ie(y.a) - Fe + ge + ut, Ae = Math.abs(ge - ye) > 1, z && Ae && I.splice(I.length - 2, 2), i.render(0, !0, !0), ze || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), $m(0)) : ye = ge, qe && (qe.value ? qe.style["overflow" + y.a.toUpperCase()] = qe.value : qe.style.removeProperty("overflow-" + y.a));
                            else if (d && fe() && !T)
                                for (C = d.parentNode; C && C !== Ot;) C._pinOffset && (xe -= C._pinOffset, F -= C._pinOffset), C = C.parentNode;
                            Ie && Ie.forEach(function(lt) {
                                return lt.revert(!1, !0)
                            }), L.start = xe, L.end = F, Xe = nt = Qn ? me : fe(), !T && !Qn && (Xe < me && fe(me), L.scroll.rec = 0), L.revert(!1, !0), ee = zn(), Ee && (Y = -1, Ee.restart(!0)), kn = 0, i && D && (i._initted || ce) && i.progress() !== ce && i.progress(ce || 0, !0).render(i.time(), !0, !0), (xt || he !== L.progress || T || g) && (i && !D && i.totalProgress(T && xe < -.001 && !he ? Be.utils.normalize(xe, F, 0) : he, !0), L.progress = xt || (Xe - xe) / ge === he ? 0 : he), u && _ && ($._pinOffset = Math.round(L.progress * ye)), U && U.invalidate(), isNaN(Ze) || (Ze -= Be.getProperty(q, y.p), We -= Be.getProperty(ve, y.p), uh(q, y, Ze), uh(Ge, y, Ze - (De || 0)), uh(ve, y, We), uh(Je, y, We - (De || 0))), xt && !Qn && L.update(), f && !Qn && !Le && (Le = !0, f(L), Le = !1)
                        }
                    }, L.getVelocity = function() {
                        return (fe() - nt) / (zn() - Ll) * 1e3 || 0
                    }, L.endAnimation = function() {
                        Bl(L.callbackAnimation), i && (U ? U.progress(1) : i.paused() ? D || Bl(i, L.direction < 0, 1) : Bl(i, i.reversed()))
                    }, L.labelToScroll = function(Q) {
                        return i && i.labels && (xe || L.refresh() || xe) + i.labels[Q] / i.duration() * ge || 0
                    }, L.getTrailing = function(Q) {
                        var Te = dt.indexOf(L),
                            ue = L.direction > 0 ? dt.slice(0, Te).reverse() : dt.slice(Te + 1);
                        return (Si(Q) ? ue.filter(function(De) {
                            return De.vars.preventOverlaps === Q
                        }) : ue).filter(function(De) {
                            return L.direction > 0 ? De.end <= xe : De.start >= F
                        })
                    }, L.update = function(Q, Te, ue) {
                        if (!(T && !ue && !Q)) {
                            var De = Qn === !0 ? me : L.scroll(),
                                $e = Q ? 0 : (De - xe) / ge,
                                Oe = $e < 0 ? 0 : $e > 1 ? 1 : $e || 0,
                                tt = L.progress,
                                xt, _t, ut, ft, Et, it, pn, kt;
                            if (Te && (nt = Xe, Xe = T ? fe() : De, b && (je = Se, Se = i && !D ? i.totalProgress() : Oe)), m && u && !kn && !Kf && Bi && (!Oe && xe < De + (De - nt) / (zn() - Ll) * m ? Oe = 1e-4 : Oe === 1 && F > De + (De - nt) / (zn() - Ll) * m && (Oe = .9999)), Oe !== tt && L.enabled) {
                                if (xt = L.isActive = !!Oe && Oe < 1, _t = !!tt && tt < 1, it = xt !== _t, Et = it || !!Oe != !!tt, L.direction = Oe > tt ? 1 : -1, L.progress = Oe, Et && !kn && (ut = Oe && !tt ? 0 : Oe === 1 ? 1 : tt === 1 ? 2 : 3, D && (ft = !it && X[ut + 1] !== "none" && X[ut + 1] || X[ut], kt = i && (ft === "complete" || ft === "reset" || ft in i))), M && (it || kt) && (kt || h || !i) && (Zn(M) ? M(L) : L.getTrailing(M).forEach(function(j) {
                                        return j.endAnimation()
                                    })), D || (U && !kn && !Kf ? (U._dp._time - U._start !== U._time && U.render(U._dp._time - U._start), U.resetTo ? U.resetTo("totalProgress", Oe, i._tTime / i._tDur) : (U.vars.totalProgress = Oe, U.invalidate().restart())) : i && i.totalProgress(Oe, !!(kn && (ee || Q)))), u) {
                                    if (Q && _ && ($.style[_ + y.os2] = Ue), !z) te(Ul(Fe + ye * Oe));
                                    else if (Et) {
                                        if (pn = !Q && Oe > tt && F + 1 > De && De + 1 >= Tr(R, y), S)
                                            if (!Q && (xt || pn)) {
                                                var mn = ts(u, !0),
                                                    gn = De - xe;
                                                uy(u, Ot, mn.top + (y === un ? gn : 0) + dn, mn.left + (y === un ? 0 : gn) + dn)
                                            } else uy(u, $);
                                        sc(xt || pn ? I : A), Ae && Oe < 1 && xt || te(Fe + (Oe === 1 && !pn ? ye : 0))
                                    }
                                }
                                b && !be.tween && !kn && !Kf && Ee.restart(!0), o && (it || x && Oe && (Oe < 1 || !tg)) && Fl(o.targets).forEach(function(j) {
                                    return j.classList[xt || x ? "add" : "remove"](o.className)
                                }), a && !D && !Q && a(L), Et && !kn ? (D && (kt && (ft === "complete" ? i.pause().totalProgress(1) : ft === "reset" ? i.restart(!0).pause() : ft === "restart" ? i.restart(!0) : i[ft]()), a && a(L)), (it || !tg) && (l && it && ig(L, l), k[ut] && ig(L, k[ut]), x && (Oe === 1 ? L.kill(!1, 1) : k[ut] = 0), it || (ut = Oe === 1 ? 1 : 3, k[ut] && ig(L, k[ut]))), w && !xt && Math.abs(L.getVelocity()) > (Ol(w) ? w : 2500) && (Bl(L.callbackAnimation), U ? U.progress(1) : Bl(i, ft === "reverse" ? 1 : !Oe, 1))) : D && a && !kn && a(L)
                            }
                            if (Ve) {
                                var C = T ? De / T.duration() * (T._caScrollDist || 0) : De;
                                pe(C + (q._isFlipped ? 1 : 0)), Ve(C)
                            }
                            ae && ae(-De / T.duration() * (T._caScrollDist || 0))
                        }
                    }, L.enable = function(Q, Te) {
                        L.enabled || (L.enabled = !0, yn(R, "resize", Wl), O || yn(R, "scroll", rc), se && yn(r, "refreshInit", se), Q !== !1 && (L.progress = he = 0, Xe = nt = Y = fe()), Te !== !1 && L.refresh())
                    }, L.getTween = function(Q) {
                        return Q && be ? be.tween : U
                    }, L.setPositions = function(Q, Te, ue, De) {
                        if (T) {
                            var $e = T.scrollTrigger,
                                Oe = T.duration(),
                                tt = $e.end - $e.start;
                            Q = $e.start + tt * Q / Oe, Te = $e.start + tt * Te / Oe
                        }
                        L.refresh(!1, !1, {
                            start: Wv(Q, ue && !!L._startClamp),
                            end: Wv(Te, ue && !!L._endClamp)
                        }, De), L.update()
                    }, L.adjustPinSpacing = function(Q) {
                        if (we && Q) {
                            var Te = we.indexOf(y.d) + 1;
                            we[Te] = parseFloat(we[Te]) + Q + dn, we[1] = parseFloat(we[1]) + Q + dn, sc(we)
                        }
                    }, L.disable = function(Q, Te) {
                        if (L.enabled && (Q !== !1 && L.revert(!0, !0), L.enabled = L.isActive = !1, Te || U && U.pause(), me = 0, Ye && (Ye.uncache = 1), se && Sn(r, "refreshInit", se), Ee && (Ee.pause(), be.tween && be.tween.kill() && (be.tween = 0)), !O)) {
                            for (var ue = dt.length; ue--;)
                                if (dt[ue].scroller === R && dt[ue] !== L) return;
                            Sn(R, "resize", Wl), O || Sn(R, "scroll", rc)
                        }
                    }, L.kill = function(Q, Te) {
                        L.disable(Q, Te), U && !Te && U.kill(), c && delete cg[c];
                        var ue = dt.indexOf(L);
                        ue >= 0 && dt.splice(ue, 1), ue === Kn && ah > 0 && Kn--, ue = 0, dt.forEach(function(De) {
                            return De.scroller === L.scroller && (ue = 1)
                        }), ue || Qn || (L.scroll.rec = 0), i && (i.scrollTrigger = null, Q && i.revert({
                            kill: !1
                        }), Te || i.kill()), Ge && [Ge, Je, q, ve].forEach(function(De) {
                            return De.parentNode && De.parentNode.removeChild(De)
                        }), Xl === L && (Xl = 0), u && (Ye && (Ye.uncache = 1), ue = 0, dt.forEach(function(De) {
                            return De.pin === u && ue++
                        }), ue || (Ye.spacer = 0)), n.onKill && n.onKill(L)
                    }, dt.push(L), L.enable(!1, !1), N && N(L), i && i.add && !ge) {
                    var le = L.update;
                    L.update = function() {
                        L.update = le, xe || F || L.refresh()
                    }, Be.delayedCall(.01, L.update), ge = .01, xe = F = 0
                } else L.refresh();
                u && HP()
            }, r.register = function(n) {
                return Qo || (Be = n || Yv(), qv() && window.document && r.enable(), Qo = Nl), Qo
            }, r.defaults = function(n) {
                if (n)
                    for (var i in n) th[i] = n[i];
                return th
            }, r.disable = function(n, i) {
                Nl = 0, dt.forEach(function(a) {
                    return a[i ? "kill" : "disable"](n)
                }), Sn(St, "wheel", rc), Sn(jt, "scroll", rc), clearInterval(qf), Sn(jt, "touchcancel", Mr), Sn(Ot, "touchstart", Mr), Qf(Sn, jt, "pointerdown,touchstart,mousedown", Xv), Qf(Sn, jt, "pointerup,touchend,mouseup", jv), jf.kill(), Jf(Sn);
                for (var s = 0; s < gt.length; s += 3) eh(Sn, gt[s], gt[s + 1]), eh(Sn, gt[s], gt[s + 2])
            }, r.enable = function() {
                if (St = window, jt = document, or = jt.documentElement, Ot = jt.body, Be && (Fl = Be.utils.toArray, Il = Be.utils.clamp, Jm = Be.core.context || Mr, $m = Be.core.suppressOverwrites || Mr, Zm = St.history.scrollRestoration || "auto", fg = St.pageYOffset, Be.core.globals("ScrollTrigger", r), Ot)) {
                    Nl = 1, tc = document.createElement("div"), tc.style.height = "100vh", tc.style.position = "absolute", oy(), NP(), Xt.register(Be), r.isTouch = Xt.isTouch, Vs = Xt.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Km = Xt.isTouch === 1, yn(St, "wheel", rc), Uv = [St, jt, or, Ot], Be.matchMedia ? (r.matchMedia = function(c) {
                        var l = Be.matchMedia(),
                            f;
                        for (f in c) l.add(f, c[f]);
                        return l
                    }, Be.addEventListener("matchMediaInit", function() {
                        return ug()
                    }), Be.addEventListener("matchMediaRevert", function() {
                        return ry()
                    }), Be.addEventListener("matchMedia", function() {
                        Ia(0, 1), Pa("matchMedia")
                    }), Be.matchMedia("(orientation: portrait)", function() {
                        return lg(), lg
                    })) : console.warn("Requires GSAP 3.11.0 or later"), lg(), yn(jt, "scroll", rc);
                    var n = Ot.style,
                        i = n.borderTopStyle,
                        s = Be.core.Animation.prototype,
                        a, o;
                    for (s.revert || Object.defineProperty(s, "revert", {
                            value: function() {
                                return this.time(-.01, !0)
                            }
                        }), n.borderTopStyle = "solid", a = ts(Ot), un.m = Math.round(a.top + un.sc()) || 0, $n.m = Math.round(a.left + $n.sc()) || 0, i ? n.borderTopStyle = i : n.removeProperty("border-top-style"), qf = setInterval(ny, 250), Be.delayedCall(.5, function() {
                            return Kf = 0
                        }), yn(jt, "touchcancel", Mr), yn(Ot, "touchstart", Mr), Qf(yn, jt, "pointerdown,touchstart,mousedown", Xv), Qf(yn, jt, "pointerup,touchend,mouseup", jv), Ym = Be.utils.checkPrefix("transform"), oh.push(Ym), Qo = zn(), jf = Be.delayedCall(.2, Ia).pause(), ec = [jt, "visibilitychange", function() {
                            var c = St.innerWidth,
                                l = St.innerHeight;
                            jt.hidden ? (Ov = c, Bv = l) : (Ov !== c || Bv !== l) && Wl()
                        }, jt, "DOMContentLoaded", Ia, St, "load", Ia, St, "resize", Wl], Jf(yn), dt.forEach(function(c) {
                            return c.enable(0, 1)
                        }), o = 0; o < gt.length; o += 3) eh(Sn, gt[o], gt[o + 1]), eh(Sn, gt[o], gt[o + 2])
                }
            }, r.config = function(n) {
                "limitCallbacks" in n && (tg = !!n.limitCallbacks);
                var i = n.syncInterval;
                i && clearInterval(qf) || (qf = i) && setInterval(ny, i), "ignoreMobileResize" in n && (Km = r.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (Jf(Sn) || Jf(yn, n.autoRefreshEvents || "none"), zv = (n.autoRefreshEvents + "").indexOf("resize") === -1)
            }, r.scrollerProxy = function(n, i) {
                var s = li(n),
                    a = gt.indexOf(s),
                    o = wa(s);
                ~a && gt.splice(a, o ? 6 : 2), i && (o ? yr.unshift(St, i, Ot, i, or, i) : yr.unshift(s, i))
            }, r.clearMatchMedia = function(n) {
                dt.forEach(function(i) {
                    return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
                })
            }, r.isInViewport = function(n, i, s) {
                var a = (Si(n) ? li(n) : n).getBoundingClientRect(),
                    o = a[s ? Da : Ca] * i || 0;
                return s ? a.right - o > 0 && a.left + o < St.innerWidth : a.bottom - o > 0 && a.top + o < St.innerHeight
            }, r.positionInViewport = function(n, i, s) {
                Si(n) && (n = li(n));
                var a = n.getBoundingClientRect(),
                    o = a[s ? Da : Ca],
                    c = i == null ? o / 2 : i in nh ? nh[i] * o : ~i.indexOf("%") ? parseFloat(i) * o / 100 : parseFloat(i) || 0;
                return s ? (a.left + c) / St.innerWidth : (a.top + c) / St.innerHeight
            }, r.killAll = function(n) {
                if (dt.slice(0).forEach(function(s) {
                        return s.vars.id !== "ScrollSmoother" && s.kill()
                    }), n !== !0) {
                    var i = Ra.killAll || [];
                    Ra = {}, i.forEach(function(s) {
                        return s()
                    })
                }
            }, r
        }();
    pt.version = "3.12.5", pt.saveStyles = function(r) {
        return r ? Fl(r).forEach(function(e) {
            if (e && e.style) {
                var t = Mi.indexOf(e);
                t >= 0 && Mi.splice(t, 5), Mi.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Be.core.getCache(e), Jm())
            }
        }) : Mi
    }, pt.revert = function(r, e) {
        return ug(!r, e)
    }, pt.create = function(r, e) {
        return new pt(r, e)
    }, pt.refresh = function(r) {
        return r ? Wl() : (Qo || pt.register()) && Ia(!0)
    }, pt.update = function(r) {
        return ++gt.cache && ns(r === !0 ? 2 : 0)
    }, pt.clearScrollMemory = sy, pt.maxScroll = function(r, e) {
        return Tr(r, e ? $n : un)
    }, pt.getScrollFunc = function(r, e) {
        return Us(li(r), e ? $n : un)
    }, pt.getById = function(r) {
        return cg[r]
    }, pt.getAll = function() {
        return dt.filter(function(r) {
            return r.vars.id !== "ScrollSmoother"
        })
    }, pt.isScrolling = function() {
        return !!Bi
    }, pt.snapDirectional = og, pt.addEventListener = function(r, e) {
        var t = Ra[r] || (Ra[r] = []);
        ~t.indexOf(e) || t.push(e)
    }, pt.removeEventListener = function(r, e) {
        var t = Ra[r],
            n = t && t.indexOf(e);
        n >= 0 && t.splice(n, 1)
    }, pt.batch = function(r, e) {
        var t = [],
            n = {},
            i = e.interval || .016,
            s = e.batchMax || 1e9,
            a = function(l, f) {
                var h = [],
                    d = [],
                    u = Be.delayedCall(i, function() {
                        f(h, d), h = [], d = []
                    }).pause();
                return function(_) {
                    h.length || u.restart(!0), h.push(_.trigger), d.push(_), s <= h.length && u.progress(1)
                }
            },
            o;
        for (o in e) n[o] = o.substr(0, 2) === "on" && Zn(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o];
        return Zn(s) && (s = s(), yn(pt, "refresh", function() {
            return s = e.batchMax()
        })), Fl(r).forEach(function(c) {
            var l = {};
            for (o in n) l[o] = n[o];
            l.trigger = c, t.push(pt.create(l))
        }), t
    };
    var dy = function(e, t, n, i) {
            return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
        },
        pg = function r(e, t) {
            t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Xt.isTouch ? " pinch-zoom" : "") : "none", e === or && r(Ot, t)
        },
        fh = {
            auto: 1,
            scroll: 1
        },
        qP = function(e) {
            var t = e.event,
                n = e.target,
                i = e.axis,
                s = (t.changedTouches ? t.changedTouches[0] : t).target,
                a = s._gsap || Be.core.getCache(s),
                o = zn(),
                c;
            if (!a._isScrollT || o - a._isScrollT > 2e3) {
                for (; s && s !== Ot && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(fh[(c = zi(s)).overflowY] || fh[c.overflowX]));) s = s.parentNode;
                a._isScroll = s && s !== n && !wa(s) && (fh[(c = zi(s)).overflowY] || fh[c.overflowX]), a._isScrollT = o
            }(a._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0)
        },
        py = function(e, t, n, i) {
            return Xt.create({
                target: e,
                capture: !0,
                debounce: !1,
                lockAxis: !0,
                type: t,
                onWheel: i = i && qP,
                onPress: i,
                onDrag: i,
                onScroll: i,
                onEnable: function() {
                    return n && yn(jt, Xt.eventTypes[0], gy, !1, !0)
                },
                onDisable: function() {
                    return Sn(jt, Xt.eventTypes[0], gy, !0)
                }
            })
        },
        YP = /(input|label|select|textarea)/i,
        my, gy = function(e) {
            var t = YP.test(e.target.tagName);
            (t || my) && (e._gsapAllow = !0, my = t)
        },
        $P = function(e) {
            Aa(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
            var t = e,
                n = t.normalizeScrollX,
                i = t.momentum,
                s = t.allowNestedScroll,
                a = t.onRelease,
                o, c, l = li(e.target) || or,
                f = Be.core.globals().ScrollSmoother,
                h = f && f.get(),
                d = Vs && (e.content && li(e.content) || h && e.content !== !1 && !h.smooth() && h.content()),
                u = Us(l, un),
                _ = Us(l, $n),
                g = 1,
                m = (Xt.isTouch && St.visualViewport ? St.visualViewport.scale * St.visualViewport.width : St.outerWidth) / St.innerWidth,
                p = 0,
                v = Zn(i) ? function() {
                    return i(o)
                } : function() {
                    return i || 2.8
                },
                x, b, S = py(l, e.type, !0, s),
                E = function() {
                    return b = !1
                },
                T = Mr,
                w = Mr,
                M = function() {
                    c = Tr(l, un), w = Il(Vs ? 1 : 0, c), n && (T = Il(0, Tr(l, $n))), x = Fa
                },
                y = function() {
                    d._gsap.y = Ul(parseFloat(d._gsap.y) + u.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", u.offset = u.cacheID = 0
                },
                D = function() {
                    if (b) {
                        requestAnimationFrame(E);
                        var V = Ul(o.deltaY / 2),
                            H = w(u.v - V);
                        if (d && H !== u.v + u.offset) {
                            u.offset = H - u.v;
                            var L = Ul((parseFloat(d && d._gsap.y) || 0) - u.offset);
                            d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + L + ", 0, 1)", d._gsap.y = L + "px", u.cacheID = gt.cache, ns()
                        }
                        return !0
                    }
                    u.offset && y(), b = !0
                },
                R, P, O, z, k = function() {
                    M(), R.isActive() && R.vars.scrollY > c && (u() > c ? R.progress(1) && u(c) : R.resetTo("scrollY", c))
                };
            return d && Be.set(d, {
                y: "+=0"
            }), e.ignoreCheck = function(X) {
                return Vs && X.type === "touchmove" && D() || g > 1.05 && X.type !== "touchstart" || o.isGesturing || X.touches && X.touches.length > 1
            }, e.onPress = function() {
                b = !1;
                var X = g;
                g = Ul((St.visualViewport && St.visualViewport.scale || 1) / m), R.pause(), X !== g && pg(l, g > 1.01 ? !0 : n ? !1 : "x"), P = _(), O = u(), M(), x = Fa
            }, e.onRelease = e.onGestureStart = function(X, V) {
                if (u.offset && y(), !V) z.restart(!0);
                else {
                    gt.cache++;
                    var H = v(),
                        L, se;
                    n && (L = _(), se = L + H * .05 * -X.velocityX / .227, H *= dy(_, L, se, Tr(l, $n)), R.vars.scrollX = T(se)), L = u(), se = L + H * .05 * -X.velocityY / .227, H *= dy(u, L, se, Tr(l, un)), R.vars.scrollY = w(se), R.invalidate().duration(H).play(.01), (Vs && R.vars.scrollY >= c || L >= c - 1) && Be.to({}, {
                        onUpdate: k,
                        duration: H
                    })
                }
                a && a(X)
            }, e.onWheel = function() {
                R._ts && R.pause(), zn() - p > 1e3 && (x = 0, p = zn())
            }, e.onChange = function(X, V, H, L, se) {
                if (Fa !== x && M(), V && n && _(T(L[2] === V ? P + (X.startX - X.x) : _() + V - L[1])), H) {
                    u.offset && y();
                    var de = se[2] === H,
                        ke = de ? O + X.startY - X.y : u() + H - se[1],
                        Y = w(ke);
                    de && ke !== Y && (O += Y - ke), u(Y)
                }(H || V) && ns()
            }, e.onEnable = function() {
                pg(l, n ? !1 : "x"), pt.addEventListener("refresh", k), yn(St, "resize", k), u.smooth && (u.target.style.scrollBehavior = "auto", u.smooth = _.smooth = !1), S.enable()
            }, e.onDisable = function() {
                pg(l, !0), Sn(St, "resize", k), pt.removeEventListener("refresh", k), S.kill()
            }, e.lockAxis = e.lockAxis !== !1, o = new Xt(e), o.iOS = Vs, Vs && !u() && u(1), Vs && Be.ticker.add(Mr), z = o._dc, R = Be.to(o, {
                ease: "power4",
                paused: !0,
                inherit: !1,
                scrollX: n ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                modifiers: {
                    scrollY: fy(u, u(), function() {
                        return R.pause()
                    })
                },
                onUpdate: ns,
                onComplete: z.vars.onComplete
            }), o
        };
    pt.sort = function(r) {
        return dt.sort(r || function(e, t) {
            return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
        })
    }, pt.observe = function(r) {
        return new Xt(r)
    }, pt.normalizeScroll = function(r) {
        if (typeof r > "u") return Jn;
        if (r === !0 && Jn) return Jn.enable();
        if (r === !1) {
            Jn && Jn.kill(), Jn = r;
            return
        }
        var e = r instanceof Xt ? r : $P(r);
        return Jn && Jn.target === e.target && Jn.kill(), wa(e.target) && (Jn = e), e
    }, pt.core = {
        _getVelocityProp: rm,
        _inputObserver: py,
        _scrollers: gt,
        _proxies: yr,
        bridge: {
            ss: function() {
                Bi || Pa("scrollStart"), Bi = zn()
            },
            ref: function() {
                return kn
            }
        }
    }, Yv() && Be.registerPlugin(pt);
    /*!
     * strings: 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var KP = /(?:^\s+|\s+$)/g,
        _y = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

    function hh(r) {
        var e = r.nodeType,
            t = "";
        if (e === 1 || e === 9 || e === 11) {
            if (typeof r.textContent == "string") return r.textContent;
            for (r = r.firstChild; r; r = r.nextSibling) t += hh(r)
        } else if (e === 3 || e === 4) return r.nodeValue;
        return t
    }

    function Er(r, e, t, n) {
        if (r += "", t && (r = r.trim ? r.trim() : r.replace(KP, "")), e && e !== "") return r.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(e);
        for (var i = [], s = r.length, a = 0, o, c; a < s; a++) c = r.charAt(a), (c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039) && (o = ((r.substr(a, 12).split(_y) || [])[1] || "").length || 2, c = r.substr(a, o), i.emoji = 1, a += o - 1), i.push(c === ">" ? "&gt;" : c === "<" ? "&lt;" : n && c === " " && (r.charAt(a - 1) === " " || r.charAt(a + 1) === " ") ? "&nbsp;" : c);
        return i
    }
    /*!
     * SplitText: 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var ac, mg, by, jl, xy, dh, JP = /(?:\r|\n|\t\t)/g,
        ZP = /(?:\s\s+)/g,
        QP = " ",
        vy = function(e) {
            ac = document, mg = window, jl = jl || e || mg.gsap || console.warn("Please gsap.registerPlugin(SplitText)"), jl && (dh = jl.utils.toArray, xy = jl.core.context || function() {}, by = 1)
        },
        yy = function(e) {
            return mg.getComputedStyle(e)
        },
        gg = function(e) {
            return e.position === "absolute" || e.absolute === !0
        },
        eF = function(e, t) {
            for (var n = t.length, i; --n > -1;)
                if (i = t[n], e.substr(0, i.length) === i) return i.length
        },
        tF = " style='position:relative;display:inline-block;'",
        Sy = function(e, t) {
            e === void 0 && (e = "");
            var n = ~e.indexOf("++"),
                i = 1;
            return n && (e = e.split("++").join("")),
                function() {
                    return "<" + t + tF + (e ? " class='" + e + (n ? i++ : "") + "'>" : ">")
                }
        },
        My = function r(e, t, n) {
            var i = e.nodeType;
            if (i === 1 || i === 9 || i === 11)
                for (e = e.firstChild; e; e = e.nextSibling) r(e, t, n);
            else(i === 3 || i === 4) && (e.nodeValue = e.nodeValue.split(t).join(n))
        },
        _g = function(e, t) {
            for (var n = t.length; --n > -1;) e.push(t[n])
        },
        Ty = function(e, t, n) {
            for (var i; e && e !== t;) {
                if (i = e._next || e.nextSibling, i) return i.textContent.charAt(0) === n;
                e = e.parentNode || e._parent
            }
        },
        nF = function r(e) {
            var t = dh(e.childNodes),
                n = t.length,
                i, s;
            for (i = 0; i < n; i++) s = t[i], s._isSplit ? r(s) : i && s.previousSibling && s.previousSibling.nodeType === 3 ? (s.previousSibling.nodeValue += s.nodeType === 3 ? s.nodeValue : s.firstChild.nodeValue, e.removeChild(s)) : s.nodeType !== 3 && (e.insertBefore(s.firstChild, s), e.removeChild(s))
        },
        wr = function(e, t) {
            return parseFloat(t[e]) || 0
        },
        iF = function(e, t, n, i, s, a, o) {
            var c = yy(e),
                l = wr("paddingLeft", c),
                f = -999,
                h = wr("borderBottomWidth", c) + wr("borderTopWidth", c),
                d = wr("borderLeftWidth", c) + wr("borderRightWidth", c),
                u = wr("paddingTop", c) + wr("paddingBottom", c),
                _ = wr("paddingLeft", c) + wr("paddingRight", c),
                g = wr("fontSize", c) * (t.lineThreshold || .2),
                m = c.textAlign,
                p = [],
                v = [],
                x = [],
                b = t.wordDelimiter || " ",
                S = t.tag ? t.tag : t.span ? "span" : "div",
                E = t.type || t.split || "chars,words,lines",
                T = s && ~E.indexOf("lines") ? [] : null,
                w = ~E.indexOf("words"),
                M = ~E.indexOf("chars"),
                y = gg(t),
                D = t.linesClass,
                R = ~(D || "").indexOf("++"),
                P = [],
                O = c.display === "flex",
                z = e.style.display,
                k, X, V, H, L, se, de, ke, Y, ee, he, fe;
            for (R && (D = D.split("++").join("")), O && (e.style.display = "block"), X = e.getElementsByTagName("*"), V = X.length, L = [], k = 0; k < V; k++) L[k] = X[k];
            if (T || y)
                for (k = 0; k < V; k++) H = L[k], se = H.parentNode === e, (se || y || M && !w) && (fe = H.offsetTop, T && se && Math.abs(fe - f) > g && (H.nodeName !== "BR" || k === 0) && (de = [], T.push(de), f = fe), y && (H._x = H.offsetLeft, H._y = fe, H._w = H.offsetWidth, H._h = H.offsetHeight), T && ((H._isSplit && se || !M && se || w && se || !w && H.parentNode.parentNode === e && !H.parentNode._isSplit) && (de.push(H), H._x -= l, Ty(H, e, b) && (H._wordEnd = !0)), H.nodeName === "BR" && (H.nextSibling && H.nextSibling.nodeName === "BR" || k === 0) && T.push([])));
            for (k = 0; k < V; k++) {
                if (H = L[k], se = H.parentNode === e, H.nodeName === "BR") {
                    T || y ? (H.parentNode && H.parentNode.removeChild(H), L.splice(k--, 1), V--) : w || e.appendChild(H);
                    continue
                }
                if (y && (Y = H.style, !w && !se && (H._x += H.parentNode._x, H._y += H.parentNode._y), Y.left = H._x + "px", Y.top = H._y + "px", Y.position = "absolute", Y.display = "block", Y.width = H._w + 1 + "px", Y.height = H._h + "px"), !w && M)
                    if (H._isSplit)
                        for (H._next = X = H.nextSibling, H.parentNode.appendChild(H); X && X.nodeType === 3 && X.textContent === " ";) H._next = X.nextSibling, H.parentNode.appendChild(X), X = X.nextSibling;
                    else H.parentNode._isSplit ? (H._parent = H.parentNode, !H.previousSibling && H.firstChild && (H.firstChild._isFirst = !0), H.nextSibling && H.nextSibling.textContent === " " && !H.nextSibling.nextSibling && P.push(H.nextSibling), H._next = H.nextSibling && H.nextSibling._isFirst ? null : H.nextSibling, H.parentNode.removeChild(H), L.splice(k--, 1), V--) : se || (fe = !H.nextSibling && Ty(H.parentNode, e, b), H.parentNode._parent && H.parentNode._parent.appendChild(H), fe && H.parentNode.appendChild(ac.createTextNode(" ")), S === "span" && (H.style.display = "inline"), p.push(H));
                else H.parentNode._isSplit && !H._isSplit && H.innerHTML !== "" ? v.push(H) : M && !H._isSplit && (S === "span" && (H.style.display = "inline"), p.push(H))
            }
            for (k = P.length; --k > -1;) P[k].parentNode.removeChild(P[k]);
            if (T) {
                for (y && (ee = ac.createElement(S), e.appendChild(ee), he = ee.offsetWidth + "px", fe = ee.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(ee)), Y = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;) e.removeChild(e.firstChild);
                for (ke = b === " " && (!y || !w && !M), k = 0; k < T.length; k++) {
                    for (de = T[k], ee = ac.createElement(S), ee.style.cssText = "display:block;text-align:" + m + ";position:" + (y ? "absolute;" : "relative;"), D && (ee.className = D + (R ? k + 1 : "")), x.push(ee), V = de.length, X = 0; X < V; X++) de[X].nodeName !== "BR" && (H = de[X], ee.appendChild(H), ke && H._wordEnd && ee.appendChild(ac.createTextNode(" ")), y && (X === 0 && (ee.style.top = H._y + "px", ee.style.left = l + fe + "px"), H.style.top = "0px", fe && (H.style.left = H._x - fe + "px")));
                    V === 0 ? ee.innerHTML = "&nbsp;" : !w && !M && (nF(ee), My(ee, " ", " ")), y && (ee.style.width = he, ee.style.height = H._h + "px"), e.appendChild(ee)
                }
                e.style.cssText = Y
            }
            y && (o > e.clientHeight && (e.style.height = o - u + "px", e.clientHeight < o && (e.style.height = o + h + "px")), a > e.clientWidth && (e.style.width = a - _ + "px", e.clientWidth < a && (e.style.width = a + d + "px"))), O && (z ? e.style.display = z : e.style.removeProperty("display")), _g(n, p), w && _g(i, v), _g(s, x)
        },
        rF = function(e, t, n, i) {
            var s = t.tag ? t.tag : t.span ? "span" : "div",
                a = t.type || t.split || "chars,words,lines",
                o = ~a.indexOf("chars"),
                c = gg(t),
                l = t.wordDelimiter || " ",
                f = function(y) {
                    return y === l || y === QP && l === " "
                },
                h = l !== " " ? "" : c ? "&#173; " : " ",
                d = "</" + s + ">",
                u = 1,
                _ = t.specialChars ? typeof t.specialChars == "function" ? t.specialChars : eF : null,
                g, m, p, v, x, b, S, E, T = ac.createElement("div"),
                w = e.parentNode;
            for (w.insertBefore(T, e), T.textContent = e.nodeValue, w.removeChild(e), e = T, g = hh(e), S = g.indexOf("<") !== -1, t.reduceWhiteSpace !== !1 && (g = g.replace(ZP, " ").replace(JP, "")), S && (g = g.split("<").join("{{LT}}")), x = g.length, m = (g.charAt(0) === " " ? h : "") + n(), p = 0; p < x; p++)
                if (b = g.charAt(p), _ && (E = _(g.substr(p), t.specialChars))) b = g.substr(p, E || 1), m += o && b !== " " ? i() + b + "</" + s + ">" : b, p += E - 1;
                else if (f(b) && !f(g.charAt(p - 1)) && p) {
                for (m += u ? d : "", u = 0; f(g.charAt(p + 1));) m += h, p++;
                p === x - 1 ? m += h : g.charAt(p + 1) !== ")" && (m += h + n(), u = 1)
            } else b === "{" && g.substr(p, 6) === "{{LT}}" ? (m += o ? i() + "{{LT}}</" + s + ">" : "{{LT}}", p += 5) : b.charCodeAt(0) >= 55296 && b.charCodeAt(0) <= 56319 || g.charCodeAt(p + 1) >= 65024 && g.charCodeAt(p + 1) <= 65039 ? (v = ((g.substr(p, 12).split(_y) || [])[1] || "").length || 2, m += o && b !== " " ? i() + g.substr(p, v) + "</" + s + ">" : g.substr(p, v), p += v - 1) : m += o && b !== " " ? i() + b + "</" + s + ">" : b;
            e.outerHTML = m + (u ? d : ""), S && My(w, "{{LT}}", "<")
        },
        sF = function r(e, t, n, i) {
            var s = dh(e.childNodes),
                a = s.length,
                o = gg(t),
                c, l;
            if (e.nodeType !== 3 || a > 1) {
                for (t.absolute = !1, c = 0; c < a; c++) l = s[c], l._next = l._isFirst = l._parent = l._wordEnd = null, (l.nodeType !== 3 || /\S+/.test(l.nodeValue)) && (o && l.nodeType !== 3 && yy(l).display === "inline" && (l.style.display = "inline-block", l.style.position = "relative"), l._isSplit = !0, r(l, t, n, i));
                t.absolute = o, e._isSplit = !0;
                return
            }
            rF(e, t, n, i)
        },
        ph = function() {
            function r(t, n) {
                by || vy(), this.elements = dh(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = n || {}, xy(this), this.split(n)
            }
            var e = r.prototype;
            return e.split = function(n) {
                this.isSplit && this.revert(), this.vars = n = n || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                for (var i = this.elements.length, s = n.tag ? n.tag : n.span ? "span" : "div", a = Sy(n.wordsClass, s), o = Sy(n.charsClass, s), c, l, f; --i > -1;) f = this.elements[i], this._originals[i] = {
                    html: f.innerHTML,
                    style: f.getAttribute("style")
                }, c = f.clientHeight, l = f.clientWidth, sF(f, n, a, o), iF(f, n, this.chars, this.words, this.lines, l, c);
                return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
            }, e.revert = function() {
                var n = this._originals;
                if (!n) throw "revert() call wasn't scoped properly.";
                return this.elements.forEach(function(i, s) {
                    i.innerHTML = n[s].html, i.setAttribute("style", n[s].style)
                }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
            }, r.create = function(n, i) {
                return new r(n, i)
            }, r
        }();
    ph.version = "3.12.5", ph.register = vy;
    /*!
     * ScrambleTextPlugin 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var mh = function() {
            function r(t) {
                this.chars = Er(t), this.sets = [], this.length = 50;
                for (var n = 0; n < 20; n++) this.sets[n] = Dy(80, this.chars)
            }
            var e = r.prototype;
            return e.grow = function(n) {
                for (var i = 0; i < 20; i++) this.sets[i] += Dy(n - this.length, this.chars);
                this.length = n
            }, r
        }(),
        La, Ey, wy = function() {
            return La || typeof window < "u" && (La = window.gsap) && La.registerPlugin && La
        },
        aF = 1,
        Ay = /\s+/g,
        Dy = function(e, t) {
            for (var n = t.length, i = ""; --e > -1;) i += t[~~(Math.random() * n)];
            return i
        },
        bg = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Cy = bg.toLowerCase(),
        oF = {
            upperCase: new mh(bg),
            lowerCase: new mh(Cy),
            upperAndLowerCase: new mh(bg + Cy)
        },
        Ry = function() {
            Ey = La = wy()
        },
        gh = {
            version: "3.12.5",
            name: "scrambleText",
            register: function(e, t, n) {
                La = e, Ry()
            },
            init: function(e, t, n, i, s) {
                if (Ey || Ry(), this.prop = "innerHTML" in e ? "innerHTML" : "textContent" in e ? "textContent" : 0, !!this.prop) {
                    this.target = e, typeof t != "object" && (t = {
                        text: t
                    });
                    var a = t.text || t.value || "",
                        o = t.trim !== !1,
                        c = this,
                        l, f, h, d;
                    return c.delimiter = l = t.delimiter || "", c.original = Er(hh(e).replace(Ay, " ").split("&nbsp;").join(""), l, o), (a === "{original}" || a === !0 || a == null) && (a = c.original.join(l)), c.text = Er((a || "").replace(Ay, " "), l, o), c.hasClass = !!(t.newClass || t.oldClass), c.newClass = t.newClass, c.oldClass = t.oldClass, d = l === "", c.textHasEmoji = d && !!c.text.emoji, c.charsHaveEmoji = !!t.chars && !!Er(t.chars).emoji, c.length = d ? c.original.length : c.original.join(l).length, c.lengthDif = (d ? c.text.length : c.text.join(l).length) - c.length, c.fillChar = t.fillChar || t.chars && ~t.chars.indexOf(" ") ? "&nbsp;" : "", c.charSet = h = oF[t.chars || "upperCase"] || new mh(t.chars), c.speed = .05 / (t.speed || 1), c.prevScrambleTime = 0, c.setIndex = Math.random() * 20 | 0, f = c.length + Math.max(c.lengthDif, 0), f > h.length && h.grow(f), c.chars = h.sets[c.setIndex], c.revealDelay = t.revealDelay || 0, c.tweenLength = t.tweenLength !== !1, c.tween = n, c.rightToLeft = !!t.rightToLeft, c._props.push("scrambleText", "text"), aF
                }
            },
            render: function(e, t) {
                var n = t.target,
                    i = t.prop,
                    s = t.text,
                    a = t.delimiter,
                    o = t.tween,
                    c = t.prevScrambleTime,
                    l = t.revealDelay,
                    f = t.setIndex,
                    h = t.chars,
                    d = t.charSet,
                    u = t.length,
                    _ = t.textHasEmoji,
                    g = t.charsHaveEmoji,
                    m = t.lengthDif,
                    p = t.tweenLength,
                    v = t.oldClass,
                    x = t.newClass,
                    b = t.rightToLeft,
                    S = t.fillChar,
                    E = t.speed,
                    T = t.original,
                    w = t.hasClass,
                    M = s.length,
                    y = o._time,
                    D = y - c,
                    R, P, O, z, k, X, V, H, L, se, de;
                l && (o._from && (y = o._dur - y), e = y === 0 ? 0 : y < l ? 1e-6 : y === o._dur ? 1 : o._ease((y - l) / (o._dur - l))), e < 0 ? e = 0 : e > 1 && (e = 1), b && (e = 1 - e), R = ~~(e * M + .5), e ? ((D > E || D < -E) && (t.setIndex = f = (f + (Math.random() * 19 | 0)) % 20, t.chars = d.sets[f], t.prevScrambleTime += D), z = h) : z = T.join(a), de = o._from ? e : 1 - e, se = u + (p ? o._from ? de * de * de : 1 - de * de * de : 1) * m, b ? e === 1 && (o._from || o.data === "isFromStart") ? (O = "", z = T.join(a)) : (V = s.slice(R).join(a), g ? O = Er(z).slice(0, se - (_ ? Er(V) : V).length + .5 | 0).join("") : O = z.substr(0, se - (_ ? Er(V) : V).length + .5 | 0), z = V) : (O = s.slice(0, R).join(a), P = (_ ? Er(O) : O).length, g ? z = Er(z).slice(P, se + .5 | 0).join("") : z = z.substr(P, se - P + .5 | 0)), w ? (H = b ? v : x, L = b ? x : v, k = H && R !== 0, X = L && R !== M, V = (k ? "<span class='" + H + "'>" : "") + O + (k ? "</span>" : "") + (X ? "<span class='" + L + "'>" : "") + a + z + (X ? "</span>" : "")) : V = O + a + z, n[i] = S === "&nbsp;" && ~V.indexOf("  ") ? V.split("  ").join("&nbsp;&nbsp;") : V
            }
        };
    gh.emojiSafeSplit = Er, gh.getText = hh, wy() && La.registerPlugin(gh);

    function cF() {
        return Tf.ticker.fps(60), Tf.registerPlugin(Xt, Xo, Lm, Pl, pt, ph, gh), pt.config({
            ignoreMobileResize: !0
        }), {
            gsap: Tf,
            Observer: Xt,
            Draggable: Xo,
            Flip: Pl,
            ScrollTrigger: pt,
            SplitText: ph
        }
    }
    var lF = `uniform float u_AnimateIn;
uniform float u_DisplacementStrength;

uniform sampler2D t_HoverMap;

varying vec2 vUv;
varying float v_DistanceFromMouse;

float map(in float v, in float iMin, in float iMax, in float oMin, in float oMax) { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }

void main() {
	vUv = uv;

	// Get distance from hover map - ensure we're reading the red channel correctly
	vec4 hoverData = texture2D(t_HoverMap, uv);
	float distanceFromMouse = hoverData.r;

	// Debug: If the texture read is failing, use a fallback value
	// if (distanceFromMouse < 0.001) { // Use a small threshold instead of exact 0
	//	distanceFromMouse = 0.5; // Fallback value
	// }

	distanceFromMouse = map(distanceFromMouse, 0.0, 1.0, 0.0, 1.2);
	v_DistanceFromMouse = distanceFromMouse;

	// Calculate animation
	float animateIn = min(1.0, distance(vec3(position.xy, 0.0), vec3(0.0)) - (1.0 - u_AnimateIn));
	animateIn = smoothstep((1.0 - u_AnimateIn) + 0.2, (1.0 - u_AnimateIn) - 0.6, animateIn);
}
`,
        uF = `// uniform vec2 u_MousePosition;
uniform sampler2D t_HoverMap;

varying vec2 vUv;
varying float v_DistanceFromMouse;

void main() {
	// vec4 previous = texture2D(t_HoverMap, vUv);

	// csm_FragColor = vec4(v_DistanceFromMouse, 0.0, 0.0, 1.0);
}
`,
        fF = `uniform sampler2D t_HoverMap;
uniform vec2 u_MousePosition;
uniform float u_Decay;
uniform float u_Radius;
uniform float u_Time;
uniform float u_LastMovementTime;

varying vec2 vUv;

float map(in float v, in float iMin, in float iMax, in float oMin, in float oMax) { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }

void main() {
  vec4 previous = texture2D(t_HoverMap, vUv);

  // Compute distance from mouse
  float dist = distance(vUv, u_MousePosition);
  float influence = smoothstep(u_Radius, 0.0, dist);

  float deltaTime = u_Time - u_LastMovementTime;
  deltaTime = clamp(deltaTime, 0.0, 1.0);
  deltaTime = map(deltaTime, 0.0, 1.0, 1.0, 0.0);

  // Update value with influence and decay
  float newValue = max(previous.r * u_Decay, influence);

  gl_FragColor = vec4(vec3(newValue) * deltaTime, 1.0);
}
`,
        hF = `varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
    let _h, ui, Gi, ql, is, Yl, xg, vg, yg, oc, $l, Sg, Py, Fy, Na, rs, Ws, Mg = {
            x: 0,
            y: 0
        },
        cc = !1,
        Tg = 0;
    const Eg = Db(!1),
        wg = Db({
            x: -10,
            y: -10
        }),
        dF = new B,
        {
            gsap: bh
        } = cF();
    qc.onProgress = (r, e, t) => {
        postMessage({
            modelLoaded: !0
        }), qc.onProgress = void 0
    }, self.addEventListener("message", ({
        data: r
    }) => {
        cc = r.width >= 768, r.init && Iy(r.canvas, r.width, r.height, r.texture)
    }, {
        once: !0
    }), self.addEventListener("message", ({
        data: r
    }) => {
        Iy && (r.resize && SF(r.width, r.height), r.dpr && MF(r.dpr), r.update && pF(r.tick), r.mouse && EF(r.x, r.y), r.drag && DF(r.x), r.isVisible !== void 0 && wF(r.isVisible))
    }), vD(Eg, r => {
        bh.to(is.material.uniforms.u_DisplacementStrength, {
            value: () => r ? 1 : 0,
            duration: () => r ? .3 : 2,
            ease: "power2.out",
            overwrite: !0
        }), postMessage({
            hover: r
        })
    });

    function pF(r) {
        Tg = r, Gi.position.x = Mg.x, Gi.position.y = Mg.y, Gi.lookAt(is.position), TF(), xF(), ui.render(_h, Gi)
    }
    async function Iy(r, e, t, n) {
        Fn.prototype.raycast = G1, Fn.prototype.computeBoundsTree = W1, Fn.prototype.disposeBoundsTree = X1, rs = e, Ws = t, mF(), gF(), _F(r), bF(), await vF(n), yF(), postMessage({
            init: !0
        })
    }

    function mF() {
        _h = new n_
    }

    function gF() {
        Gi = new Hn(40, rs / Ws, .1, 100), Gi.position.set(0, 0, cc ? 2.6 : 2.3), ql = new ps, ql.add(Gi), _h.add(ql)
    }

    function _F(r) {
        ui = new wA({
            canvas: r,
            alpha: !0,
            antialias: !0
        }), ui.setSize(rs, Ws, !1)
    }

    function bF() {
        vg = new Dr(256, 256, {
            format: 1023,
            type: 1015,
            minFilter: 1003,
            magFilter: 1003,
            generateMipmaps: !1
        }), yg = new Dr(256, 256, {
            format: 1023,
            type: 1015,
            minFilter: 1003,
            magFilter: 1003,
            generateMipmaps: !1
        }), ui.setRenderTarget(vg), ui.clear(16777215, 1, 0), ui.setRenderTarget(yg), ui.clear(16777215, 1, 0), ui.setRenderTarget(null), oc = vg, $l = yg, Sg = new n_, Py = new Du(-1, 1, 1, -1, 0, 1), Na = new Nr({
            vertexShader: hF,
            fragmentShader: fF,
            uniforms: {
                u_MousePosition: {
                    value: new at(-10, -10)
                },
                u_Time: {
                    value: 0
                },
                u_LastMovementTime: {
                    value: 0
                },
                u_Decay: {
                    value: .96
                },
                u_Radius: {
                    value: .23
                },
                t_HoverMap: {
                    value: oc.texture
                }
            }
        }), Fy = new bn(new Tc(2, 2), Na), Sg.add(Fy)
    }

    function xF() {
        Na.uniforms.u_Time.value = Tg, Na.uniforms.t_HoverMap.value = oc.texture, Na.needsUpdate = !0, ui.setRenderTarget($l), ui.clear(0, 1, 0), ui.render(Sg, Py), ui.setRenderTarget(null), $l.texture.needsUpdate = !0;
        let r = oc;
        oc = $l, $l = r
    }
    async function vF(r) {
        const e = new on(r);
        e.colorSpace = Jt, e.flipY = !1, e.needsUpdate = !0;
        const t = await FC.load("/asterisk.glb");
        is = t.scene.getObjectByName("Asterisk"), is.morphTargetInfluences[0] = 1, is.geometry.computeBoundsTree(), is.material = new ND({
            baseMaterial: qS,
            matcap: e,
            uniforms: {
                t_HoverMap: {
                    value: oc.texture
                },
                u_DisplacementStrength: {
                    value: 0
                },
                u_AnimateIn: {
                    value: 0
                }
            },
            vertexShader: lF,
            fragmentShader: uF,
            patchMap: {
                "*": {
                    "#include <morphnormal_vertex>": `
					#ifdef USE_MORPHNORMALS
						// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
						// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
						// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
						objectNormal *= morphTargetBaseInfluence;

						for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
							objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * u_DisplacementStrength * distanceFromMouse;
							objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * animateIn * 0.85;
						}

					#endif
				`,
                    "#include <morphtarget_vertex>": `
					#ifdef USE_MORPHTARGETS
						// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
						// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
						// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
						transformed *= morphTargetBaseInfluence;

						for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
							transformed += getMorph( gl_VertexID, i, 0 ).xyz * u_DisplacementStrength * distanceFromMouse;
							transformed += getMorph( gl_VertexID, i, 0 ).xyz * animateIn * 0.85;
						}
					#endif
				`
                }
            }
        }), _h.add(is), Yl = t.scene.getObjectByName("Hover_Mesh"), Yl.material = new hs({
            color: 16777215,
            visible: !1
        }), Yl.scale.set(1, 1, 1), is.add(Yl)
    }

    function yF() {
        xg = new MM(new B, new B(0, 0, -1), 1.5, 20)
    }

    function SF(r, e) {
        rs = r, Ws = e, cc = rs >= 768, Gi.position.z = cc ? 2.8 : 2.4, Gi.aspect = rs / Ws, Gi.updateProjectionMatrix(), ui.setSize(rs, Ws, !1)
    }

    function MF(r) {
        ui.setPixelRatio(Math.min(r, 1))
    }

    function TF() {
        xg.setFromCamera(new at(Vu(wg).x, Vu(wg).y), Gi);
        const r = xg.intersectObject(Yl);
        MD(Eg, r.length > 0), r.length && Na.uniforms.u_MousePosition.value.set(r[0].uv.x, r[0].uv.y)
    }

    function EF(r, e) {
        bh.to(Vu(wg), {
            x: () => r / rs * 2 - 1,
            y: () => e / Ws * -2 + 1,
            duration: .8,
            ease: "elastic.out(2, 0.45)",
            overwrite: !0
        }), Gi.getWorldPosition(dF), Vu(Eg) && (Na.uniforms.u_LastMovementTime.value = Tg), bh.to(Mg, {
            x: () => (r / rs * 2 - 1) * (cc ? .5 : .15),
            y: () => (e / Ws * -2 + 1) * (cc ? .5 : .15),
            duration: .4,
            ease: "power2.out",
            overwrite: !0
        })
    }

    function wF(r) {
        r ? AF() : ql.rotation.y = 0
    }

    function AF() {
        bh.fromTo(is.material.uniforms.u_AnimateIn, {
            value: 0
        }, {
            value: 1,
            duration: 2.5,
            ease: "power3.out",
            overwrite: !0
        })
    }

    function DF(r) {
        ql.rotation.y = -(r * .0035)
    }
})();